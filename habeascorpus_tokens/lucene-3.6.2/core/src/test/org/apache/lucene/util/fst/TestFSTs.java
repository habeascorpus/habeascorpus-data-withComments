package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedReader	TokenNameIdentifier	 Buffered Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringWriter	TokenNameIdentifier	 String Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Writer	TokenNameIdentifier	 Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriter	TokenNameIdentifier	 Index Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
TermEnum	TokenNameIdentifier	 Term Enum
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
IndexSearcher	TokenNameIdentifier	 Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
FSDirectory	TokenNameIdentifier	 FS Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexInput	TokenNameIdentifier	 Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexOutput	TokenNameIdentifier	 Index Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRef	TokenNameIdentifier	 Bytes Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntsRef	TokenNameIdentifier	 Ints Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LineFileDocs	TokenNameIdentifier	 Line File Docs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
UnicodeUtil	TokenNameIdentifier	 Unicode Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
_TestUtil	TokenNameIdentifier	 Test Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
TestFSTs	TokenNameIdentifier	 Test FS Ts
extends	TokenNameextends	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
{	TokenNameLBRACE	
private	TokenNameprivate	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setUp	TokenNameIdentifier	 set Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
setUp	TokenNameIdentifier	 set Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
setPreventDoubleWrite	TokenNameIdentifier	 set Prevent Double Write
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
BytesRef	TokenNameIdentifier	 Bytes Ref
toBytesRef	TokenNameIdentifier	 to Bytes Ref
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BytesRef	TokenNameIdentifier	 Bytes Ref
br	TokenNameIdentifier	 br
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
x	TokenNameIdentifier	 x
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
x	TokenNameIdentifier	 x
<=	TokenNameLESS_EQUAL	
255	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
return	TokenNamereturn	
br	TokenNameIdentifier	 br
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
IntsRef	TokenNameIdentifier	 Ints Ref
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
IntsRef	TokenNameIdentifier	 Ints Ref
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// utf8 	TokenNameCOMMENT_LINE	utf8 
return	TokenNamereturn	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// utf32 	TokenNameCOMMENT_LINE	utf32 
return	TokenNamereturn	
toIntsRefUTF32	TokenNameIdentifier	 to Ints Ref UT F32
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
IntsRef	TokenNameIdentifier	 Ints Ref
toIntsRefUTF32	TokenNameIdentifier	 to Ints Ref UT F32
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
charLength	TokenNameIdentifier	 char Length
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
charIdx	TokenNameIdentifier	 char Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
intIdx	TokenNameIdentifier	 int Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
charIdx	TokenNameIdentifier	 char Idx
<	TokenNameLESS	
charLength	TokenNameIdentifier	 char Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
intIdx	TokenNameIdentifier	 int Idx
==	TokenNameEQUAL_EQUAL	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
intIdx	TokenNameIdentifier	 int Idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
utf32	TokenNameIdentifier	 utf32
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
codePointAt	TokenNameIdentifier	 code Point At
(	TokenNameLPAREN	
charIdx	TokenNameIdentifier	 char Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
intIdx	TokenNameIdentifier	 int Idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
utf32	TokenNameIdentifier	 utf32
;	TokenNameSEMICOLON	
charIdx	TokenNameIdentifier	 char Idx
+=	TokenNamePLUS_EQUAL	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
charCount	TokenNameIdentifier	 char Count
(	TokenNameLPAREN	
utf32	TokenNameIdentifier	 utf32
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intIdx	TokenNameIdentifier	 int Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
intIdx	TokenNameIdentifier	 int Idx
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ir	TokenNameIdentifier	 ir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
IntsRef	TokenNameIdentifier	 Ints Ref
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
BytesRef	TokenNameIdentifier	 Bytes Ref
br	TokenNameIdentifier	 br
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
ir	TokenNameIdentifier	 ir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
br	TokenNameIdentifier	 br
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ir	TokenNameIdentifier	 ir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testBasicFSA	TokenNameIdentifier	 test Basic FSA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
strings	TokenNameIdentifier	 strings
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"station"	TokenNameStringLiteral	station
,	TokenNameCOMMA	
"commotion"	TokenNameStringLiteral	commotion
,	TokenNameCOMMA	
"elation"	TokenNameStringLiteral	elation
,	TokenNameCOMMA	
"elastic"	TokenNameStringLiteral	elastic
,	TokenNameCOMMA	
"plastic"	TokenNameStringLiteral	plastic
,	TokenNameCOMMA	
"stop"	TokenNameStringLiteral	stop
,	TokenNameCOMMA	
"ftop"	TokenNameStringLiteral	ftop
,	TokenNameCOMMA	
"ftation"	TokenNameStringLiteral	ftation
,	TokenNameCOMMA	
"stat"	TokenNameStringLiteral	stat
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
strings2	TokenNameIdentifier	 strings2
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"station"	TokenNameStringLiteral	station
,	TokenNameCOMMA	
"commotion"	TokenNameStringLiteral	commotion
,	TokenNameCOMMA	
"elation"	TokenNameStringLiteral	elation
,	TokenNameCOMMA	
"elastic"	TokenNameStringLiteral	elastic
,	TokenNameCOMMA	
"plastic"	TokenNameStringLiteral	plastic
,	TokenNameCOMMA	
"stop"	TokenNameStringLiteral	stop
,	TokenNameCOMMA	
"ftop"	TokenNameStringLiteral	ftop
,	TokenNameCOMMA	
"ftation"	TokenNameStringLiteral	ftation
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
strings	TokenNameIdentifier	 strings
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms2	TokenNameIdentifier	 terms2
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
strings2	TokenNameIdentifier	 strings2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
inputMode	TokenNameIdentifier	 input Mode
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
inputMode	TokenNameIdentifier	 input Mode
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: inputMode="	TokenNameStringLiteral	TEST: inputMode=
+	TokenNamePLUS	
inputModeToString	TokenNameIdentifier	 input Mode To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
strings	TokenNameIdentifier	 strings
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
strings	TokenNameIdentifier	 strings
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
strings2	TokenNameIdentifier	 strings2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
terms2	TokenNameIdentifier	 terms2
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
strings2	TokenNameIdentifier	 strings2
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test pre-determined FST sizes to make sure we haven't lost minimality (at least on this trivial set of terms): 	TokenNameCOMMENT_LINE	Test pre-determined FST sizes to make sure we haven't lost minimality (at least on this trivial set of terms): 
// FSA 	TokenNameCOMMENT_LINE	FSA 
{	TokenNameLBRACE	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
terms2	TokenNameIdentifier	 terms2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
22	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// FST ord pos int 	TokenNameCOMMENT_LINE	FST ord pos int 
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms2	TokenNameIdentifier	 terms2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
22	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// FST byte sequence ord 	TokenNameCOMMENT_LINE	FST byte sequence ord 
{	TokenNameLBRACE	
final	TokenNamefinal	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms2	TokenNameIdentifier	 terms2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
17	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
:	TokenNameCOLON	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms2	TokenNameIdentifier	 terms2
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
30	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
simpleRandomString	TokenNameIdentifier	 simple Random String
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
end	TokenNameIdentifier	 end
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// allow 0 length 	TokenNameCOMMENT_LINE	allow 0 length 
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
end	TokenNameIdentifier	 end
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
97	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
102	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// given set of terms, test the different outputs for them 	TokenNameCOMMENT_LINE	given set of terms, test the different outputs for them 
private	TokenNameprivate	
void	TokenNamevoid	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NoOutputs (simple FSA) 	TokenNameCOMMENT_LINE	NoOutputs (simple FSA) 
{	TokenNameLBRACE	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PositiveIntOutput (ord) 	TokenNameCOMMENT_LINE	PositiveIntOutput (ord) 
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PositiveIntOutput (random monotonically increasing positive number) 	TokenNameCOMMENT_LINE	PositiveIntOutput (random monotonically increasing positive number) 
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doShare	TokenNameIdentifier	 do Share
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
doShare	TokenNameIdentifier	 do Share
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
lastOutput	TokenNameIdentifier	 last Output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
long	TokenNamelong	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastOutput	TokenNameIdentifier	 last Output
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
doShare	TokenNameIdentifier	 do Share
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PositiveIntOutput (random positive number) 	TokenNameCOMMENT_LINE	PositiveIntOutput (random positive number) 
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Pair<ord, (random monotonically increasing positive number> 	TokenNameCOMMENT_LINE	Pair<ord, (random monotonically increasing positive number> 
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
o1	TokenNameIdentifier	 o1
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
o2	TokenNameIdentifier	 o2
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
new	TokenNamenew	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
lastOutput	TokenNameIdentifier	 last Output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
long	TokenNamelong	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastOutput	TokenNameIdentifier	 last Output
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
idx	TokenNameIdentifier	 idx
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Sequence-of-bytes 	TokenNameCOMMENT_LINE	Sequence-of-bytes 
{	TokenNameLBRACE	
final	TokenNamefinal	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
17	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
:	TokenNameCOLON	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Sequence-of-ints 	TokenNameCOMMENT_LINE	Sequence-of-ints 
{	TokenNameLBRACE	
final	TokenNamefinal	
IntSequenceOutputs	TokenNameIdentifier	 Int Sequence Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
IntSequenceOutputs	TokenNameIdentifier	 Int Sequence Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx2	TokenNameIdentifier	 idx2
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx2	TokenNameIdentifier	 idx2
<	TokenNameLESS	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx2	TokenNameIdentifier	 idx2
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
idx2	TokenNameIdentifier	 idx2
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Up to two positive ints, shared, generally but not 	TokenNameCOMMENT_LINE	Up to two positive ints, shared, generally but not 
// monotonically increasing 	TokenNameCOMMENT_LINE	monotonically increasing 
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now test UpToTwoPositiveIntOutputs"	TokenNameStringLiteral	TEST: now test UpToTwoPositiveIntOutputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
lastOutput	TokenNameIdentifier	 last Output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sometimes go backwards 	TokenNameCOMMENT_LINE	Sometimes go backwards 
long	TokenNamelong	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
-	TokenNameMINUS	
100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
-	TokenNameMINUS	
100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
value2	TokenNameIdentifier	 value2
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
-	TokenNameMINUS	
100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
value2	TokenNameIdentifier	 value2
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value2	TokenNameIdentifier	 value2
=	TokenNameEQUAL	
lastOutput	TokenNameIdentifier	 last Output
+	TokenNamePLUS	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
-	TokenNameMINUS	
100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
new	TokenNamenew	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
.	TokenNameDOT	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
FSTTester	TokenNameIdentifier	 FST Tester
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
final	TokenNamefinal	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
;	TokenNameSEMICOLON	
public	TokenNamepublic	
FSTTester	TokenNameIdentifier	 FST Tester
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
random	TokenNameIdentifier	 random
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
inputMode	TokenNameIdentifier	 input Mode
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
pairs	TokenNameIdentifier	 pairs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
=	TokenNameEQUAL	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
implements	TokenNameimplements	
Comparable	TokenNameIdentifier	 Comparable
<	TokenNameLESS	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
{	TokenNameLBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
public	TokenNamepublic	
InputOutput	TokenNameIdentifier	 Input Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
instanceof	TokenNameinstanceof	
InputOutput	TokenNameIdentifier	 Input Output
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// no pruning 	TokenNameCOMMENT_LINE	no pruning 
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
instanceof	TokenNameinstanceof	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// simple pruning 	TokenNameCOMMENT_LINE	simple pruning 
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// leafy pruning 	TokenNameCOMMENT_LINE	leafy pruning 
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// runs the term, returning the output, or null if term 	TokenNameCOMMENT_LINE	runs the term, returning the output, or null if term 
// isn't accepted. if prefixLength is non-null it must be 	TokenNameCOMMENT_LINE	isn't accepted. if prefixLength is non-null it must be 
// length 1 int array; prefixLength[0] is set to the length 	TokenNameCOMMENT_LINE	length 1 int array; prefixLength[0] is set to the length 
// of the term prefix that matches 	TokenNameCOMMENT_LINE	of the term prefix that matches 
private	TokenNameprivate	
T	TokenNameIdentifier	 T
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
prefixLength	TokenNameIdentifier	 prefix Length
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
prefixLength	TokenNameIdentifier	 prefix Length
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
prefixLength	TokenNameIdentifier	 prefix Length
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
T	TokenNameIdentifier	 T
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
fstReader	TokenNameIdentifier	 fst Reader
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
END_LABEL	TokenNameIdentifier	 END  LABEL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// System.out.println(" loop i=" + i + " label=" + label + " output=" + fst.outputs.outputToString(output) + " curArc: target=" + arc.target + " isFinal?=" + arc.isFinal()); 	TokenNameCOMMENT_LINE	System.out.println(" loop i=" + i + " label=" + label + " output=" + fst.outputs.outputToString(output) + " curArc: target=" + arc.target + " isFinal?=" + arc.isFinal()); 
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
fstReader	TokenNameIdentifier	 fst Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.out.println(" not found"); 	TokenNameCOMMENT_LINE	System.out.println(" not found"); 
if	TokenNameif	
(	TokenNameLPAREN	
prefixLength	TokenNameIdentifier	 prefix Length
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefixLength	TokenNameIdentifier	 prefix Length
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
return	TokenNamereturn	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prefixLength	TokenNameIdentifier	 prefix Length
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefixLength	TokenNameIdentifier	 prefix Length
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
T	TokenNameIdentifier	 T
randomAcceptedWord	TokenNameIdentifier	 random Accepted Word
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
arcs	TokenNameIdentifier	 arcs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
T	TokenNameIdentifier	 T
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// read all arcs: 	TokenNameCOMMENT_LINE	read all arcs: 
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arcs	TokenNameIdentifier	 arcs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arcs	TokenNameIdentifier	 arcs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// pick one 	TokenNameCOMMENT_LINE	pick one 
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
arcs	TokenNameIdentifier	 arcs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
arcs	TokenNameIdentifier	 arcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arcs	TokenNameIdentifier	 arcs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// accumulate output 	TokenNameCOMMENT_LINE	accumulate output 
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// append label 	TokenNameCOMMENT_LINE	append label 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
int	TokenNameint	
prune1	TokenNameIdentifier	 prune1
,	TokenNameCOMMA	
int	TokenNameint	
prune2	TokenNameIdentifier	 prune2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
allowRandomSuffixSharing	TokenNameIdentifier	 allow Random Suffix Sharing
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" TEST: prune1="	TokenNameStringLiteral	 TEST: prune1=
+	TokenNamePLUS	
prune1	TokenNameIdentifier	 prune1
+	TokenNamePLUS	
" prune2="	TokenNameStringLiteral	 prune2=
+	TokenNamePLUS	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
willRewrite	TokenNameIdentifier	 will Rewrite
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
:	TokenNameCOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
,	TokenNameCOMMA	
prune1	TokenNameIdentifier	 prune1
,	TokenNameCOMMA	
prune2	TokenNameIdentifier	 prune2
,	TokenNameCOMMA	
prune1	TokenNameIdentifier	 prune1
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
prune2	TokenNameIdentifier	 prune2
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
allowRandomSuffixSharing	TokenNameIdentifier	 allow Random Suffix Sharing
?	TokenNameQUESTION	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
true	TokenNametrue	
,	TokenNameCOMMA	
allowRandomSuffixSharing	TokenNameIdentifier	 allow Random Suffix Sharing
?	TokenNameQUESTION	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
willRewrite	TokenNameIdentifier	 will Rewrite
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
instanceof	TokenNameinstanceof	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
.	TokenNameDOT	
TwoLongs	TokenNameIdentifier	 Two Longs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
_outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
)	TokenNameRPAREN	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
.	TokenNameDOT	
TwoLongs	TokenNameIdentifier	 Two Longs
twoLongs	TokenNameIdentifier	 two Longs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UpToTwoPositiveIntOutputs	TokenNameIdentifier	 Up To Two Positive Int Outputs
.	TokenNameDOT	
TwoLongs	TokenNameIdentifier	 Two Longs
)	TokenNameRPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
builderObject	TokenNameIdentifier	 builder Object
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
;	TokenNameSEMICOLON	
builderObject	TokenNameIdentifier	 builder Object
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
_outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
twoLongs	TokenNameIdentifier	 two Longs
.	TokenNameDOT	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builderObject	TokenNameIdentifier	 builder Object
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
_outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
twoLongs	TokenNameIdentifier	 two Longs
.	TokenNameDOT	
second	TokenNameIdentifier	 second
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fst	TokenNameIdentifier	 fst
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
willRewrite	TokenNameIdentifier	 will Rewrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexOutput	TokenNameIdentifier	 Index Output
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
createOutput	TokenNameIdentifier	 create Output
(	TokenNameLPAREN	
"fst.bin"	TokenNameStringLiteral	fst.bin
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexInput	TokenNameIdentifier	 Index Input
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
"fst.bin"	TokenNameStringLiteral	fst.bin
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
"fst.bin"	TokenNameStringLiteral	fst.bin
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
&&	TokenNameAND_AND	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
20	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fst	TokenNameIdentifier	 fst
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Writer	TokenNameIdentifier	 Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
(	TokenNameLPAREN	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
"out.dot"	TokenNameStringLiteral	out.dot
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toDot	TokenNameIdentifier	 to Dot
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"SAVED out.dot"	TokenNameStringLiteral	SAVED out.dot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" fst has 0 nodes (fully pruned)"	TokenNameStringLiteral	 fst has 0 nodes (fully pruned)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" fst has "	TokenNameStringLiteral	 fst has 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" nodes and "	TokenNameStringLiteral	 nodes and 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" arcs"	TokenNameStringLiteral	 arcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prune1	TokenNameIdentifier	 prune1
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
prune2	TokenNameIdentifier	 prune2
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
verifyUnPruned	TokenNameIdentifier	 verify Un Pruned
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
verifyPruned	TokenNameIdentifier	 verify Pruned
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
prune1	TokenNameIdentifier	 prune1
,	TokenNameCOMMA	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
willRewrite	TokenNameIdentifier	 will Rewrite
&&	TokenNameAND_AND	
fst	TokenNameIdentifier	 fst
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now rewrite"	TokenNameStringLiteral	TEST: now rewrite
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
packed	TokenNameIdentifier	 packed
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
pack	TokenNameIdentifier	 pack
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now verify packed FST"	TokenNameStringLiteral	TEST: now verify packed FST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prune1	TokenNameIdentifier	 prune1
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
prune2	TokenNameIdentifier	 prune2
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
verifyUnPruned	TokenNameIdentifier	 verify Un Pruned
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
packed	TokenNameIdentifier	 packed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
verifyPruned	TokenNameIdentifier	 verify Pruned
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
packed	TokenNameIdentifier	 packed
,	TokenNameCOMMA	
prune1	TokenNameIdentifier	 prune1
,	TokenNameCOMMA	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// FST is complete 	TokenNameCOMMENT_LINE	FST is complete 
private	TokenNameprivate	
void	TokenNamevoid	
verifyUnPruned	TokenNameIdentifier	 verify Un Pruned
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fstLong	TokenNameIdentifier	 fst Long
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
validOutputs	TokenNameIdentifier	 valid Outputs
;	TokenNameSEMICOLON	
long	TokenNamelong	
minLong	TokenNameIdentifier	 min Long
=	TokenNameEQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
long	TokenNamelong	
maxLong	TokenNameIdentifier	 max Long
=	TokenNameEQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fstLong0	TokenNameIdentifier	 fst Long0
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
)	TokenNameRPAREN	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
fstLong	TokenNameIdentifier	 fst Long
=	TokenNameEQUAL	
fstLong0	TokenNameIdentifier	 fst Long0
;	TokenNameSEMICOLON	
validOutputs	TokenNameIdentifier	 valid Outputs
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Long	TokenNameIdentifier	 Long
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
)	TokenNameRPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
maxLong	TokenNameIdentifier	 max Long
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxLong	TokenNameIdentifier	 max Long
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
minLong	TokenNameIdentifier	 min Long
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
minLong	TokenNameIdentifier	 min Long
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validOutputs	TokenNameIdentifier	 valid Outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fstLong	TokenNameIdentifier	 fst Long
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
validOutputs	TokenNameIdentifier	 valid Outputs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now verify "	TokenNameStringLiteral	TEST: now verify 
+	TokenNamePLUS	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" terms"	TokenNameStringLiteral	 terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// visit valid pairs in order -- make sure all words 	TokenNameCOMMENT_LINE	visit valid pairs in order -- make sure all words 
// are accepted, and FSTEnum's next() steps through 	TokenNameCOMMENT_LINE	are accepted, and FSTEnum's next() steps through 
// them correctly 	TokenNameCOMMENT_LINE	them correctly 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: check valid terms/next()"	TokenNameStringLiteral	TEST: check valid terms/next()
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: check term="	TokenNameStringLiteral	TEST: check term=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
+	TokenNamePLUS	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Object	TokenNameIdentifier	 Object
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
+	TokenNamePLUS	
" is not accepted"	TokenNameStringLiteral	 is not accepted
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// verify enum's next 	TokenNameCOMMENT_LINE	verify enum's next 
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"expected input="	TokenNameStringLiteral	expected input=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
+	TokenNamePLUS	
" but fstEnum returned "	TokenNameStringLiteral	 but fstEnum returned 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
termsMap	TokenNameIdentifier	 terms Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termsMap	TokenNameIdentifier	 terms Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
&&	TokenNameAND_AND	
maxLong	TokenNameIdentifier	 max Long
>	TokenNameGREATER	
minLong	TokenNameIdentifier	 min Long
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Do random lookups so we test null (output doesn't 	TokenNameCOMMENT_LINE	Do random lookups so we test null (output doesn't 
// exist) case: 	TokenNameCOMMENT_LINE	exist) case: 
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fstLong	TokenNameIdentifier	 fst Long
,	TokenNameCOMMA	
minLong	TokenNameIdentifier	 min Long
-	TokenNameMINUS	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fstLong	TokenNameIdentifier	 fst Long
,	TokenNameCOMMA	
maxLong	TokenNameIdentifier	 max Long
+	TokenNamePLUS	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Long	TokenNameIdentifier	 Long
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
minLong	TokenNameIdentifier	 min Long
+	TokenNamePLUS	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
(	TokenNameLPAREN	
maxLong	TokenNameIdentifier	 max Long
-	TokenNameMINUS	
minLong	TokenNameIdentifier	 min Long
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fstLong	TokenNameIdentifier	 fst Long
,	TokenNameCOMMA	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
validOutputs	TokenNameIdentifier	 valid Outputs
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
||	TokenNameOR_OR	
input	TokenNameIdentifier	 input
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// find random matching word and make sure it's valid 	TokenNameCOMMENT_LINE	find random matching word and make sure it's valid 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: verify random accepted terms"	TokenNameStringLiteral	TEST: verify random accepted terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
500	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
randomAcceptedWord	TokenNameIdentifier	 random Accepted Word
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"accepted word "	TokenNameStringLiteral	accepted word 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
+	TokenNamePLUS	
" is not valid"	TokenNameStringLiteral	 is not valid
,	TokenNameCOMMA	
termsMap	TokenNameIdentifier	 terms Map
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
termsMap	TokenNameIdentifier	 terms Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doReverseLookup	TokenNameIdentifier	 do Reverse Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("lookup output=" + output + " outs=" + fst.outputs); 	TokenNameCOMMENT_LINE	System.out.println("lookup output=" + output + " outs=" + fst.outputs); 
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fstLong	TokenNameIdentifier	 fst Long
,	TokenNameCOMMA	
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" got " + Util.toBytesRef(input, new BytesRef()).utf8ToString()); 	TokenNameCOMMENT_LINE	System.out.println(" got " + Util.toBytesRef(input, new BytesRef()).utf8ToString()); 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// test IntsRefFSTEnum.seek: 	TokenNameCOMMENT_LINE	test IntsRefFSTEnum.seek: 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: verify seek"	TokenNameStringLiteral	TEST: verify seek
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" iter="	TokenNameStringLiteral	 iter=
+	TokenNamePLUS	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// seek to term that doesn't exist: 	TokenNameCOMMENT_LINE	seek to term that doesn't exist: 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
getRandomString	TokenNameIdentifier	 get Random String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
new	TokenNamenew	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
-	TokenNameMINUS	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ok doesn't exist 	TokenNameCOMMENT_LINE	ok doesn't exist 
//System.out.println(" seek " + inputToString(inputMode, term)); 	TokenNameCOMMENT_LINE	System.out.println(" seek " + inputToString(inputMode, term)); 
final	TokenNamefinal	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
seekResult	TokenNameIdentifier	 seek Result
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do non-exist seekFloor term="	TokenNameStringLiteral	 do non-exist seekFloor term=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do non-exist seekCeil term="	TokenNameStringLiteral	 do non-exist seekCeil term=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" got " + inputToString(inputMode,seekResult.input) + " output=" + fst.outputs.outputToString(seekResult.output)); 	TokenNameCOMMENT_LINE	System.out.println(" got " + inputToString(inputMode,seekResult.input) + " output=" + fst.outputs.outputToString(seekResult.output)); 
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
"got null but expected term="	TokenNameStringLiteral	got null but expected term=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" got "	TokenNameStringLiteral	 got 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"expected "	TokenNameStringLiteral	expected 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
" but got "	TokenNameStringLiteral	 but got 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// seeked before start or beyond end 	TokenNameCOMMENT_LINE	seeked before start or beyond end 
//System.out.println("seek=" + seekTerm); 	TokenNameCOMMENT_LINE	System.out.println("seek=" + seekTerm); 
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
"expected null but got "	TokenNameStringLiteral	expected null but got 
+	TokenNamePLUS	
(	TokenNameLPAREN	
seekResult	TokenNameIdentifier	 seek Result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"null"	TokenNameStringLiteral	null
:	TokenNameCOLON	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" got null"	TokenNameStringLiteral	 got null
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// seek to term that does exist: 	TokenNameCOMMENT_LINE	seek to term that does exist: 
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
=	TokenNameEQUAL	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
seekResult	TokenNameIdentifier	 seek Result
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do exists seekFloor "	TokenNameStringLiteral	 do exists seekFloor 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do exists seekCeil "	TokenNameStringLiteral	 do exists seekCeil 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"got "	TokenNameStringLiteral	got 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
" but expected "	TokenNameStringLiteral	 but expected 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: mixed next/seek"	TokenNameStringLiteral	TEST: mixed next/seek
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// test mixed next/seek 	TokenNameCOMMENT_LINE	test mixed next/seek 
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: iter "	TokenNameStringLiteral	TEST: iter 
+	TokenNamePLUS	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset: 	TokenNameCOMMENT_LINE	reset: 
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
==	TokenNameEQUAL_EQUAL	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// next 	TokenNameCOMMENT_LINE	next 
upto	TokenNameIdentifier	 upto
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do next"	TokenNameStringLiteral	 do next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
0.75	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attempt	TokenNameIdentifier	 attempt
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
attempt	TokenNameIdentifier	 attempt
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
attempt	TokenNameIdentifier	 attempt
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
getRandomString	TokenNameIdentifier	 get Random String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
termsMap	TokenNameIdentifier	 terms Map
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
new	TokenNamenew	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
-	TokenNameMINUS	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
upto	TokenNameIdentifier	 upto
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do non-exist seekFloor("	TokenNameStringLiteral	 do non-exist seekFloor(
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do non-exist seekCeil("	TokenNameStringLiteral	 do non-exist seekCeil(
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attempt	TokenNameIdentifier	 attempt
==	TokenNameEQUAL_EQUAL	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
inc	TokenNameIdentifier	 inc
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
upto	TokenNameIdentifier	 upto
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
upto	TokenNameIdentifier	 upto
+=	TokenNamePLUS_EQUAL	
inc	TokenNameIdentifier	 inc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do advanceCeil("	TokenNameStringLiteral	 do advanceCeil(
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" do advanceFloor("	TokenNameStringLiteral	 do advanceFloor(
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isDone	TokenNameIdentifier	 is Done
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isDone	TokenNameIdentifier	 is Done
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" got "	TokenNameStringLiteral	 got 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" got null"	TokenNameStringLiteral	 got null
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
==	TokenNameEQUAL_EQUAL	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
isDone	TokenNameIdentifier	 is Done
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertFalse	TokenNameIdentifier	 assert False
(	TokenNameLPAREN	
isDone	TokenNameIdentifier	 is Done
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* if (upto < pairs.size()-1) { int tryCount = 0; while(tryCount < 10) { final IntsRef t = toIntsRef(getRandomString(), inputMode); if (pairs.get(upto).input.compareTo(t) < 0) { final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0; if (VERBOSE) { System.out.println("TEST: call beforeNext(" + inputToString(inputMode, t) + "); current=" + inputToString(inputMode, pairs.get(upto).input) + " next=" + inputToString(inputMode, pairs.get(upto+1).input) + " expected=" + expected); } assertEquals(expected, fstEnum.beforeNext(t)); break; } tryCount++; } } */	TokenNameCOMMENT_BLOCK	 if (upto < pairs.size()-1) { int tryCount = 0; while(tryCount < 10) { final IntsRef t = toIntsRef(getRandomString(), inputMode); if (pairs.get(upto).input.compareTo(t) < 0) { final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0; if (VERBOSE) { System.out.println("TEST: call beforeNext(" + inputToString(inputMode, t) + "); current=" + inputToString(inputMode, pairs.get(upto).input) + " next=" + inputToString(inputMode, pairs.get(upto+1).input) + " expected=" + expected); } assertEquals(expected, fstEnum.beforeNext(t)); break; } tryCount++; } } 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
finalOutput	TokenNameIdentifier	 final Output
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isLeaf	TokenNameIdentifier	 is Leaf
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isFinal	TokenNameIdentifier	 is Final
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// FST is pruned 	TokenNameCOMMENT_LINE	FST is pruned 
private	TokenNameprivate	
void	TokenNamevoid	
verifyPruned	TokenNameIdentifier	 verify Pruned
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
int	TokenNameint	
prune1	TokenNameIdentifier	 prune1
,	TokenNameCOMMA	
int	TokenNameint	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now verify pruned "	TokenNameStringLiteral	TEST: now verify pruned 
+	TokenNamePLUS	
pairs	TokenNameIdentifier	 pairs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" terms; outputs="	TokenNameStringLiteral	 terms; outputs=
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// To validate the FST, we brute-force compute all prefixes 	TokenNameCOMMENT_LINE	To validate the FST, we brute-force compute all prefixes 
// in the terms, matched to their "common" outputs, prune that 	TokenNameCOMMENT_LINE	in the terms, matched to their "common" outputs, prune that 
// set according to the prune thresholds, then assert the FST 	TokenNameCOMMENT_LINE	set according to the prune thresholds, then assert the FST 
// matches that same set. 	TokenNameCOMMENT_LINE	matches that same set. 
// NOTE: Crazy RAM intensive!! 	TokenNameCOMMENT_LINE	NOTE: Crazy RAM intensive!! 
//System.out.println("TEST: tally prefixes"); 	TokenNameCOMMENT_LINE	System.out.println("TEST: tally prefixes"); 
// build all prefixes 	TokenNameCOMMENT_LINE	build all prefixes 
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
prefixes	TokenNameIdentifier	 prefixes
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
:	TokenNameCOLON	
pairs	TokenNameIdentifier	 pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
copyInts	TokenNameIdentifier	 copy Ints
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<=	TokenNameLESS_EQUAL	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo	TokenNameIdentifier	 cmo
=	TokenNameEQUAL	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cmo	TokenNameIdentifier	 cmo
=	TokenNameEQUAL	
new	TokenNamenew	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
.	TokenNameDOT	
deepCopyOf	TokenNameIdentifier	 deep Copy Of
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cmo	TokenNameIdentifier	 cmo
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
output1	TokenNameIdentifier	 output1
=	TokenNameEQUAL	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
output1	TokenNameIdentifier	 output1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output1	TokenNameIdentifier	 output1
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
T	TokenNameIdentifier	 T
output2	TokenNameIdentifier	 output2
=	TokenNameEQUAL	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
output2	TokenNameIdentifier	 output2
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output2	TokenNameIdentifier	 output2
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
common	TokenNameIdentifier	 common
(	TokenNameLPAREN	
output1	TokenNameIdentifier	 output1
,	TokenNameCOMMA	
output2	TokenNameIdentifier	 output2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
==	TokenNameEQUAL_EQUAL	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
finalOutput	TokenNameIdentifier	 final Output
=	TokenNameEQUAL	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: now prune"	TokenNameStringLiteral	TEST: now prune
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// prune 'em 	TokenNameCOMMENT_LINE	prune 'em 
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
ent	TokenNameIdentifier	 ent
=	TokenNameEQUAL	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo	TokenNameIdentifier	 cmo
=	TokenNameEQUAL	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" term prefix="	TokenNameStringLiteral	 term prefix=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" count="	TokenNameStringLiteral	 count=
+	TokenNamePLUS	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
" isLeaf="	TokenNameStringLiteral	 isLeaf=
+	TokenNamePLUS	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isLeaf	TokenNameIdentifier	 is Leaf
+	TokenNamePLUS	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
+	TokenNamePLUS	
" isFinal="	TokenNameStringLiteral	 isFinal=
+	TokenNamePLUS	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
keep	TokenNameIdentifier	 keep
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prune1	TokenNameIdentifier	 prune1
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keep	TokenNameIdentifier	 keep
=	TokenNameEQUAL	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
prune1	TokenNameIdentifier	 prune1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
prune2	TokenNameIdentifier	 prune2
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prune2	TokenNameIdentifier	 prune2
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keep	TokenNameIdentifier	 keep
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// consult our parent 	TokenNameCOMMENT_LINE	consult our parent 
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo2	TokenNameIdentifier	 cmo2
=	TokenNameEQUAL	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" parent count = " + (cmo2 == null ? -1 : cmo2.count)); 	TokenNameCOMMENT_LINE	System.out.println(" parent count = " + (cmo2 == null ? -1 : cmo2.count)); 
keep	TokenNameIdentifier	 keep
=	TokenNameEQUAL	
cmo2	TokenNameIdentifier	 cmo2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
prune2	TokenNameIdentifier	 prune2
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
cmo2	TokenNameIdentifier	 cmo2
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
prune2	TokenNameIdentifier	 prune2
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
cmo2	TokenNameIdentifier	 cmo2
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
prune2	TokenNameIdentifier	 prune2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keep	TokenNameIdentifier	 keep
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
keep	TokenNameIdentifier	 keep
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
keep	TokenNameIdentifier	 keep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" remove"); 	TokenNameCOMMENT_LINE	System.out.println(" remove"); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// clear isLeaf for all ancestors 	TokenNameCOMMENT_LINE	clear isLeaf for all ancestors 
//System.out.println(" keep"); 	TokenNameCOMMENT_LINE	System.out.println(" keep"); 
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
copyInts	TokenNameIdentifier	 copy Ints
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo2	TokenNameIdentifier	 cmo2
=	TokenNameEQUAL	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cmo2	TokenNameIdentifier	 cmo2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" clear isLeaf " + inputToString(inputMode, scratch)); 	TokenNameCOMMENT_LINE	System.out.println(" clear isLeaf " + inputToString(inputMode, scratch)); 
cmo2	TokenNameIdentifier	 cmo2
.	TokenNameDOT	
isLeaf	TokenNameIdentifier	 is Leaf
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* if (VERBOSE) { System.out.println("TEST: after prune"); for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) { System.out.println(" " + inputToString(inputMode, ent.getKey(), false) + ": isLeaf=" + ent.getValue().isLeaf + " isFinal=" + ent.getValue().isFinal); if (ent.getValue().isFinal) { System.out.println(" finalOutput=" + outputs.outputToString(ent.getValue().finalOutput)); } } } */	TokenNameCOMMENT_BLOCK	 if (VERBOSE) { System.out.println("TEST: after prune"); for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) { System.out.println(" " + inputToString(inputMode, ent.getKey(), false) + ": isLeaf=" + ent.getValue().isLeaf + " isFinal=" + ent.getValue().isFinal); if (ent.getValue().isFinal) { System.out.println(" finalOutput=" + outputs.outputToString(ent.getValue().finalOutput)); } } } 
if	TokenNameif	
(	TokenNameLPAREN	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// make sure FST only enums valid prefixes 	TokenNameCOMMENT_LINE	make sure FST only enums valid prefixes 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: check pruned enum"	TokenNameStringLiteral	TEST: check pruned enum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" fstEnum.next prefix="	TokenNameStringLiteral	 fstEnum.next prefix=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo	TokenNameIdentifier	 cmo
=	TokenNameEQUAL	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isLeaf	TokenNameIdentifier	 is Leaf
||	TokenNameOR_OR	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if (cmo.isFinal && !cmo.isLeaf) { 	TokenNameCOMMENT_LINE	if (cmo.isFinal && !cmo.isLeaf) { 
if	TokenNameif	
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
finalOutput	TokenNameIdentifier	 final Output
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// make sure all non-pruned prefixes are present in the FST 	TokenNameCOMMENT_LINE	make sure all non-pruned prefixes are present in the FST 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: verify all prefixes"	TokenNameStringLiteral	TEST: verify all prefixes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stopNode	TokenNameIdentifier	 stop Node
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
,	TokenNameCOMMA	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
ent	TokenNameIdentifier	 ent
:	TokenNameCOLON	
prefixes	TokenNameIdentifier	 prefixes
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
CountMinOutput	TokenNameIdentifier	 Count Min Output
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
cmo	TokenNameIdentifier	 cmo
=	TokenNameEQUAL	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
T	TokenNameIdentifier	 T
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
stopNode	TokenNameIdentifier	 stop Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: verify prefix="	TokenNameStringLiteral	TEST: verify prefix=
+	TokenNamePLUS	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if (cmo.isFinal && !cmo.isLeaf) { 	TokenNameCOMMENT_LINE	if (cmo.isFinal && !cmo.isLeaf) { 
if	TokenNameif	
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
finalOutput	TokenNameIdentifier	 final Output
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
cmo	TokenNameIdentifier	 cmo
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
stopNode	TokenNameIdentifier	 stop Node
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testRandomWords	TokenNameIdentifier	 test Random Words
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
testRandomWords	TokenNameIdentifier	 test Random Words
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//testRandomWords(100, 1); 	TokenNameCOMMENT_LINE	testRandomWords(100, 1); 
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
inputModeToString	TokenNameIdentifier	 input Mode To String
(	TokenNameLPAREN	
int	TokenNameint	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mode	TokenNameIdentifier	 mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"utf8"	TokenNameStringLiteral	utf8
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
"utf32"	TokenNameStringLiteral	utf32
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
testRandomWords	TokenNameIdentifier	 test Random Words
(	TokenNameLPAREN	
int	TokenNameint	
maxNumWords	TokenNameIdentifier	 max Num Words
,	TokenNameCOMMA	
int	TokenNameint	
numIter	TokenNameIdentifier	 num Iter
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
numIter	TokenNameIdentifier	 num Iter
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" TEST: iter "	TokenNameStringLiteral	 TEST: iter 
+	TokenNamePLUS	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
inputMode	TokenNameIdentifier	 input Mode
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
inputMode	TokenNameIdentifier	 input Mode
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
numWords	TokenNameIdentifier	 num Words
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
maxNumWords	TokenNameIdentifier	 max Num Words
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>	TokenNameGREATER	
termsSet	TokenNameIdentifier	 terms Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
IntsRef	TokenNameIdentifier	 Ints Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
terms	TokenNameIdentifier	 terms
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
numWords	TokenNameIdentifier	 num Words
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
termsSet	TokenNameIdentifier	 terms Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
numWords	TokenNameIdentifier	 num Words
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
getRandomString	TokenNameIdentifier	 get Random String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termsSet	TokenNameIdentifier	 terms Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
doTest	TokenNameIdentifier	 do Test
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
termsSet	TokenNameIdentifier	 terms Set
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
[	TokenNameLBRACKET	
termsSet	TokenNameIdentifier	 terms Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getRandomString	TokenNameIdentifier	 get Random String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
randomRealisticUnicodeString	TokenNameIdentifier	 random Realistic Unicode String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// we want to mix in limited-alphabet symbols so 	TokenNameCOMMENT_LINE	we want to mix in limited-alphabet symbols so 
// we get more sharing of the nodes given how few 	TokenNameCOMMENT_LINE	we get more sharing of the nodes given how few 
// terms we are testing... 	TokenNameCOMMENT_LINE	terms we are testing... 
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
simpleRandomString	TokenNameIdentifier	 simple Random String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Nightly	TokenNameIdentifier	 Nightly
public	TokenNamepublic	
void	TokenNamevoid	
testBigSet	TokenNameIdentifier	 test Big Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
testRandomWords	TokenNameIdentifier	 test Random Words
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
50000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
60000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
inputToString	TokenNameIdentifier	 input To String
(	TokenNameLPAREN	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
IntsRef	TokenNameIdentifier	 Ints Ref
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isValidUnicode	TokenNameIdentifier	 is Valid Unicode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isValidUnicode	TokenNameIdentifier	 is Valid Unicode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// utf8 	TokenNameCOMMENT_LINE	utf8 
return	TokenNamereturn	
toBytesRef	TokenNameIdentifier	 to Bytes Ref
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
.	TokenNameDOT	
utf8ToString	TokenNameIdentifier	 utf8 To String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// utf32 	TokenNameCOMMENT_LINE	utf32 
return	TokenNamereturn	
UnicodeUtil	TokenNameIdentifier	 Unicode Util
.	TokenNameDOT	
newString	TokenNameIdentifier	 new String
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
IntsRef	TokenNameIdentifier	 Ints Ref
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
charCount	TokenNameIdentifier	 char Count
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IntsRef	TokenNameIdentifier	 Ints Ref
ir	TokenNameIdentifier	 ir
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
charCount	TokenNameIdentifier	 char Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
charIDX	TokenNameIdentifier	 char IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
charIDX	TokenNameIdentifier	 char IDX
<	TokenNameLESS	
charCount	TokenNameIdentifier	 char Count
;	TokenNameSEMICOLON	
charIDX	TokenNameIdentifier	 char IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
charIDX	TokenNameIdentifier	 char IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
charIDX	TokenNameIdentifier	 char IDX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ir	TokenNameIdentifier	 ir
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
charCount	TokenNameIdentifier	 char Count
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ir	TokenNameIdentifier	 ir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
ints	TokenNameIdentifier	 ints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chars	TokenNameIdentifier	 chars
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
charIDX	TokenNameIdentifier	 char IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
charIDX	TokenNameIdentifier	 char IDX
<	TokenNameLESS	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
charIDX	TokenNameIdentifier	 char IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
ints	TokenNameIdentifier	 ints
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
charIDX	TokenNameIdentifier	 char IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
<	TokenNameLESS	
65536	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
charIDX	TokenNameIdentifier	 char IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Build FST for all unique terms in the test line docs 	TokenNameCOMMENT_LINE	Build FST for all unique terms in the test line docs 
// file, up until a time limit 	TokenNameCOMMENT_LINE	file, up until a time limit 
public	TokenNamepublic	
void	TokenNamevoid	
testRealTerms	TokenNameIdentifier	 test Real Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
/* if (CodecProvider.getDefault().getDefaultFieldCodec().equals("SimpleText")) { // no CodecProvider.getDefault().setDefaultFieldCodec("Standard"); } */	TokenNameCOMMENT_BLOCK	 if (CodecProvider.getDefault().getDefaultFieldCodec().equals("SimpleText")) { // no CodecProvider.getDefault().setDefaultFieldCodec("Standard"); } 
final	TokenNamefinal	
LineFileDocs	TokenNameIdentifier	 Line File Docs
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
new	TokenNamenew	
LineFileDocs	TokenNameIdentifier	 Line File Docs
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
RUN_TIME_MSEC	TokenNameIdentifier	 RUN  TIME  MSEC
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
500	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
conf	TokenNameIdentifier	 conf
=	TokenNameEQUAL	
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setMaxBufferedDocs	TokenNameIdentifier	 set Max Buffered Docs
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRAMBufferSizeMB	TokenNameIdentifier	 set RAM Buffer Size MB
(	TokenNameLPAREN	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
tempDir	TokenNameIdentifier	 temp Dir
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
getTempDir	TokenNameIdentifier	 get Temp Dir
(	TokenNameLPAREN	
"fstlines"	TokenNameStringLiteral	fstlines
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
newFSDirectory	TokenNameIdentifier	 new FS Directory
(	TokenNameLPAREN	
tempDir	TokenNameIdentifier	 temp Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
new	TokenNamenew	
IndexWriter	TokenNameIdentifier	 Index Writer
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
?	TokenNameQUESTION	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
stopTime	TokenNameIdentifier	 stop Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
RUN_TIME_MSEC	TokenNameIdentifier	 RUN  TIME  MSEC
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
stopTime	TokenNameIdentifier	 stop Time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
docCount	TokenNameIdentifier	 doc Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
doRewrite	TokenNameIdentifier	 do Rewrite
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE2	TokenNameIdentifier	 BYT E2
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
doRewrite	TokenNameIdentifier	 do Rewrite
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
storeOrd	TokenNameIdentifier	 store Ord
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"FST stores ord"	TokenNameStringLiteral	FST stores ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"FST stores docFreq"	TokenNameStringLiteral	FST stores docFreq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
TermEnum	TokenNameIdentifier	 Term Enum
termEnum	TokenNameIdentifier	 term Enum
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
terms	TokenNameIdentifier	 terms
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
"body"	TokenNameStringLiteral	body
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: got termEnum="	TokenNameStringLiteral	TEST: got termEnum=
+	TokenNamePLUS	
termEnum	TokenNameIdentifier	 term Enum
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
"body"	TokenNameStringLiteral	body
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// No ord in 3.x: 	TokenNameCOMMENT_LINE	No ord in 3.x: 
/* if (ord == 0) { try { termsEnum.ord(); } catch (UnsupportedOperationException uoe) { if (VERBOSE) { System.out.println("TEST: codec doesn't support ord; FST stores docFreq"); } storeOrd = false; } } */	TokenNameCOMMENT_BLOCK	 if (ord == 0) { try { termsEnum.ord(); } catch (UnsupportedOperationException uoe) { if (VERBOSE) { System.out.println("TEST: codec doesn't support ord; FST stores docFreq"); } storeOrd = false; } } 
final	TokenNamefinal	
int	TokenNameint	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
ord	TokenNameIdentifier	 ord
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println("ADD: " + term.text() + " ch[0]=" + (term.text().length() == 0 ? -1 : term.text().charAt(0))); 	TokenNameCOMMENT_LINE	System.out.println("ADD: " + term.text() + " ch[0]=" + (term.text().length() == 0 ? -1 : term.text().charAt(0))); 
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ord	TokenNameIdentifier	 ord
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
&&	TokenNameAND_AND	
ord	TokenNameIdentifier	 ord
%	TokenNameREMAINDER	
100000	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
.	TokenNameDOT	
TEST_NIGHTLY	TokenNameIdentifier	 TEST  NIGHTLY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
+	TokenNamePLUS	
" terms..."	TokenNameStringLiteral	 terms...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"FST: "	TokenNameStringLiteral	FST: 
+	TokenNamePLUS	
docCount	TokenNameIdentifier	 doc Count
+	TokenNamePLUS	
" docs; "	TokenNameStringLiteral	 docs; 
+	TokenNamePLUS	
ord	TokenNameIdentifier	 ord
+	TokenNamePLUS	
" terms; "	TokenNameStringLiteral	 terms; 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" nodes; "	TokenNameStringLiteral	 nodes; 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" arcs;"	TokenNameStringLiteral	 arcs;
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" bytes"	TokenNameStringLiteral	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
rewriteIter	TokenNameIdentifier	 rewrite Iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rewriteIter	TokenNameIdentifier	 rewrite Iter
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rewriteIter	TokenNameIdentifier	 rewrite Iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rewriteIter	TokenNameIdentifier	 rewrite Iter
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doRewrite	TokenNameIdentifier	 do Rewrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Verify again, with packed FST: 	TokenNameCOMMENT_LINE	Verify again, with packed FST: 
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
pack	TokenNameIdentifier	 pack
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Now confirm BytesRefFSTEnum and TermsEnum act the 	TokenNameCOMMENT_LINE	Now confirm BytesRefFSTEnum and TermsEnum act the 
// same: 	TokenNameCOMMENT_LINE	same: 
final	TokenNamefinal	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
randomTerm	TokenNameIdentifier	 random Term
=	TokenNameEQUAL	
getRandomString	TokenNameIdentifier	 get Random String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: seek "	TokenNameStringLiteral	TEST: seek 
+	TokenNamePLUS	
randomTerm	TokenNameIdentifier	 random Term
+	TokenNamePLUS	
" ch[0]="	TokenNameStringLiteral	 ch[0]=
+	TokenNamePLUS	
(	TokenNameLPAREN	
randomTerm	TokenNameIdentifier	 random Term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
randomTerm	TokenNameIdentifier	 random Term
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
termEnum	TokenNameIdentifier	 term Enum
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
terms	TokenNameIdentifier	 terms
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
"body"	TokenNameStringLiteral	body
,	TokenNameCOMMA	
randomTerm	TokenNameIdentifier	 random Term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fstSeekResult	TokenNameIdentifier	 fst Seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
randomTerm	TokenNameIdentifier	 random Term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
"body"	TokenNameStringLiteral	body
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
"got "	TokenNameStringLiteral	got 
+	TokenNamePLUS	
(	TokenNameLPAREN	
fstSeekResult	TokenNameIdentifier	 fst Seek Result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"null"	TokenNameStringLiteral	null
:	TokenNameCOLON	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fstSeekResult	TokenNameIdentifier	 fst Seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
" but expected null"	TokenNameStringLiteral	 but expected null
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fstSeekResult	TokenNameIdentifier	 fst Seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertSame	TokenNameIdentifier	 assert Same
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
,	TokenNameCOMMA	
fstEnum	TokenNameIdentifier	 fst Enum
,	TokenNameCOMMA	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
nextIter	TokenNameIdentifier	 next Iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextIter	TokenNameIdentifier	 next Iter
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextIter	TokenNameIdentifier	 next Iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: next"	TokenNameStringLiteral	TEST: next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if (storeOrd) { 	TokenNameCOMMENT_LINE	if (storeOrd) { 
//System.out.println(" ord=" + termEnum.ord()); 	TokenNameCOMMENT_LINE	System.out.println(" ord=" + termEnum.ord()); 
//} 	TokenNameCOMMENT_LINE	} 
}	TokenNameRBRACE	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
"body"	TokenNameStringLiteral	body
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" term="	TokenNameStringLiteral	 term=
+	TokenNamePLUS	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertSame	TokenNameIdentifier	 assert Same
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
,	TokenNameCOMMA	
fstEnum	TokenNameIdentifier	 fst Enum
,	TokenNameCOMMA	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" end!"	TokenNameStringLiteral	 end!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
nextResult	TokenNameIdentifier	 next Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextResult	TokenNameIdentifier	 next Result
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"expected null but got: input="	TokenNameStringLiteral	expected null but got: input=
+	TokenNamePLUS	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
nextResult	TokenNameIdentifier	 next Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
+	TokenNamePLUS	
" output="	TokenNameStringLiteral	 output=
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
nextResult	TokenNameIdentifier	 next Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
assertSame	TokenNameIdentifier	 assert Same
(	TokenNameLPAREN	
TermEnum	TokenNameIdentifier	 Term Enum
termEnum	TokenNameIdentifier	 term Enum
,	TokenNameCOMMA	
IntsRefFSTEnum	TokenNameIdentifier	 Ints Ref FST Enum
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
,	TokenNameCOMMA	
boolean	TokenNameboolean	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
"body"	TokenNameStringLiteral	body
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"fstEnum.current().input="	TokenNameStringLiteral	fstEnum.current().input=
+	TokenNamePLUS	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" != "	TokenNameStringLiteral	 != 
+	TokenNamePLUS	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
storeOrd	TokenNameIdentifier	 store Ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// fst stored the ord 	TokenNameCOMMENT_LINE	fst stored the ord 
// No ord in 3.x 	TokenNameCOMMENT_LINE	No ord in 3.x 
// assertEquals(termEnum.ord(), ((Long) fstEnum.current().output).longValue()); 	TokenNameCOMMENT_LINE	assertEquals(termEnum.ord(), ((Long) fstEnum.current().output).longValue()); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// fst stored the docFreq 	TokenNameCOMMENT_LINE	fst stored the docFreq 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
)	TokenNameRPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
current	TokenNameIdentifier	 current
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
VisitTerms	TokenNameIdentifier	 Visit Terms
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
dirOut	TokenNameIdentifier	 dir Out
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
wordsFileIn	TokenNameIdentifier	 words File In
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
doPack	TokenNameIdentifier	 do Pack
;	TokenNameSEMICOLON	
public	TokenNamepublic	
VisitTerms	TokenNameIdentifier	 Visit Terms
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
dirOut	TokenNameIdentifier	 dir Out
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
wordsFileIn	TokenNameIdentifier	 words File In
,	TokenNameCOMMA	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
int	TokenNameint	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doPack	TokenNameIdentifier	 do Pack
,	TokenNameCOMMA	
boolean	TokenNameboolean	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dirOut	TokenNameIdentifier	 dir Out
=	TokenNameEQUAL	
dirOut	TokenNameIdentifier	 dir Out
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
wordsFileIn	TokenNameIdentifier	 words File In
=	TokenNameEQUAL	
wordsFileIn	TokenNameIdentifier	 words File In
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
inputMode	TokenNameIdentifier	 input Mode
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
doPack	TokenNameIdentifier	 do Pack
=	TokenNameEQUAL	
doPack	TokenNameIdentifier	 do Pack
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
(	TokenNameLPAREN	
inputMode	TokenNameIdentifier	 input Mode
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
:	TokenNameCOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
doPack	TokenNameIdentifier	 do Pack
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
setAllowArrayArcs	TokenNameIdentifier	 set Allow Array Arcs
(	TokenNameLPAREN	
!	TokenNameNOT	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
abstract	TokenNameabstract	
T	TokenNameIdentifier	 T
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
boolean	TokenNameboolean	
verify	TokenNameIdentifier	 verify
,	TokenNameCOMMA	
boolean	TokenNameboolean	
verifyByOutput	TokenNameIdentifier	 verify By Output
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
BufferedReader	TokenNameIdentifier	 Buffered Reader
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedReader	TokenNameIdentifier	 Buffered Reader
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
wordsFileIn	TokenNameIdentifier	 words File In
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
,	TokenNameCOMMA	
65536	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
intsRef	TokenNameIdentifier	 ints Ref
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
tStart	TokenNameIdentifier	 t Start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
intsRef	TokenNameIdentifier	 ints Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
intsRef	TokenNameIdentifier	 ints Ref
,	TokenNameCOMMA	
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
intsRef	TokenNameIdentifier	 ints Ref
,	TokenNameCOMMA	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ord	TokenNameIdentifier	 ord
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
%	TokenNameREMAINDER	
500000	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
ENGLISH	TokenNameIdentifier	 ENGLISH
,	TokenNameCOMMA	
"%6.2fs: %9d..."	TokenNameStringLiteral	%6.2fs: %9d...
,	TokenNameCOMMA	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tStart	TokenNameIdentifier	 t Start
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
>=	TokenNameGREATER_EQUAL	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assert	TokenNameassert	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
getTermCount	TokenNameIdentifier	 get Term Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ord	TokenNameIdentifier	 ord
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"FST was fully pruned!"	TokenNameStringLiteral	FST was fully pruned!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
+	TokenNamePLUS	
" terms; "	TokenNameStringLiteral	 terms; 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" nodes; "	TokenNameStringLiteral	 nodes; 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcCount	TokenNameIdentifier	 get Arc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" arcs; "	TokenNameStringLiteral	 arcs; 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getArcWithOutputCount	TokenNameIdentifier	 get Arc With Output Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" arcs w/ output; tot size "	TokenNameStringLiteral	 arcs w/ output; tot size 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getNodeCount	TokenNameIdentifier	 get Node Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Writer	TokenNameIdentifier	 Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
OutputStreamWriter	TokenNameIdentifier	 Output Stream Writer
(	TokenNameLPAREN	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
"out.dot"	TokenNameStringLiteral	out.dot
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toDot	TokenNameIdentifier	 to Dot
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Wrote FST to out.dot"	TokenNameStringLiteral	Wrote FST to out.dot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doPack	TokenNameIdentifier	 do Pack
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Pack..."	TokenNameStringLiteral	Pack...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
pack	TokenNameIdentifier	 pack
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
100000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"New size "	TokenNameStringLiteral	New size 
+	TokenNamePLUS	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" bytes"	TokenNameStringLiteral	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexOutput	TokenNameIdentifier	 Index Output
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
createOutput	TokenNameIdentifier	 create Output
(	TokenNameLPAREN	
"fst.bin"	TokenNameStringLiteral	fst.bin
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Saved FST to fst.bin."	TokenNameStringLiteral	Saved FST to fst.bin.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
verify	TokenNameIdentifier	 verify
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Now verify..."	TokenNameStringLiteral	 Now verify...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedReader	TokenNameIdentifier	 Buffered Reader
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamReader	TokenNameIdentifier	 Input Stream Reader
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
wordsFileIn	TokenNameIdentifier	 words File In
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"UTF-8"	TokenNameStringLiteral	UTF-8
)	TokenNameRPAREN	
,	TokenNameCOMMA	
65536	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ord	TokenNameIdentifier	 ord
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
tStart	TokenNameIdentifier	 t Start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
readLine	TokenNameIdentifier	 read Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
intsRef	TokenNameIdentifier	 ints Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
T	TokenNameIdentifier	 T
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
intsRef	TokenNameIdentifier	 ints Ref
,	TokenNameCOMMA	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
actual	TokenNameIdentifier	 actual
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
intsRef	TokenNameIdentifier	 ints Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"unexpected null output on input="	TokenNameStringLiteral	unexpected null output on input=
+	TokenNamePLUS	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"wrong output (got "	TokenNameStringLiteral	wrong output (got 
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
+	TokenNamePLUS	
" but expected "	TokenNameStringLiteral	 but expected 
+	TokenNamePLUS	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
outputToString	TokenNameIdentifier	 output To String
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
+	TokenNamePLUS	
") on input="	TokenNameStringLiteral	) on input=
+	TokenNamePLUS	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Get by output 	TokenNameCOMMENT_LINE	Get by output 
final	TokenNamefinal	
Long	TokenNameIdentifier	 Long
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
)	TokenNameRPAREN	
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
intsRef	TokenNameIdentifier	 ints Ref
,	TokenNameCOMMA	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
actual	TokenNameIdentifier	 actual
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
)	TokenNameRPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"unexpected null input from output="	TokenNameStringLiteral	unexpected null input from output=
+	TokenNamePLUS	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
intsRef	TokenNameIdentifier	 ints Ref
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"wrong input (got "	TokenNameStringLiteral	wrong input (got 
+	TokenNamePLUS	
actual	TokenNameIdentifier	 actual
+	TokenNamePLUS	
" but expected "	TokenNameStringLiteral	 but expected 
+	TokenNamePLUS	
intsRef	TokenNameIdentifier	 ints Ref
+	TokenNamePLUS	
" from output="	TokenNameStringLiteral	 from output=
+	TokenNamePLUS	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ord	TokenNameIdentifier	 ord
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
%	TokenNameREMAINDER	
500000	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tStart	TokenNameIdentifier	 t Start
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"s: "	TokenNameStringLiteral	s: 
+	TokenNamePLUS	
ord	TokenNameIdentifier	 ord
+	TokenNamePLUS	
"..."	TokenNameStringLiteral	...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
>=	TokenNameGREATER_EQUAL	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
double	TokenNamedouble	
totSec	TokenNameIdentifier	 tot Sec
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tStart	TokenNameIdentifier	 t Start
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Verify "	TokenNameStringLiteral	Verify 
+	TokenNamePLUS	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
"(by output) "	TokenNameStringLiteral	(by output) 
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
+	TokenNamePLUS	
"took "	TokenNameStringLiteral	took 
+	TokenNamePLUS	
totSec	TokenNameIdentifier	 tot Sec
+	TokenNamePLUS	
" sec + ("	TokenNameStringLiteral	 sec + (
+	TokenNamePLUS	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
totSec	TokenNameIdentifier	 tot Sec
*	TokenNameMULTIPLY	
1000000000	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" nsec per lookup)"	TokenNameStringLiteral	 nsec per lookup)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
verifyByOutput	TokenNameIdentifier	 verify By Output
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// NOTE: comment out to profile lookup... 	TokenNameCOMMENT_LINE	NOTE: comment out to profile lookup... 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// java -cp build/classes/test:build/classes/test-framework:build/classes/java:lib/junit-4.10.jar org.apache.lucene.util.fst.TestFSTs /x/tmp/allTerms3.txt out 	TokenNameCOMMENT_LINE	java -cp build/classes/test:build/classes/test-framework:build/classes/java:lib/junit-4.10.jar org.apache.lucene.util.fst.TestFSTs /x/tmp/allTerms3.txt out 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
main	TokenNameIdentifier	 main
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
prune	TokenNameIdentifier	 prune
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
int	TokenNameint	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// utf8 	TokenNameCOMMENT_LINE	utf8 
boolean	TokenNameboolean	
storeOrds	TokenNameIdentifier	 store Ords
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
storeDocFreqs	TokenNameIdentifier	 store Doc Freqs
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
verify	TokenNameIdentifier	 verify
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
doPack	TokenNameIdentifier	 do Pack
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
wordsFileIn	TokenNameIdentifier	 words File In
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dirOut	TokenNameIdentifier	 dir Out
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
args	TokenNameIdentifier	 args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-prune"	TokenNameStringLiteral	-prune
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prune	TokenNameIdentifier	 prune
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-limit"	TokenNameStringLiteral	-limit
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-utf8"	TokenNameStringLiteral	-utf8
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-utf32"	TokenNameStringLiteral	-utf32
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inputMode	TokenNameIdentifier	 input Mode
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-docFreq"	TokenNameStringLiteral	-docFreq
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
storeDocFreqs	TokenNameIdentifier	 store Doc Freqs
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-noArcArrays"	TokenNameStringLiteral	-noArcArrays
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-ords"	TokenNameStringLiteral	-ords
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
storeOrds	TokenNameIdentifier	 store Ords
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-noverify"	TokenNameStringLiteral	-noverify
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
verify	TokenNameIdentifier	 verify
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-pack"	TokenNameStringLiteral	-pack
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doPack	TokenNameIdentifier	 do Pack
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"-"	TokenNameStringLiteral	-
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Unrecognized option: "	TokenNameStringLiteral	Unrecognized option: 
+	TokenNamePLUS	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wordsFileIn	TokenNameIdentifier	 words File In
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
wordsFileIn	TokenNameIdentifier	 words File In
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dirOut	TokenNameIdentifier	 dir Out
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Too many arguments, expected: input [output]"	TokenNameStringLiteral	Too many arguments, expected: input [output]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wordsFileIn	TokenNameIdentifier	 words File In
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"No input file."	TokenNameStringLiteral	No input file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ord benefits from share, docFreqs don't: 	TokenNameCOMMENT_LINE	ord benefits from share, docFreqs don't: 
if	TokenNameif	
(	TokenNameLPAREN	
storeOrds	TokenNameIdentifier	 store Ords
&&	TokenNameAND_AND	
storeDocFreqs	TokenNameIdentifier	 store Doc Freqs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Store both ord & docFreq: 	TokenNameCOMMENT_LINE	Store both ord & docFreq: 
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
o1	TokenNameIdentifier	 o1
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
o2	TokenNameIdentifier	 o2
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
new	TokenNamenew	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
new	TokenNamenew	
VisitTerms	TokenNameIdentifier	 Visit Terms
<	TokenNameLESS	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
,	TokenNameCOMMA	
wordsFileIn	TokenNameIdentifier	 words File In
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
doPack	TokenNameIdentifier	 do Pack
,	TokenNameCOMMA	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Random	TokenNameIdentifier	 Random
rand	TokenNameIdentifier	 rand
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
PairOutputs	TokenNameIdentifier	 Pair Outputs
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rand	TokenNameIdentifier	 rand
=	TokenNameEQUAL	
new	TokenNamenew	
Random	TokenNameIdentifier	 Random
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
ord	TokenNameIdentifier	 ord
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
rand	TokenNameIdentifier	 rand
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
verify	TokenNameIdentifier	 verify
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
storeOrds	TokenNameIdentifier	 store Ords
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Store only ords 	TokenNameCOMMENT_LINE	Store only ords 
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
new	TokenNamenew	
VisitTerms	TokenNameIdentifier	 Visit Terms
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
,	TokenNameCOMMA	
wordsFileIn	TokenNameIdentifier	 words File In
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
doPack	TokenNameIdentifier	 do Pack
,	TokenNameCOMMA	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
ord	TokenNameIdentifier	 ord
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
verify	TokenNameIdentifier	 verify
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
storeDocFreqs	TokenNameIdentifier	 store Doc Freqs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Store only docFreq 	TokenNameCOMMENT_LINE	Store only docFreq 
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
new	TokenNamenew	
VisitTerms	TokenNameIdentifier	 Visit Terms
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
,	TokenNameCOMMA	
wordsFileIn	TokenNameIdentifier	 words File In
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
doPack	TokenNameIdentifier	 do Pack
,	TokenNameCOMMA	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Random	TokenNameIdentifier	 Random
rand	TokenNameIdentifier	 rand
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rand	TokenNameIdentifier	 rand
=	TokenNameEQUAL	
new	TokenNamenew	
Random	TokenNameIdentifier	 Random
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
rand	TokenNameIdentifier	 rand
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
verify	TokenNameIdentifier	 verify
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Store nothing 	TokenNameCOMMENT_LINE	Store nothing 
final	TokenNamefinal	
NoOutputs	TokenNameIdentifier	 No Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
new	TokenNamenew	
VisitTerms	TokenNameIdentifier	 Visit Terms
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
dirOut	TokenNameIdentifier	 dir Out
,	TokenNameCOMMA	
wordsFileIn	TokenNameIdentifier	 words File In
,	TokenNameCOMMA	
inputMode	TokenNameIdentifier	 input Mode
,	TokenNameCOMMA	
prune	TokenNameIdentifier	 prune
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
doPack	TokenNameIdentifier	 do Pack
,	TokenNameCOMMA	
noArcArrays	TokenNameIdentifier	 no Arc Arrays
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getOutput	TokenNameIdentifier	 get Output
(	TokenNameLPAREN	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
NO_OUTPUT	TokenNameIdentifier	 NO  OUTPUT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
verify	TokenNameIdentifier	 verify
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testSingleString	TokenNameIdentifier	 test Single String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"foobar"	TokenNameStringLiteral	foobar
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"foo"	TokenNameStringLiteral	foo
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"foobaz"	TokenNameStringLiteral	foobaz
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* public void testTrivial() throws Exception { // Get outputs -- passing true means FST will share // (delta code) the outputs. This should result in // smaller FST if the outputs grow monotonically. But // if numbers are "random", false should give smaller // final size: final NoOutputs outputs = NoOutputs.getSingleton(); String[] strings = new String[] {"station", "commotion", "elation", "elastic", "plastic", "stop", "ftop", "ftation", "stat"}; final Builder<Object> builder = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, true); Arrays.sort(strings); final IntsRef scratch = new IntsRef(); for(String s : strings) { builder.add(Util.toIntsRef(new BytesRef(s), scratch), outputs.getNoOutput()); } final FST<Object> fst = builder.finish(); System.out.println("DOT before rewrite"); Writer w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/before.dot")); Util.toDot(fst, w, false, false); w.close(); final FST<Object> rewrite = new FST<Object>(fst, 1, 100); System.out.println("DOT after rewrite"); w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/after.dot")); Util.toDot(rewrite, w, false, false); w.close(); } */	TokenNameCOMMENT_BLOCK	 public void testTrivial() throws Exception { // Get outputs -- passing true means FST will share // (delta code) the outputs. This should result in // smaller FST if the outputs grow monotonically. But // if numbers are "random", false should give smaller // final size: final NoOutputs outputs = NoOutputs.getSingleton(); String[] strings = new String[] {"station", "commotion", "elation", "elastic", "plastic", "stop", "ftop", "ftation", "stat"}; final Builder<Object> builder = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, true); Arrays.sort(strings); final IntsRef scratch = new IntsRef(); for(String s : strings) { builder.add(Util.toIntsRef(new BytesRef(s), scratch), outputs.getNoOutput()); } final FST<Object> fst = builder.finish(); System.out.println("DOT before rewrite"); Writer w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/before.dot")); Util.toDot(fst, w, false, false); w.close(); final FST<Object> rewrite = new FST<Object>(fst, 1, 100); System.out.println("DOT after rewrite"); w = new OutputStreamWriter(new FileOutputStream("/mnt/scratch/after.dot")); Util.toDot(rewrite, w, false, false); w.close(); } 
public	TokenNamepublic	
void	TokenNamevoid	
testSimple	TokenNameIdentifier	 test Simple
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// Get outputs -- passing true means FST will share 	TokenNameCOMMENT_LINE	Get outputs -- passing true means FST will share 
// (delta code) the outputs. This should result in 	TokenNameCOMMENT_LINE	(delta code) the outputs. This should result in 
// smaller FST if the outputs grow monotonically. But 	TokenNameCOMMENT_LINE	smaller FST if the outputs grow monotonically. But 
// if numbers are "random", false should give smaller 	TokenNameCOMMENT_LINE	if numbers are "random", false should give smaller 
// final size: 	TokenNameCOMMENT_LINE	final size: 
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Build an FST mapping BytesRef -> Long 	TokenNameCOMMENT_LINE	Build an FST mapping BytesRef -> Long 
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"b"	TokenNameStringLiteral	b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"c"	TokenNameStringLiteral	c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
17L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
42L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
13824324872317238L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
13824324872317238L	TokenNameLongLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
42	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fstEnum	TokenNameIdentifier	 fst Enum
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BytesRefFSTEnum	TokenNameIdentifier	 Bytes Ref FST Enum
.	TokenNameDOT	
InputOutput	TokenNameIdentifier	 Input Output
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
seekResult	TokenNameIdentifier	 seek Result
;	TokenNameSEMICOLON	
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// goes to a 	TokenNameCOMMENT_LINE	goes to a 
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekFloor	TokenNameIdentifier	 seek Floor
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aa"	TokenNameStringLiteral	aa
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// goes to b 	TokenNameCOMMENT_LINE	goes to b 
seekResult	TokenNameIdentifier	 seek Result
=	TokenNameEQUAL	
fstEnum	TokenNameIdentifier	 fst Enum
.	TokenNameDOT	
seekCeil	TokenNameIdentifier	 seek Ceil
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aa"	TokenNameStringLiteral	aa
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
seekResult	TokenNameIdentifier	 seek Result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
42	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
seekResult	TokenNameIdentifier	 seek Result
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"c"	TokenNameStringLiteral	c
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
13824324872317238L	TokenNameLongLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNull	TokenNameIdentifier	 assert Null
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
47	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"b"	TokenNameStringLiteral	b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
42	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"a"	TokenNameStringLiteral	a
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
getByOutput	TokenNameIdentifier	 get By Output
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testPrimaryKeys	TokenNameIdentifier	 test Primary Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
cycle	TokenNameIdentifier	 cycle
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
cycle	TokenNameIdentifier	 cycle
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
cycle	TokenNameIdentifier	 cycle
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: cycle="	TokenNameStringLiteral	TEST: cycle=
+	TokenNamePLUS	
cycle	TokenNameIdentifier	 cycle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setOpenMode	TokenNameIdentifier	 set Open Mode
(	TokenNameLPAREN	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
OpenMode	TokenNameIdentifier	 Open Mode
.	TokenNameDOT	
CREATE	TokenNameIdentifier	 CREATE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
new	TokenNamenew	
Document	TokenNameIdentifier	 Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
idField	TokenNameIdentifier	 id Field
=	TokenNameEQUAL	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
"id"	TokenNameStringLiteral	id
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
idField	TokenNameIdentifier	 id Field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
200	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//final int NUM_IDS = (int) (377 * (1.0+random.nextDouble())); 	TokenNameCOMMENT_LINE	final int NUM_IDS = (int) (377 * (1.0+random.nextDouble())); 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: NUM_IDS="	TokenNameStringLiteral	TEST: NUM_IDS=
+	TokenNamePLUS	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allIDs	TokenNameIdentifier	 all I Ds
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
id	TokenNameIdentifier	 id
<	TokenNameLESS	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
;	TokenNameSEMICOLON	
id	TokenNameIdentifier	 id
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
idString	TokenNameIdentifier	 id String
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cycle	TokenNameIdentifier	 cycle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PKs are assigned sequentially 	TokenNameCOMMENT_LINE	PKs are assigned sequentially 
idString	TokenNameIdentifier	 id String
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%07d"	TokenNameStringLiteral	%07d
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allIDs	TokenNameIdentifier	 all I Ds
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
idString	TokenNameIdentifier	 id String
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
allIDs	TokenNameIdentifier	 all I Ds
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
idString	TokenNameIdentifier	 id String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idField	TokenNameIdentifier	 id Field
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
idString	TokenNameIdentifier	 id String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//w.forceMerge(1); 	TokenNameCOMMENT_LINE	w.forceMerge(1); 
// turn writer into reader: 	TokenNameCOMMENT_LINE	turn writer into reader: 
final	TokenNamefinal	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
getReader	TokenNameIdentifier	 get Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allIDsList	TokenNameIdentifier	 all I Ds List
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
allIDs	TokenNameIdentifier	 all I Ds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
sortedAllIDsList	TokenNameIdentifier	 sorted All I Ds List
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
allIDsList	TokenNameIdentifier	 all I Ds List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
sortedAllIDsList	TokenNameIdentifier	 sorted All I Ds List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Sprinkle in some non-existent PKs: 	TokenNameCOMMENT_LINE	Sprinkle in some non-existent PKs: 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
outOfBounds	TokenNameIdentifier	 out Of Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
/	TokenNameDIVIDE	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
idString	TokenNameIdentifier	 id String
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cycle	TokenNameIdentifier	 cycle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
idString	TokenNameIdentifier	 id String
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%07d"	TokenNameStringLiteral	%07d
,	TokenNameCOMMA	
(	TokenNameLPAREN	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
+	TokenNamePLUS	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
idString	TokenNameIdentifier	 id String
=	TokenNameEQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allIDs	TokenNameIdentifier	 all I Ds
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
idString	TokenNameIdentifier	 id String
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
outOfBounds	TokenNameIdentifier	 out Of Bounds
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
idString	TokenNameIdentifier	 id String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allIDsList	TokenNameIdentifier	 all I Ds List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
idString	TokenNameIdentifier	 id String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Verify w/ TermQuery 	TokenNameCOMMENT_LINE	Verify w/ TermQuery 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
allIDsList	TokenNameIdentifier	 all I Ds List
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
allIDsList	TokenNameIdentifier	 all I Ds List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
exists	TokenNameIdentifier	 exists
=	TokenNameEQUAL	
!	TokenNameNOT	
outOfBounds	TokenNameIdentifier	 out Of Bounds
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: TermQuery "	TokenNameStringLiteral	TEST: TermQuery 
+	TokenNamePLUS	
(	TokenNameLPAREN	
exists	TokenNameIdentifier	 exists
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
"non-exist "	TokenNameStringLiteral	non-exist 
)	TokenNameRPAREN	
+	TokenNamePLUS	
" id="	TokenNameStringLiteral	 id=
+	TokenNamePLUS	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
(	TokenNameLPAREN	
exists	TokenNameIdentifier	 exists
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
"non-exist "	TokenNameStringLiteral	non-exist 
)	TokenNameRPAREN	
+	TokenNamePLUS	
"id="	TokenNameStringLiteral	id=
+	TokenNamePLUS	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
exists	TokenNameIdentifier	 exists
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
"id"	TokenNameStringLiteral	id
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Verify w/ MultiTermsEnum 	TokenNameCOMMENT_LINE	Verify w/ MultiTermsEnum 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
<	TokenNameLESS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
nextID	TokenNameIdentifier	 next ID
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
exists	TokenNameIdentifier	 exists
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
allIDsList	TokenNameIdentifier	 all I Ds List
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
allIDsList	TokenNameIdentifier	 all I Ds List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
exists	TokenNameIdentifier	 exists
=	TokenNameEQUAL	
!	TokenNameNOT	
outOfBounds	TokenNameIdentifier	 out Of Bounds
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextID	TokenNameIdentifier	 next ID
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: exactOnly "	TokenNameStringLiteral	TEST: exactOnly 
+	TokenNamePLUS	
(	TokenNameLPAREN	
exists	TokenNameIdentifier	 exists
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
"non-exist "	TokenNameStringLiteral	non-exist 
)	TokenNameRPAREN	
+	TokenNamePLUS	
"id="	TokenNameStringLiteral	id=
+	TokenNamePLUS	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Pick ID between two IDs: 	TokenNameCOMMENT_LINE	Pick ID between two IDs: 
exists	TokenNameIdentifier	 exists
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
idv	TokenNameIdentifier	 idv
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
NUM_IDS	TokenNameIdentifier	 NUM  IDS
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cycle	TokenNameIdentifier	 cycle
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%07da"	TokenNameStringLiteral	%07da
,	TokenNameCOMMA	
idv	TokenNameIdentifier	 idv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextID	TokenNameIdentifier	 next ID
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%07d"	TokenNameStringLiteral	%07d
,	TokenNameCOMMA	
idv	TokenNameIdentifier	 idv
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
sortedAllIDsList	TokenNameIdentifier	 sorted All I Ds List
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
idv	TokenNameIdentifier	 idv
)	TokenNameRPAREN	
+	TokenNamePLUS	
"a"	TokenNameStringLiteral	a
;	TokenNameSEMICOLON	
nextID	TokenNameIdentifier	 next ID
=	TokenNameEQUAL	
sortedAllIDsList	TokenNameIdentifier	 sorted All I Ds List
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
idv	TokenNameIdentifier	 idv
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: not exactOnly id="	TokenNameStringLiteral	TEST: not exactOnly id=
+	TokenNamePLUS	
id	TokenNameIdentifier	 id
+	TokenNamePLUS	
" nextID="	TokenNameStringLiteral	 nextID=
+	TokenNamePLUS	
nextID	TokenNameIdentifier	 next ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
useCache	TokenNameIdentifier	 use Cache
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" useCache="	TokenNameStringLiteral	 useCache=
+	TokenNamePLUS	
useCache	TokenNameIdentifier	 use Cache
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
idTerm	TokenNameIdentifier	 id Term
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
"id"	TokenNameStringLiteral	id
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TermEnum	TokenNameIdentifier	 Term Enum
termEnum	TokenNameIdentifier	 term Enum
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
terms	TokenNameIdentifier	 terms
(	TokenNameLPAREN	
idTerm	TokenNameIdentifier	 id Term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
actual	TokenNameIdentifier	 actual
=	TokenNameEQUAL	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextID	TokenNameIdentifier	 next ID
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
!	TokenNameNOT	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
idTerm	TokenNameIdentifier	 id Term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"expected="	TokenNameStringLiteral	expected=
+	TokenNamePLUS	
nextID	TokenNameIdentifier	 next ID
+	TokenNamePLUS	
" actual="	TokenNameStringLiteral	 actual=
+	TokenNamePLUS	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
nextID	TokenNameIdentifier	 next ID
,	TokenNameCOMMA	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
text	TokenNameIdentifier	 text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
exists	TokenNameIdentifier	 exists
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
actual	TokenNameIdentifier	 actual
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
idTerm	TokenNameIdentifier	 id Term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
,	TokenNameCOMMA	
idTerm	TokenNameIdentifier	 id Term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testRandomTermLookup	TokenNameIdentifier	 test Random Term Lookup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setOpenMode	TokenNameIdentifier	 set Open Mode
(	TokenNameLPAREN	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
OpenMode	TokenNameIdentifier	 Open Mode
.	TokenNameDOT	
CREATE	TokenNameIdentifier	 CREATE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
?	TokenNameQUESTION	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
:	TokenNameCOLON	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
new	TokenNamenew	
Document	TokenNameIdentifier	 Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Field	TokenNameIdentifier	 Field
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
"field"	TokenNameStringLiteral	field
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
NOT_ANALYZED	TokenNameIdentifier	 NOT  ANALYZED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
NUM_TERMS	TokenNameIdentifier	 NUM  TERMS
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: NUM_TERMS="	TokenNameStringLiteral	TEST: NUM_TERMS=
+	TokenNamePLUS	
NUM_TERMS	TokenNameIdentifier	 NUM  TERMS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allTerms	TokenNameIdentifier	 all Terms
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
allTerms	TokenNameIdentifier	 all Terms
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
NUM_TERMS	TokenNameIdentifier	 NUM  TERMS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allTerms	TokenNameIdentifier	 all Terms
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
simpleRandomString	TokenNameIdentifier	 simple Random String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
allTerms	TokenNameIdentifier	 all Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// turn writer into reader: 	TokenNameCOMMENT_LINE	turn writer into reader: 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: get reader"	TokenNameStringLiteral	TEST: get reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
getReader	TokenNameIdentifier	 get Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: got reader="	TokenNameStringLiteral	TEST: got reader=
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexSearcher	TokenNameIdentifier	 Index Searcher
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allTermsList	TokenNameIdentifier	 all Terms List
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
allTerms	TokenNameIdentifier	 all Terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
shuffle	TokenNameIdentifier	 shuffle
(	TokenNameLPAREN	
allTermsList	TokenNameIdentifier	 all Terms List
,	TokenNameCOMMA	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// verify exact lookup 	TokenNameCOMMENT_LINE	verify exact lookup 
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
allTermsList	TokenNameIdentifier	 all Terms List
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TEST: term="	TokenNameStringLiteral	TEST: term=
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"term="	TokenNameStringLiteral	term=
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
"field"	TokenNameStringLiteral	field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
totalHits	TokenNameIdentifier	 total Hits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test state expansion (array format) on close-to-root states. Creates * synthetic input that has one expanded state on each level. * * @see "https://issues.apache.org/jira/browse/LUCENE-2933" */	TokenNameCOMMENT_JAVADOC	 Test state expansion (array format) on close-to-root states. Creates synthetic input that has one expanded state on each level. * @see "https://issues.apache.org/jira/browse/LUCENE-2933" 
public	TokenNamepublic	
void	TokenNamevoid	
testExpandedCloseToRoot	TokenNameIdentifier	 test Expanded Close To Root
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
class	TokenNameclass	
SyntheticData	TokenNameIdentifier	 Synthetic Data
{	TokenNameLBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
compile	TokenNameIdentifier	 compile
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lines	TokenNameIdentifier	 lines
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
NoOutputs	TokenNameIdentifier	 No Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
nothing	TokenNameIdentifier	 nothing
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
line	TokenNameIdentifier	 line
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
line	TokenNameIdentifier	 line
<	TokenNameLESS	
lines	TokenNameIdentifier	 lines
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
lines	TokenNameIdentifier	 lines
[	TokenNameLBRACKET	
line	TokenNameIdentifier	 line
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
copyChars	TokenNameIdentifier	 copy Chars
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
)	TokenNameRPAREN	
,	TokenNameCOMMA	
nothing	TokenNameIdentifier	 nothing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
generate	TokenNameIdentifier	 generate
(	TokenNameLPAREN	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
out	TokenNameIdentifier	 out
,	TokenNameCOMMA	
StringBuilder	TokenNameIdentifier	 String Builder
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
char	TokenNamechar	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
char	TokenNamechar	
to	TokenNameIdentifier	 to
,	TokenNameCOMMA	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
from	TokenNameIdentifier	 from
==	TokenNameEQUAL_EQUAL	
to	TokenNameIdentifier	 to
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
seq	TokenNameIdentifier	 seq
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"_"	TokenNameStringLiteral	_
+	TokenNamePLUS	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"_end"	TokenNameStringLiteral	_end
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
seq	TokenNameIdentifier	 seq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
from	TokenNameIdentifier	 from
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
<=	TokenNameLESS_EQUAL	
to	TokenNameIdentifier	 to
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
generate	TokenNameIdentifier	 generate
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
to	TokenNameIdentifier	 to
?	TokenNameQUESTION	
to	TokenNameIdentifier	 to
:	TokenNameCOLON	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
depth	TokenNameIdentifier	 depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
deleteCharAt	TokenNameIdentifier	 delete Char At
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
verifyStateAndBelow	TokenNameIdentifier	 verify State And Below
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
targetHasArcs	TokenNameIdentifier	 target Has Arcs
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
childCount	TokenNameIdentifier	 child Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
,	TokenNameCOMMA	
childCount	TokenNameIdentifier	 child Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
expanded	TokenNameIdentifier	 expanded
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
isExpandedTarget	TokenNameIdentifier	 is Expanded Target
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
children	TokenNameIdentifier	 children
=	TokenNameEQUAL	
verifyStateAndBelow	TokenNameIdentifier	 verify State And Below
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
,	TokenNameCOMMA	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
expanded	TokenNameIdentifier	 expanded
,	TokenNameCOMMA	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
<=	TokenNameLESS_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier	 FIXED  ARRAY  SHALLOW  DISTANCE
&&	TokenNameAND_AND	
children	TokenNameIdentifier	 children
>=	TokenNameGREATER_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  SHALLOW
)	TokenNameRPAREN	
||	TokenNameOR_OR	
children	TokenNameIdentifier	 children
>=	TokenNameGREATER_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  DEEP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
childCount	TokenNameIdentifier	 child Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Sanity check. 	TokenNameCOMMENT_LINE	Sanity check. 
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  SHALLOW
<	TokenNameLESS	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier	 FIXED  ARRAY  NUM  ARCS  DEEP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier	 FIXED  ARRAY  SHALLOW  DISTANCE
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SyntheticData	TokenNameIdentifier	 Synthetic Data
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
new	TokenNamenew	
SyntheticData	TokenNameIdentifier	 Synthetic Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuilder	TokenNameIdentifier	 String Builder
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
generate	TokenNameIdentifier	 generate
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
'a'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
'i'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
compile	TokenNameIdentifier	 compile
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
verifyStateAndBelow	TokenNameIdentifier	 verify State And Below
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testFinalOutputOnEndState	TokenNameIdentifier	 test Final Output On End State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toUTF32	TokenNameIdentifier	 to UT F32
(	TokenNameLPAREN	
"stat"	TokenNameStringLiteral	stat
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
17L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toUTF32	TokenNameIdentifier	 to UT F32
(	TokenNameLPAREN	
"station"	TokenNameStringLiteral	station
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
10L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot")); 
StringWriter	TokenNameIdentifier	 String Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
StringWriter	TokenNameIdentifier	 String Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toDot	TokenNameIdentifier	 to Dot
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(w.toString()); 	TokenNameCOMMENT_LINE	System.out.println(w.toString()); 
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"label="t/[7]""	TokenNameStringLiteral	label="t/[7]"
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testInternalFinalState	TokenNameIdentifier	 test Internal Final State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
willRewrite	TokenNameIdentifier	 will Rewrite
=	TokenNameEQUAL	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
willRewrite	TokenNameIdentifier	 will Rewrite
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"stat"	TokenNameStringLiteral	stat
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"station"	TokenNameStringLiteral	station
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringWriter	TokenNameIdentifier	 String Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
StringWriter	TokenNameIdentifier	 String Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp/out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp/out.dot")); 
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toDot	TokenNameIdentifier	 to Dot
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(w.toString()); 	TokenNameCOMMENT_LINE	System.out.println(w.toString()); 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
expected	TokenNameIdentifier	 expected
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
willRewrite	TokenNameIdentifier	 will Rewrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
"4 -> 3 [label="t" style="bold""	TokenNameStringLiteral	4 -> 3 [label="t" style="bold"
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
"8 -> 6 [label="t" style="bold""	TokenNameStringLiteral	8 -> 6 [label="t" style="bold"
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Make sure raw FST can differentiate between final vs 	TokenNameCOMMENT_LINE	Make sure raw FST can differentiate between final vs 
// non-final end nodes 	TokenNameCOMMENT_LINE	non-final end nodes 
public	TokenNamepublic	
void	TokenNamevoid	
testNonFinalStopNode	TokenNameIdentifier	 test Non Final Stop Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Long	TokenNameIdentifier	 Long
nothing	TokenNameIdentifier	 nothing
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
rootNode	TokenNameIdentifier	 root Node
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add final stop node 	TokenNameCOMMENT_LINE	Add final stop node 
{	TokenNameLBRACE	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
addArc	TokenNameIdentifier	 add Arc
(	TokenNameLPAREN	
'a'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
frozen	TokenNameIdentifier	 frozen
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
frozen	TokenNameIdentifier	 frozen
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
17L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
nothing	TokenNameIdentifier	 nothing
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
frozen	TokenNameIdentifier	 frozen
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Add non-final stop node 	TokenNameCOMMENT_LINE	Add non-final stop node 
{	TokenNameLBRACE	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
UnCompiledNode	TokenNameIdentifier	 Un Compiled Node
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
addArc	TokenNameIdentifier	 add Arc
(	TokenNameLPAREN	
'b'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
frozen	TokenNameIdentifier	 frozen
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
.	TokenNameDOT	
CompiledNode	TokenNameIdentifier	 Compiled Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
frozen	TokenNameIdentifier	 frozen
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
=	TokenNameEQUAL	
nothing	TokenNameIdentifier	 nothing
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
42L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
rootNode	TokenNameIdentifier	 root Node
.	TokenNameDOT	
arcs	TokenNameIdentifier	 arcs
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
frozen	TokenNameIdentifier	 frozen
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringWriter	TokenNameIdentifier	 String Writer
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
new	TokenNamenew	
StringWriter	TokenNameIdentifier	 String Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("/x/tmp3/out.dot")); 
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toDot	TokenNameIdentifier	 to Dot
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkStopNodes	TokenNameIdentifier	 check Stop Nodes
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Make sure it still works after save/load: 	TokenNameCOMMENT_LINE	Make sure it still works after save/load: 
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexOutput	TokenNameIdentifier	 Index Output
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
createOutput	TokenNameIdentifier	 create Output
(	TokenNameLPAREN	
"fst"	TokenNameStringLiteral	fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexInput	TokenNameIdentifier	 Index Input
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
"fst"	TokenNameStringLiteral	fst
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst2	TokenNameIdentifier	 fst2
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkStopNodes	TokenNameIdentifier	 check Stop Nodes
(	TokenNameLPAREN	
fst2	TokenNameIdentifier	 fst2
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkStopNodes	TokenNameIdentifier	 check Stop Nodes
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
Long	TokenNameIdentifier	 Long
nothing	TokenNameIdentifier	 nothing
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
startArc	TokenNameIdentifier	 start Arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
nothing	TokenNameIdentifier	 nothing
,	TokenNameCOMMA	
startArc	TokenNameIdentifier	 start Arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
nothing	TokenNameIdentifier	 nothing
,	TokenNameCOMMA	
startArc	TokenNameIdentifier	 start Arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
startArc	TokenNameIdentifier	 start Arc
,	TokenNameCOMMA	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
'a'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
'b'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertFalse	TokenNameIdentifier	 assert False
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
42	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
minLongComparator	TokenNameIdentifier	 min Long Comparator
=	TokenNameEQUAL	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
testShortestPaths	TokenNameIdentifier	 test Shortest Paths
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aab"	TokenNameStringLiteral	aab
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
22L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aac"	TokenNameStringLiteral	aac
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
7L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"ax"	TokenNameStringLiteral	ax
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
17L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 
//Util.toDot(fst, w, false, false); 	TokenNameCOMMENT_LINE	Util.toDot(fst, w, false, false); 
//w.close(); 	TokenNameCOMMENT_LINE	w.close(); 
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
shortestPaths	TokenNameIdentifier	 shortest Paths
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
minLongComparator	TokenNameIdentifier	 min Long Comparator
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aac"	TokenNameStringLiteral	aac
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
7L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"ax"	TokenNameStringLiteral	ax
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aab"	TokenNameStringLiteral	aab
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
22L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// compares just the weight side of the pair 	TokenNameCOMMENT_LINE	compares just the weight side of the pair 
static	TokenNamestatic	
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
minPairWeightComparator	TokenNameIdentifier	 min Pair Weight Comparator
=	TokenNameEQUAL	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** like testShortestPaths, but uses pairoutputs so we have both a weight and an output */	TokenNameCOMMENT_JAVADOC	 like testShortestPaths, but uses pairoutputs so we have both a weight and an output 
public	TokenNamepublic	
void	TokenNamevoid	
testShortestPathsWFST	TokenNameIdentifier	 test Shortest Paths WFST
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
new	TokenNamenew	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// weight 	TokenNameCOMMENT_LINE	weight 
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
// output 	TokenNameCOMMENT_LINE	output 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aab"	TokenNameStringLiteral	aab
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
22L	TokenNameLongLiteral	
,	TokenNameCOMMA	
57L	TokenNameLongLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aac"	TokenNameStringLiteral	aac
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
7L	TokenNameLongLiteral	
,	TokenNameCOMMA	
36L	TokenNameLongLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"ax"	TokenNameStringLiteral	ax
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
17L	TokenNameLongLiteral	
,	TokenNameCOMMA	
85L	TokenNameLongLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 
//Util.toDot(fst, w, false, false); 	TokenNameCOMMENT_LINE	Util.toDot(fst, w, false, false); 
//w.close(); 	TokenNameCOMMENT_LINE	w.close(); 
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
shortestPaths	TokenNameIdentifier	 shortest Paths
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
minPairWeightComparator	TokenNameIdentifier	 min Pair Weight Comparator
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aac"	TokenNameStringLiteral	aac
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
7L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// weight 	TokenNameCOMMENT_LINE	weight 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
36L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output2	TokenNameIdentifier	 output2
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// output 	TokenNameCOMMENT_LINE	output 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"ax"	TokenNameStringLiteral	ax
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
17L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// weight 	TokenNameCOMMENT_LINE	weight 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
85L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output2	TokenNameIdentifier	 output2
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// output 	TokenNameCOMMENT_LINE	output 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
"aab"	TokenNameStringLiteral	aab
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
22L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// weight 	TokenNameCOMMENT_LINE	weight 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
57L	TokenNameLongLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
output2	TokenNameIdentifier	 output2
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// output 	TokenNameCOMMENT_LINE	output 
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testShortestPathsRandom	TokenNameIdentifier	 test Shortest Paths Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
int	TokenNameint	
numWords	TokenNameIdentifier	 num Words
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
slowCompletor	TokenNameIdentifier	 slow Completor
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allPrefixes	TokenNameIdentifier	 all Prefixes
=	TokenNameEQUAL	
new	TokenNamenew	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numWords	TokenNameIdentifier	 num Words
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
randomSimpleString	TokenNameIdentifier	 random Simple String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allPrefixes	TokenNameIdentifier	 all Prefixes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// weights 1..100 	TokenNameCOMMENT_LINE	weights 1..100 
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("add: " + e); 	TokenNameCOMMENT_LINE	System.out.println("add: " + e); 
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("SAVE out.dot"); 	TokenNameCOMMENT_LINE	System.out.println("SAVE out.dot"); 
//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 
//Util.toDot(fst, w, false, false); 	TokenNameCOMMENT_LINE	Util.toDot(fst, w, false, false); 
//w.close(); 	TokenNameCOMMENT_LINE	w.close(); 
BytesReader	TokenNameIdentifier	 Bytes Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("testing: " + allPrefixes.size() + " prefixes"); 	TokenNameCOMMENT_LINE	System.out.println("testing: " + allPrefixes.size() + " prefixes"); 
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
:	TokenNameCOLON	
allPrefixes	TokenNameIdentifier	 all Prefixes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1. run prefix against fst, then complete by value 	TokenNameCOMMENT_LINE	1. run prefix against fst, then complete by value 
//System.out.println("TEST: " + prefix); 	TokenNameCOMMENT_LINE	System.out.println("TEST: " + prefix); 
long	TokenNamelong	
prefixOutput	TokenNameIdentifier	 prefix Output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
prefixOutput	TokenNameIdentifier	 prefix Output
+=	TokenNamePLUS_EQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
topN	TokenNameIdentifier	 top N
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
shortestPaths	TokenNameIdentifier	 shortest Paths
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
minLongComparator	TokenNameIdentifier	 min Long Comparator
,	TokenNameCOMMA	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion 	TokenNameCOMMENT_LINE	2. go thru whole treemap (slowCompletor) and check its actually the best suggestion 
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
matches	TokenNameIdentifier	 matches
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: could be faster... but its slowCompletor for a reason 	TokenNameCOMMENT_LINE	TODO: could be faster... but its slowCompletor for a reason 
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" consider " + e.getKey()); 	TokenNameCOMMENT_LINE	System.out.println(" consider " + e.getKey()); 
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
prefixOutput	TokenNameIdentifier	 prefix Output
,	TokenNameCOMMA	
minLongComparator	TokenNameIdentifier	 min Long Comparator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
topN	TokenNameIdentifier	 top N
,	TokenNameCOMMA	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
hit	TokenNameIdentifier	 hit
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
hit	TokenNameIdentifier	 hit
<	TokenNameLESS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
hit	TokenNameIdentifier	 hit
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" check hit " + hit); 	TokenNameCOMMENT_LINE	System.out.println(" check hit " + hit); 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hit	TokenNameIdentifier	 hit
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
hit	TokenNameIdentifier	 hit
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hit	TokenNameIdentifier	 hit
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
hit	TokenNameIdentifier	 hit
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// used by slowcompletor 	TokenNameCOMMENT_LINE	used by slowcompletor 
class	TokenNameclass	
TwoLongs	TokenNameIdentifier	 Two Longs
{	TokenNameLBRACE	
long	TokenNamelong	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
long	TokenNamelong	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
TwoLongs	TokenNameIdentifier	 Two Longs
(	TokenNameLPAREN	
long	TokenNamelong	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
long	TokenNamelong	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */	TokenNameCOMMENT_JAVADOC	 like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output 
public	TokenNamepublic	
void	TokenNamevoid	
testShortestPathsWFSTRandom	TokenNameIdentifier	 test Shortest Paths WFST Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
int	TokenNameint	
numWords	TokenNameIdentifier	 num Words
=	TokenNameEQUAL	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
TwoLongs	TokenNameIdentifier	 Two Longs
>	TokenNameGREATER	
slowCompletor	TokenNameIdentifier	 slow Completor
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
TwoLongs	TokenNameIdentifier	 Two Longs
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
allPrefixes	TokenNameIdentifier	 all Prefixes
=	TokenNameEQUAL	
new	TokenNamenew	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
new	TokenNamenew	
PairOutputs	TokenNameIdentifier	 Pair Outputs
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// weight 	TokenNameCOMMENT_LINE	weight 
PositiveIntOutputs	TokenNameIdentifier	 Positive Int Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
// output 	TokenNameCOMMENT_LINE	output 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numWords	TokenNameIdentifier	 num Words
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
randomSimpleString	TokenNameIdentifier	 random Simple String
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allPrefixes	TokenNameIdentifier	 all Prefixes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// weights 1..100 	TokenNameCOMMENT_LINE	weights 1..100 
int	TokenNameint	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
500	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// outputs 0..500 	TokenNameCOMMENT_LINE	outputs 0..500 
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
new	TokenNamenew	
TwoLongs	TokenNameIdentifier	 Two Longs
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
TwoLongs	TokenNameIdentifier	 Two Longs
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("add: " + e); 	TokenNameCOMMENT_LINE	System.out.println("add: " + e); 
long	TokenNamelong	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
long	TokenNamelong	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("SAVE out.dot"); 	TokenNameCOMMENT_LINE	System.out.println("SAVE out.dot"); 
//Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 	TokenNameCOMMENT_LINE	Writer w = new OutputStreamWriter(new FileOutputStream("out.dot")); 
//Util.toDot(fst, w, false, false); 	TokenNameCOMMENT_LINE	Util.toDot(fst, w, false, false); 
//w.close(); 	TokenNameCOMMENT_LINE	w.close(); 
BytesReader	TokenNameIdentifier	 Bytes Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("testing: " + allPrefixes.size() + " prefixes"); 	TokenNameCOMMENT_LINE	System.out.println("testing: " + allPrefixes.size() + " prefixes"); 
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
:	TokenNameCOLON	
allPrefixes	TokenNameIdentifier	 all Prefixes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1. run prefix against fst, then complete by value 	TokenNameCOMMENT_LINE	1. run prefix against fst, then complete by value 
//System.out.println("TEST: " + prefix); 	TokenNameCOMMENT_LINE	System.out.println("TEST: " + prefix); 
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
prefixOutput	TokenNameIdentifier	 prefix Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
prefixOutput	TokenNameIdentifier	 prefix Output
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
prefixOutput	TokenNameIdentifier	 prefix Output
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
topN	TokenNameIdentifier	 top N
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
shortestPaths	TokenNameIdentifier	 shortest Paths
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
minPairWeightComparator	TokenNameIdentifier	 min Pair Weight Comparator
,	TokenNameCOMMA	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion 	TokenNameCOMMENT_LINE	2. go thru whole treemap (slowCompletor) and check its actually the best suggestion 
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
matches	TokenNameIdentifier	 matches
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: could be faster... but its slowCompletor for a reason 	TokenNameCOMMENT_LINE	TODO: could be faster... but its slowCompletor for a reason 
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
TwoLongs	TokenNameIdentifier	 Two Longs
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
slowCompletor	TokenNameIdentifier	 slow Completor
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" consider " + e.getKey()); 	TokenNameCOMMENT_LINE	System.out.println(" consider " + e.getKey()); 
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
MinResult	TokenNameIdentifier	 Min Result
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toIntsRef	TokenNameIdentifier	 to Ints Ref
(	TokenNameLPAREN	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
newPair	TokenNameIdentifier	 new Pair
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
a	TokenNameIdentifier	 a
-	TokenNameMINUS	
prefixOutput	TokenNameIdentifier	 prefix Output
.	TokenNameDOT	
output1	TokenNameIdentifier	 output1
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
b	TokenNameIdentifier	 b
-	TokenNameMINUS	
prefixOutput	TokenNameIdentifier	 prefix Output
.	TokenNameDOT	
output2	TokenNameIdentifier	 output2
)	TokenNameRPAREN	
,	TokenNameCOMMA	
minPairWeightComparator	TokenNameIdentifier	 min Pair Weight Comparator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
topN	TokenNameIdentifier	 top N
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
topN	TokenNameIdentifier	 top N
,	TokenNameCOMMA	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
hit	TokenNameIdentifier	 hit
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
hit	TokenNameIdentifier	 hit
<	TokenNameLESS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
hit	TokenNameIdentifier	 hit
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" check hit " + hit); 	TokenNameCOMMENT_LINE	System.out.println(" check hit " + hit); 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hit	TokenNameIdentifier	 hit
)	TokenNameRPAREN	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
hit	TokenNameIdentifier	 hit
]	TokenNameRBRACKET	
.	TokenNameDOT	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
matches	TokenNameIdentifier	 matches
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
hit	TokenNameIdentifier	 hit
)	TokenNameRPAREN	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
hit	TokenNameIdentifier	 hit
]	TokenNameRBRACKET	
.	TokenNameDOT	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
testLargeOutputsOnArrayArcs	TokenNameIdentifier	 test Large Outputs On Array Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE1	TokenNameIdentifier	 BYT E1
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
300	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
<	TokenNameLESS	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
BytesRef	TokenNameIdentifier	 Bytes Ref
.	TokenNameDOT	
deepCopyOf	TokenNameIdentifier	 deep Copy Of
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
<	TokenNameLESS	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arc	TokenNameIdentifier	 arc
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
arc	TokenNameIdentifier	 arc
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
300	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
byteIDX	TokenNameIdentifier	 byte IDX
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byteIDX	TokenNameIdentifier	 byte IDX
<	TokenNameLESS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
byteIDX	TokenNameIdentifier	 byte IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
byteIDX	TokenNameIdentifier	 byte IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
