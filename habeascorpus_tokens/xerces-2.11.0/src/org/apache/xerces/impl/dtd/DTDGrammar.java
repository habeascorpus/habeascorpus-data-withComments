/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMAny	TokenNameIdentifier	 CM Any
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMBinOp	TokenNameIdentifier	 CM Bin Op
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMLeaf	TokenNameIdentifier	 CM Leaf
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMNode	TokenNameIdentifier	 CM Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMUniOp	TokenNameIdentifier	 CM Uni Op
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
DFAContentModel	TokenNameIdentifier	 DFA Content Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
MixedContentModel	TokenNameIdentifier	 Mixed Content Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
SimpleContentModel	TokenNameIdentifier	 Simple Content Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
EntityState	TokenNameIdentifier	 Entity State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLLocator	TokenNameIdentifier	 XML Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
Grammar	TokenNameIdentifier	 Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDTDContentModelSource	TokenNameIdentifier	 XMLDTD Content Model Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
;	TokenNameSEMICOLON	
/** * A DTD grammar. This class implements the XNI handler interfaces * for DTD information so that it can build the approprate validation * structures automatically from the callbacks. * * @xerces.internal * * @author Eric Ye, IBM * @author Jeffrey Rodriguez, IBM * @author Andy Clark, IBM * @author Neil Graham, IBM * * @version $Id: DTDGrammar.java 606543 2007-12-23 06:38:17Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 A DTD grammar. This class implements the XNI handler interfaces for DTD information so that it can build the approprate validation structures automatically from the callbacks. * @xerces.internal * @author Eric Ye, IBM @author Jeffrey Rodriguez, IBM @author Andy Clark, IBM @author Neil Graham, IBM * @version $Id: DTDGrammar.java 606543 2007-12-23 06:38:17Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
implements	TokenNameimplements	
XMLDTDHandler	TokenNameIdentifier	 XMLDTD Handler
,	TokenNameCOMMA	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
,	TokenNameCOMMA	
EntityState	TokenNameIdentifier	 Entity State
,	TokenNameCOMMA	
Grammar	TokenNameIdentifier	 Grammar
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
/** Top level scope (-1). */	TokenNameCOMMENT_JAVADOC	 Top level scope (-1). 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TOP_LEVEL_SCOPE	TokenNameIdentifier	 TOP  LEVEL  SCOPE
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// private 	TokenNameCOMMENT_LINE	private 
/** Chunk shift (8). */	TokenNameCOMMENT_JAVADOC	 Chunk shift (8). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 2^8 = 256 	TokenNameCOMMENT_LINE	2^8 = 256 
/** Chunk size (1 << CHUNK_SHIFT). */	TokenNameCOMMENT_JAVADOC	 Chunk size (1 << CHUNK_SHIFT). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
=	TokenNameEQUAL	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Chunk mask (CHUNK_SIZE - 1). */	TokenNameCOMMENT_JAVADOC	 Chunk mask (CHUNK_SIZE - 1). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
=	TokenNameEQUAL	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Initial chunk count (1 << (10 - CHUNK_SHIFT)). */	TokenNameCOMMENT_JAVADOC	 Initial chunk count (1 << (10 - CHUNK_SHIFT)). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
=	TokenNameEQUAL	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
-	TokenNameMINUS	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 2^10 = 1k 	TokenNameCOMMENT_LINE	2^10 = 1k 
/** List flag (0x80). */	TokenNameCOMMENT_JAVADOC	 List flag (0x80). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
=	TokenNameEQUAL	
0x80	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** List mask (~LIST_FLAG). */	TokenNameCOMMENT_JAVADOC	 List mask (~LIST_FLAG). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
LIST_MASK	TokenNameIdentifier	 LIST  MASK
=	TokenNameEQUAL	
~	TokenNameTWIDDLE	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
;	TokenNameSEMICOLON	
// debugging 	TokenNameCOMMENT_LINE	debugging 
/** Debug DTDGrammar. */	TokenNameCOMMENT_JAVADOC	 Debug DTDGrammar. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
protected	TokenNameprotected	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
fDTDSource	TokenNameIdentifier	 f DTD Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLDTDContentModelSource	TokenNameIdentifier	 XMLDTD Content Model Source
fDTDContentModelSource	TokenNameIdentifier	 f DTD Content Model Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Current element index. */	TokenNameCOMMENT_JAVADOC	 Current element index. 
protected	TokenNameprotected	
int	TokenNameint	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
;	TokenNameSEMICOLON	
/** Current attribute index. */	TokenNameCOMMENT_JAVADOC	 Current attribute index. 
protected	TokenNameprotected	
int	TokenNameint	
fCurrentAttributeIndex	TokenNameIdentifier	 f Current Attribute Index
;	TokenNameSEMICOLON	
/** fReadingExternalDTD */	TokenNameCOMMENT_JAVADOC	 fReadingExternalDTD 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Symbol table. */	TokenNameCOMMENT_JAVADOC	 Symbol table. 
private	TokenNameprivate	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
// The XMLDTDDescription with which this Grammar is associated 	TokenNameCOMMENT_LINE	The XMLDTDDescription with which this Grammar is associated 
protected	TokenNameprotected	
XMLDTDDescription	TokenNameIdentifier	 XMLDTD Description
fGrammarDescription	TokenNameIdentifier	 f Grammar Description
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// element declarations 	TokenNameCOMMENT_LINE	element declarations 
/** Number of element declarations. */	TokenNameCOMMENT_JAVADOC	 Number of element declarations. 
private	TokenNameprivate	
int	TokenNameint	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Element declaration name. */	TokenNameCOMMENT_JAVADOC	 Element declaration name. 
private	TokenNameprivate	
QName	TokenNameIdentifier	 Q Name
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** * Element declaration type. * @see XMLElementDecl */	TokenNameCOMMENT_JAVADOC	 Element declaration type. @see XMLElementDecl 
private	TokenNameprivate	
short	TokenNameshort	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** * Element declaration content spec index. This index value is used * to refer to the content spec information tables. */	TokenNameCOMMENT_JAVADOC	 Element declaration content spec index. This index value is used to refer to the content spec information tables. 
private	TokenNameprivate	
int	TokenNameint	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** * Element declaration content model validator. This validator is * constructed from the content spec nodes. */	TokenNameCOMMENT_JAVADOC	 Element declaration content model validator. This validator is constructed from the content spec nodes. 
private	TokenNameprivate	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** First attribute declaration of an element declaration. */	TokenNameCOMMENT_JAVADOC	 First attribute declaration of an element declaration. 
private	TokenNameprivate	
int	TokenNameint	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Last attribute declaration of an element declaration. */	TokenNameCOMMENT_JAVADOC	 Last attribute declaration of an element declaration. 
private	TokenNameprivate	
int	TokenNameint	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// attribute declarations 	TokenNameCOMMENT_LINE	attribute declarations 
/** Number of attribute declarations. */	TokenNameCOMMENT_JAVADOC	 Number of attribute declarations. 
private	TokenNameprivate	
int	TokenNameint	
fAttributeDeclCount	TokenNameIdentifier	 f Attribute Decl Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Attribute declaration name. */	TokenNameCOMMENT_JAVADOC	 Attribute declaration name. 
private	TokenNameprivate	
QName	TokenNameIdentifier	 Q Name
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// is this grammar immutable? (fully constructed and not changeable) 	TokenNameCOMMENT_LINE	is this grammar immutable? (fully constructed and not changeable) 
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Attribute declaration type. * @see XMLAttributeDecl */	TokenNameCOMMENT_JAVADOC	 Attribute declaration type. @see XMLAttributeDecl 
private	TokenNameprivate	
short	TokenNameshort	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Attribute declaration enumeration values. */	TokenNameCOMMENT_JAVADOC	 Attribute declaration enumeration values. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// content specs 	TokenNameCOMMENT_LINE	content specs 
// here saves the content spec binary trees for element decls, 	TokenNameCOMMENT_LINE	here saves the content spec binary trees for element decls, 
// each element with a content model will hold a pointer which is 	TokenNameCOMMENT_LINE	each element with a content model will hold a pointer which is 
// the index of the head node of the content spec tree. 	TokenNameCOMMENT_LINE	the index of the head node of the content spec tree. 
private	TokenNameprivate	
int	TokenNameint	
fContentSpecCount	TokenNameIdentifier	 f Content Spec Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// entities 	TokenNameCOMMENT_LINE	entities 
private	TokenNameprivate	
int	TokenNameint	
fEntityCount	TokenNameIdentifier	 f Entity Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fEntityName	TokenNameIdentifier	 f Entity Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityValue	TokenNameIdentifier	 f Entity Value
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// notations 	TokenNameCOMMENT_LINE	notations 
private	TokenNameprivate	
int	TokenNameint	
fNotationCount	TokenNameIdentifier	 f Notation Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fNotationName	TokenNameIdentifier	 f Notation Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// other information 	TokenNameCOMMENT_LINE	other information 
/** Element index mapping table. */	TokenNameCOMMENT_JAVADOC	 Element index mapping table. 
private	TokenNameprivate	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
fElementIndexMap	TokenNameIdentifier	 f Element Index Map
=	TokenNameEQUAL	
new	TokenNamenew	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Entity index mapping table. */	TokenNameCOMMENT_JAVADOC	 Entity index mapping table. 
private	TokenNameprivate	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
fEntityIndexMap	TokenNameIdentifier	 f Entity Index Map
=	TokenNameEQUAL	
new	TokenNamenew	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Notation index mapping table. */	TokenNameCOMMENT_JAVADOC	 Notation index mapping table. 
private	TokenNameprivate	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
fNotationIndexMap	TokenNameIdentifier	 f Notation Index Map
=	TokenNameEQUAL	
new	TokenNamenew	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// temp variables 	TokenNameCOMMENT_LINE	temp variables 
/** Mixed. */	TokenNameCOMMENT_JAVADOC	 Mixed. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fMixed	TokenNameIdentifier	 f Mixed
;	TokenNameSEMICOLON	
/** Temporary qualified name. */	TokenNameCOMMENT_JAVADOC	 Temporary qualified name. 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fQName	TokenNameIdentifier	 f Q Name
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary qualified name. */	TokenNameCOMMENT_JAVADOC	 Temporary qualified name. 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fQName2	TokenNameIdentifier	 f Q Name2
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Temporary Attribute decl. */	TokenNameCOMMENT_JAVADOC	 Temporary Attribute decl. 
protected	TokenNameprotected	
final	TokenNamefinal	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for buildSyntaxTree method 	TokenNameCOMMENT_LINE	for buildSyntaxTree method 
private	TokenNameprivate	
int	TokenNameint	
fLeafCount	TokenNameIdentifier	 f Leaf Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fEpsilonIndex	TokenNameIdentifier	 f Epsilon Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Element declaration. */	TokenNameCOMMENT_JAVADOC	 Element declaration. 
private	TokenNameprivate	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
fElementDecl	TokenNameIdentifier	 f Element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Entity declaration. */	TokenNameCOMMENT_JAVADOC	 Entity declaration. 
private	TokenNameprivate	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
fEntityDecl	TokenNameIdentifier	 f Entity Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Simple type. */	TokenNameCOMMENT_JAVADOC	 Simple type. 
private	TokenNameprivate	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
fSimpleType	TokenNameIdentifier	 f Simple Type
=	TokenNameEQUAL	
new	TokenNamenew	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Content spec node. */	TokenNameCOMMENT_JAVADOC	 Content spec node. 
private	TokenNameprivate	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
fContentSpec	TokenNameIdentifier	 f Content Spec
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** table of XMLElementDecl */	TokenNameCOMMENT_JAVADOC	 table of XMLElementDecl 
Hashtable	TokenNameIdentifier	 Hashtable
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Children content model operation stack. */	TokenNameCOMMENT_JAVADOC	 Children content model operation stack. 
private	TokenNameprivate	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fOpStack	TokenNameIdentifier	 f Op Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Children content model index stack. */	TokenNameCOMMENT_JAVADOC	 Children content model index stack. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Children content model previous node index stack. */	TokenNameCOMMENT_JAVADOC	 Children content model previous node index stack. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Stack depth */	TokenNameCOMMENT_JAVADOC	 Stack depth 
private	TokenNameprivate	
int	TokenNameint	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Entity stack. */	TokenNameCOMMENT_JAVADOC	 Entity stack. 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fPEDepth	TokenNameIdentifier	 f PE Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// additional fields(columns) for the element Decl pool in the Grammar 	TokenNameCOMMENT_LINE	additional fields(columns) for the element Decl pool in the Grammar 
/** flag if the elementDecl is External. */	TokenNameCOMMENT_JAVADOC	 flag if the elementDecl is External. 
private	TokenNameprivate	
int	TokenNameint	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// additional fields(columns) for the attribute Decl pool in the Grammar 	TokenNameCOMMENT_LINE	additional fields(columns) for the attribute Decl pool in the Grammar 
/** flag if the AttributeDecl is External. */	TokenNameCOMMENT_JAVADOC	 flag if the AttributeDecl is External. 
private	TokenNameprivate	
int	TokenNameint	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_CHUNK_COUNT	TokenNameIdentifier	 INITIAL  CHUNK  COUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// for mixedElement method 	TokenNameCOMMENT_LINE	for mixedElement method 
int	TokenNameint	
valueIndex	TokenNameIdentifier	 value Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
prevNodeIndex	TokenNameIdentifier	 prev Node Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
nodeIndex	TokenNameIdentifier	 node Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Default constructor. */	TokenNameCOMMENT_JAVADOC	 Default constructor. 
public	TokenNamepublic	
DTDGrammar	TokenNameIdentifier	 DTD Grammar
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
XMLDTDDescription	TokenNameIdentifier	 XMLDTD Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
fGrammarDescription	TokenNameIdentifier	 f Grammar Description
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>(SymbolTable) 	TokenNameCOMMENT_LINE	<init>(SymbolTable) 
// Grammar methods 	TokenNameCOMMENT_LINE	Grammar methods 
// return the XMLDTDDescription object with which this is associated 	TokenNameCOMMENT_LINE	return the XMLDTDDescription object with which this is associated 
public	TokenNamepublic	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
getGrammarDescription	TokenNameIdentifier	 get Grammar Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fGrammarDescription	TokenNameIdentifier	 f Grammar Description
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getGrammarDescription(): XMLGrammarDescription 	TokenNameCOMMENT_LINE	getGrammarDescription(): XMLGrammarDescription 
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
/** * Returns true if the specified element declaration is external. * * @param elementDeclIndex The element declaration index. */	TokenNameCOMMENT_JAVADOC	 Returns true if the specified element declaration is external. * @param elementDeclIndex The element declaration index. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getElementDeclIsExternal	TokenNameIdentifier	 get Element Decl Is External
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getElementDeclIsExternal(int):boolean 	TokenNameCOMMENT_LINE	getElementDeclIsExternal(int):boolean 
/** * Returns true if the specified attribute declaration is external. * * @param attributeDeclIndex Attribute declaration index. */	TokenNameCOMMENT_JAVADOC	 Returns true if the specified attribute declaration is external. * @param attributeDeclIndex Attribute declaration index. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getAttributeDeclIsExternal	TokenNameIdentifier	 get Attribute Decl Is External
(	TokenNameLPAREN	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getAttributeDeclIndex	TokenNameIdentifier	 get Attribute Decl Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
attributeDeclName	TokenNameIdentifier	 attribute Decl Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
attDefIndex	TokenNameIdentifier	 att Def Index
=	TokenNameEQUAL	
getFirstAttributeDeclIndex	TokenNameIdentifier	 get First Attribute Decl Index
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
attDefIndex	TokenNameIdentifier	 att Def Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
attDefIndex	TokenNameIdentifier	 att Def Index
,	TokenNameCOMMA	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
==	TokenNameEQUAL_EQUAL	
attributeDeclName	TokenNameIdentifier	 attribute Decl Name
||	TokenNameOR_OR	
attributeDeclName	TokenNameIdentifier	 attribute Decl Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
attDefIndex	TokenNameIdentifier	 att Def Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attDefIndex	TokenNameIdentifier	 att Def Index
=	TokenNameEQUAL	
getNextAttributeDeclIndex	TokenNameIdentifier	 get Next Attribute Decl Index
(	TokenNameLPAREN	
attDefIndex	TokenNameIdentifier	 att Def Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getAttributeDeclIndex (int,QName) 	TokenNameCOMMENT_LINE	getAttributeDeclIndex (int,QName) 
// 	TokenNameCOMMENT_LINE	 
// XMLDTDHandler methods 	TokenNameCOMMENT_LINE	XMLDTDHandler methods 
// 	TokenNameCOMMENT_LINE	 
/** * The start of the DTD. * * @param locator The document locator, or null if the document * location cannot be reported during the parsing of * the document DTD. However, it is <em>strongly</em> * recommended that a locator be supplied that can * at least report the base system identifier of the * DTD. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of the DTD. * @param locator The document locator, or null if the document location cannot be reported during the parsing of the document DTD. However, it is <em>strongly</em> recommended that a locator be supplied that can at least report the base system identifier of the DTD. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startDTD	TokenNameIdentifier	 start DTD
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
//Initialize stack 	TokenNameCOMMENT_LINE	Initialize stack 
fOpStack	TokenNameIdentifier	 f Op Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startDTD(XMLLocator) 	TokenNameCOMMENT_LINE	startDTD(XMLLocator) 
/** * This method notifies of the start of an entity. The DTD has the * pseudo-name of "[dtd]" and parameter entity names start with '%'. * <p> * <strong>Note:</strong> Since the DTD is an entity, the handler * will be notified of the start of the DTD entity by calling the * startParameterEntity method with the entity name "[dtd]" <em>before</em> calling * the startDTD method. * * @param name The name of the parameter entity. * @param identifier The resource identifier. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal parameter entities). * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies of the start of an entity. The DTD has the pseudo-name of "[dtd]" and parameter entity names start with '%'. <p> <strong>Note:</strong> Since the DTD is an entity, the handler will be notified of the start of the DTD entity by calling the startParameterEntity method with the entity name "[dtd]" <em>before</em> calling the startDTD method. * @param name The name of the parameter entity. @param identifier The resource identifier. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal parameter entities). @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startParameterEntity	TokenNameIdentifier	 start Parameter Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// keep track of this entity before fEntityDepth is increased 	TokenNameCOMMENT_LINE	keep track of this entity before fEntityDepth is increased 
if	TokenNameif	
(	TokenNameLPAREN	
fPEDepth	TokenNameIdentifier	 f PE Depth
==	TokenNameEQUAL_EQUAL	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
entityarray	TokenNameIdentifier	 entityarray
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
entityarray	TokenNameIdentifier	 entityarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
=	TokenNameEQUAL	
entityarray	TokenNameIdentifier	 entityarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
;	TokenNameSEMICOLON	
fPEDepth	TokenNameIdentifier	 f PE Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startParameterEntity(String,XMLResourceIdentifier,String,Augmentations) 	TokenNameCOMMENT_LINE	startParameterEntity(String,XMLResourceIdentifier,String,Augmentations) 
/** * The start of the DTD external subset. * * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of the DTD external subset. * @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startExternalSubset	TokenNameIdentifier	 start External Subset
(	TokenNameLPAREN	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startExternalSubset(Augmentations) 	TokenNameCOMMENT_LINE	startExternalSubset(Augmentations) 
/** * This method notifies the end of an entity. The DTD has the pseudo-name * of "[dtd]" and parameter entity names start with '%'. * <p> * <strong>Note:</strong> Since the DTD is an entity, the handler * will be notified of the end of the DTD entity by calling the * endEntity method with the entity name "[dtd]" <em>after</em> calling * the endDTD method. * * @param name The name of the entity. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the end of an entity. The DTD has the pseudo-name of "[dtd]" and parameter entity names start with '%'. <p> <strong>Note:</strong> Since the DTD is an entity, the handler will be notified of the end of the DTD entity by calling the endEntity method with the entity name "[dtd]" <em>after</em> calling the endDTD method. * @param name The name of the entity. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endParameterEntity	TokenNameIdentifier	 end Parameter Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fPEDepth	TokenNameIdentifier	 f PE Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
=	TokenNameEQUAL	
fPEntityStack	TokenNameIdentifier	 f P Entity Stack
[	TokenNameLBRACKET	
fPEDepth	TokenNameIdentifier	 f PE Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endParameterEntity(String,Augmentations) 	TokenNameCOMMENT_LINE	endParameterEntity(String,Augmentations) 
/** * The end of the DTD external subset. * * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of the DTD external subset. * @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endExternalSubset	TokenNameIdentifier	 end External Subset
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endExternalSubset(Augmentations) 	TokenNameCOMMENT_LINE	endExternalSubset(Augmentations) 
/** * An element declaration. * * @param name The name of the element. * @param contentModel The element content model. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An element declaration. * @param name The name of the element. @param contentModel The element content model. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
elementDecl	TokenNameIdentifier	 element Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
contentModel	TokenNameIdentifier	 content Model
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
tmpElementDecl	TokenNameIdentifier	 tmp Element Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
)	TokenNameRPAREN	
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check if it is already defined 	TokenNameCOMMENT_LINE	check if it is already defined 
if	TokenNameif	
(	TokenNameLPAREN	
tmpElementDecl	TokenNameIdentifier	 tmp Element Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tmpElementDecl	TokenNameIdentifier	 tmp Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// duplicate element, ignored. 	TokenNameCOMMENT_LINE	duplicate element, ignored. 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
createElementDecl	TokenNameIdentifier	 create Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//create element decl 	TokenNameCOMMENT_LINE	create element decl 
}	TokenNameRBRACE	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fQName	TokenNameIdentifier	 f Q Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
contentModelValidator	TokenNameIdentifier	 content Model Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
scope	TokenNameIdentifier	 scope
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentModel	TokenNameIdentifier	 content Model
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"EMPTY"	TokenNameStringLiteral	EMPTY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_EMPTY	TokenNameIdentifier	 TYPE  EMPTY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentModel	TokenNameIdentifier	 content Model
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ANY"	TokenNameStringLiteral	ANY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_ANY	TokenNameIdentifier	 TYPE  ANY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentModel	TokenNameIdentifier	 content Model
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"("	TokenNameStringLiteral	(
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
contentModel	TokenNameIdentifier	 content Model
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//add(or set) this elementDecl to the local cache 	TokenNameCOMMENT_LINE	add(or set) this elementDecl to the local cache 
this	TokenNamethis	
.	TokenNameDOT	
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDecl	TokenNameIdentifier	 f Element Decl
=	TokenNameEQUAL	
elementDecl	TokenNameIdentifier	 element Decl
;	TokenNameSEMICOLON	
addContentSpecToElement	TokenNameIdentifier	 add Content Spec To Element
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"name = "	TokenNameStringLiteral	name = 
+	TokenNamePLUS	
fElementDecl	TokenNameIdentifier	 f Element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Type = "	TokenNameStringLiteral	Type = 
+	TokenNamePLUS	
fElementDecl	TokenNameIdentifier	 f Element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setElementDecl	TokenNameIdentifier	 set Element Decl
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
fElementDecl	TokenNameIdentifier	 f Element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//set internal structure 	TokenNameCOMMENT_LINE	set internal structure 
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureElementDeclCapacity	TokenNameIdentifier	 ensure Element Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
||	TokenNameOR_OR	
fPEDepth	TokenNameIdentifier	 f PE Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// elementDecl(String,String) 	TokenNameCOMMENT_LINE	elementDecl(String,String) 
/** * An attribute declaration. * * @param elementName The name of the element that this attribute * is associated with. * @param attributeName The name of the attribute. * @param type The attribute type. This value will be one of * the following: "CDATA", "ENTITY", "ENTITIES", * "ENUMERATION", "ID", "IDREF", "IDREFS", * "NMTOKEN", "NMTOKENS", or "NOTATION". * @param enumeration If the type has the value "ENUMERATION", this * array holds the allowed attribute values; * otherwise, this array is null. * @param defaultType The attribute default type. This value will be * one of the following: "#FIXED", "#IMPLIED", * "#REQUIRED", or null. * @param defaultValue The attribute default value, or null if no * default value is specified. * @param nonNormalizedDefaultValue The attribute default value with no normalization * performed, or null if no default value is specified. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An attribute declaration. * @param elementName The name of the element that this attribute is associated with. @param attributeName The name of the attribute. @param type The attribute type. This value will be one of the following: "CDATA", "ENTITY", "ENTITIES", "ENUMERATION", "ID", "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", or "NOTATION". @param enumeration If the type has the value "ENUMERATION", this array holds the allowed attribute values; otherwise, this array is null. @param defaultType The attribute default type. This value will be one of the following: "#FIXED", "#IMPLIED", "#REQUIRED", or null. @param defaultValue The attribute default value, or null if no default value is specified. @param nonNormalizedDefaultValue The attribute default value with no normalization performed, or null if no default value is specified. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
attributeDecl	TokenNameIdentifier	 attribute Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
attributeName	TokenNameIdentifier	 attribute Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
enumeration	TokenNameIdentifier	 enumeration
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
defaultValue	TokenNameIdentifier	 default Value
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if ElementDecl has already being created in the Grammar then remove from table, 	TokenNameCOMMENT_LINE	if ElementDecl has already being created in the Grammar then remove from table, 
//this.fElementDeclTab.remove( (String) elementName ); 	TokenNameCOMMENT_LINE	this.fElementDeclTab.remove( (String) elementName ); 
}	TokenNameRBRACE	
// then it is forward reference to a element decl, create the elementDecl first. 	TokenNameCOMMENT_LINE	then it is forward reference to a element decl, create the elementDecl first. 
else	TokenNameelse	
{	TokenNameLBRACE	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
=	TokenNameEQUAL	
createElementDecl	TokenNameIdentifier	 create Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//create element decl 	TokenNameCOMMENT_LINE	create element decl 
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
scope	TokenNameIdentifier	 scope
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//add(or set) this elementDecl to the local cache 	TokenNameCOMMENT_LINE	add(or set) this elementDecl to the local cache 
this	TokenNamethis	
.	TokenNameDOT	
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//set internal structure 	TokenNameCOMMENT_LINE	set internal structure 
setElementDecl	TokenNameIdentifier	 set Element Decl
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//Get Grammar index to grammar array 	TokenNameCOMMENT_LINE	Get Grammar index to grammar array 
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
=	TokenNameEQUAL	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//return, when more than one definition is provided for the same attribute of given element type 	TokenNameCOMMENT_LINE	return, when more than one definition is provided for the same attribute of given element type 
//only the first declaration is binding and later declarations are ignored 	TokenNameCOMMENT_LINE	only the first declaration is binding and later declarations are ignored 
if	TokenNameif	
(	TokenNameLPAREN	
getAttributeDeclIndex	TokenNameIdentifier	 get Attribute Decl Index
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
attributeName	TokenNameIdentifier	 attribute Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fCurrentAttributeIndex	TokenNameIdentifier	 f Current Attribute Index
=	TokenNameEQUAL	
createAttributeDecl	TokenNameIdentifier	 create Attribute Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Create current Attribute Decl 	TokenNameCOMMENT_LINE	Create current Attribute Decl 
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"#FIXED"	TokenNameStringLiteral	#FIXED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_FIXED	TokenNameIdentifier	 DEFAULT  TYPE  FIXED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"#IMPLIED"	TokenNameStringLiteral	#IMPLIED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_IMPLIED	TokenNameIdentifier	 DEFAULT  TYPE  IMPLIED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"#REQUIRED"	TokenNameStringLiteral	#REQUIRED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_REQUIRED	TokenNameIdentifier	 DEFAULT  TYPE  REQUIRED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"defaultvalue = "	TokenNameStringLiteral	defaultvalue = 
+	TokenNamePLUS	
defaultValue	TokenNameIdentifier	 default Value
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
=	TokenNameEQUAL	
defaultValue	TokenNameIdentifier	 default Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
defaultValue	TokenNameIdentifier	 default Value
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
=	TokenNameEQUAL	
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
=	TokenNameEQUAL	
enumeration	TokenNameIdentifier	 enumeration
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"CDATA"	TokenNameStringLiteral	CDATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_CDATA	TokenNameIdentifier	 TYPE  CDATA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ID"	TokenNameStringLiteral	ID
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ID	TokenNameIdentifier	 TYPE  ID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"IDREF"	TokenNameStringLiteral	IDREF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_IDREF	TokenNameIdentifier	 TYPE  IDREF
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"S"	TokenNameStringLiteral	S
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ENTITIES"	TokenNameStringLiteral	ENTITIES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENTITY	TokenNameIdentifier	 TYPE  ENTITY
;	TokenNameSEMICOLON	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ENTITY"	TokenNameStringLiteral	ENTITY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENTITY	TokenNameIdentifier	 TYPE  ENTITY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"NMTOKENS"	TokenNameStringLiteral	NMTOKENS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NMTOKEN	TokenNameIdentifier	 TYPE  NMTOKEN
;	TokenNameSEMICOLON	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"NMTOKEN"	TokenNameStringLiteral	NMTOKEN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NMTOKEN	TokenNameIdentifier	 TYPE  NMTOKEN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"NOTATION"	TokenNameStringLiteral	NOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_NOTATION	TokenNameIdentifier	 TYPE  NOTATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"ENUMERATION"	TokenNameStringLiteral	ENUMERATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleType	TokenNameIdentifier	 f Simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_ENUMERATION	TokenNameIdentifier	 TYPE  ENUMERATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// REVISIT: Report error message. -Ac 	TokenNameCOMMENT_LINE	REVISIT: Report error message. -Ac 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"!!! unknown attribute type "	TokenNameStringLiteral	!!! unknown attribute type 
+	TokenNamePLUS	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT: The datatype should be stored with the attribute value 	TokenNameCOMMENT_LINE	REVISIT: The datatype should be stored with the attribute value 
// and not special-cased in the XMLValidator. -Ac 	TokenNameCOMMENT_LINE	and not special-cased in the XMLValidator. -Ac 
//fSimpleType.datatypeValidator = fDatatypeValidatorFactory.createDatatypeValidator(type, null, facets, fSimpleType.list); 	TokenNameCOMMENT_LINE	fSimpleType.datatypeValidator = fDatatypeValidatorFactory.createDatatypeValidator(type, null, facets, fSimpleType.list); 
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
attributeName	TokenNameIdentifier	 attribute Name
,	TokenNameCOMMA	
attributeName	TokenNameIdentifier	 attribute Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fQName	TokenNameIdentifier	 f Q Name
,	TokenNameCOMMA	
fSimpleType	TokenNameIdentifier	 f Simple Type
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setAttributeDecl	TokenNameIdentifier	 set Attribute Decl
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
,	TokenNameCOMMA	
fCurrentAttributeIndex	TokenNameIdentifier	 f Current Attribute Index
,	TokenNameCOMMA	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fCurrentAttributeIndex	TokenNameIdentifier	 f Current Attribute Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fCurrentAttributeIndex	TokenNameIdentifier	 f Current Attribute Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureAttributeDeclCapacity	TokenNameIdentifier	 ensure Attribute Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
||	TokenNameOR_OR	
fPEDepth	TokenNameIdentifier	 f PE Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// attributeDecl(String,String,String,String[],String,XMLString,XMLString, Augmentations) 	TokenNameCOMMENT_LINE	attributeDecl(String,String,String,String[],String,XMLString,XMLString, Augmentations) 
/** * An internal entity declaration. * * @param name The name of the entity. Parameter entity names start with * '%', whereas the name of a general entity is just the * entity name. * @param text The value of the entity. * @param nonNormalizedText The non-normalized value of the entity. This * value contains the same sequence of characters that was in * the internal entity declaration, without any entity * references expanded. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An internal entity declaration. * @param name The name of the entity. Parameter entity names start with '%', whereas the name of a general entity is just the entity name. @param text The value of the entity. @param nonNormalizedText The non-normalized value of the entity. This value contains the same sequence of characters that was in the internal entity declaration, without any entity references expanded. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
internalEntityDecl	TokenNameIdentifier	 internal Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
nonNormalizedText	TokenNameIdentifier	 non Normalized Text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
createEntityDecl	TokenNameIdentifier	 create Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isPE	TokenNameIdentifier	 is PE
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"%"	TokenNameStringLiteral	%
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inExternal	TokenNameIdentifier	 in External
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
||	TokenNameOR_OR	
fPEDepth	TokenNameIdentifier	 f PE Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
entityDecl	TokenNameIdentifier	 entity Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isPE	TokenNameIdentifier	 is PE
,	TokenNameCOMMA	
inExternal	TokenNameIdentifier	 in External
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setEntityDecl	TokenNameIdentifier	 set Entity Decl
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
,	TokenNameCOMMA	
entityDecl	TokenNameIdentifier	 entity Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// internalEntityDecl(String,XMLString,XMLString) 	TokenNameCOMMENT_LINE	internalEntityDecl(String,XMLString,XMLString) 
/** * An external entity declaration. * * @param name The name of the entity. Parameter entity names start * with '%', whereas the name of a general entity is just * the entity name. * @param identifier An object containing all location information * pertinent to this external entity declaration. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An external entity declaration. * @param name The name of the entity. Parameter entity names start with '%', whereas the name of a general entity is just the entity name. @param identifier An object containing all location information pertinent to this external entity declaration. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
externalEntityDecl	TokenNameIdentifier	 external Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
createEntityDecl	TokenNameIdentifier	 create Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isPE	TokenNameIdentifier	 is PE
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"%"	TokenNameStringLiteral	%
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inExternal	TokenNameIdentifier	 in External
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
||	TokenNameOR_OR	
fPEDepth	TokenNameIdentifier	 f PE Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
entityDecl	TokenNameIdentifier	 entity Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
isPE	TokenNameIdentifier	 is PE
,	TokenNameCOMMA	
inExternal	TokenNameIdentifier	 in External
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setEntityDecl	TokenNameIdentifier	 set Entity Decl
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
,	TokenNameCOMMA	
entityDecl	TokenNameIdentifier	 entity Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// externalEntityDecl(String, XMLResourceIdentifier, Augmentations) 	TokenNameCOMMENT_LINE	externalEntityDecl(String, XMLResourceIdentifier, Augmentations) 
/** * An unparsed entity declaration. * * @param name The name of the entity. * @param identifier An object containing all location information * pertinent to this entity. * @param notation The name of the notation. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An unparsed entity declaration. * @param name The name of the entity. @param identifier An object containing all location information pertinent to this entity. @param notation The name of the notation. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
unparsedEntityDecl	TokenNameIdentifier	 unparsed Entity Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
entityDecl	TokenNameIdentifier	 entity Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isPE	TokenNameIdentifier	 is PE
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"%"	TokenNameStringLiteral	%
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inExternal	TokenNameIdentifier	 in External
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fReadingExternalDTD	TokenNameIdentifier	 f Reading External DTD
||	TokenNameOR_OR	
fPEDepth	TokenNameIdentifier	 f PE Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
notation	TokenNameIdentifier	 notation
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
isPE	TokenNameIdentifier	 is PE
,	TokenNameCOMMA	
inExternal	TokenNameIdentifier	 in External
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
createEntityDecl	TokenNameIdentifier	 create Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setEntityDecl	TokenNameIdentifier	 set Entity Decl
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
,	TokenNameCOMMA	
entityDecl	TokenNameIdentifier	 entity Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// unparsedEntityDecl(String,StringXMLResourceIdentifier,Augmentations) 	TokenNameCOMMENT_LINE	unparsedEntityDecl(String,StringXMLResourceIdentifier,Augmentations) 
/** * A notation declaration * * @param name The name of the notation. * @param identifier An object containing all location information * pertinent to this notation. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A notation declaration * @param name The name of the notation. @param identifier An object containing all location information pertinent to this notation. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
notationDecl	TokenNameIdentifier	 notation Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
XMLNotationDecl	TokenNameIdentifier	 XML Notation Decl
notationDecl	TokenNameIdentifier	 notation Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLNotationDecl	TokenNameIdentifier	 XML Notation Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
notationIndex	TokenNameIdentifier	 notation Index
=	TokenNameEQUAL	
getNotationDeclIndex	TokenNameIdentifier	 get Notation Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
notationIndex	TokenNameIdentifier	 notation Index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notationIndex	TokenNameIdentifier	 notation Index
=	TokenNameEQUAL	
createNotationDecl	TokenNameIdentifier	 create Notation Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setNotationDecl	TokenNameIdentifier	 set Notation Decl
(	TokenNameLPAREN	
notationIndex	TokenNameIdentifier	 notation Index
,	TokenNameCOMMA	
notationDecl	TokenNameIdentifier	 notation Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// notationDecl(String,XMLResourceIdentifier,Augmentations) 	TokenNameCOMMENT_LINE	notationDecl(String,XMLResourceIdentifier,Augmentations) 
/** * The end of the DTD. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of the DTD. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endDTD	TokenNameIdentifier	 end DTD
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// make sure our description contains useful stuff... 	TokenNameCOMMENT_LINE	make sure our description contains useful stuff... 
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarDescription	TokenNameIdentifier	 f Grammar Description
.	TokenNameDOT	
getRootName	TokenNameIdentifier	 get Root Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we don't know what the root is; so use possibleRoots... 	TokenNameCOMMENT_LINE	we don't know what the root is; so use possibleRoots... 
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
currName	TokenNameIdentifier	 curr Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
elements	TokenNameIdentifier	 elements
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
currName	TokenNameIdentifier	 curr Name
=	TokenNameEQUAL	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
elements	TokenNameIdentifier	 elements
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
currName	TokenNameIdentifier	 curr Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fGrammarDescription	TokenNameIdentifier	 f Grammar Description
.	TokenNameDOT	
setPossibleRoots	TokenNameIdentifier	 set Possible Roots
(	TokenNameLPAREN	
elements	TokenNameIdentifier	 elements
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endDTD() 	TokenNameCOMMENT_LINE	endDTD() 
// sets the source of this handler 	TokenNameCOMMENT_LINE	sets the source of this handler 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDSource	TokenNameIdentifier	 set DTD Source
(	TokenNameLPAREN	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDSource	TokenNameIdentifier	 f DTD Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDTDSource(XMLDTDSource) 	TokenNameCOMMENT_LINE	setDTDSource(XMLDTDSource) 
// returns the source of this handler 	TokenNameCOMMENT_LINE	returns the source of this handler 
public	TokenNamepublic	
XMLDTDSource	TokenNameIdentifier	 XMLDTD Source
getDTDSource	TokenNameIdentifier	 get DTD Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDSource	TokenNameIdentifier	 f DTD Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getDTDSource(): XMLDTDSource 	TokenNameCOMMENT_LINE	getDTDSource(): XMLDTDSource 
// no-op methods 	TokenNameCOMMENT_LINE	no-op methods 
/** * Notifies of the presence of a TextDecl line in an entity. If present, * this method will be called immediately following the startEntity call. * <p> * <strong>Note:</strong> This method is only called for external * parameter entities referenced in the DTD. * * @param version The XML version, or null if not specified. * @param encoding The IANA encoding name of the entity. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of a TextDecl line in an entity. If present, this method will be called immediately following the startEntity call. <p> <strong>Note:</strong> This method is only called for external parameter entities referenced in the DTD. * @param version The XML version, or null if not specified. @param encoding The IANA encoding name of the entity. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * A comment. * * @param text The text in the comment. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by application to signal an error. */	TokenNameCOMMENT_JAVADOC	 A comment. * @param text The text in the comment. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by application to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * A processing instruction. Processing instructions consist of a * target name and, optionally, text data. The data is only meaningful * to the application. * <p> * Typically, a processing instruction's data will contain a series * of pseudo-attributes. These pseudo-attributes follow the form of * element attributes but are <strong>not</strong> parsed or presented * to the application as anything other than text. The application is * responsible for parsing the data. * * @param target The target. * @param data The data or null if none specified. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A processing instruction. Processing instructions consist of a target name and, optionally, text data. The data is only meaningful to the application. <p> Typically, a processing instruction's data will contain a series of pseudo-attributes. These pseudo-attributes follow the form of element attributes but are <strong>not</strong> parsed or presented to the application as anything other than text. The application is responsible for parsing the data. * @param target The target. @param data The data or null if none specified. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * The start of an attribute list. * * @param elementName The name of the element that this attribute * list is associated with. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of an attribute list. * @param elementName The name of the element that this attribute list is associated with. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startAttlist	TokenNameIdentifier	 start Attlist
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * The end of an attribute list. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of an attribute list. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endAttlist	TokenNameIdentifier	 end Attlist
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * The start of a conditional section. * * @param type The type of the conditional section. This value will * either be CONDITIONAL_INCLUDE or CONDITIONAL_IGNORE. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see XMLDTDHandler#CONDITIONAL_INCLUDE * @see XMLDTDHandler#CONDITIONAL_IGNORE */	TokenNameCOMMENT_JAVADOC	 The start of a conditional section. * @param type The type of the conditional section. This value will either be CONDITIONAL_INCLUDE or CONDITIONAL_IGNORE. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see XMLDTDHandler#CONDITIONAL_INCLUDE @see XMLDTDHandler#CONDITIONAL_IGNORE 
public	TokenNamepublic	
void	TokenNamevoid	
startConditional	TokenNameIdentifier	 start Conditional
(	TokenNameLPAREN	
short	TokenNameshort	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Characters within an IGNORE conditional section. * * @param text The ignored text. * @param augs Additional information that may include infoset * augmentations. */	TokenNameCOMMENT_JAVADOC	 Characters within an IGNORE conditional section. * @param text The ignored text. @param augs Additional information that may include infoset augmentations. 
public	TokenNamepublic	
void	TokenNamevoid	
ignoredCharacters	TokenNameIdentifier	 ignored Characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * The end of a conditional section. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a conditional section. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endConditional	TokenNameIdentifier	 end Conditional
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// XMLDTDContentModelHandler methods 	TokenNameCOMMENT_LINE	XMLDTDContentModelHandler methods 
// 	TokenNameCOMMENT_LINE	 
// set content model source 	TokenNameCOMMENT_LINE	set content model source 
public	TokenNamepublic	
void	TokenNamevoid	
setDTDContentModelSource	TokenNameIdentifier	 set DTD Content Model Source
(	TokenNameLPAREN	
XMLDTDContentModelSource	TokenNameIdentifier	 XMLDTD Content Model Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDTDContentModelSource	TokenNameIdentifier	 f DTD Content Model Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get content model source 	TokenNameCOMMENT_LINE	get content model source 
public	TokenNamepublic	
XMLDTDContentModelSource	TokenNameIdentifier	 XMLDTD Content Model Source
getDTDContentModelSource	TokenNameIdentifier	 get DTD Content Model Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDTDContentModelSource	TokenNameIdentifier	 f DTD Content Model Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The start of a content model. Depending on the type of the content * model, specific methods may be called between the call to the * startContentModel method and the call to the endContentModel method. * * @param elementName The name of the element. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of a content model. Depending on the type of the content model, specific methods may be called between the call to the startContentModel method and the call to the endContentModel method. * @param elementName The name of the element. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startContentModel	TokenNameIdentifier	 start Content Model
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fElementDeclTab	TokenNameIdentifier	 f Element Decl Tab
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementDecl	TokenNameIdentifier	 f Element Decl
=	TokenNameEQUAL	
elementDecl	TokenNameIdentifier	 element Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
initializeContentModelStack	TokenNameIdentifier	 initialize Content Model Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startContentModel(String) 	TokenNameCOMMENT_LINE	startContentModel(String) 
/** * A start of either a mixed or children content model. A mixed * content model will immediately be followed by a call to the * <code>pcdata()</code> method. A children content model will * contain additional groups and/or elements. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see #any * @see #empty */	TokenNameCOMMENT_JAVADOC	 A start of either a mixed or children content model. A mixed content model will immediately be followed by a call to the <code>pcdata()</code> method. A children content model will contain additional groups and/or elements. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see #any @see #empty 
public	TokenNamepublic	
void	TokenNamevoid	
startGroup	TokenNameIdentifier	 start Group
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fDepth	TokenNameIdentifier	 f Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
initializeContentModelStack	TokenNameIdentifier	 initialize Content Model Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMixed	TokenNameIdentifier	 f Mixed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startGroup() 	TokenNameCOMMENT_LINE	startGroup() 
/** * The appearance of "#PCDATA" within a group signifying a * mixed content model. This method will be the first called * following the content model's <code>startGroup()</code>. * *@param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. * * @see #startGroup */	TokenNameCOMMENT_JAVADOC	 The appearance of "#PCDATA" within a group signifying a mixed content model. This method will be the first called following the content model's <code>startGroup()</code>. *@param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. * @see #startGroup 
public	TokenNamepublic	
void	TokenNamevoid	
pcdata	TokenNameIdentifier	 pcdata
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fMixed	TokenNameIdentifier	 f Mixed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// pcdata() 	TokenNameCOMMENT_LINE	pcdata() 
/** * A referenced element in a mixed or children content model. * * @param elementName The name of the referenced element. * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A referenced element in a mixed or children content model. * @param elementName The name of the referenced element. @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
element	TokenNameIdentifier	 element
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMixed	TokenNameIdentifier	 f Mixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addUniqueLeafNode	TokenNameIdentifier	 add Unique Leaf Node
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
addUniqueLeafNode	TokenNameIdentifier	 add Unique Leaf Node
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
,	TokenNameCOMMA	
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// element(String) 	TokenNameCOMMENT_LINE	element(String) 
/** * The separator between choices or sequences of a mixed or children * content model. * * @param separator The type of children separator. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see org.apache.xerces.xni.XMLDTDContentModelHandler#SEPARATOR_CHOICE * @see org.apache.xerces.xni.XMLDTDContentModelHandler#SEPARATOR_SEQUENCE */	TokenNameCOMMENT_JAVADOC	 The separator between choices or sequences of a mixed or children content model. * @param separator The type of children separator. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see org.apache.xerces.xni.XMLDTDContentModelHandler#SEPARATOR_CHOICE @see org.apache.xerces.xni.XMLDTDContentModelHandler#SEPARATOR_SEQUENCE 
public	TokenNamepublic	
void	TokenNamevoid	
separator	TokenNameIdentifier	 separator
(	TokenNameLPAREN	
short	TokenNameshort	
separator	TokenNameIdentifier	 separator
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fMixed	TokenNameIdentifier	 f Mixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
&&	TokenNameAND_AND	
separator	TokenNameIdentifier	 separator
==	TokenNameEQUAL_EQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
SEPARATOR_CHOICE	TokenNameIdentifier	 SEPARATOR  CHOICE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
&&	TokenNameAND_AND	
separator	TokenNameIdentifier	 separator
==	TokenNameEQUAL_EQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
SEPARATOR_SEQUENCE	TokenNameIdentifier	 SEPARATOR  SEQUENCE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// separator(short) 	TokenNameCOMMENT_LINE	separator(short) 
/** * The occurrence count for a child in a children content model or * for the mixed content model group. * * @param occurrence The occurrence count for the last element * or group. * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ZERO_OR_ONE * @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ZERO_OR_MORE * @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ONE_OR_MORE */	TokenNameCOMMENT_JAVADOC	 The occurrence count for a child in a children content model or for the mixed content model group. * @param occurrence The occurrence count for the last element or group. @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ZERO_OR_ONE @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ZERO_OR_MORE @see org.apache.xerces.xni.XMLDTDContentModelHandler#OCCURS_ONE_OR_MORE 
public	TokenNamepublic	
void	TokenNamevoid	
occurrence	TokenNameIdentifier	 occurrence
(	TokenNameLPAREN	
short	TokenNameshort	
occurrence	TokenNameIdentifier	 occurrence
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fMixed	TokenNameIdentifier	 f Mixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
occurrence	TokenNameIdentifier	 occurrence
==	TokenNameEQUAL_EQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_ONE	TokenNameIdentifier	 OCCURS  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
occurrence	TokenNameIdentifier	 occurrence
==	TokenNameEQUAL_EQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ZERO_OR_MORE	TokenNameIdentifier	 OCCURS  ZERO  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
occurrence	TokenNameIdentifier	 occurrence
==	TokenNameEQUAL_EQUAL	
XMLDTDContentModelHandler	TokenNameIdentifier	 XMLDTD Content Model Handler
.	TokenNameDOT	
OCCURS_ONE_OR_MORE	TokenNameIdentifier	 OCCURS  ONE  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// occurrence(short) 	TokenNameCOMMENT_LINE	occurrence(short) 
/** * The end of a group for mixed or children content models. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a group for mixed or children content models. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endGroup	TokenNameIdentifier	 end Group
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fMixed	TokenNameIdentifier	 f Mixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
nodeIndex	TokenNameIdentifier	 node Index
=	TokenNameEQUAL	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
nodeIndex	TokenNameIdentifier	 node Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endGroup() 	TokenNameCOMMENT_LINE	endGroup() 
// no-op methods 	TokenNameCOMMENT_LINE	no-op methods 
/** * A content model of ANY. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see #empty * @see #startGroup */	TokenNameCOMMENT_JAVADOC	 A content model of ANY. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see #empty @see #startGroup 
public	TokenNamepublic	
void	TokenNamevoid	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * A content model of EMPTY. * * @param augs Additional information that may include infoset * augmentations. * @throws XNIException Thrown by handler to signal an error. * * @see #any * @see #startGroup */	TokenNameCOMMENT_JAVADOC	 A content model of EMPTY. * @param augs Additional information that may include infoset augmentations. @throws XNIException Thrown by handler to signal an error. * @see #any @see #startGroup 
public	TokenNamepublic	
void	TokenNamevoid	
empty	TokenNameIdentifier	 empty
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * The end of a content model. * @param augs Additional information that may include infoset * augmentations. * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a content model. @param augs Additional information that may include infoset augmentations. * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endContentModel	TokenNameIdentifier	 end Content Model
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Grammar methods 	TokenNameCOMMENT_LINE	Grammar methods 
// 	TokenNameCOMMENT_LINE	 
/** Returns true if this grammar is namespace aware. */	TokenNameCOMMENT_JAVADOC	 Returns true if this grammar is namespace aware. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isNamespaceAware	TokenNameIdentifier	 is Namespace Aware
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// isNamespaceAware():boolean 	TokenNameCOMMENT_LINE	isNamespaceAware():boolean 
/** Returns the symbol table. */	TokenNameCOMMENT_JAVADOC	 Returns the symbol table. 
public	TokenNamepublic	
SymbolTable	TokenNameIdentifier	 Symbol Table
getSymbolTable	TokenNameIdentifier	 get Symbol Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSymbolTable():SymbolTable 	TokenNameCOMMENT_LINE	getSymbolTable():SymbolTable 
/** * Returns the index of the first element declaration. This index * is then used to query more information about the element declaration. * * @see #getNextElementDeclIndex * @see #getElementDecl */	TokenNameCOMMENT_JAVADOC	 Returns the index of the first element declaration. This index is then used to query more information about the element declaration. * @see #getNextElementDeclIndex @see #getElementDecl 
public	TokenNamepublic	
int	TokenNameint	
getFirstElementDeclIndex	TokenNameIdentifier	 get First Element Decl Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFirstElementDeclIndex():int 	TokenNameCOMMENT_LINE	getFirstElementDeclIndex():int 
/** * Returns the next index of the element declaration following the * specified element declaration. * * @param elementDeclIndex The element declaration index. */	TokenNameCOMMENT_JAVADOC	 Returns the next index of the element declaration following the specified element declaration. * @param elementDeclIndex The element declaration index. 
public	TokenNamepublic	
int	TokenNameint	
getNextElementDeclIndex	TokenNameIdentifier	 get Next Element Decl Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getNextElementDeclIndex(int):int 	TokenNameCOMMENT_LINE	getNextElementDeclIndex(int):int 
/** * getElementDeclIndex * * @param elementDeclName * * @return index of the elementDeclName in scope */	TokenNameCOMMENT_JAVADOC	 getElementDeclIndex * @param elementDeclName * @return index of the elementDeclName in scope 
public	TokenNamepublic	
int	TokenNameint	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementDeclName	TokenNameIdentifier	 element Decl Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
mapping	TokenNameIdentifier	 mapping
=	TokenNameEQUAL	
fElementIndexMap	TokenNameIdentifier	 f Element Index Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
elementDeclName	TokenNameIdentifier	 element Decl Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("getElementDeclIndex("+elementDeclName+") -> "+mapping); 	TokenNameCOMMENT_LINE	System.out.println("getElementDeclIndex("+elementDeclName+") -> "+mapping); 
return	TokenNamereturn	
mapping	TokenNameIdentifier	 mapping
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getElementDeclIndex(String):int 	TokenNameCOMMENT_LINE	getElementDeclIndex(String):int 
/** Returns the element decl index. * @param elementDeclQName qualilfied name of the element */	TokenNameCOMMENT_JAVADOC	 Returns the element decl index. @param elementDeclQName qualilfied name of the element 
public	TokenNamepublic	
int	TokenNameint	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
elementDeclQName	TokenNameIdentifier	 element Decl Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
elementDeclQName	TokenNameIdentifier	 element Decl Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getElementDeclIndex(QName):int 	TokenNameCOMMENT_LINE	getElementDeclIndex(QName):int 
/** make separate function for getting contentSpecType of element. * we can avoid setting of the element values. */	TokenNameCOMMENT_JAVADOC	 make separate function for getting contentSpecType of element. we can avoid setting of the element values. 
public	TokenNamepublic	
short	TokenNameshort	
getContentSpecType	TokenNameIdentifier	 get Content Spec Type
(	TokenNameLPAREN	
int	TokenNameint	
elementIndex	TokenNameIdentifier	 element Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementIndex	TokenNameIdentifier	 element Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementIndex	TokenNameIdentifier	 element Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementIndex	TokenNameIdentifier	 element Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementIndex	TokenNameIdentifier	 element Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
&	TokenNameAND	
LIST_MASK	TokenNameIdentifier	 LIST  MASK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//getContentSpecType 	TokenNameCOMMENT_LINE	getContentSpecType 
/** * getElementDecl * * @param elementDeclIndex * @param elementDecl The values of this structure are set by this call. * * @return True if find the element, False otherwise. */	TokenNameCOMMENT_JAVADOC	 getElementDecl * @param elementDeclIndex @param elementDecl The values of this structure are set by this call. * @return True if find the element, False otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
&	TokenNameAND	
LIST_MASK	TokenNameIdentifier	 LIST  MASK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
&	TokenNameAND	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Validators are null until we add that code */	TokenNameCOMMENT_BLOCK	 Validators are null until we add that code 
if	TokenNameif	
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
||	TokenNameOR_OR	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
contentModelValidator	TokenNameIdentifier	 content Model Validator
=	TokenNameEQUAL	
getElementContentModelValidator	TokenNameIdentifier	 get Element Content Model Validator
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
datatypeValidator	TokenNameIdentifier	 datatype Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getElementDecl(int,XMLElementDecl):boolean 	TokenNameCOMMENT_LINE	getElementDecl(int,XMLElementDecl):boolean 
QName	TokenNameIdentifier	 Q Name
getElementDeclName	TokenNameIdentifier	 get Element Decl Name
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT: Make this getAttributeDeclCount/getAttributeDeclAt. -Ac 	TokenNameCOMMENT_LINE	REVISIT: Make this getAttributeDeclCount/getAttributeDeclAt. -Ac 
/** * getFirstAttributeDeclIndex * * @param elementDeclIndex * * @return index of the first attribute for element declaration elementDeclIndex */	TokenNameCOMMENT_JAVADOC	 getFirstAttributeDeclIndex * @param elementDeclIndex * @return index of the first attribute for element declaration elementDeclIndex 
public	TokenNamepublic	
int	TokenNameint	
getFirstAttributeDeclIndex	TokenNameIdentifier	 get First Attribute Decl Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFirstAttributeDeclIndex 	TokenNameCOMMENT_LINE	getFirstAttributeDeclIndex 
/** * getNextAttributeDeclIndex * * @param attributeDeclIndex * * @return index of the next attribute of the attribute at attributeDeclIndex */	TokenNameCOMMENT_JAVADOC	 getNextAttributeDeclIndex * @param attributeDeclIndex * @return index of the next attribute of the attribute at attributeDeclIndex 
public	TokenNamepublic	
int	TokenNameint	
getNextAttributeDeclIndex	TokenNameIdentifier	 get Next Attribute Decl Index
(	TokenNameLPAREN	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getNextAttributeDeclIndex 	TokenNameCOMMENT_LINE	getNextAttributeDeclIndex 
/** * getAttributeDecl * * @param attributeDeclIndex * @param attributeDecl The values of this structure are set by this call. * * @return true if getAttributeDecl was able to fill in the value of attributeDecl */	TokenNameCOMMENT_JAVADOC	 getAttributeDecl * @param attributeDeclIndex @param attributeDecl The values of this structure are set by this call. * @return true if getAttributeDecl was able to fill in the value of attributeDecl 
public	TokenNamepublic	
boolean	TokenNameboolean	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
,	TokenNameCOMMA	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
attributeDecl	TokenNameIdentifier	 attribute Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
>=	TokenNameGREATER_EQUAL	
fAttributeDeclCount	TokenNameIdentifier	 f Attribute Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
attributeType	TokenNameIdentifier	 attribute Type
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isList	TokenNameIdentifier	 is List
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributeType	TokenNameIdentifier	 attribute Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
isList	TokenNameIdentifier	 is List
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
attributeType	TokenNameIdentifier	 attribute Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
&	TokenNameAND	
LIST_MASK	TokenNameIdentifier	 LIST  MASK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isList	TokenNameIdentifier	 is List
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
&	TokenNameAND	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
attributeType	TokenNameIdentifier	 attribute Type
,	TokenNameCOMMA	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
isList	TokenNameIdentifier	 is List
,	TokenNameCOMMA	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getAttributeDecl 	TokenNameCOMMENT_LINE	getAttributeDecl 
/** * Returns whether the given attribute is of type CDATA or not * * @param elName The element name. * @param atName The attribute name. * * @return true if the attribute is of type CDATA */	TokenNameCOMMENT_JAVADOC	 Returns whether the given attribute is of type CDATA or not * @param elName The element name. @param atName The attribute name. * @return true if the attribute is of type CDATA 
public	TokenNamepublic	
boolean	TokenNameboolean	
isCDATAAttribute	TokenNameIdentifier	 is CDATA Attribute
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
elName	TokenNameIdentifier	 el Name
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
atName	TokenNameIdentifier	 at Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
elDeclIdx	TokenNameIdentifier	 el Decl Idx
=	TokenNameEQUAL	
getElementDeclIndex	TokenNameIdentifier	 get Element Decl Index
(	TokenNameLPAREN	
elName	TokenNameIdentifier	 el Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
elDeclIdx	TokenNameIdentifier	 el Decl Idx
,	TokenNameCOMMA	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fAttributeDecl	TokenNameIdentifier	 f Attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
TYPE_CDATA	TokenNameIdentifier	 TYPE  CDATA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * getEntityDeclIndex * * @param entityDeclName * * @return the index of the EntityDecl */	TokenNameCOMMENT_JAVADOC	 getEntityDeclIndex * @param entityDeclName * @return the index of the EntityDecl 
public	TokenNamepublic	
int	TokenNameint	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
entityDeclName	TokenNameIdentifier	 entity Decl Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entityDeclName	TokenNameIdentifier	 entity Decl Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEntityIndexMap	TokenNameIdentifier	 f Entity Index Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
entityDeclName	TokenNameIdentifier	 entity Decl Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getEntityDeclIndex 	TokenNameCOMMENT_LINE	getEntityDeclIndex 
/** * getEntityDecl * * @param entityDeclIndex * @param entityDecl * * @return true if getEntityDecl was able to fill entityDecl with the contents of the entity * with index entityDeclIndex */	TokenNameCOMMENT_JAVADOC	 getEntityDecl * @param entityDeclIndex @param entityDecl * @return true if getEntityDecl was able to fill entityDecl with the contents of the entity with index entityDeclIndex 
public	TokenNamepublic	
boolean	TokenNameboolean	
getEntityDecl	TokenNameIdentifier	 get Entity Decl
(	TokenNameLPAREN	
int	TokenNameint	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
,	TokenNameCOMMA	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
entityDecl	TokenNameIdentifier	 entity Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
>=	TokenNameGREATER_EQUAL	
fEntityCount	TokenNameIdentifier	 f Entity Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fEntityName	TokenNameIdentifier	 f Entity Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntityValue	TokenNameIdentifier	 f Entity Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
false	TokenNamefalse	
:	TokenNameCOLON	
true	TokenNametrue	
,	TokenNameCOMMA	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
false	TokenNamefalse	
:	TokenNameCOLON	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getEntityDecl 	TokenNameCOMMENT_LINE	getEntityDecl 
/** * getNotationDeclIndex * * @param notationDeclName * * @return the index if found a notation with the name, otherwise -1. */	TokenNameCOMMENT_JAVADOC	 getNotationDeclIndex * @param notationDeclName * @return the index if found a notation with the name, otherwise -1. 
public	TokenNamepublic	
int	TokenNameint	
getNotationDeclIndex	TokenNameIdentifier	 get Notation Decl Index
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
notationDeclName	TokenNameIdentifier	 notation Decl Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
notationDeclName	TokenNameIdentifier	 notation Decl Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fNotationIndexMap	TokenNameIdentifier	 f Notation Index Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
notationDeclName	TokenNameIdentifier	 notation Decl Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getNotationDeclIndex 	TokenNameCOMMENT_LINE	getNotationDeclIndex 
/** * getNotationDecl * * @param notationDeclIndex * @param notationDecl * * @return return true of getNotationDecl can fill notationDecl with information about * the notation at notationDeclIndex. */	TokenNameCOMMENT_JAVADOC	 getNotationDecl * @param notationDeclIndex @param notationDecl * @return return true of getNotationDecl can fill notationDecl with information about the notation at notationDeclIndex. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getNotationDecl	TokenNameIdentifier	 get Notation Decl
(	TokenNameLPAREN	
int	TokenNameint	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
,	TokenNameCOMMA	
XMLNotationDecl	TokenNameIdentifier	 XML Notation Decl
notationDecl	TokenNameIdentifier	 notation Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
>=	TokenNameGREATER_EQUAL	
fNotationCount	TokenNameIdentifier	 f Notation Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fNotationName	TokenNameIdentifier	 f Notation Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getNotationDecl 	TokenNameCOMMENT_LINE	getNotationDecl 
/** * getContentSpec * * @param contentSpecIndex * @param contentSpec * * @return true if find the requested contentSpec node, false otherwise */	TokenNameCOMMENT_JAVADOC	 getContentSpec * @param contentSpecIndex @param contentSpec * @return true if find the requested contentSpec node, false otherwise 
public	TokenNamepublic	
boolean	TokenNameboolean	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
>=	TokenNameGREATER_EQUAL	
fContentSpecCount	TokenNameIdentifier	 f Content Spec Count
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
=	TokenNameEQUAL	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the index to the content spec for the given element * declaration, or <code>-1</code> if the element declaration * index was invalid. */	TokenNameCOMMENT_JAVADOC	 Returns the index to the content spec for the given element declaration, or <code>-1</code> if the element declaration index was invalid. 
public	TokenNamepublic	
int	TokenNameint	
getContentSpecIndex	TokenNameIdentifier	 get Content Spec Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * getContentSpecAsString * * @param elementDeclIndex * * @return String */	TokenNameCOMMENT_JAVADOC	 getContentSpecAsString * @param elementDeclIndex * @return String 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getContentSpecAsString	TokenNameIdentifier	 get Content Spec As String
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
=	TokenNameEQUAL	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// lookup content spec node 	TokenNameCOMMENT_LINE	lookup content spec node 
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// build string 	TokenNameCOMMENT_LINE	build string 
StringBuffer	TokenNameIdentifier	 String Buffer
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
nextContentSpec	TokenNameIdentifier	 next Content Spec
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
:	TokenNameCOLON	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextContentSpec	TokenNameIdentifier	 next Content Spec
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'?'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
:	TokenNameCOLON	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextContentSpec	TokenNameIdentifier	 next Content Spec
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any:uri="	TokenNameStringLiteral	##any:uri=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any"	TokenNameStringLiteral	##any
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'*'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
:	TokenNameCOLON	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextContentSpec	TokenNameIdentifier	 next Content Spec
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any:uri="	TokenNameStringLiteral	##any:uri=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any"	TokenNameStringLiteral	##any
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
nextContentSpec	TokenNameIdentifier	 next Content Spec
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'+'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
:	TokenNameCOLON	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
:	TokenNameCOLON	
{	TokenNameLBRACE	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY	TokenNameIdentifier	 CONTENTSPECNODE  ANY
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any"	TokenNameStringLiteral	##any
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
":uri="	TokenNameStringLiteral	:uri=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_OTHER	TokenNameIdentifier	 CONTENTSPECNODE  ANY  OTHER
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##other:uri="	TokenNameStringLiteral	##other:uri=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_LOCAL	TokenNameIdentifier	 CONTENTSPECNODE  ANY  LOCAL
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##local"	TokenNameStringLiteral	##local
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"???"	TokenNameStringLiteral	???
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// switch type 	TokenNameCOMMENT_LINE	switch type 
// return string 	TokenNameCOMMENT_LINE	return string 
return	TokenNamereturn	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// not found 	TokenNameCOMMENT_LINE	not found 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getContentSpecAsString(int):String 	TokenNameCOMMENT_LINE	getContentSpecAsString(int):String 
// debugging 	TokenNameCOMMENT_LINE	debugging 
public	TokenNamepublic	
void	TokenNamevoid	
printElements	TokenNameIdentifier	 print Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
getElementDecl	TokenNameIdentifier	 get Element Decl
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
++	TokenNamePLUS_PLUS	
,	TokenNameCOMMA	
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"element decl: "	TokenNameStringLiteral	element decl: 
+	TokenNamePLUS	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ", "+ elementDecl.contentModelValidator.toString()); 	TokenNameCOMMENT_LINE	", "+ elementDecl.contentModelValidator.toString()); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
printAttributes	TokenNameIdentifier	 print Attributes
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
=	TokenNameEQUAL	
getFirstAttributeDeclIndex	TokenNameIdentifier	 get First Attribute Decl Index
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" ["	TokenNameStringLiteral	 [
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
printAttribute	TokenNameIdentifier	 print Attribute
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
=	TokenNameEQUAL	
getNextAttributeDeclIndex	TokenNameIdentifier	 get Next Attribute Decl Index
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" ]"	TokenNameStringLiteral	 ]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Protected methods 	TokenNameCOMMENT_LINE	Protected methods 
// 	TokenNameCOMMENT_LINE	 
/** * Adds the content spec to the given element declaration. */	TokenNameCOMMENT_JAVADOC	 Adds the content spec to the given element declaration. 
protected	TokenNameprotected	
void	TokenNamevoid	
addContentSpecToElement	TokenNameIdentifier	 add Content Spec To Element
(	TokenNameLPAREN	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
pcdata	TokenNameIdentifier	 pcdata
=	TokenNameEQUAL	
addUniqueLeafNode	TokenNameIdentifier	 add Unique Leaf Node
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pcdata	TokenNameIdentifier	 pcdata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
,	TokenNameCOMMA	
pcdata	TokenNameIdentifier	 pcdata
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
setContentSpecIndex	TokenNameIdentifier	 set Content Spec Index
(	TokenNameLPAREN	
fCurrentElementIndex	TokenNameIdentifier	 f Current Element Index
,	TokenNameCOMMA	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * getElementContentModelValidator * * @param elementDeclIndex * * @return its ContentModelValidator if any. */	TokenNameCOMMENT_JAVADOC	 getElementContentModelValidator * @param elementDeclIndex * @return its ContentModelValidator if any. 
protected	TokenNameprotected	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
getElementContentModelValidator	TokenNameIdentifier	 get Element Content Model Validator
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// If we have one, just return that. Otherwise, gotta create one 	TokenNameCOMMENT_LINE	If we have one, just return that. Otherwise, gotta create one 
if	TokenNameif	
(	TokenNameLPAREN	
contentModel	TokenNameIdentifier	 content Model
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
contentModel	TokenNameIdentifier	 content Model
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
contentType	TokenNameIdentifier	 content Type
=	TokenNameEQUAL	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_SIMPLE	TokenNameIdentifier	 TYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get the type of content this element has 	TokenNameCOMMENT_LINE	Get the type of content this element has 
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
=	TokenNameEQUAL	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/*** if ( contentSpecIndex == -1 ) return null; /***/	TokenNameCOMMENT_JAVADOC	* if ( contentSpecIndex == -1 ) return null; /**
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// And create the content model according to the spec type 	TokenNameCOMMENT_LINE	And create the content model according to the spec type 
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_MIXED	TokenNameIdentifier	 TYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Just create a mixel content model object. This type of 	TokenNameCOMMENT_LINE	Just create a mixel content model object. This type of 
// content model is optimized for mixed content validation. 	TokenNameCOMMENT_LINE	content model is optimized for mixed content validation. 
// 	TokenNameCOMMENT_LINE	 
ChildrenList	TokenNameIdentifier	 Children List
children	TokenNameIdentifier	 children
=	TokenNameEQUAL	
new	TokenNamenew	
ChildrenList	TokenNameIdentifier	 Children List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentSpecTree	TokenNameIdentifier	 content Spec Tree
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
new	TokenNamenew	
MixedContentModel	TokenNameIdentifier	 Mixed Content Model
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
qname	TokenNameIdentifier	 qname
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
==	TokenNameEQUAL_EQUAL	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
.	TokenNameDOT	
TYPE_CHILDREN	TokenNameIdentifier	 TYPE  CHILDREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This method will create an optimal model for the complexity 	TokenNameCOMMENT_LINE	This method will create an optimal model for the complexity 
// of the element's defined model. If its simple, it will create 	TokenNameCOMMENT_LINE	of the element's defined model. If its simple, it will create 
// a SimpleContentModel object. If its a simple list, it will 	TokenNameCOMMENT_LINE	a SimpleContentModel object. If its a simple list, it will 
// create a SimpleListContentModel object. If its complex, it 	TokenNameCOMMENT_LINE	create a SimpleListContentModel object. If its complex, it 
// will create a DFAContentModel object. 	TokenNameCOMMENT_LINE	will create a DFAContentModel object. 
// 	TokenNameCOMMENT_LINE	 
contentModel	TokenNameIdentifier	 content Model
=	TokenNameEQUAL	
createChildModel	TokenNameIdentifier	 create Child Model
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Unknown content type for a element decl "	TokenNameStringLiteral	Unknown content type for a element decl 
+	TokenNamePLUS	
"in getElementContentModelValidator() in AbstractDTDGrammar class"	TokenNameStringLiteral	in getElementContentModelValidator() in AbstractDTDGrammar class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Add the new model to the content model for this element 	TokenNameCOMMENT_LINE	Add the new model to the content model for this element 
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentModel	TokenNameIdentifier	 content Model
;	TokenNameSEMICOLON	
return	TokenNamereturn	
contentModel	TokenNameIdentifier	 content Model
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getElementContentModelValidator(int):ContentModelValidator 	TokenNameCOMMENT_LINE	getElementContentModelValidator(int):ContentModelValidator 
protected	TokenNameprotected	
int	TokenNameint	
createElementDecl	TokenNameIdentifier	 create Element Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureElementDeclCapacity	TokenNameIdentifier	 ensure Element Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setElementDecl	TokenNameIdentifier	 set Element Decl
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
XMLElementDecl	TokenNameIdentifier	 XML Element Decl
elementDecl	TokenNameIdentifier	 element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
contentModelValidator	TokenNameIdentifier	 content Model Validator
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
|=	TokenNameOR_EQUAL	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElementIndexMap	TokenNameIdentifier	 f Element Index Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
elementDecl	TokenNameIdentifier	 element Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
putElementNameMapping	TokenNameIdentifier	 put Element Name Mapping
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
int	TokenNameint	
scope	TokenNameIdentifier	 scope
,	TokenNameCOMMA	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setFirstAttributeDeclIndex	TokenNameIdentifier	 set First Attribute Decl Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
int	TokenNameint	
newFirstAttrIndex	TokenNameIdentifier	 new First Attr Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
newFirstAttrIndex	TokenNameIdentifier	 new First Attr Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setContentSpecIndex	TokenNameIdentifier	 set Content Spec Index
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>=	TokenNameGREATER_EQUAL	
fElementDeclCount	TokenNameIdentifier	 f Element Decl Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
createAttributeDecl	TokenNameIdentifier	 create Attribute Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fAttributeDeclCount	TokenNameIdentifier	 f Attribute Decl Count
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fAttributeDeclCount	TokenNameIdentifier	 f Attribute Decl Count
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureAttributeDeclCapacity	TokenNameIdentifier	 ensure Attribute Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XMLSimpleType	TokenNameIdentifier	 XML Simple Type
.	TokenNameDOT	
DEFAULT_TYPE_IMPLIED	TokenNameIdentifier	 DEFAULT  TYPE  IMPLIED
;	TokenNameSEMICOLON	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fAttributeDeclCount	TokenNameIdentifier	 f Attribute Decl Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setAttributeDecl	TokenNameIdentifier	 set Attribute Decl
(	TokenNameLPAREN	
int	TokenNameint	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
,	TokenNameCOMMA	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
,	TokenNameCOMMA	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
attributeDecl	TokenNameIdentifier	 attribute Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attrChunk	TokenNameIdentifier	 attr Chunk
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
|=	TokenNameOR_EQUAL	
LIST_FLAG	TokenNameIdentifier	 LIST  FLAG
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
;	TokenNameSEMICOLON	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultType	TokenNameIdentifier	 default Type
;	TokenNameSEMICOLON	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
datatypeValidator	TokenNameIdentifier	 datatype Validator
;	TokenNameSEMICOLON	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
defaultValue	TokenNameIdentifier	 default Value
;	TokenNameSEMICOLON	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
simpleType	TokenNameIdentifier	 simple Type
.	TokenNameDOT	
nonNormalizedDefaultValue	TokenNameIdentifier	 non Normalized Default Value
;	TokenNameSEMICOLON	
int	TokenNameint	
elemChunk	TokenNameIdentifier	 elem Chunk
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
elementDeclIndex	TokenNameIdentifier	 element Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
elemChunk	TokenNameIdentifier	 elem Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attrChunk	TokenNameIdentifier	 attr Chunk
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
elemChunk	TokenNameIdentifier	 elem Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
elemChunk	TokenNameIdentifier	 elem Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
[	TokenNameLBRACKET	
elemChunk	TokenNameIdentifier	 elem Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
attrChunk	TokenNameIdentifier	 attr Chunk
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
attrChunk	TokenNameIdentifier	 attr Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
attrIndex	TokenNameIdentifier	 attr Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
[	TokenNameLBRACKET	
elemChunk	TokenNameIdentifier	 elem Chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
createContentSpec	TokenNameIdentifier	 create Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fContentSpecCount	TokenNameIdentifier	 f Content Spec Count
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fContentSpecCount	TokenNameIdentifier	 f Content Spec Count
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureContentSpecCapacity	TokenNameIdentifier	 ensure Content Spec Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fContentSpecCount	TokenNameIdentifier	 f Content Spec Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setContentSpec	TokenNameIdentifier	 set Content Spec
(	TokenNameLPAREN	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
createEntityDecl	TokenNameIdentifier	 create Entity Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fEntityCount	TokenNameIdentifier	 f Entity Count
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
fEntityCount	TokenNameIdentifier	 f Entity Count
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
ensureEntityDeclCapacity	TokenNameIdentifier	 ensure Entity Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fEntityCount	TokenNameIdentifier	 f Entity Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setEntityDecl	TokenNameIdentifier	 set Entity Decl
(	TokenNameLPAREN	
int	TokenNameint	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
,	TokenNameCOMMA	
XMLEntityDecl	TokenNameIdentifier	 XML Entity Decl
entityDecl	TokenNameIdentifier	 entity Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fEntityName	TokenNameIdentifier	 f Entity Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fEntityValue	TokenNameIdentifier	 f Entity Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
;	TokenNameSEMICOLON	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
baseSystemId	TokenNameIdentifier	 base System Id
;	TokenNameSEMICOLON	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
notation	TokenNameIdentifier	 notation
;	TokenNameSEMICOLON	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
isPE	TokenNameIdentifier	 is PE
?	TokenNameQUESTION	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
inExternal	TokenNameIdentifier	 in External
?	TokenNameQUESTION	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fEntityIndexMap	TokenNameIdentifier	 f Entity Index Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
entityDecl	TokenNameIdentifier	 entity Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
entityDeclIndex	TokenNameIdentifier	 entity Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
int	TokenNameint	
createNotationDecl	TokenNameIdentifier	 create Notation Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
fNotationCount	TokenNameIdentifier	 f Notation Count
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
ensureNotationDeclCapacity	TokenNameIdentifier	 ensure Notation Decl Capacity
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fNotationCount	TokenNameIdentifier	 f Notation Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
setNotationDecl	TokenNameIdentifier	 set Notation Decl
(	TokenNameLPAREN	
int	TokenNameint	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
,	TokenNameCOMMA	
XMLNotationDecl	TokenNameIdentifier	 XML Notation Decl
notationDecl	TokenNameIdentifier	 notation Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
fNotationName	TokenNameIdentifier	 f Notation Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
publicId	TokenNameIdentifier	 public Id
;	TokenNameSEMICOLON	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
baseSystemId	TokenNameIdentifier	 base System Id
;	TokenNameSEMICOLON	
fNotationIndexMap	TokenNameIdentifier	 f Notation Index Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
notationDecl	TokenNameIdentifier	 notation Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
notationDeclIndex	TokenNameIdentifier	 notation Decl Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create an XMLContentSpec for a single non-leaf * * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_* * @param nodeValue handle to an XMLContentSpec * @return handle to the newly create XMLContentSpec */	TokenNameCOMMENT_JAVADOC	 Create an XMLContentSpec for a single non-leaf * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_* @param nodeValue handle to an XMLContentSpec @return handle to the newly create XMLContentSpec 
protected	TokenNameprotected	
int	TokenNameint	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
short	TokenNameshort	
nodeType	TokenNameIdentifier	 node Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
nodeValue	TokenNameIdentifier	 node Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// create content spec node 	TokenNameCOMMENT_LINE	create content spec node 
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
=	TokenNameEQUAL	
createContentSpec	TokenNameIdentifier	 create Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set content spec node values 	TokenNameCOMMENT_LINE	set content spec node values 
fContentSpec	TokenNameIdentifier	 f Content Spec
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
nodeType	TokenNameIdentifier	 node Type
,	TokenNameCOMMA	
nodeValue	TokenNameIdentifier	 node Value
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setContentSpec	TokenNameIdentifier	 set Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
fContentSpec	TokenNameIdentifier	 f Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return index 	TokenNameCOMMENT_LINE	return index 
return	TokenNamereturn	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// addContentSpecNode(short,String):int 	TokenNameCOMMENT_LINE	addContentSpecNode(short,String):int 
/** * create an XMLContentSpec for a leaf * * @param elementName the name (Element) for the node * @return handle to the newly create XMLContentSpec */	TokenNameCOMMENT_JAVADOC	 create an XMLContentSpec for a leaf * @param elementName the name (Element) for the node @return handle to the newly create XMLContentSpec 
protected	TokenNameprotected	
int	TokenNameint	
addUniqueLeafNode	TokenNameIdentifier	 add Unique Leaf Node
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// create content spec node 	TokenNameCOMMENT_LINE	create content spec node 
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
=	TokenNameEQUAL	
createContentSpec	TokenNameIdentifier	 create Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set content spec node values 	TokenNameCOMMENT_LINE	set content spec node values 
fContentSpec	TokenNameIdentifier	 f Content Spec
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
,	TokenNameCOMMA	
elementName	TokenNameIdentifier	 element Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setContentSpec	TokenNameIdentifier	 set Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
fContentSpec	TokenNameIdentifier	 f Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return index 	TokenNameCOMMENT_LINE	return index 
return	TokenNamereturn	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// addUniqueLeafNode(String):int 	TokenNameCOMMENT_LINE	addUniqueLeafNode(String):int 
/** * Create an XMLContentSpec for a two child leaf * * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_* * @param leftNodeIndex handle to an XMLContentSpec * @param rightNodeIndex handle to an XMLContentSpec * @return handle to the newly create XMLContentSpec */	TokenNameCOMMENT_JAVADOC	 Create an XMLContentSpec for a two child leaf * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_* @param leftNodeIndex handle to an XMLContentSpec @param rightNodeIndex handle to an XMLContentSpec @return handle to the newly create XMLContentSpec 
protected	TokenNameprotected	
int	TokenNameint	
addContentSpecNode	TokenNameIdentifier	 add Content Spec Node
(	TokenNameLPAREN	
short	TokenNameshort	
nodeType	TokenNameIdentifier	 node Type
,	TokenNameCOMMA	
int	TokenNameint	
leftNodeIndex	TokenNameIdentifier	 left Node Index
,	TokenNameCOMMA	
int	TokenNameint	
rightNodeIndex	TokenNameIdentifier	 right Node Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// create content spec node 	TokenNameCOMMENT_LINE	create content spec node 
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
=	TokenNameEQUAL	
createContentSpec	TokenNameIdentifier	 create Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set content spec node values 	TokenNameCOMMENT_LINE	set content spec node values 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
leftIntArray	TokenNameIdentifier	 left Int Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rightIntArray	TokenNameIdentifier	 right Int Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
leftIntArray	TokenNameIdentifier	 left Int Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
leftNodeIndex	TokenNameIdentifier	 left Node Index
;	TokenNameSEMICOLON	
rightIntArray	TokenNameIdentifier	 right Int Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rightNodeIndex	TokenNameIdentifier	 right Node Index
;	TokenNameSEMICOLON	
fContentSpec	TokenNameIdentifier	 f Content Spec
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
nodeType	TokenNameIdentifier	 node Type
,	TokenNameCOMMA	
leftIntArray	TokenNameIdentifier	 left Int Array
,	TokenNameCOMMA	
rightIntArray	TokenNameIdentifier	 right Int Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setContentSpec	TokenNameIdentifier	 set Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
fContentSpec	TokenNameIdentifier	 f Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return index 	TokenNameCOMMENT_LINE	return index 
return	TokenNamereturn	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// addContentSpecNode(short,int,int):int 	TokenNameCOMMENT_LINE	addContentSpecNode(short,int,int):int 
/** Initialize content model stack. */	TokenNameCOMMENT_JAVADOC	 Initialize content model stack. 
protected	TokenNameprotected	
void	TokenNamevoid	
initializeContentModelStack	TokenNameIdentifier	 initialize Content Model Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fOpStack	TokenNameIdentifier	 f Op Stack
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
fOpStack	TokenNameIdentifier	 f Op Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStack	TokenNameIdentifier	 new Stack
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fOpStack	TokenNameIdentifier	 f Op Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStack	TokenNameIdentifier	 new Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fOpStack	TokenNameIdentifier	 f Op Stack
=	TokenNameEQUAL	
newStack	TokenNameIdentifier	 new Stack
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newIntStack	TokenNameIdentifier	 new Int Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newIntStack	TokenNameIdentifier	 new Int Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
=	TokenNameEQUAL	
newIntStack	TokenNameIdentifier	 new Int Stack
;	TokenNameSEMICOLON	
newIntStack	TokenNameIdentifier	 new Int Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newIntStack	TokenNameIdentifier	 new Int Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
=	TokenNameEQUAL	
newIntStack	TokenNameIdentifier	 new Int Stack
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fOpStack	TokenNameIdentifier	 f Op Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNodeIndexStack	TokenNameIdentifier	 f Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fPrevNodeIndexStack	TokenNameIdentifier	 f Prev Node Index Stack
[	TokenNameLBRACKET	
fDepth	TokenNameIdentifier	 f Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// initializeContentModelStack() 	TokenNameCOMMENT_LINE	initializeContentModelStack() 
boolean	TokenNameboolean	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
void	TokenNamevoid	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
StringBuffer	TokenNameIdentifier	 String Buffer
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
boolean	TokenNameboolean	
parens	TokenNameIdentifier	 parens
,	TokenNameCOMMA	
int	TokenNameint	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
thisContentSpec	TokenNameIdentifier	 this Content Spec
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"#PCDATA"	TokenNameStringLiteral	#PCDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any:uri="	TokenNameStringLiteral	##any:uri=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any"	TokenNameStringLiteral	##any
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'?'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'*'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
parentContentSpecType	TokenNameIdentifier	 parent Content Spec Type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'+'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
:	TokenNameCOLON	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parens	TokenNameIdentifier	 parens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'('	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
int	TokenNameint	
otherValue	TokenNameIdentifier	 other Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'|'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
otherValue	TokenNameIdentifier	 other Value
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendContentSpec	TokenNameIdentifier	 append Content Spec
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
thisContentSpec	TokenNameIdentifier	 this Content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parens	TokenNameIdentifier	 parens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
')'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY	TokenNameIdentifier	 CONTENTSPECNODE  ANY
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##any"	TokenNameStringLiteral	##any
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
":uri="	TokenNameStringLiteral	:uri=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_OTHER	TokenNameIdentifier	 CONTENTSPECNODE  ANY  OTHER
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##other:uri="	TokenNameStringLiteral	##other:uri=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_LOCAL	TokenNameIdentifier	 CONTENTSPECNODE  ANY  LOCAL
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"##local"	TokenNameStringLiteral	##local
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"???"	TokenNameStringLiteral	???
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// switch type 	TokenNameCOMMENT_LINE	switch type 
}	TokenNameRBRACE	
// appendContentSpec(XMLContentSpec.Provider,StringPool,XMLContentSpec,StringBuffer,boolean) 	TokenNameCOMMENT_LINE	appendContentSpec(XMLContentSpec.Provider,StringPool,XMLContentSpec,StringBuffer,boolean) 
// debugging 	TokenNameCOMMENT_LINE	debugging 
private	TokenNameprivate	
void	TokenNamevoid	
printAttribute	TokenNameIdentifier	 print Attribute
(	TokenNameLPAREN	
int	TokenNameint	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
attributeDecl	TokenNameIdentifier	 attribute Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XMLAttributeDecl	TokenNameIdentifier	 XML Attribute Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getAttributeDecl	TokenNameIdentifier	 get Attribute Decl
(	TokenNameLPAREN	
attributeDeclIndex	TokenNameIdentifier	 attribute Decl Index
,	TokenNameCOMMA	
attributeDecl	TokenNameIdentifier	 attribute Decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" { "	TokenNameStringLiteral	 { 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
attributeDecl	TokenNameIdentifier	 attribute Decl
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" }"	TokenNameStringLiteral	 }
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// printAttribute(int) 	TokenNameCOMMENT_LINE	printAttribute(int) 
// content models 	TokenNameCOMMENT_LINE	content models 
/** * When the element has a 'CHILDREN' model, this method is called to * create the content model object. It looks for some special case simple * models and creates SimpleContentModel objects for those. For the rest * it creates the standard DFA style model. */	TokenNameCOMMENT_JAVADOC	 When the element has a 'CHILDREN' model, this method is called to create the content model object. It looks for some special case simple models and creates SimpleContentModel objects for those. For the rest it creates the standard DFA style model. 
private	TokenNameprivate	
synchronized	TokenNamesynchronized	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
createChildModel	TokenNameIdentifier	 create Child Model
(	TokenNameLPAREN	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Get the content spec node for the element we are working on. 	TokenNameCOMMENT_LINE	Get the content spec node for the element we are working on. 
// This will tell us what kind of node it is, which tells us what 	TokenNameCOMMENT_LINE	This will tell us what kind of node it is, which tells us what 
// kind of model we will try to create. 	TokenNameCOMMENT_LINE	kind of model we will try to create. 
// 	TokenNameCOMMENT_LINE	 
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY	TokenNameIdentifier	 CONTENTSPECNODE  ANY
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_OTHER	TokenNameIdentifier	 CONTENTSPECNODE  ANY  OTHER
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_LOCAL	TokenNameIdentifier	 CONTENTSPECNODE  ANY  LOCAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// let fall through to build a DFAContentModel 	TokenNameCOMMENT_LINE	let fall through to build a DFAContentModel 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check that the left value is not -1, since any content model 	TokenNameCOMMENT_LINE	Check that the left value is not -1, since any content model 
// with PCDATA should be MIXED, so we should not have gotten here. 	TokenNameCOMMENT_LINE	with PCDATA should be MIXED, so we should not have gotten here. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"ImplementationMessages.VAL_NPCD"	TokenNameStringLiteral	ImplementationMessages.VAL_NPCD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Its a single leaf, so its an 'a' type of content model, i.e. 	TokenNameCOMMENT_LINE	Its a single leaf, so its an 'a' type of content model, i.e. 
// just one instance of one element. That one is definitely a 	TokenNameCOMMENT_LINE	just one instance of one element. That one is definitely a 
// simple content model. 	TokenNameCOMMENT_LINE	simple content model. 
// 	TokenNameCOMMENT_LINE	 
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleContentModel	TokenNameIdentifier	 Simple Content Model
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fQName	TokenNameIdentifier	 f Q Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Lets see if both of the children are leafs. If so, then it 	TokenNameCOMMENT_LINE	Lets see if both of the children are leafs. If so, then it 
// it has to be a simple content model 	TokenNameCOMMENT_LINE	it has to be a simple content model 
// 	TokenNameCOMMENT_LINE	 
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpecLeft	TokenNameIdentifier	 content Spec Left
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpecRight	TokenNameIdentifier	 content Spec Right
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpecRight	TokenNameIdentifier	 content Spec Right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
contentSpecRight	TokenNameIdentifier	 content Spec Right
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Its a simple choice or sequence, so we can do a simple 	TokenNameCOMMENT_LINE	Its a simple choice or sequence, so we can do a simple 
// content model for it. 	TokenNameCOMMENT_LINE	content model for it. 
// 	TokenNameCOMMENT_LINE	 
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fQName2	TokenNameIdentifier	 f Q Name2
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecRight	TokenNameIdentifier	 content Spec Right
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecRight	TokenNameIdentifier	 content Spec Right
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecRight	TokenNameIdentifier	 content Spec Right
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleContentModel	TokenNameIdentifier	 Simple Content Model
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fQName	TokenNameIdentifier	 f Q Name
,	TokenNameCOMMA	
fQName2	TokenNameIdentifier	 f Q Name2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Its a repetition, so see if its one child is a leaf. If so 	TokenNameCOMMENT_LINE	Its a repetition, so see if its one child is a leaf. If so 
// its a repetition of a single element, so we can do a simple 	TokenNameCOMMENT_LINE	its a repetition of a single element, so we can do a simple 
// content model for that. 	TokenNameCOMMENT_LINE	content model for that. 
// 	TokenNameCOMMENT_LINE	 
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpecLeft	TokenNameIdentifier	 content Spec Left
=	TokenNameEQUAL	
new	TokenNamenew	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// It is, so we can create a simple content model here that 	TokenNameCOMMENT_LINE	It is, so we can create a simple content model here that 
// will check for this repetition. We pass -1 for the unused 	TokenNameCOMMENT_LINE	will check for this repetition. We pass -1 for the unused 
// right node. 	TokenNameCOMMENT_LINE	right node. 
// 	TokenNameCOMMENT_LINE	 
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpecLeft	TokenNameIdentifier	 content Spec Left
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleContentModel	TokenNameIdentifier	 Simple Content Model
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fQName	TokenNameIdentifier	 f Q Name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"ImplementationMessages.VAL_CST"	TokenNameStringLiteral	ImplementationMessages.VAL_CST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Its not a simple content model, so here we have to create a DFA 	TokenNameCOMMENT_LINE	Its not a simple content model, so here we have to create a DFA 
// for this element. So we create a DFAContentModel object. He 	TokenNameCOMMENT_LINE	for this element. So we create a DFAContentModel object. He 
// encapsulates all of the work to create the DFA. 	TokenNameCOMMENT_LINE	encapsulates all of the work to create the DFA. 
// 	TokenNameCOMMENT_LINE	 
fLeafCount	TokenNameIdentifier	 f Leaf Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//int leafCount = countLeaves(contentSpecIndex); 	TokenNameCOMMENT_LINE	int leafCount = countLeaves(contentSpecIndex); 
fLeafCount	TokenNameIdentifier	 f Leaf Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
CMNode	TokenNameIdentifier	 CM Node
cmn	TokenNameIdentifier	 cmn
=	TokenNameEQUAL	
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: has to be fLeafCount because we convert x+ to x,x*, one more leaf 	TokenNameCOMMENT_LINE	REVISIT: has to be fLeafCount because we convert x+ to x,x*, one more leaf 
return	TokenNamereturn	
new	TokenNamenew	
DFAContentModel	TokenNameIdentifier	 DFA Content Model
(	TokenNameLPAREN	
cmn	TokenNameIdentifier	 cmn
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// createChildModel(int):ContentModelValidator 	TokenNameCOMMENT_LINE	createChildModel(int):ContentModelValidator 
private	TokenNameprivate	
final	TokenNamefinal	
CMNode	TokenNameIdentifier	 CM Node
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
int	TokenNameint	
startNode	TokenNameIdentifier	 start Node
,	TokenNameCOMMA	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We will build a node at this level for the new tree 	TokenNameCOMMENT_LINE	We will build a node at this level for the new tree 
CMNode	TokenNameIdentifier	 CM Node
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
startNode	TokenNameIdentifier	 start Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY	TokenNameIdentifier	 CONTENTSPECNODE  ANY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//nodeRet = new CMAny(contentSpec.type, -1, fLeafCount++); 	TokenNameCOMMENT_LINE	nodeRet = new CMAny(contentSpec.type, -1, fLeafCount++); 
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMAny	TokenNameIdentifier	 CM Any
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_OTHER	TokenNameIdentifier	 CONTENTSPECNODE  ANY  OTHER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMAny	TokenNameIdentifier	 CM Any
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_LOCAL	TokenNameIdentifier	 CONTENTSPECNODE  ANY  LOCAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMAny	TokenNameIdentifier	 CM Any
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// If this node is a leaf, then its an easy one. We just add it 	TokenNameCOMMENT_LINE	If this node is a leaf, then its an easy one. We just add it 
// to the tree. 	TokenNameCOMMENT_LINE	to the tree. 
// 	TokenNameCOMMENT_LINE	 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Create a new leaf node, and pass it the current leaf count, 	TokenNameCOMMENT_LINE	Create a new leaf node, and pass it the current leaf count, 
// which is its DFA state position. Bump the leaf count after 	TokenNameCOMMENT_LINE	which is its DFA state position. Bump the leaf count after 
// storing it. This makes the positions zero based since we 	TokenNameCOMMENT_LINE	storing it. This makes the positions zero based since we 
// store first and then increment. 	TokenNameCOMMENT_LINE	store first and then increment. 
// 	TokenNameCOMMENT_LINE	 
fQName	TokenNameIdentifier	 f Q Name
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMLeaf	TokenNameIdentifier	 CM Leaf
(	TokenNameLPAREN	
fQName	TokenNameIdentifier	 f Q Name
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Its not a leaf, so we have to recurse its left and maybe right 	TokenNameCOMMENT_LINE	Its not a leaf, so we have to recurse its left and maybe right 
// nodes. Save both values before we recurse and trash the node. 	TokenNameCOMMENT_LINE	nodes. Save both values before we recurse and trash the node. 
final	TokenNamefinal	
int	TokenNameint	
leftNode	TokenNameIdentifier	 left Node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
rightNode	TokenNameIdentifier	 right Node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Recurse on both children, and return a binary op node 	TokenNameCOMMENT_LINE	Recurse on both children, and return a binary op node 
// with the two created sub nodes as its children. The node 	TokenNameCOMMENT_LINE	with the two created sub nodes as its children. The node 
// type is the same type as the source. 	TokenNameCOMMENT_LINE	type is the same type as the source. 
// 	TokenNameCOMMENT_LINE	 
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMBinOp	TokenNameIdentifier	 CM Bin Op
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
leftNode	TokenNameIdentifier	 left Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
,	TokenNameCOMMA	
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
rightNode	TokenNameIdentifier	 right Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMUniOp	TokenNameIdentifier	 CM Uni Op
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
leftNode	TokenNameIdentifier	 left Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
||	TokenNameOR_OR	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeRet	TokenNameIdentifier	 node Ret
=	TokenNameEQUAL	
new	TokenNamenew	
CMUniOp	TokenNameIdentifier	 CM Uni Op
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
buildSyntaxTree	TokenNameIdentifier	 build Syntax Tree
(	TokenNameLPAREN	
leftNode	TokenNameIdentifier	 left Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"ImplementationMessages.VAL_CST"	TokenNameStringLiteral	ImplementationMessages.VAL_CST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// And return our new node for this level 	TokenNameCOMMENT_LINE	And return our new node for this level 
return	TokenNamereturn	
nodeRet	TokenNameIdentifier	 node Ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Build a vector of valid QNames from Content Spec * table. * * @param contentSpecIndex * Content Spec index * @param vectorQName * Array of QName * @exception RuntimeException */	TokenNameCOMMENT_JAVADOC	 Build a vector of valid QNames from Content Spec table. * @param contentSpecIndex Content Spec index @param vectorQName Array of QName @exception RuntimeException 
private	TokenNameprivate	
void	TokenNamevoid	
contentSpecTree	TokenNameIdentifier	 content Spec Tree
(	TokenNameLPAREN	
int	TokenNameint	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
ChildrenList	TokenNameIdentifier	 Children List
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Handle any and leaf nodes 	TokenNameCOMMENT_LINE	Handle any and leaf nodes 
getContentSpec	TokenNameIdentifier	 get Content Spec
(	TokenNameLPAREN	
contentSpecIndex	TokenNameIdentifier	 content Spec Index
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_LEAF	TokenNameIdentifier	 CONTENTSPECNODE  LEAF
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY	TokenNameIdentifier	 CONTENTSPECNODE  ANY
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_LOCAL	TokenNameIdentifier	 CONTENTSPECNODE  ANY  LOCAL
||	TokenNameOR_OR	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
&	TokenNameAND	
0x0f	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ANY_OTHER	TokenNameIdentifier	 CONTENTSPECNODE  ANY  OTHER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// resize arrays, if needed 	TokenNameCOMMENT_LINE	resize arrays, if needed 
if	TokenNameif	
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newQName	TokenNameIdentifier	 new Q Name
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
qname	TokenNameIdentifier	 qname
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newQName	TokenNameIdentifier	 new Q Name
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
newQName	TokenNameIdentifier	 new Q Name
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newType	TokenNameIdentifier	 new Type
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newType	TokenNameIdentifier	 new Type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
newType	TokenNameIdentifier	 new Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// save values and return length 	TokenNameCOMMENT_LINE	save values and return length 
children	TokenNameIdentifier	 children
.	TokenNameDOT	
qname	TokenNameIdentifier	 qname
[	TokenNameLBRACKET	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
type	TokenNameIdentifier	 type
[	TokenNameLBRACKET	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Its not a leaf, so we have to recurse its left and maybe right 	TokenNameCOMMENT_LINE	Its not a leaf, so we have to recurse its left and maybe right 
// nodes. Save both values before we recurse and trash the node. 	TokenNameCOMMENT_LINE	nodes. Save both values before we recurse and trash the node. 
// 	TokenNameCOMMENT_LINE	 
final	TokenNamefinal	
int	TokenNameint	
leftNode	TokenNameIdentifier	 left Node
=	TokenNameEQUAL	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
rightNode	TokenNameIdentifier	 right Node
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
rightNode	TokenNameIdentifier	 right Node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
otherValue	TokenNameIdentifier	 other Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_CHOICE	TokenNameIdentifier	 CONTENTSPECNODE  CHOICE
||	TokenNameOR_OR	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_SEQ	TokenNameIdentifier	 CONTENTSPECNODE  SEQ
)	TokenNameRPAREN	
{	TokenNameLBRACE	
contentSpecTree	TokenNameIdentifier	 content Spec Tree
(	TokenNameLPAREN	
leftNode	TokenNameIdentifier	 left Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentSpecTree	TokenNameIdentifier	 content Spec Tree
(	TokenNameLPAREN	
rightNode	TokenNameIdentifier	 right Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_ONE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  ONE
||	TokenNameOR_OR	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ZERO_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ZERO  OR  MORE
||	TokenNameOR_OR	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XMLContentSpec	TokenNameIdentifier	 XML Content Spec
.	TokenNameDOT	
CONTENTSPECNODE_ONE_OR_MORE	TokenNameIdentifier	 CONTENTSPECNODE  ONE  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
contentSpecTree	TokenNameIdentifier	 content Spec Tree
(	TokenNameLPAREN	
leftNode	TokenNameIdentifier	 left Node
,	TokenNameCOMMA	
contentSpec	TokenNameIdentifier	 content Spec
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// error 	TokenNameCOMMENT_LINE	error 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Invalid content spec type seen in contentSpecTree() method of AbstractDTDGrammar class : "	TokenNameStringLiteral	Invalid content spec type seen in contentSpecTree() method of AbstractDTDGrammar class : 
+	TokenNamePLUS	
contentSpec	TokenNameIdentifier	 content Spec
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// contentSpecTree(int,XMLContentSpec,ChildrenList) 	TokenNameCOMMENT_LINE	contentSpecTree(int,XMLContentSpec,ChildrenList) 
// ensure capacity 	TokenNameCOMMENT_LINE	ensure capacity 
private	TokenNameprivate	
void	TokenNamevoid	
ensureElementDeclCapacity	TokenNameIdentifier	 ensure Element Decl Capacity
(	TokenNameLPAREN	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
>=	TokenNameGREATER_EQUAL	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
,	TokenNameCOMMA	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
,	TokenNameCOMMA	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
,	TokenNameCOMMA	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
,	TokenNameCOMMA	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
,	TokenNameCOMMA	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
,	TokenNameCOMMA	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
,	TokenNameCOMMA	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElementDeclIsExternal	TokenNameIdentifier	 f Element Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclName	TokenNameIdentifier	 f Element Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclType	TokenNameIdentifier	 f Element Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclContentModelValidator	TokenNameIdentifier	 f Element Decl Content Model Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclContentSpecIndex	TokenNameIdentifier	 f Element Decl Content Spec Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclFirstAttributeDeclIndex	TokenNameIdentifier	 f Element Decl First Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElementDeclLastAttributeDeclIndex	TokenNameIdentifier	 f Element Decl Last Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ensureAttributeDeclCapacity	TokenNameIdentifier	 ensure Attribute Decl Capacity
(	TokenNameLPAREN	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
>=	TokenNameGREATER_EQUAL	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
,	TokenNameCOMMA	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
,	TokenNameCOMMA	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
,	TokenNameCOMMA	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
,	TokenNameCOMMA	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
,	TokenNameCOMMA	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
,	TokenNameCOMMA	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
,	TokenNameCOMMA	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
,	TokenNameCOMMA	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
,	TokenNameCOMMA	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fAttributeDeclIsExternal	TokenNameIdentifier	 f Attribute Decl Is External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclName	TokenNameIdentifier	 f Attribute Decl Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclType	TokenNameIdentifier	 f Attribute Decl Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclEnumeration	TokenNameIdentifier	 f Attribute Decl Enumeration
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclDefaultType	TokenNameIdentifier	 f Attribute Decl Default Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclDatatypeValidator	TokenNameIdentifier	 f Attribute Decl Datatype Validator
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclDefaultValue	TokenNameIdentifier	 f Attribute Decl Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclNonNormalizedDefaultValue	TokenNameIdentifier	 f Attribute Decl Non Normalized Default Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttributeDeclNextAttributeDeclIndex	TokenNameIdentifier	 f Attribute Decl Next Attribute Decl Index
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ensureEntityDeclCapacity	TokenNameIdentifier	 ensure Entity Decl Capacity
(	TokenNameLPAREN	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
>=	TokenNameGREATER_EQUAL	
fEntityName	TokenNameIdentifier	 f Entity Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fEntityName	TokenNameIdentifier	 f Entity Name
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityName	TokenNameIdentifier	 f Entity Name
,	TokenNameCOMMA	
fEntityName	TokenNameIdentifier	 f Entity Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityValue	TokenNameIdentifier	 f Entity Value
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityValue	TokenNameIdentifier	 f Entity Value
,	TokenNameCOMMA	
fEntityValue	TokenNameIdentifier	 f Entity Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
,	TokenNameCOMMA	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
,	TokenNameCOMMA	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
,	TokenNameCOMMA	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
,	TokenNameCOMMA	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
,	TokenNameCOMMA	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
,	TokenNameCOMMA	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fEntityName	TokenNameIdentifier	 f Entity Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityName	TokenNameIdentifier	 f Entity Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityValue	TokenNameIdentifier	 f Entity Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityPublicId	TokenNameIdentifier	 f Entity Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntitySystemId	TokenNameIdentifier	 f Entity System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityBaseSystemId	TokenNameIdentifier	 f Entity Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityIsPE	TokenNameIdentifier	 f Entity Is PE
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fEntityInExternal	TokenNameIdentifier	 f Entity In External
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ensureNotationDeclCapacity	TokenNameIdentifier	 ensure Notation Decl Capacity
(	TokenNameLPAREN	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
>=	TokenNameGREATER_EQUAL	
fNotationName	TokenNameIdentifier	 f Notation Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNotationName	TokenNameIdentifier	 f Notation Name
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fNotationName	TokenNameIdentifier	 f Notation Name
,	TokenNameCOMMA	
fNotationName	TokenNameIdentifier	 f Notation Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
,	TokenNameCOMMA	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
,	TokenNameCOMMA	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
,	TokenNameCOMMA	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fNotationName	TokenNameIdentifier	 f Notation Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fNotationName	TokenNameIdentifier	 f Notation Name
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNotationPublicId	TokenNameIdentifier	 f Notation Public Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNotationSystemId	TokenNameIdentifier	 f Notation System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNotationBaseSystemId	TokenNameIdentifier	 f Notation Base System Id
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ensureContentSpecCapacity	TokenNameIdentifier	 ensure Content Spec Capacity
(	TokenNameLPAREN	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chunk	TokenNameIdentifier	 chunk
>=	TokenNameGREATER_EQUAL	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
,	TokenNameCOMMA	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
,	TokenNameCOMMA	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
=	TokenNameEQUAL	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
,	TokenNameCOMMA	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fContentSpecType	TokenNameIdentifier	 f Content Spec Type
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fContentSpecValue	TokenNameIdentifier	 f Content Spec Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fContentSpecOtherValue	TokenNameIdentifier	 f Content Spec Other Value
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
CHUNK_SIZE	TokenNameIdentifier	 CHUNK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Private static methods 	TokenNameCOMMENT_LINE	Private static methods 
// 	TokenNameCOMMENT_LINE	 
// resize chunks 	TokenNameCOMMENT_LINE	resize chunks 
private	TokenNameprivate	
static	TokenNamestatic	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
byte	TokenNamebyte	
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
short	TokenNameshort	
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
int	TokenNameint	
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DatatypeValidator	TokenNameIdentifier	 Datatype Validator
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
ContentModelValidator	TokenNameIdentifier	 Content Model Validator
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
array	TokenNameIdentifier	 array
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
int	TokenNameint	
newsize	TokenNameIdentifier	 newsize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
newarray	TokenNameIdentifier	 newarray
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
newsize	TokenNameIdentifier	 newsize
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newarray	TokenNameIdentifier	 newarray
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newarray	TokenNameIdentifier	 newarray
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Classes 	TokenNameCOMMENT_LINE	Classes 
// 	TokenNameCOMMENT_LINE	 
/** * Children list for <code>contentSpecTree</code> method. * * @xerces.internal * * @author Eric Ye, IBM */	TokenNameCOMMENT_JAVADOC	 Children list for <code>contentSpecTree</code> method. * @xerces.internal * @author Eric Ye, IBM 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ChildrenList	TokenNameIdentifier	 Children List
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Length. */	TokenNameCOMMENT_JAVADOC	 Length. 
public	TokenNamepublic	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// NOTE: The following set of data is mutually exclusive. It is 	TokenNameCOMMENT_LINE	NOTE: The following set of data is mutually exclusive. It is 
// written this way because Java doesn't have a native 	TokenNameCOMMENT_LINE	written this way because Java doesn't have a native 
// union data structure. -Ac 	TokenNameCOMMENT_LINE	union data structure. -Ac 
/** Left and right children names. */	TokenNameCOMMENT_JAVADOC	 Left and right children names. 
public	TokenNamepublic	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Left and right children types. */	TokenNameCOMMENT_JAVADOC	 Left and right children types. 
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
public	TokenNamepublic	
ChildrenList	TokenNameIdentifier	 Children List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class ChildrenList 	TokenNameCOMMENT_LINE	class ChildrenList 
// 	TokenNameCOMMENT_LINE	 
// Classes 	TokenNameCOMMENT_LINE	Classes 
// 	TokenNameCOMMENT_LINE	 
/** * A simple Hashtable implementation that takes a tuple (String, String) * as the key and a int as value. * * @xerces.internal * * @author Eric Ye, IBM * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 A simple Hashtable implementation that takes a tuple (String, String) as the key and a int as value. * @xerces.internal * @author Eric Ye, IBM @author Andy Clark, IBM 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
QNameHashtable	TokenNameIdentifier	 Q Name Hashtable
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
/** Initial bucket size (4). */	TokenNameCOMMENT_JAVADOC	 Initial bucket size (4). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INITIAL_BUCKET_SIZE	TokenNameIdentifier	 INITIAL  BUCKET  SIZE
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// NOTE: Changed previous hashtable size from 512 to 101 so 	TokenNameCOMMENT_LINE	NOTE: Changed previous hashtable size from 512 to 101 so 
// that we get a better distribution for hashing. -Ac 	TokenNameCOMMENT_LINE	that we get a better distribution for hashing. -Ac 
/** Hashtable size (101). */	TokenNameCOMMENT_JAVADOC	 Hashtable size (101). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
HASHTABLE_SIZE	TokenNameIdentifier	 HASHTABLE  SIZE
=	TokenNameEQUAL	
101	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fHashTable	TokenNameIdentifier	 f Hash Table
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
HASHTABLE_SIZE	TokenNameIdentifier	 HASHTABLE  SIZE
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
/** Associates the given value with the specified key tuple. */	TokenNameCOMMENT_JAVADOC	 Associates the given value with the specified key tuple. 
public	TokenNamepublic	
void	TokenNamevoid	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
int	TokenNameint	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0x7FFFFFFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
HASHTABLE_SIZE	TokenNameIdentifier	 HASHTABLE  SIZE
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bucket	TokenNameIdentifier	 bucket
=	TokenNameEQUAL	
fHashTable	TokenNameIdentifier	 f Hash Table
[	TokenNameLBRACKET	
hash	TokenNameIdentifier	 hash
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bucket	TokenNameIdentifier	 bucket
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bucket	TokenNameIdentifier	 bucket
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
INITIAL_BUCKET_SIZE	TokenNameIdentifier	 INITIAL  BUCKET  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
fHashTable	TokenNameIdentifier	 f Hash Table
[	TokenNameLBRACKET	
hash	TokenNameIdentifier	 hash
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bucket	TokenNameIdentifier	 bucket
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
==	TokenNameEQUAL_EQUAL	
bucket	TokenNameIdentifier	 bucket
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
INITIAL_BUCKET_SIZE	TokenNameIdentifier	 INITIAL  BUCKET  SIZE
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newBucket	TokenNameIdentifier	 new Bucket
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
bucket	TokenNameIdentifier	 bucket
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newBucket	TokenNameIdentifier	 new Bucket
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bucket	TokenNameIdentifier	 bucket
=	TokenNameEQUAL	
newBucket	TokenNameIdentifier	 new Bucket
;	TokenNameSEMICOLON	
fHashTable	TokenNameIdentifier	 f Hash Table
[	TokenNameLBRACKET	
hash	TokenNameIdentifier	 hash
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bucket	TokenNameIdentifier	 bucket
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
j	TokenNameIdentifier	 j
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
found	TokenNameIdentifier	 found
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
++	TokenNamePLUS_PLUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//System.out.println("put("+key+" -> "+value+')'); 	TokenNameCOMMENT_LINE	System.out.println("put("+key+" -> "+value+')'); 
//System.out.println("get("+key+") -> "+get(key)); 	TokenNameCOMMENT_LINE	System.out.println("get("+key+") -> "+get(key)); 
}	TokenNameRBRACE	
// put(int,String,String,int) 	TokenNameCOMMENT_LINE	put(int,String,String,int) 
/** Returns the value associated with the specified key tuple. */	TokenNameCOMMENT_JAVADOC	 Returns the value associated with the specified key tuple. 
public	TokenNamepublic	
int	TokenNameint	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0x7FFFFFFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
HASHTABLE_SIZE	TokenNameIdentifier	 HASHTABLE  SIZE
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bucket	TokenNameIdentifier	 bucket
=	TokenNameEQUAL	
fHashTable	TokenNameIdentifier	 f Hash Table
[	TokenNameLBRACKET	
hash	TokenNameIdentifier	 hash
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bucket	TokenNameIdentifier	 bucket
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
bucket	TokenNameIdentifier	 bucket
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
j	TokenNameIdentifier	 j
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get(int,String,String) 	TokenNameCOMMENT_LINE	get(int,String,String) 
}	TokenNameRBRACE	
// class QNameHashtable 	TokenNameCOMMENT_LINE	class QNameHashtable 
// 	TokenNameCOMMENT_LINE	 
// EntityState methods 	TokenNameCOMMENT_LINE	EntityState methods 
// 	TokenNameCOMMENT_LINE	 
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityDeclared	TokenNameIdentifier	 is Entity Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
true	TokenNametrue	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityUnparsed	TokenNameIdentifier	 is Entity Unparsed
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
entityIndex	TokenNameIdentifier	 entity Index
=	TokenNameEQUAL	
getEntityDeclIndex	TokenNameIdentifier	 get Entity Decl Index
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
entityIndex	TokenNameIdentifier	 entity Index
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
chunk	TokenNameIdentifier	 chunk
=	TokenNameEQUAL	
entityIndex	TokenNameIdentifier	 entity Index
>>	TokenNameRIGHT_SHIFT	
CHUNK_SHIFT	TokenNameIdentifier	 CHUNK  SHIFT
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
entityIndex	TokenNameIdentifier	 entity Index
&	TokenNameAND	
CHUNK_MASK	TokenNameIdentifier	 CHUNK  MASK
;	TokenNameSEMICOLON	
//for unparsed entity notation!=null 	TokenNameCOMMENT_LINE	for unparsed entity notation!=null 
return	TokenNamereturn	
(	TokenNameLPAREN	
fEntityNotation	TokenNameIdentifier	 f Entity Notation
[	TokenNameLBRACKET	
chunk	TokenNameIdentifier	 chunk
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
true	TokenNametrue	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class DTDGrammar 	TokenNameCOMMENT_LINE	class DTDGrammar 
