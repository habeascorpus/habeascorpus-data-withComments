package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexInput	TokenNameIdentifier	 Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexOutput	TokenNameIdentifier	 Index Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
ChecksumIndexOutput	TokenNameIdentifier	 Checksum Index Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
ChecksumIndexInput	TokenNameIdentifier	 Checksum Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
NoSuchDirectoryException	TokenNameIdentifier	 No Such Directory Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IOUtils	TokenNameIdentifier	 IO Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileNotFoundException	TokenNameIdentifier	 File Not Found Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collection	TokenNameIdentifier	 Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
/** * A collection of segmentInfo objects with methods for operating on * those segments in relation to the file system. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 A collection of segmentInfo objects with methods for operating on those segments in relation to the file system. * @lucene.experimental 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
SegmentInfos	TokenNameIdentifier	 Segment Infos
implements	TokenNameimplements	
Cloneable	TokenNameIdentifier	 Cloneable
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
{	TokenNameLBRACE	
/** The file format version, a negative number. */	TokenNameCOMMENT_JAVADOC	 The file format version, a negative number. 
/* Works since counter, the old 1st entry, is always >= 0 */	TokenNameCOMMENT_BLOCK	 Works since counter, the old 1st entry, is always >= 0 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT	TokenNameIdentifier	 FORMAT
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds details used for lockless commits. It differs * slightly from the previous format in that file names * are never re-used (write once). Instead, each file is * written to the next generation. For example, * segments_1, segments_2, etc. This allows us to not use * a commit lock. See <a * href="http://lucene.apache.org/java/docs/fileformats.html">file * formats</a> for details. */	TokenNameCOMMENT_JAVADOC	 This format adds details used for lockless commits. It differs slightly from the previous format in that file names are never re-used (write once). Instead, each file is written to the next generation. For example, segments_1, segments_2, etc. This allows us to not use a commit lock. See <a href="http://lucene.apache.org/java/docs/fileformats.html">file formats</a> for details. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
=	TokenNameEQUAL	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds a "hasSingleNormFile" flag into each segment info. * See <a href="http://issues.apache.org/jira/browse/LUCENE-756">LUCENE-756</a> * for details. */	TokenNameCOMMENT_JAVADOC	 This format adds a "hasSingleNormFile" flag into each segment info. See <a href="http://issues.apache.org/jira/browse/LUCENE-756">LUCENE-756</a> for details. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_SINGLE_NORM_FILE	TokenNameIdentifier	 FORMAT  SINGLE  NORM  FILE
=	TokenNameEQUAL	
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format allows multiple segments to share a single * vectors and stored fields file. */	TokenNameCOMMENT_JAVADOC	 This format allows multiple segments to share a single vectors and stored fields file. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_SHARED_DOC_STORE	TokenNameIdentifier	 FORMAT  SHARED  DOC  STORE
=	TokenNameEQUAL	
-	TokenNameMINUS	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds a checksum at the end of the file to * ensure all bytes were successfully written. */	TokenNameCOMMENT_JAVADOC	 This format adds a checksum at the end of the file to ensure all bytes were successfully written. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_CHECKSUM	TokenNameIdentifier	 FORMAT  CHECKSUM
=	TokenNameEQUAL	
-	TokenNameMINUS	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds the deletion count for each segment. * This way IndexWriter can efficiently report numDocs(). */	TokenNameCOMMENT_JAVADOC	 This format adds the deletion count for each segment. This way IndexWriter can efficiently report numDocs(). 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_DEL_COUNT	TokenNameIdentifier	 FORMAT  DEL  COUNT
=	TokenNameEQUAL	
-	TokenNameMINUS	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds the boolean hasProx to record if any * fields in the segment store prox information (ie, have * omitTermFreqAndPositions==false) */	TokenNameCOMMENT_JAVADOC	 This format adds the boolean hasProx to record if any fields in the segment store prox information (ie, have omitTermFreqAndPositions==false) 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_HAS_PROX	TokenNameIdentifier	 FORMAT  HAS  PROX
=	TokenNameEQUAL	
-	TokenNameMINUS	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds optional commit userData (String) storage. */	TokenNameCOMMENT_JAVADOC	 This format adds optional commit userData (String) storage. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_USER_DATA	TokenNameIdentifier	 FORMAT  USER  DATA
=	TokenNameEQUAL	
-	TokenNameMINUS	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** This format adds optional per-segment String * diagnostics storage, and switches userData to Map */	TokenNameCOMMENT_JAVADOC	 This format adds optional per-segment String diagnostics storage, and switches userData to Map 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_DIAGNOSTICS	TokenNameIdentifier	 FORMAT  DIAGNOSTICS
=	TokenNameEQUAL	
-	TokenNameMINUS	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Each segment records whether it has term vectors */	TokenNameCOMMENT_JAVADOC	 Each segment records whether it has term vectors 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_HAS_VECTORS	TokenNameIdentifier	 FORMAT  HAS  VECTORS
=	TokenNameEQUAL	
-	TokenNameMINUS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Each segment records the Lucene version that created it. */	TokenNameCOMMENT_JAVADOC	 Each segment records the Lucene version that created it. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_3_1	TokenNameIdentifier	 FORMAT 3 1
=	TokenNameEQUAL	
-	TokenNameMINUS	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* This must always point to the most recent file format. */	TokenNameCOMMENT_BLOCK	 This must always point to the most recent file format. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CURRENT_FORMAT	TokenNameIdentifier	 CURRENT  FORMAT
=	TokenNameEQUAL	
FORMAT_3_1	TokenNameIdentifier	 FORMAT 3 1
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_MINIMUM	TokenNameIdentifier	 FORMAT  MINIMUM
=	TokenNameEQUAL	
FORMAT	TokenNameIdentifier	 FORMAT
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FORMAT_MAXIMUM	TokenNameIdentifier	 FORMAT  MAXIMUM
=	TokenNameEQUAL	
CURRENT_FORMAT	TokenNameIdentifier	 CURRENT  FORMAT
;	TokenNameSEMICOLON	
public	TokenNamepublic	
int	TokenNameint	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// used to name new segments 	TokenNameCOMMENT_LINE	used to name new segments 
/** * counts how often the index has been changed by adding or deleting docs. * starting with the current time in milliseconds forces to create unique version numbers. */	TokenNameCOMMENT_JAVADOC	 counts how often the index has been changed by adding or deleting docs. starting with the current time in milliseconds forces to create unique version numbers. 
long	TokenNamelong	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
long	TokenNamelong	
generation	TokenNameIdentifier	 generation
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// generation of the "segments_N" for the next commit 	TokenNameCOMMENT_LINE	generation of the "segments_N" for the next commit 
private	TokenNameprivate	
long	TokenNamelong	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// generation of the "segments_N" file we last successfully read 	TokenNameCOMMENT_LINE	generation of the "segments_N" file we last successfully read 
// or wrote; this is normally the same as generation except if 	TokenNameCOMMENT_LINE	or wrote; this is normally the same as generation except if 
// there was an IOException that had interrupted a commit 	TokenNameCOMMENT_LINE	there was an IOException that had interrupted a commit 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
emptyMap	TokenNameIdentifier	 empty Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Opaque Map<String, String> that user can specify during IndexWriter.commit 	TokenNameCOMMENT_LINE	Opaque Map<String, String> that user can specify during IndexWriter.commit 
private	TokenNameprivate	
int	TokenNameint	
format	TokenNameIdentifier	 format
;	TokenNameSEMICOLON	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
segments	TokenNameIdentifier	 segments
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
segmentSet	TokenNameIdentifier	 segment Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
transient	TokenNametransient	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
cachedUnmodifiableList	TokenNameIdentifier	 cached Unmodifiable List
;	TokenNameSEMICOLON	
private	TokenNameprivate	
transient	TokenNametransient	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
cachedUnmodifiableSet	TokenNameIdentifier	 cached Unmodifiable Set
;	TokenNameSEMICOLON	
/** * If non-null, information about loading segments_N files * will be printed here. @see #setInfoStream. */	TokenNameCOMMENT_JAVADOC	 If non-null, information about loading segments_N files will be printed here. @see #setInfoStream. 
private	TokenNameprivate	
static	TokenNamestatic	
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
setFormat	TokenNameIdentifier	 set Format
(	TokenNameLPAREN	
int	TokenNameint	
format	TokenNameIdentifier	 format
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
format	TokenNameIdentifier	 format
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getFormat	TokenNameIdentifier	 get Format
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
format	TokenNameIdentifier	 format
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the generation of the most recent commit to the * list of index files (N in the segments_N file). * * @param files -- array of file names to check */	TokenNameCOMMENT_JAVADOC	 Get the generation of the most recent commit to the list of index files (N in the segments_N file). * @param files -- array of file names to check 
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
files	TokenNameIdentifier	 files
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
generationFromSegmentsFileName	TokenNameIdentifier	 generation From Segments File Name
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
gen	TokenNameIdentifier	 gen
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the generation of the most recent commit to the * index in this directory (N in the segments_N file). * * @param directory -- directory to search for the latest segments_N file */	TokenNameCOMMENT_JAVADOC	 Get the generation of the most recent commit to the index in this directory (N in the segments_N file). * @param directory -- directory to search for the latest segments_N file 
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
listAll	TokenNameIdentifier	 list All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NoSuchDirectoryException	TokenNameIdentifier	 No Such Directory Exception
nsde	TokenNameIdentifier	 nsde
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the filename of the segments_N file for the most * recent commit in the list of index files. * * @param files -- array of file names to check */	TokenNameCOMMENT_JAVADOC	 Get the filename of the segments_N file for the most recent commit in the list of index files. * @param files -- array of file names to check 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getLastCommitSegmentsFileName	TokenNameIdentifier	 get Last Commit Segments File Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the filename of the segments_N file for the most * recent commit to the index in this Directory. * * @param directory -- directory to search for the latest segments_N file */	TokenNameCOMMENT_JAVADOC	 Get the filename of the segments_N file for the most recent commit to the index in this Directory. * @param directory -- directory to search for the latest segments_N file 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getLastCommitSegmentsFileName	TokenNameIdentifier	 get Last Commit Segments File Name
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the segments_N filename in use by this segment infos. */	TokenNameCOMMENT_JAVADOC	 Get the segments_N filename in use by this segment infos. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
lastGeneration	TokenNameIdentifier	 last Generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Parse the generation off the segments file name and * return it. */	TokenNameCOMMENT_JAVADOC	 Parse the generation off the segments file name and return it. 
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
generationFromSegmentsFileName	TokenNameIdentifier	 generation From Segments File Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
parseLong	TokenNameIdentifier	 parse Long
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
MAX_RADIX	TokenNameIdentifier	 MAX  RADIX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"fileName ""	TokenNameStringLiteral	fileName "
+	TokenNamePLUS	
fileName	TokenNameIdentifier	 file Name
+	TokenNamePLUS	
"" is not a segments file"	TokenNameStringLiteral	" is not a segments file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the next segments_N filename that will be written. */	TokenNameCOMMENT_JAVADOC	 Get the next segments_N filename that will be written. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNextSegmentFileName	TokenNameIdentifier	 get Next Segment File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
nextGeneration	TokenNameIdentifier	 next Generation
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
generation	TokenNameIdentifier	 generation
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextGeneration	TokenNameIdentifier	 next Generation
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
nextGeneration	TokenNameIdentifier	 next Generation
=	TokenNameEQUAL	
generation	TokenNameIdentifier	 generation
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
nextGeneration	TokenNameIdentifier	 next Generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Read a particular segmentFileName. Note that this may * throw an IOException if a commit is in process. * * @param directory -- directory containing the segments file * @param segmentFileName -- segment file to load * @throws CorruptIndexException if the index is corrupt * @throws IOException if there is a low-level IO error */	TokenNameCOMMENT_JAVADOC	 Read a particular segmentFileName. Note that this may throw an IOException if a commit is in process. * @param directory -- directory containing the segments file @param segmentFileName -- segment file to load @throws CorruptIndexException if the index is corrupt @throws IOException if there is a low-level IO error 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Clear any previous segments: 	TokenNameCOMMENT_LINE	Clear any previous segments: 
this	TokenNamethis	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChecksumIndexInput	TokenNameIdentifier	 Checksum Index Input
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
new	TokenNamenew	
ChecksumIndexInput	TokenNameIdentifier	 Checksum Index Input
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
generation	TokenNameIdentifier	 generation
=	TokenNameEQUAL	
generationFromSegmentsFileName	TokenNameIdentifier	 generation From Segments File Name
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
generation	TokenNameIdentifier	 generation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check that it is a format we can understand 	TokenNameCOMMENT_LINE	check that it is a format we can understand 
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>	TokenNameGREATER	
FORMAT_MINIMUM	TokenNameIdentifier	 FORMAT  MINIMUM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IndexFormatTooOldException	TokenNameIdentifier	 Index Format Too Old Exception
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
FORMAT_MINIMUM	TokenNameIdentifier	 FORMAT  MINIMUM
,	TokenNameCOMMA	
FORMAT_MAXIMUM	TokenNameIdentifier	 FORMAT  MAXIMUM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<	TokenNameLESS	
FORMAT_MAXIMUM	TokenNameIdentifier	 FORMAT  MAXIMUM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IndexFormatTooNewException	TokenNameIdentifier	 Index Format Too New Exception
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
FORMAT_MINIMUM	TokenNameIdentifier	 FORMAT  MINIMUM
,	TokenNameCOMMA	
FORMAT_MAXIMUM	TokenNameIdentifier	 FORMAT  MAXIMUM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// read version 	TokenNameCOMMENT_LINE	read version 
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// read counter 	TokenNameCOMMENT_LINE	read counter 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// read segmentInfos 	TokenNameCOMMENT_LINE	read segmentInfos 
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentInfo	TokenNameIdentifier	 Segment Info
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// It's a pre-3.1 segment, upgrade its version to either 3.0 or 2.x 	TokenNameCOMMENT_LINE	It's a pre-3.1 segment, upgrade its version to either 3.0 or 2.x 
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getDocStoreOffset	TokenNameIdentifier	 get Doc Store Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getDocStoreIsCompoundFile	TokenNameIdentifier	 get Doc Store Is Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
CompoundFileReader	TokenNameIdentifier	 Compound File Reader
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getDocStoreSegment	TokenNameIdentifier	 get Doc Store Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
COMPOUND_FILE_STORE_EXTENSION	TokenNameIdentifier	 COMPOUND  FILE  STORE  EXTENSION
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1024	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getUseCompoundFile	TokenNameIdentifier	 get Use Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
CompoundFileReader	TokenNameIdentifier	 Compound File Reader
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
COMPOUND_FILE_EXTENSION	TokenNameIdentifier	 COMPOUND  FILE  EXTENSION
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1024	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
store	TokenNameIdentifier	 store
=	TokenNameEQUAL	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getDocStoreOffset	TokenNameIdentifier	 get Doc Store Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getDocStoreSegment	TokenNameIdentifier	 get Doc Store Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
setVersion	TokenNameIdentifier	 set Version
(	TokenNameLPAREN	
FieldsReader	TokenNameIdentifier	 Fields Reader
.	TokenNameDOT	
detectCodeVersion	TokenNameIdentifier	 detect Code Version
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// If we opened the directory, close it 	TokenNameCOMMENT_LINE	If we opened the directory, close it 
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
!=	TokenNameNOT_EQUAL	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// in old format the version number may be at the end of the file 	TokenNameCOMMENT_LINE	in old format the version number may be at the end of the file 
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// old file format without version number 	TokenNameCOMMENT_LINE	old file format without version number 
else	TokenNameelse	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// read version 	TokenNameCOMMENT_LINE	read version 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<=	TokenNameLESS_EQUAL	
FORMAT_USER_DATA	TokenNameIdentifier	 FORMAT  USER  DATA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<=	TokenNameLESS_EQUAL	
FORMAT_DIAGNOSTICS	TokenNameIdentifier	 FORMAT  DIAGNOSTICS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readStringStringMap	TokenNameIdentifier	 read String String Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readByte	TokenNameIdentifier	 read Byte
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonMap	TokenNameIdentifier	 singleton Map
(	TokenNameLPAREN	
"userData"	TokenNameStringLiteral	userData
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readString	TokenNameIdentifier	 read String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
emptyMap	TokenNameIdentifier	 empty Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
emptyMap	TokenNameIdentifier	 empty Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<=	TokenNameLESS_EQUAL	
FORMAT_CHECKSUM	TokenNameIdentifier	 FORMAT  CHECKSUM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
long	TokenNamelong	
checksumNow	TokenNameIdentifier	 checksum Now
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
getChecksum	TokenNameIdentifier	 get Checksum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
checksumThen	TokenNameIdentifier	 checksum Then
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
checksumNow	TokenNameIdentifier	 checksum Now
!=	TokenNameNOT_EQUAL	
checksumThen	TokenNameIdentifier	 checksum Then
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
(	TokenNameLPAREN	
"checksum mismatch in segments file (resource: "	TokenNameStringLiteral	checksum mismatch in segments file (resource: 
+	TokenNamePLUS	
input	TokenNameIdentifier	 input
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Clear any segment infos we had loaded so we 	TokenNameCOMMENT_LINE	Clear any segment infos we had loaded so we 
// have a clean slate on retry: 	TokenNameCOMMENT_LINE	have a clean slate on retry: 
this	TokenNamethis	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * This version of read uses the retry logic (for lock-less * commits) to find the right segments file to load. * @throws CorruptIndexException if the index is corrupt * @throws IOException if there is a low-level IO error */	TokenNameCOMMENT_JAVADOC	 This version of read uses the retry logic (for lock-less commits) to find the right segments file to load. @throws CorruptIndexException if the index is corrupt @throws IOException if there is a low-level IO error 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
generation	TokenNameIdentifier	 generation
=	TokenNameEQUAL	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
new	TokenNamenew	
FindSegmentsFile	TokenNameIdentifier	 Find Segments File
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
doBody	TokenNameIdentifier	 do Body
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Only non-null after prepareCommit has been called and 	TokenNameCOMMENT_LINE	Only non-null after prepareCommit has been called and 
// before finishCommit is called 	TokenNameCOMMENT_LINE	before finishCommit is called 
ChecksumIndexOutput	TokenNameIdentifier	 Checksum Index Output
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
=	TokenNameEQUAL	
getNextSegmentFileName	TokenNameIdentifier	 get Next Segment File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Always advance the generation on write: 	TokenNameCOMMENT_LINE	Always advance the generation on write: 
if	TokenNameif	
(	TokenNameLPAREN	
generation	TokenNameIdentifier	 generation
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
generation	TokenNameIdentifier	 generation
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
generation	TokenNameIdentifier	 generation
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ChecksumIndexOutput	TokenNameIdentifier	 Checksum Index Output
segnOutput	TokenNameIdentifier	 segn Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
segnOutput	TokenNameIdentifier	 segn Output
=	TokenNameEQUAL	
new	TokenNamenew	
ChecksumIndexOutput	TokenNameIdentifier	 Checksum Index Output
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
createOutput	TokenNameIdentifier	 create Output
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
CURRENT_FORMAT	TokenNameIdentifier	 CURRENT  FORMAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write FORMAT 	TokenNameCOMMENT_LINE	write FORMAT 
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
counter	TokenNameIdentifier	 counter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write counter 	TokenNameCOMMENT_LINE	write counter 
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write infos 	TokenNameCOMMENT_LINE	write infos 
for	TokenNamefor	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
:	TokenNameCOLON	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
segnOutput	TokenNameIdentifier	 segn Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
writeStringStringMap	TokenNameIdentifier	 write String String Map
(	TokenNameLPAREN	
userData	TokenNameIdentifier	 user Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segnOutput	TokenNameIdentifier	 segn Output
.	TokenNameDOT	
prepareCommit	TokenNameIdentifier	 prepare Commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
=	TokenNameEQUAL	
segnOutput	TokenNameIdentifier	 segn Output
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We hit an exception above; try to close the file 	TokenNameCOMMENT_LINE	We hit an exception above; try to close the file 
// but suppress any exception: 	TokenNameCOMMENT_LINE	but suppress any exception: 
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
closeWhileHandlingException	TokenNameIdentifier	 close While Handling Exception
(	TokenNameLPAREN	
segnOutput	TokenNameIdentifier	 segn Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Try not to leave a truncated segments_N file in 	TokenNameCOMMENT_LINE	Try not to leave a truncated segments_N file in 
// the index: 	TokenNameCOMMENT_LINE	the index: 
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Suppress so we keep throwing the original exception 	TokenNameCOMMENT_LINE	Suppress so we keep throwing the original exception 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Prunes any segment whose docs are all deleted. */	TokenNameCOMMENT_JAVADOC	 Prunes any segment whose docs are all deleted. 
public	TokenNamepublic	
void	TokenNamevoid	
pruneDeletedSegments	TokenNameIdentifier	 prune Deleted Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assert	TokenNameassert	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a copy of this instance, also copying each * SegmentInfo. */	TokenNameCOMMENT_JAVADOC	 Returns a copy of this instance, also copying each SegmentInfo. 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
SegmentInfos	TokenNameIdentifier	 Segment Infos
sis	TokenNameIdentifier	 sis
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SegmentInfos	TokenNameIdentifier	 Segment Infos
)	TokenNameRPAREN	
super	TokenNamesuper	
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// deep clone, first recreate all collections: 	TokenNameCOMMENT_LINE	deep clone, first recreate all collections: 
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
segments	TokenNameIdentifier	 segments
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
segmentSet	TokenNameIdentifier	 segment Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
cachedUnmodifiableList	TokenNameIdentifier	 cached Unmodifiable List
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
cachedUnmodifiableSet	TokenNameIdentifier	 cached Unmodifiable Set
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
:	TokenNameCOLON	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// dont directly access segments, use add method!!! 	TokenNameCOMMENT_LINE	dont directly access segments, use add method!!! 
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
)	TokenNameRPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
userData	TokenNameIdentifier	 user Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sis	TokenNameIdentifier	 sis
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
CloneNotSupportedException	TokenNameIdentifier	 Clone Not Supported Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"should not happen"	TokenNameStringLiteral	should not happen
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * version number when this SegmentInfos was generated. */	TokenNameCOMMENT_JAVADOC	 version number when this SegmentInfos was generated. 
public	TokenNamepublic	
long	TokenNamelong	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
version	TokenNameIdentifier	 version
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getGeneration	TokenNameIdentifier	 get Generation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
generation	TokenNameIdentifier	 generation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getLastGeneration	TokenNameIdentifier	 get Last Generation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lastGeneration	TokenNameIdentifier	 last Generation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Current version number from segments file. * @throws CorruptIndexException if the index is corrupt * @throws IOException if there is a low-level IO error * @deprecated Load the SegmentInfos and then call {@link * #getVersion}. */	TokenNameCOMMENT_JAVADOC	 Current version number from segments file. @throws CorruptIndexException if the index is corrupt @throws IOException if there is a low-level IO error @deprecated Load the SegmentInfos and then call {@link #getVersion}. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
readCurrentVersion	TokenNameIdentifier	 read Current Version
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Fully read the segments file: this ensures that it's 	TokenNameCOMMENT_LINE	Fully read the segments file: this ensures that it's 
// completely written so that if 	TokenNameCOMMENT_LINE	completely written so that if 
// IndexWriter.prepareCommit has been called (but not 	TokenNameCOMMENT_LINE	IndexWriter.prepareCommit has been called (but not 
// yet commit), then the reader will still see itself as 	TokenNameCOMMENT_LINE	yet commit), then the reader will still see itself as 
// current: 	TokenNameCOMMENT_LINE	current: 
SegmentInfos	TokenNameIdentifier	 Segment Infos
sis	TokenNameIdentifier	 sis
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentInfos	TokenNameIdentifier	 Segment Infos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
version	TokenNameIdentifier	 version
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** If non-null, information about retries when loading * the segments file will be printed to this. */	TokenNameCOMMENT_JAVADOC	 If non-null, information about retries when loading the segments file will be printed to this. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Advanced configuration of retry logic in loading segments_N file */	TokenNameCOMMENT_BLOCK	 Advanced configuration of retry logic in loading segments_N file 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
defaultGenLookaheadCount	TokenNameIdentifier	 default Gen Lookahead Count
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Advanced: set how many times to try incrementing the * gen when loading the segments file. This only runs if * the primary (listing directory) and secondary (opening * segments.gen file) methods fail to find the segments * file. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Advanced: set how many times to try incrementing the gen when loading the segments file. This only runs if the primary (listing directory) and secondary (opening segments.gen file) methods fail to find the segments file. * @lucene.experimental 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
setDefaultGenLookaheadCount	TokenNameIdentifier	 set Default Gen Lookahead Count
(	TokenNameLPAREN	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultGenLookaheadCount	TokenNameIdentifier	 default Gen Lookahead Count
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setDefaultGenLookaheadCount * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 @see #setDefaultGenLookaheadCount * @lucene.experimental 
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
getDefaultGenLookahedCount	TokenNameIdentifier	 get Default Gen Lookahed Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
defaultGenLookaheadCount	TokenNameIdentifier	 default Gen Lookahead Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setInfoStream */	TokenNameCOMMENT_JAVADOC	 @see #setInfoStream 
public	TokenNamepublic	
static	TokenNamestatic	
PrintStream	TokenNameIdentifier	 Print Stream
getInfoStream	TokenNameIdentifier	 get Info Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Prints the given message to the infoStream. Note, this method does not * check for null infoStream. It assumes this check has been performed by the * caller, which is recommended to avoid the (usually) expensive message * creation. */	TokenNameCOMMENT_JAVADOC	 Prints the given message to the infoStream. Note, this method does not check for null infoStream. It assumes this check has been performed by the caller, which is recommended to avoid the (usually) expensive message creation. 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"SIS ["	TokenNameStringLiteral	SIS [
+	TokenNamePLUS	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]: "	TokenNameStringLiteral	]: 
+	TokenNamePLUS	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Utility class for executing code that needs to do * something with the current segments file. This is * necessary with lock-less commits because from the time * you locate the current segments file name, until you * actually open it, read its contents, or check modified * time, etc., it could have been deleted due to a writer * commit finishing. */	TokenNameCOMMENT_JAVADOC	 Utility class for executing code that needs to do something with the current segments file. This is necessary with lock-less commits because from the time you locate the current segments file name, until you actually open it, read its contents, or check modified time, etc., it could have been deleted due to a writer commit finishing. 
public	TokenNamepublic	
abstract	TokenNameabstract	
static	TokenNamestatic	
class	TokenNameclass	
FindSegmentsFile	TokenNameIdentifier	 Find Segments File
{	TokenNameLBRACE	
final	TokenNamefinal	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
public	TokenNamepublic	
FindSegmentsFile	TokenNameIdentifier	 Find Segments File
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
IndexCommit	TokenNameIdentifier	 Index Commit
commit	TokenNameIdentifier	 commit
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
commit	TokenNameIdentifier	 commit
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
!=	TokenNameNOT_EQUAL	
commit	TokenNameIdentifier	 commit
.	TokenNameDOT	
getDirectory	TokenNameIdentifier	 get Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"the specified commit does not match the specified Directory"	TokenNameStringLiteral	the specified commit does not match the specified Directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
doBody	TokenNameIdentifier	 do Body
(	TokenNameLPAREN	
commit	TokenNameIdentifier	 commit
.	TokenNameDOT	
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
long	TokenNamelong	
lastGen	TokenNameIdentifier	 last Gen
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
genLookaheadCount	TokenNameIdentifier	 gen Lookahead Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
IOException	TokenNameIdentifier	 IO Exception
exc	TokenNameIdentifier	 exc
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
retryCount	TokenNameIdentifier	 retry Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
useFirstMethod	TokenNameIdentifier	 use First Method
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Loop until we succeed in calling doBody() without 	TokenNameCOMMENT_LINE	Loop until we succeed in calling doBody() without 
// hitting an IOException. An IOException most likely 	TokenNameCOMMENT_LINE	hitting an IOException. An IOException most likely 
// means a commit was in process and has finished, in 	TokenNameCOMMENT_LINE	means a commit was in process and has finished, in 
// the time it took us to load the now-old infos files 	TokenNameCOMMENT_LINE	the time it took us to load the now-old infos files 
// (and segments files). It's also possible it's a 	TokenNameCOMMENT_LINE	(and segments files). It's also possible it's a 
// true error (corrupt index). To distinguish these, 	TokenNameCOMMENT_LINE	true error (corrupt index). To distinguish these, 
// on each retry we must see "forward progress" on 	TokenNameCOMMENT_LINE	on each retry we must see "forward progress" on 
// which generation we are trying to load. If we 	TokenNameCOMMENT_LINE	which generation we are trying to load. If we 
// don't, then the original error is real and we throw 	TokenNameCOMMENT_LINE	don't, then the original error is real and we throw 
// it. 	TokenNameCOMMENT_LINE	it. 
// We have three methods for determining the current 	TokenNameCOMMENT_LINE	We have three methods for determining the current 
// generation. We try the first two in parallel (when 	TokenNameCOMMENT_LINE	generation. We try the first two in parallel (when 
// useFirstMethod is true), and fall back to the third 	TokenNameCOMMENT_LINE	useFirstMethod is true), and fall back to the third 
// when necessary. 	TokenNameCOMMENT_LINE	when necessary. 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useFirstMethod	TokenNameIdentifier	 use First Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// List the directory and use the highest 	TokenNameCOMMENT_LINE	List the directory and use the highest 
// segments_N file. This method works well as long 	TokenNameCOMMENT_LINE	segments_N file. This method works well as long 
// as there is no stale caching on the directory 	TokenNameCOMMENT_LINE	as there is no stale caching on the directory 
// contents (NOTE: NFS clients often have such stale 	TokenNameCOMMENT_LINE	contents (NOTE: NFS clients often have such stale 
// caching): 	TokenNameCOMMENT_LINE	caching): 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
long	TokenNamelong	
genA	TokenNameIdentifier	 gen A
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
listAll	TokenNameIdentifier	 list All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
genA	TokenNameIdentifier	 gen A
=	TokenNameEQUAL	
getLastCommitGeneration	TokenNameIdentifier	 get Last Commit Generation
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"directory listing genA="	TokenNameStringLiteral	directory listing genA=
+	TokenNamePLUS	
genA	TokenNameIdentifier	 gen A
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Also open segments.gen and read its 	TokenNameCOMMENT_LINE	Also open segments.gen and read its 
// contents. Then we take the larger of the two 	TokenNameCOMMENT_LINE	contents. Then we take the larger of the two 
// gens. This way, if either approach is hitting 	TokenNameCOMMENT_LINE	gens. This way, if either approach is hitting 
// a stale cache (NFS) we have a better chance of 	TokenNameCOMMENT_LINE	a stale cache (NFS) we have a better chance of 
// getting the right generation. 	TokenNameCOMMENT_LINE	getting the right generation. 
long	TokenNamelong	
genB	TokenNameIdentifier	 gen B
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
IndexInput	TokenNameIdentifier	 Index Input
genInput	TokenNameIdentifier	 gen Input
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
genInput	TokenNameIdentifier	 gen Input
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
FileNotFoundException	TokenNameIdentifier	 File Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"segments.gen open: FileNotFoundException "	TokenNameStringLiteral	segments.gen open: FileNotFoundException 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"segments.gen open: IOException "	TokenNameStringLiteral	segments.gen open: IOException 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
genInput	TokenNameIdentifier	 gen Input
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
genInput	TokenNameIdentifier	 gen Input
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
==	TokenNameEQUAL_EQUAL	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
gen0	TokenNameIdentifier	 gen0
=	TokenNameEQUAL	
genInput	TokenNameIdentifier	 gen Input
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
gen1	TokenNameIdentifier	 gen1
=	TokenNameEQUAL	
genInput	TokenNameIdentifier	 gen Input
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"fallback check: "	TokenNameStringLiteral	fallback check: 
+	TokenNamePLUS	
gen0	TokenNameIdentifier	 gen0
+	TokenNamePLUS	
"; "	TokenNameStringLiteral	; 
+	TokenNamePLUS	
gen1	TokenNameIdentifier	 gen1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
gen0	TokenNameIdentifier	 gen0
==	TokenNameEQUAL_EQUAL	
gen1	TokenNameIdentifier	 gen1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The file is consistent. 	TokenNameCOMMENT_LINE	The file is consistent. 
genB	TokenNameIdentifier	 gen B
=	TokenNameEQUAL	
gen0	TokenNameIdentifier	 gen0
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IndexFormatTooNewException	TokenNameIdentifier	 Index Format Too New Exception
(	TokenNameLPAREN	
genInput	TokenNameIdentifier	 gen Input
,	TokenNameCOMMA	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
,	TokenNameCOMMA	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
err2	TokenNameIdentifier	 err2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// rethrow any format exception 	TokenNameCOMMENT_LINE	rethrow any format exception 
if	TokenNameif	
(	TokenNameLPAREN	
err2	TokenNameIdentifier	 err2
instanceof	TokenNameinstanceof	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
)	TokenNameRPAREN	
throw	TokenNamethrow	
err2	TokenNameIdentifier	 err2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
genInput	TokenNameIdentifier	 gen Input
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
+	TokenNamePLUS	
" check: genB="	TokenNameStringLiteral	 check: genB=
+	TokenNamePLUS	
genB	TokenNameIdentifier	 gen B
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Pick the larger of the two gen's: 	TokenNameCOMMENT_LINE	Pick the larger of the two gen's: 
if	TokenNameif	
(	TokenNameLPAREN	
genA	TokenNameIdentifier	 gen A
>	TokenNameGREATER	
genB	TokenNameIdentifier	 gen B
)	TokenNameRPAREN	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
genA	TokenNameIdentifier	 gen A
;	TokenNameSEMICOLON	
else	TokenNameelse	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
genB	TokenNameIdentifier	 gen B
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gen	TokenNameIdentifier	 gen
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Neither approach found a generation 	TokenNameCOMMENT_LINE	Neither approach found a generation 
throw	TokenNamethrow	
new	TokenNamenew	
IndexNotFoundException	TokenNameIdentifier	 Index Not Found Exception
(	TokenNameLPAREN	
"no segments* file found in "	TokenNameStringLiteral	no segments* file found in 
+	TokenNamePLUS	
directory	TokenNameIdentifier	 directory
+	TokenNamePLUS	
": files: "	TokenNameStringLiteral	: files: 
+	TokenNamePLUS	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useFirstMethod	TokenNameIdentifier	 use First Method
&&	TokenNameAND_AND	
lastGen	TokenNameIdentifier	 last Gen
==	TokenNameEQUAL_EQUAL	
gen	TokenNameIdentifier	 gen
&&	TokenNameAND_AND	
retryCount	TokenNameIdentifier	 retry Count
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Give up on first method -- this is 3rd cycle on 	TokenNameCOMMENT_LINE	Give up on first method -- this is 3rd cycle on 
// listing directory and checking gen file to 	TokenNameCOMMENT_LINE	listing directory and checking gen file to 
// attempt to locate the segments file. 	TokenNameCOMMENT_LINE	attempt to locate the segments file. 
useFirstMethod	TokenNameIdentifier	 use First Method
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Second method: since both directory cache and 	TokenNameCOMMENT_LINE	Second method: since both directory cache and 
// file contents cache seem to be stale, just 	TokenNameCOMMENT_LINE	file contents cache seem to be stale, just 
// advance the generation. 	TokenNameCOMMENT_LINE	advance the generation. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
useFirstMethod	TokenNameIdentifier	 use First Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
genLookaheadCount	TokenNameIdentifier	 gen Lookahead Count
<	TokenNameLESS	
defaultGenLookaheadCount	TokenNameIdentifier	 default Gen Lookahead Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gen	TokenNameIdentifier	 gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
genLookaheadCount	TokenNameIdentifier	 gen Lookahead Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"look ahead increment gen to "	TokenNameStringLiteral	look ahead increment gen to 
+	TokenNamePLUS	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// All attempts have failed -- throw first exc: 	TokenNameCOMMENT_LINE	All attempts have failed -- throw first exc: 
throw	TokenNamethrow	
exc	TokenNameIdentifier	 exc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
lastGen	TokenNameIdentifier	 last Gen
==	TokenNameEQUAL_EQUAL	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This means we're about to try the same 	TokenNameCOMMENT_LINE	This means we're about to try the same 
// segments_N last tried. 	TokenNameCOMMENT_LINE	segments_N last tried. 
retryCount	TokenNameIdentifier	 retry Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Segment file has advanced since our last loop 	TokenNameCOMMENT_LINE	Segment file has advanced since our last loop 
// (we made "progress"), so reset retryCount: 	TokenNameCOMMENT_LINE	(we made "progress"), so reset retryCount: 
retryCount	TokenNameIdentifier	 retry Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastGen	TokenNameIdentifier	 last Gen
=	TokenNameEQUAL	
gen	TokenNameIdentifier	 gen
;	TokenNameSEMICOLON	
segmentFileName	TokenNameIdentifier	 segment File Name
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
doBody	TokenNameIdentifier	 do Body
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"success on "	TokenNameStringLiteral	success on 
+	TokenNamePLUS	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Save the original root cause: 	TokenNameCOMMENT_LINE	Save the original root cause: 
if	TokenNameif	
(	TokenNameLPAREN	
exc	TokenNameIdentifier	 exc
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exc	TokenNameIdentifier	 exc
=	TokenNameEQUAL	
err	TokenNameIdentifier	 err
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"primary Exception on '"	TokenNameStringLiteral	primary Exception on '
+	TokenNamePLUS	
segmentFileName	TokenNameIdentifier	 segment File Name
+	TokenNamePLUS	
"': "	TokenNameStringLiteral	': 
+	TokenNamePLUS	
err	TokenNameIdentifier	 err
+	TokenNamePLUS	
"'; will retry: retryCount="	TokenNameStringLiteral	'; will retry: retryCount=
+	TokenNamePLUS	
retryCount	TokenNameIdentifier	 retry Count
+	TokenNamePLUS	
"; gen = "	TokenNameStringLiteral	; gen = 
+	TokenNamePLUS	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
useFirstMethod	TokenNameIdentifier	 use First Method
&&	TokenNameAND_AND	
retryCount	TokenNameIdentifier	 retry Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This is our second time trying this same segments 	TokenNameCOMMENT_LINE	This is our second time trying this same segments 
// file (because retryCount is 1), and, there is 	TokenNameCOMMENT_LINE	file (because retryCount is 1), and, there is 
// possibly a segments_(N-1) (because gen > 1). 	TokenNameCOMMENT_LINE	possibly a segments_(N-1) (because gen > 1). 
// So, check if the segments_(N-1) exists and 	TokenNameCOMMENT_LINE	So, check if the segments_(N-1) exists and 
// try it if so: 	TokenNameCOMMENT_LINE	try it if so: 
String	TokenNameIdentifier	 String
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
gen	TokenNameIdentifier	 gen
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
prevExists	TokenNameIdentifier	 prev Exists
;	TokenNameSEMICOLON	
prevExists	TokenNameIdentifier	 prev Exists
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
fileExists	TokenNameIdentifier	 file Exists
(	TokenNameLPAREN	
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prevExists	TokenNameIdentifier	 prev Exists
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"fallback to prior segment file '"	TokenNameStringLiteral	fallback to prior segment file '
+	TokenNamePLUS	
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
doBody	TokenNameIdentifier	 do Body
(	TokenNameLPAREN	
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"success on fallback "	TokenNameStringLiteral	success on fallback 
+	TokenNamePLUS	
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
err2	TokenNameIdentifier	 err2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"secondary Exception on '"	TokenNameStringLiteral	secondary Exception on '
+	TokenNamePLUS	
prevSegmentFileName	TokenNameIdentifier	 prev Segment File Name
+	TokenNamePLUS	
"': "	TokenNameStringLiteral	': 
+	TokenNamePLUS	
err2	TokenNameIdentifier	 err2
+	TokenNamePLUS	
"'; will retry"	TokenNameStringLiteral	'; will retry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Subclass must implement this. The assumption is an * IOException will be thrown if something goes wrong * during the processing that could have been caused by * a writer committing. */	TokenNameCOMMENT_JAVADOC	 Subclass must implement this. The assumption is an IOException will be thrown if something goes wrong during the processing that could have been caused by a writer committing. 
protected	TokenNameprotected	
abstract	TokenNameabstract	
Object	TokenNameIdentifier	 Object
doBody	TokenNameIdentifier	 do Body
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new SegmentInfos containing the SegmentInfo * instances in the specified range first (inclusive) to * last (exclusive), so total number of segments returned * is last-first. * @deprecated use {@code asList().subList(first, last)} * instead. */	TokenNameCOMMENT_JAVADOC	 Returns a new SegmentInfos containing the SegmentInfo instances in the specified range first (inclusive) to last (exclusive), so total number of segments returned is last-first. @deprecated use {@code asList().subList(first, last)} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
SegmentInfos	TokenNameIdentifier	 Segment Infos
range	TokenNameIdentifier	 range
(	TokenNameLPAREN	
int	TokenNameint	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
int	TokenNameint	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SegmentInfos	TokenNameIdentifier	 Segment Infos
infos	TokenNameIdentifier	 infos
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentInfos	TokenNameIdentifier	 Segment Infos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
infos	TokenNameIdentifier	 infos
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
infos	TokenNameIdentifier	 infos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Carry over generation numbers from another SegmentInfos 	TokenNameCOMMENT_LINE	Carry over generation numbers from another SegmentInfos 
void	TokenNamevoid	
updateGeneration	TokenNameIdentifier	 update Generation
(	TokenNameLPAREN	
SegmentInfos	TokenNameIdentifier	 Segment Infos
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
lastGeneration	TokenNameIdentifier	 last Generation
;	TokenNameSEMICOLON	
generation	TokenNameIdentifier	 generation
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
void	TokenNamevoid	
rollbackCommit	TokenNameIdentifier	 rollback Commit
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Suppress so we keep throwing the original exception 	TokenNameCOMMENT_LINE	Suppress so we keep throwing the original exception 
// in our caller 	TokenNameCOMMENT_LINE	in our caller 
}	TokenNameRBRACE	
// Must carefully compute fileName from "generation" 	TokenNameCOMMENT_LINE	Must carefully compute fileName from "generation" 
// since lastGeneration isn't incremented: 	TokenNameCOMMENT_LINE	since lastGeneration isn't incremented: 
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Suppress so we keep throwing the original exception 	TokenNameCOMMENT_LINE	Suppress so we keep throwing the original exception 
// in our caller 	TokenNameCOMMENT_LINE	in our caller 
}	TokenNameRBRACE	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Call this to start a commit. This writes the new * segments file, but writes an invalid checksum at the * end, so that it is not visible to readers. Once this * is called you must call {@link #finishCommit} to complete * the commit or {@link #rollbackCommit} to abort it. * <p> * Note: {@link #changed()} should be called prior to this * method if changes have been made to this {@link SegmentInfos} instance * </p> **/	TokenNameCOMMENT_JAVADOC	 Call this to start a commit. This writes the new segments file, but writes an invalid checksum at the end, so that it is not visible to readers. Once this is called you must call {@link #finishCommit} to complete the commit or {@link #rollbackCommit} to abort it. <p> Note: {@link #changed()} should be called prior to this method if changes have been made to this {@link SegmentInfos} instance </p> *
final	TokenNamefinal	
void	TokenNamevoid	
prepareCommit	TokenNameIdentifier	 prepare Commit
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"prepareCommit was already called"	TokenNameStringLiteral	prepareCommit was already called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns all file names referenced by SegmentInfo * instances matching the provided Directory (ie files * associated with any "external" segments are skipped). * The returned collection is recomputed on each * invocation. */	TokenNameCOMMENT_JAVADOC	 Returns all file names referenced by SegmentInfo instances matching the provided Directory (ie files associated with any "external" segments are skipped). The returned collection is recomputed on each invocation. 
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
boolean	TokenNameboolean	
includeSegmentsFile	TokenNameIdentifier	 include Segments File
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeSegmentsFile	TokenNameIdentifier	 include Segments File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
segmentFileName	TokenNameIdentifier	 segment File Name
=	TokenNameEQUAL	
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * TODO: if lastGen == -1 we get might get null here it seems wrong to * add null to the files set */	TokenNameCOMMENT_BLOCK	 TODO: if lastGen == -1 we get might get null here it seems wrong to add null to the files set 
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
segmentFileName	TokenNameIdentifier	 segment File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
dir	TokenNameIdentifier	 dir
==	TokenNameEQUAL_EQUAL	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
void	TokenNamevoid	
finishCommit	TokenNameIdentifier	 finish Commit
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"prepareCommit was not called"	TokenNameStringLiteral	prepareCommit was not called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
.	TokenNameDOT	
finishCommit	TokenNameIdentifier	 finish Commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingSegnOutput	TokenNameIdentifier	 pending Segn Output
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
rollbackCommit	TokenNameIdentifier	 rollback Commit
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// NOTE: if we crash here, we have left a segments_N 	TokenNameCOMMENT_LINE	NOTE: if we crash here, we have left a segments_N 
// file in the directory in a possibly corrupt state (if 	TokenNameCOMMENT_LINE	file in the directory in a possibly corrupt state (if 
// some bytes made it to stable storage and others 	TokenNameCOMMENT_LINE	some bytes made it to stable storage and others 
// didn't). But, the segments_N file includes checksum 	TokenNameCOMMENT_LINE	didn't). But, the segments_N file includes checksum 
// at the end, which should catch this case. So when a 	TokenNameCOMMENT_LINE	at the end, which should catch this case. So when a 
// reader tries to read it, it will throw a 	TokenNameCOMMENT_LINE	reader tries to read it, it will throw a 
// CorruptIndexException, which should cause the retry 	TokenNameCOMMENT_LINE	CorruptIndexException, which should cause the retry 
// logic in SegmentInfos to kick in and load the last 	TokenNameCOMMENT_LINE	logic in SegmentInfos to kick in and load the last 
// good (previous) segments_N-1 file. 	TokenNameCOMMENT_LINE	good (previous) segments_N-1 file. 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
fileNameFromGeneration	TokenNameIdentifier	 file Name From Generation
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS	TokenNameIdentifier	 SEGMENTS
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
sync	TokenNameIdentifier	 sync
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Suppress so we keep throwing the original exception 	TokenNameCOMMENT_LINE	Suppress so we keep throwing the original exception 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
generation	TokenNameIdentifier	 generation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
IndexOutput	TokenNameIdentifier	 Index Output
genOutput	TokenNameIdentifier	 gen Output
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
createOutput	TokenNameIdentifier	 create Output
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
genOutput	TokenNameIdentifier	 gen Output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
genOutput	TokenNameIdentifier	 gen Output
.	TokenNameDOT	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
genOutput	TokenNameIdentifier	 gen Output
.	TokenNameDOT	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
genOutput	TokenNameIdentifier	 gen Output
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
sync	TokenNameIdentifier	 sync
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// It's OK if we fail to write this file since it's 	TokenNameCOMMENT_LINE	It's OK if we fail to write this file since it's 
// used only as one of the retry fallbacks. 	TokenNameCOMMENT_LINE	used only as one of the retry fallbacks. 
try	TokenNametry	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
SEGMENTS_GEN	TokenNameIdentifier	 SEGMENTS  GEN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t2	TokenNameIdentifier	 t2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ignore; this file is only used in a retry 	TokenNameCOMMENT_LINE	Ignore; this file is only used in a retry 
// fallback on init. 	TokenNameCOMMENT_LINE	fallback on init. 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
instanceof	TokenNameinstanceof	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
(	TokenNameLPAREN	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Writes & syncs to the Directory dir, taking care to * remove the segments file on exception * <p> * Note: {@link #changed()} should be called prior to this * method if changes have been made to this {@link SegmentInfos} instance * </p> **/	TokenNameCOMMENT_JAVADOC	 Writes & syncs to the Directory dir, taking care to remove the segments file on exception <p> Note: {@link #changed()} should be called prior to this method if changes have been made to this {@link SegmentInfos} instance </p> *
final	TokenNamefinal	
void	TokenNamevoid	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
prepareCommit	TokenNameIdentifier	 prepare Commit
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
finishCommit	TokenNameIdentifier	 finish Commit
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
": "	TokenNameStringLiteral	: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
userData	TokenNameIdentifier	 user Data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
setUserData	TokenNameIdentifier	 set User Data
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
emptyMap	TokenNameIdentifier	 empty Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Replaces all segments in this instance, but keeps * generation, version, counter so that future commits * remain write once. */	TokenNameCOMMENT_JAVADOC	 Replaces all segments in this instance, but keeps generation, version, counter so that future commits remain write once. 
void	TokenNamevoid	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
SegmentInfos	TokenNameIdentifier	 Segment Infos
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rollbackSegmentInfos	TokenNameIdentifier	 rollback Segment Infos
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastGeneration	TokenNameIdentifier	 last Generation
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
lastGeneration	TokenNameIdentifier	 last Generation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns sum of all segment's docCounts. Note that * this does not include deletions */	TokenNameCOMMENT_JAVADOC	 Returns sum of all segment's docCounts. Note that this does not include deletions 
public	TokenNamepublic	
int	TokenNameint	
totalDocCount	TokenNameIdentifier	 total Doc Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
:	TokenNameCOLON	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
+=	TokenNamePLUS_EQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Call this before committing if changes have been made to the * segments. */	TokenNameCOMMENT_JAVADOC	 Call this before committing if changes have been made to the segments. 
public	TokenNamepublic	
void	TokenNamevoid	
changed	TokenNameIdentifier	 changed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
version	TokenNameIdentifier	 version
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** applies all changes caused by committing a merge to this SegmentInfos */	TokenNameCOMMENT_JAVADOC	 applies all changes caused by committing a merge to this SegmentInfos 
void	TokenNamevoid	
applyMergeChanges	TokenNameIdentifier	 apply Merge Changes
(	TokenNameLPAREN	
MergePolicy	TokenNameIdentifier	 Merge Policy
.	TokenNameDOT	
OneMerge	TokenNameIdentifier	 One Merge
merge	TokenNameIdentifier	 merge
,	TokenNameCOMMA	
boolean	TokenNameboolean	
dropSegment	TokenNameIdentifier	 drop Segment
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
mergedAway	TokenNameIdentifier	 merged Away
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
merge	TokenNameIdentifier	 merge
.	TokenNameDOT	
segments	TokenNameIdentifier	 segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inserted	TokenNameIdentifier	 inserted
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
newSegIdx	TokenNameIdentifier	 new Seg Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
segIdx	TokenNameIdentifier	 seg Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
cnt	TokenNameIdentifier	 cnt
=	TokenNameEQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segIdx	TokenNameIdentifier	 seg Idx
<	TokenNameLESS	
cnt	TokenNameIdentifier	 cnt
;	TokenNameSEMICOLON	
segIdx	TokenNameIdentifier	 seg Idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
segIdx	TokenNameIdentifier	 seg Idx
>=	TokenNameGREATER_EQUAL	
newSegIdx	TokenNameIdentifier	 new Seg Idx
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
segIdx	TokenNameIdentifier	 seg Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mergedAway	TokenNameIdentifier	 merged Away
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inserted	TokenNameIdentifier	 inserted
&&	TokenNameAND_AND	
!	TokenNameNOT	
dropSegment	TokenNameIdentifier	 drop Segment
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
segIdx	TokenNameIdentifier	 seg Idx
,	TokenNameCOMMA	
merge	TokenNameIdentifier	 merge
.	TokenNameDOT	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inserted	TokenNameIdentifier	 inserted
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
newSegIdx	TokenNameIdentifier	 new Seg Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
newSegIdx	TokenNameIdentifier	 new Seg Idx
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSegIdx	TokenNameIdentifier	 new Seg Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Either we found place to insert segment, or, we did 	TokenNameCOMMENT_LINE	Either we found place to insert segment, or, we did 
// not, but only because all segments we merged became 	TokenNameCOMMENT_LINE	not, but only because all segments we merged became 
// deleted while we are merging, in which case it should 	TokenNameCOMMENT_LINE	deleted while we are merging, in which case it should 
// be the case that the new segment is also all deleted, 	TokenNameCOMMENT_LINE	be the case that the new segment is also all deleted, 
// we insert it at the beginning if it should not be dropped: 	TokenNameCOMMENT_LINE	we insert it at the beginning if it should not be dropped: 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inserted	TokenNameIdentifier	 inserted
&&	TokenNameAND_AND	
!	TokenNameNOT	
dropSegment	TokenNameIdentifier	 drop Segment
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
merge	TokenNameIdentifier	 merge
.	TokenNameDOT	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// the rest of the segments in list are duplicates, so don't remove from map, only list! 	TokenNameCOMMENT_LINE	the rest of the segments in list are duplicates, so don't remove from map, only list! 
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
newSegIdx	TokenNameIdentifier	 new Seg Idx
,	TokenNameCOMMA	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// update the Set 	TokenNameCOMMENT_LINE	update the Set 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dropSegment	TokenNameIdentifier	 drop Segment
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
merge	TokenNameIdentifier	 merge
.	TokenNameDOT	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
removeAll	TokenNameIdentifier	 remove All
(	TokenNameLPAREN	
mergedAway	TokenNameIdentifier	 merged Away
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
createBackupSegmentInfos	TokenNameIdentifier	 create Backup Segment Infos
(	TokenNameLPAREN	
boolean	TokenNameboolean	
cloneChildren	TokenNameIdentifier	 clone Children
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cloneChildren	TokenNameIdentifier	 clone Children
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
:	TokenNameCOLON	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
)	TokenNameRPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
list	TokenNameIdentifier	 list
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
(	TokenNameLPAREN	
segments	TokenNameIdentifier	 segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
void	TokenNamevoid	
rollbackSegmentInfos	TokenNameIdentifier	 rollback Segment Infos
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
infos	TokenNameIdentifier	 infos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
infos	TokenNameIdentifier	 infos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns an <b>unmodifiable</b> {@link Iterator} of contained segments in order. */	TokenNameCOMMENT_JAVADOC	 Returns an <b>unmodifiable</b> {@link Iterator} of contained segments in order. 
// @Override (comment out until Java 6) 	TokenNameCOMMENT_LINE	@Override (comment out until Java 6) 
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns all contained segments as an <b>unmodifiable</b> {@link List} view. */	TokenNameCOMMENT_JAVADOC	 Returns all contained segments as an <b>unmodifiable</b> {@link List} view. 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cachedUnmodifiableList	TokenNameIdentifier	 cached Unmodifiable List
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cachedUnmodifiableList	TokenNameIdentifier	 cached Unmodifiable List
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
unmodifiableList	TokenNameIdentifier	 unmodifiable List
(	TokenNameLPAREN	
segments	TokenNameIdentifier	 segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
cachedUnmodifiableList	TokenNameIdentifier	 cached Unmodifiable List
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns all contained segments as an <b>unmodifiable</b> {@link Set} view. * The iterator is not sorted, use {@link List} view or {@link #iterator} to get all segments in order. */	TokenNameCOMMENT_JAVADOC	 Returns all contained segments as an <b>unmodifiable</b> {@link Set} view. The iterator is not sorted, use {@link List} view or {@link #iterator} to get all segments in order. 
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
asSet	TokenNameIdentifier	 as Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cachedUnmodifiableSet	TokenNameIdentifier	 cached Unmodifiable Set
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cachedUnmodifiableSet	TokenNameIdentifier	 cached Unmodifiable Set
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
unmodifiableSet	TokenNameIdentifier	 unmodifiable Set
(	TokenNameLPAREN	
segmentSet	TokenNameIdentifier	 segment Set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
cachedUnmodifiableSet	TokenNameIdentifier	 cached Unmodifiable Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Cannot add the same segment two times to this SegmentInfos instance"	TokenNameStringLiteral	Cannot add the same segment two times to this SegmentInfos instance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SegmentInfo	TokenNameIdentifier	 Segment Info
>	TokenNameGREATER	
sis	TokenNameIdentifier	 sis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
:	TokenNameCOLON	
sis	TokenNameIdentifier	 sis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
segmentSet	TokenNameIdentifier	 segment Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
si	TokenNameIdentifier	 si
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
