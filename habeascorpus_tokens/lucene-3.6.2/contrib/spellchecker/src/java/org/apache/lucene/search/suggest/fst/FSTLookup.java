package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
suggest	TokenNameIdentifier	 suggest
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
BufferedOutputStream	TokenNameIdentifier	 Buffered Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileOutputStream	TokenNameIdentifier	 File Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRef	TokenNameIdentifier	 Bytes Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IOUtils	TokenNameIdentifier	 IO Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntsRef	TokenNameIdentifier	 Ints Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
NoOutputs	TokenNameIdentifier	 No Outputs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Outputs	TokenNameIdentifier	 Outputs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
suggest	TokenNameIdentifier	 suggest
.	TokenNameDOT	
Lookup	TokenNameIdentifier	 Lookup
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
suggest	TokenNameIdentifier	 suggest
.	TokenNameDOT	
tst	TokenNameIdentifier	 tst
.	TokenNameDOT	
TSTLookup	TokenNameIdentifier	 TST Lookup
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spell	TokenNameIdentifier	 spell
.	TokenNameDOT	
TermFreqIterator	TokenNameIdentifier	 Term Freq Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
InputStreamDataInput	TokenNameIdentifier	 Input Stream Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
OutputStreamDataOutput	TokenNameIdentifier	 Output Stream Data Output
;	TokenNameSEMICOLON	
/** * Finite state automata based implementation of {@link Lookup} query * suggestion/ autocomplete interface. * * <h2>Implementation details</h2> * * <p>The construction step in {@link #build(TermFreqIterator)} works as follows: * <ul> * <li>A set of input terms (String) and weights (float) is given.</li> * <li>The range of weights is determined and then all weights are discretized into a fixed set * of values ({@link #buckets}). * Note that this means that minor changes in weights may be lost during automaton construction. * In general, this is not a big problem because the "priorities" of completions can be split * into a fixed set of classes (even as rough as: very frequent, frequent, baseline, marginal). * If you need exact, fine-grained weights, use {@link TSTLookup} instead.<li> * <li>All terms in the input are preprended with a synthetic pseudo-character being the weight * of that term. For example a term <code>abc</code> with a discretized weight equal '1' would * become <code>1abc</code>.</li> * <li>The terms are sorted by their raw value of utf16 character values (including the synthetic * term in front).</li> * <li>A finite state automaton ({@link FST}) is constructed from the input. The root node has * arcs labeled with all possible weights. We cache all these arcs, highest-weight first.</li> * </ul> * * <p>At runtime, in {@link #lookup(CharSequence, boolean, int)}, the automaton is utilized as follows: * <ul> * <li>For each possible term weight encoded in the automaton (cached arcs from the root above), * starting with the highest one, we descend along the path of the input key. If the key is not * a prefix of a sequence in the automaton (path ends prematurely), we exit immediately. * No completions. * <li>Otherwise, we have found an internal automaton node that ends the key. <b>The entire * subautomaton (all paths) starting from this node form the key's completions.</b> We start * the traversal of this subautomaton. Every time we reach a final state (arc), we add a single * suggestion to the list of results (the weight of this suggestion is constant and equal to the * root path we started from). The tricky part is that because automaton edges are sorted and * we scan depth-first, we can terminate the entire procedure as soon as we collect enough * suggestions the user requested. * <li>In case the number of suggestions collected in the step above is still insufficient, * we proceed to the next (smaller) weight leaving the root node and repeat the same * algorithm again. * </li> * </ul> * * <h2>Runtime behavior and performance characteristic</h2> * * <p>The algorithm described above is optimized for finding suggestions to short prefixes * in a top-weights-first order. This is probably the most common use case: it allows * presenting suggestions early and sorts them by the global frequency (and then alphabetically). * * <p>If there is an exact match in the automaton, it is returned first on the results * list (even with by-weight sorting). * * <p>Note that the maximum lookup time for <b>any prefix</b> * is the time of descending to the subtree, plus traversal of the subtree up to the number * of requested suggestions (because they are already presorted by weight on the root level * and alphabetically at any node level). * * <p>To order alphabetically only (no ordering by priorities), use identical term weights * for all terms. Alphabetical suggestions are returned even if non-constant weights are * used, but the algorithm for doing this is suboptimal. * * <p>"alphabetically" in any of the documentation above indicates utf16 codepoint order, * nothing else. * @deprecated Use {@link FSTCompletionLookup} instead. */	TokenNameCOMMENT_JAVADOC	 Finite state automata based implementation of {@link Lookup} query suggestion/ autocomplete interface. * <h2>Implementation details</h2> * <p>The construction step in {@link #build(TermFreqIterator)} works as follows: <ul> <li>A set of input terms (String) and weights (float) is given.</li> <li>The range of weights is determined and then all weights are discretized into a fixed set of values ({@link #buckets}). Note that this means that minor changes in weights may be lost during automaton construction. In general, this is not a big problem because the "priorities" of completions can be split into a fixed set of classes (even as rough as: very frequent, frequent, baseline, marginal). If you need exact, fine-grained weights, use {@link TSTLookup} instead.<li> <li>All terms in the input are preprended with a synthetic pseudo-character being the weight of that term. For example a term <code>abc</code> with a discretized weight equal '1' would become <code>1abc</code>.</li> <li>The terms are sorted by their raw value of utf16 character values (including the synthetic term in front).</li> <li>A finite state automaton ({@link FST}) is constructed from the input. The root node has arcs labeled with all possible weights. We cache all these arcs, highest-weight first.</li> </ul> * <p>At runtime, in {@link #lookup(CharSequence, boolean, int)}, the automaton is utilized as follows: <ul> <li>For each possible term weight encoded in the automaton (cached arcs from the root above), starting with the highest one, we descend along the path of the input key. If the key is not a prefix of a sequence in the automaton (path ends prematurely), we exit immediately. No completions. <li>Otherwise, we have found an internal automaton node that ends the key. <b>The entire subautomaton (all paths) starting from this node form the key's completions.</b> We start the traversal of this subautomaton. Every time we reach a final state (arc), we add a single suggestion to the list of results (the weight of this suggestion is constant and equal to the root path we started from). The tricky part is that because automaton edges are sorted and we scan depth-first, we can terminate the entire procedure as soon as we collect enough suggestions the user requested. <li>In case the number of suggestions collected in the step above is still insufficient, we proceed to the next (smaller) weight leaving the root node and repeat the same algorithm again. </li> </ul> * <h2>Runtime behavior and performance characteristic</h2> * <p>The algorithm described above is optimized for finding suggestions to short prefixes in a top-weights-first order. This is probably the most common use case: it allows presenting suggestions early and sorts them by the global frequency (and then alphabetically). * <p>If there is an exact match in the automaton, it is returned first on the results list (even with by-weight sorting). * <p>Note that the maximum lookup time for <b>any prefix</b> is the time of descending to the subtree, plus traversal of the subtree up to the number of requested suggestions (because they are already presorted by weight on the root level and alphabetically at any node level). * <p>To order alphabetically only (no ordering by priorities), use identical term weights for all terms. Alphabetical suggestions are returned even if non-constant weights are used, but the algorithm for doing this is suboptimal. * <p>"alphabetically" in any of the documentation above indicates utf16 codepoint order, nothing else. @deprecated Use {@link FSTCompletionLookup} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
public	TokenNamepublic	
class	TokenNameclass	
FSTLookup	TokenNameIdentifier	 FST Lookup
extends	TokenNameextends	
Lookup	TokenNameIdentifier	 Lookup
{	TokenNameLBRACE	
public	TokenNamepublic	
FSTLookup	TokenNameIdentifier	 FST Lookup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
FSTLookup	TokenNameIdentifier	 FST Lookup
(	TokenNameLPAREN	
int	TokenNameint	
buckets	TokenNameIdentifier	 buckets
,	TokenNameCOMMA	
boolean	TokenNameboolean	
exactMatchFirst	TokenNameIdentifier	 exact Match First
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
buckets	TokenNameIdentifier	 buckets
=	TokenNameEQUAL	
buckets	TokenNameIdentifier	 buckets
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
exactMatchFirst	TokenNameIdentifier	 exact Match First
=	TokenNameEQUAL	
exactMatchFirst	TokenNameIdentifier	 exact Match First
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** A structure for a single entry (for sorting/ preprocessing). */	TokenNameCOMMENT_JAVADOC	 A structure for a single entry (for sorting/ preprocessing). 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
Entry	TokenNameIdentifier	 Entry
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Entry	TokenNameIdentifier	 Entry
(	TokenNameLPAREN	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
float	TokenNamefloat	
freq	TokenNameIdentifier	 freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
freq	TokenNameIdentifier	 freq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Serialized automaton file name (storage). */	TokenNameCOMMENT_JAVADOC	 Serialized automaton file name (storage). 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
FILENAME	TokenNameIdentifier	 FILENAME
=	TokenNameEQUAL	
"fst.dat"	TokenNameStringLiteral	fst.dat
;	TokenNameSEMICOLON	
/** An empty result. */	TokenNameCOMMENT_JAVADOC	 An empty result. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
EMPTY_RESULT	TokenNameIdentifier	 EMPTY  RESULT
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * The number of separate buckets for weights (discretization). The more buckets, * the more fine-grained term weights (priorities) can be assigned. The speed of lookup * will not decrease for prefixes which have highly-weighted completions (because these * are filled-in first), but will decrease significantly for low-weighted terms (but * these should be infrequent, so it is all right). * * <p>The number of buckets must be within [1, 255] range. */	TokenNameCOMMENT_JAVADOC	 The number of separate buckets for weights (discretization). The more buckets, the more fine-grained term weights (priorities) can be assigned. The speed of lookup will not decrease for prefixes which have highly-weighted completions (because these are filled-in first), but will decrease significantly for low-weighted terms (but these should be infrequent, so it is all right). * <p>The number of buckets must be within [1, 255] range. 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
buckets	TokenNameIdentifier	 buckets
;	TokenNameSEMICOLON	
/** * If <code>true</code>, exact suggestions are returned first, even if they are prefixes * of other strings in the automaton (possibly with larger weights). */	TokenNameCOMMENT_JAVADOC	 If <code>true</code>, exact suggestions are returned first, even if they are prefixes of other strings in the automaton (possibly with larger weights). 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
exactMatchFirst	TokenNameIdentifier	 exact Match First
;	TokenNameSEMICOLON	
/** * Finite state automaton encoding all the lookup terms. See class * notes for details. */	TokenNameCOMMENT_JAVADOC	 Finite state automaton encoding all the lookup terms. See class notes for details. 
private	TokenNameprivate	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
automaton	TokenNameIdentifier	 automaton
;	TokenNameSEMICOLON	
/** * An array of arcs leaving the root automaton state and encoding weights of all * completions in their sub-trees. */	TokenNameCOMMENT_JAVADOC	 An array of arcs leaving the root automaton state and encoding weights of all completions in their sub-trees. 
private	TokenNameprivate	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rootArcs	TokenNameIdentifier	 root Arcs
;	TokenNameSEMICOLON	
/* */	TokenNameCOMMENT_BLOCK	 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
TermFreqIterator	TokenNameIdentifier	 Term Freq Iterator
tfit	TokenNameIdentifier	 tfit
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Buffer the input because we will need it twice: for calculating 	TokenNameCOMMENT_LINE	Buffer the input because we will need it twice: for calculating 
// weights distribution and for the actual automata building. 	TokenNameCOMMENT_LINE	weights distribution and for the actual automata building. 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BytesRef	TokenNameIdentifier	 Bytes Ref
spare	TokenNameIdentifier	 spare
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
spare	TokenNameIdentifier	 spare
=	TokenNameEQUAL	
tfit	TokenNameIdentifier	 tfit
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
spare	TokenNameIdentifier	 spare
.	TokenNameDOT	
utf8ToString	TokenNameIdentifier	 utf8 To String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
termChars	TokenNameIdentifier	 term Chars
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// add padding for weight. 	TokenNameCOMMENT_LINE	add padding for weight. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
termChars	TokenNameIdentifier	 term Chars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Entry	TokenNameIdentifier	 Entry
(	TokenNameLPAREN	
termChars	TokenNameIdentifier	 term Chars
,	TokenNameCOMMA	
tfit	TokenNameIdentifier	 tfit
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Distribute weights into at most N buckets. This is a form of discretization to 	TokenNameCOMMENT_LINE	Distribute weights into at most N buckets. This is a form of discretization to 
// limit the number of possible weights so that they can be efficiently encoded in the 	TokenNameCOMMENT_LINE	limit the number of possible weights so that they can be efficiently encoded in the 
// automaton. 	TokenNameCOMMENT_LINE	automaton. 
// 	TokenNameCOMMENT_LINE	 
// It is assumed the distribution of weights is _linear_ so proportional division 	TokenNameCOMMENT_LINE	It is assumed the distribution of weights is _linear_ so proportional division 
// of [min, max] range will be enough here. Other approaches could be to sort 	TokenNameCOMMENT_LINE	of [min, max] range will be enough here. Other approaches could be to sort 
// weights and divide into proportional ranges. 	TokenNameCOMMENT_LINE	weights and divide into proportional ranges. 
if	TokenNameif	
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
redistributeWeightsProportionalMinMax	TokenNameIdentifier	 redistribute Weights Proportional Min Max
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
buckets	TokenNameIdentifier	 buckets
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
encodeWeightPrefix	TokenNameIdentifier	 encode Weight Prefix
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Build the automaton (includes input sorting) and cache root arcs in order from the highest, 	TokenNameCOMMENT_LINE	Build the automaton (includes input sorting) and cache root arcs in order from the highest, 
// to the lowest weight. 	TokenNameCOMMENT_LINE	to the lowest weight. 
this	TokenNamethis	
.	TokenNameDOT	
automaton	TokenNameIdentifier	 automaton
=	TokenNameEQUAL	
buildAutomaton	TokenNameIdentifier	 build Automaton
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Cache the root node's output arcs starting with completions with the highest weights. */	TokenNameCOMMENT_JAVADOC	 Cache the root node's output arcs starting with completions with the highest weights. 
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
private	TokenNameprivate	
void	TokenNamevoid	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
automaton	TokenNameIdentifier	 automaton
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
rootArcs	TokenNameIdentifier	 root Arcs
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
rootArcs	TokenNameIdentifier	 root Arcs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we want highest weights first. 	TokenNameCOMMENT_LINE	we want highest weights first. 
this	TokenNamethis	
.	TokenNameDOT	
rootArcs	TokenNameIdentifier	 root Arcs
=	TokenNameEQUAL	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
[	TokenNameLBRACKET	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the (approximated) weight of a single key (if there is a perfect match * for it in the automaton). * * @return Returns the approximated weight of the input key or <code>null</code> * if not found. */	TokenNameCOMMENT_JAVADOC	 Get the (approximated) weight of a single key (if there is a perfect match for it in the automaton). * @return Returns the approximated weight of the input key or <code>null</code> if not found. 
public	TokenNamepublic	
Float	TokenNameIdentifier	 Float
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getExactMatchStartingFromRootArc	TokenNameIdentifier	 get Exact Match Starting From Root Arc
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the first exact match by traversing root arcs, starting from * the arc <code>i</code>. * * @param i The first root arc index in {@link #rootArcs} to consider when * matching. */	TokenNameCOMMENT_JAVADOC	 Returns the first exact match by traversing root arcs, starting from the arc <code>i</code>. * @param i The first root arc index in {@link #rootArcs} to consider when matching. 
private	TokenNameprivate	
Float	TokenNameIdentifier	 Float
getExactMatchStartingFromRootArc	TokenNameIdentifier	 get Exact Match Starting From Root Arc
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the UTF-8 bytes representation of the input key. 	TokenNameCOMMENT_LINE	Get the UTF-8 bytes representation of the input key. 
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
rootArc	TokenNameIdentifier	 root Arc
=	TokenNameEQUAL	
rootArcs	TokenNameIdentifier	 root Arcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
rootArc	TokenNameIdentifier	 root Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Descend into the automaton using the key as prefix. 	TokenNameCOMMENT_LINE	Descend into the automaton using the key as prefix. 
if	TokenNameif	
(	TokenNameLPAREN	
descendWithPrefix	TokenNameIdentifier	 descend With Prefix
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Prefix-encoded weight. 	TokenNameCOMMENT_LINE	Prefix-encoded weight. 
return	TokenNamereturn	
rootArc	TokenNameIdentifier	 root Arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
buckets	TokenNameIdentifier	 buckets
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Should never happen, but anyway. 	TokenNameCOMMENT_LINE	Should never happen, but anyway. 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Lookup autocomplete suggestions to <code>key</code>. * * @param key The prefix to which suggestions should be sought. * @param onlyMorePopular Return most popular suggestions first. This is the default * behavior for this implementation. Setting it to <code>false</code> has no effect (use * constant term weights to sort alphabetically only). * @param num At most this number of suggestions will be returned. * @return Returns the suggestions, sorted by their approximated weight first (decreasing) * and then alphabetically (utf16 codepoint order). */	TokenNameCOMMENT_JAVADOC	 Lookup autocomplete suggestions to <code>key</code>. * @param key The prefix to which suggestions should be sought. @param onlyMorePopular Return most popular suggestions first. This is the default behavior for this implementation. Setting it to <code>false</code> has no effect (use constant term weights to sort alphabetically only). @param num At most this number of suggestions will be returned. @return Returns the suggestions, sorted by their approximated weight first (decreasing) and then alphabetically (utf16 codepoint order). 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
boolean	TokenNameboolean	
onlyMorePopular	TokenNameIdentifier	 only More Popular
,	TokenNameCOMMA	
int	TokenNameint	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
automaton	TokenNameIdentifier	 automaton
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Keep the result an ArrayList to keep calls monomorphic. 	TokenNameCOMMENT_LINE	Keep the result an ArrayList to keep calls monomorphic. 
return	TokenNamereturn	
EMPTY_RESULT	TokenNameIdentifier	 EMPTY  RESULT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
onlyMorePopular	TokenNameIdentifier	 only More Popular
&&	TokenNameAND_AND	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We could emit a warning here (?). An optimal strategy for alphabetically sorted 	TokenNameCOMMENT_LINE	We could emit a warning here (?). An optimal strategy for alphabetically sorted 
// suggestions would be to add them with a constant weight -- this saves unnecessary 	TokenNameCOMMENT_LINE	suggestions would be to add them with a constant weight -- this saves unnecessary 
// traversals and sorting. 	TokenNameCOMMENT_LINE	traversals and sorting. 
return	TokenNamereturn	
lookupSortedAlphabetically	TokenNameIdentifier	 lookup Sorted Alphabetically
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
lookupSortedByWeight	TokenNameIdentifier	 lookup Sorted By Weight
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Should never happen, but anyway. 	TokenNameCOMMENT_LINE	Should never happen, but anyway. 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Lookup suggestions sorted alphabetically <b>if weights are not constant</b>. This * is a workaround: in general, use constant weights for alphabetically sorted result. */	TokenNameCOMMENT_JAVADOC	 Lookup suggestions sorted alphabetically <b>if weights are not constant</b>. This is a workaround: in general, use constant weights for alphabetically sorted result. 
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
lookupSortedAlphabetically	TokenNameIdentifier	 lookup Sorted Alphabetically
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
int	TokenNameint	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Greedily get num results from each weight branch. 	TokenNameCOMMENT_LINE	Greedily get num results from each weight branch. 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
lookupSortedByWeight	TokenNameIdentifier	 lookup Sorted By Weight
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Sort and trim. 	TokenNameCOMMENT_LINE	Sort and trim. 
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
,	TokenNameCOMMA	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not till java6 @Override 	TokenNameCOMMENT_LINE	not till java6 @Override 
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
LookupResult	TokenNameIdentifier	 Lookup Result
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
LookupResult	TokenNameIdentifier	 Lookup Result
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Lookup	TokenNameIdentifier	 Lookup
.	TokenNameDOT	
CHARSEQUENCE_COMPARATOR	TokenNameIdentifier	 CHARSEQUENCE  COMPARATOR
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
o2	TokenNameIdentifier	 o2
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
{	TokenNameLBRACE	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Lookup suggestions sorted by weight (descending order). * * @param collectAll If <code>true</code>, the routine terminates immediately when <code>num</code> * suggestions have been collected. If <code>false</code>, it will collect suggestions from * all weight arcs (needed for {@link #lookupSortedAlphabetically}. */	TokenNameCOMMENT_JAVADOC	 Lookup suggestions sorted by weight (descending order). * @param collectAll If <code>true</code>, the routine terminates immediately when <code>num</code> suggestions have been collected. If <code>false</code>, it will collect suggestions from all weight arcs (needed for {@link #lookupSortedAlphabetically}. 
private	TokenNameprivate	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
lookupSortedByWeight	TokenNameIdentifier	 lookup Sorted By Weight
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
int	TokenNameint	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
boolean	TokenNameboolean	
collectAll	TokenNameIdentifier	 collect All
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Don't overallocate the results buffers. This also serves the purpose of allowing 	TokenNameCOMMENT_LINE	Don't overallocate the results buffers. This also serves the purpose of allowing 
// the user of this class to request all matches using Integer.MAX_VALUE as the number 	TokenNameCOMMENT_LINE	the user of this class to request all matches using Integer.MAX_VALUE as the number 
// of results. 	TokenNameCOMMENT_LINE	of results. 
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
StringBuilder	TokenNameIdentifier	 String Builder
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
matchLength	TokenNameIdentifier	 match Length
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rootArcs	TokenNameIdentifier	 root Arcs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
rootArc	TokenNameIdentifier	 root Arc
=	TokenNameEQUAL	
rootArcs	TokenNameIdentifier	 root Arcs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
rootArc	TokenNameIdentifier	 root Arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Descend into the automaton using the key as prefix. 	TokenNameCOMMENT_LINE	Descend into the automaton using the key as prefix. 
if	TokenNameif	
(	TokenNameLPAREN	
descendWithPrefix	TokenNameIdentifier	 descend With Prefix
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Prefix-encoded weight. 	TokenNameCOMMENT_LINE	Prefix-encoded weight. 
final	TokenNamefinal	
long	TokenNamelong	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
rootArc	TokenNameIdentifier	 root Arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
/	TokenNameDIVIDE	
buckets	TokenNameIdentifier	 buckets
;	TokenNameSEMICOLON	
// A subgraph starting from the current node has the completions 	TokenNameCOMMENT_LINE	A subgraph starting from the current node has the completions 
// of the key prefix. The arc we're at is the last key's byte, 	TokenNameCOMMENT_LINE	of the key prefix. The arc we're at is the last key's byte, 
// so we will collect it too. 	TokenNameCOMMENT_LINE	so we will collect it too. 
output	TokenNameIdentifier	 output
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
matchLength	TokenNameIdentifier	 match Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
collectAll	TokenNameIdentifier	 collect All
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We have enough suggestions to return immediately. Keep on looking for an 	TokenNameCOMMENT_LINE	We have enough suggestions to return immediately. Keep on looking for an 
// exact match, if requested. 	TokenNameCOMMENT_LINE	exact match, if requested. 
if	TokenNameif	
(	TokenNameLPAREN	
exactMatchFirst	TokenNameIdentifier	 exact Match First
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
checkExistingAndReorder	TokenNameIdentifier	 check Existing And Reorder
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Number	TokenNameIdentifier	 Number
exactMatchWeight	TokenNameIdentifier	 exact Match Weight
=	TokenNameEQUAL	
getExactMatchStartingFromRootArc	TokenNameIdentifier	 get Exact Match Starting From Root Arc
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
exactMatchWeight	TokenNameIdentifier	 exact Match Weight
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Insert as the first result and truncate at num. 	TokenNameCOMMENT_LINE	Insert as the first result and truncate at num. 
while	TokenNamewhile	
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
{	TokenNameLBRACE	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
LookupResult	TokenNameIdentifier	 Lookup Result
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
exactMatchWeight	TokenNameIdentifier	 exact Match Weight
.	TokenNameDOT	
longValue	TokenNameIdentifier	 long Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if the list of {@link LookupResult}s already has a <code>key</code>. If so, * reorders that {@link LookupResult} to the first position. * * @return Returns <code>true<code> if and only if <code>list</code> contained <code>key</code>. */	TokenNameCOMMENT_JAVADOC	 Checks if the list of {@link LookupResult}s already has a <code>key</code>. If so, reorders that {@link LookupResult} to the first position. * @return Returns <code>true<code> if and only if <code>list</code> contained <code>key</code>. 
private	TokenNameprivate	
boolean	TokenNameboolean	
checkExistingAndReorder	TokenNameIdentifier	 check Existing And Reorder
(	TokenNameLPAREN	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
list	TokenNameIdentifier	 list
,	TokenNameCOMMA	
CharSequence	TokenNameIdentifier	 Char Sequence
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We assume list does not have duplicates (because of how the FST is created). 	TokenNameCOMMENT_LINE	We assume list does not have duplicates (because of how the FST is created). 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Key found. Unless already at i==0, remove it and push up front so that the ordering 	TokenNameCOMMENT_LINE	Key found. Unless already at i==0, remove it and push up front so that the ordering 
// remains identical with the exception of the exact match. 	TokenNameCOMMENT_LINE	remains identical with the exception of the exact match. 
list	TokenNameIdentifier	 list
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Descend along the path starting at <code>arc</code> and going through * bytes in <code>utf8</code> argument. * * @param arc The starting arc. This argument is modified in-place. * @param term The term to descend with. * @return If <code>true</code>, <code>arc</code> will be set to the arc matching * last byte of <code>utf8</code>. <code>false</code> is returned if no such * prefix <code>utf8</code> exists. */	TokenNameCOMMENT_JAVADOC	 Descend along the path starting at <code>arc</code> and going through bytes in <code>utf8</code> argument. * @param arc The starting arc. This argument is modified in-place. @param term The term to descend with. @return If <code>true</code>, <code>arc</code> will be set to the arc matching last byte of <code>utf8</code>. <code>false</code> is returned if no such prefix <code>utf8</code> exists. 
private	TokenNameprivate	
boolean	TokenNameboolean	
descendWithPrefix	TokenNameIdentifier	 descend With Prefix
(	TokenNameLPAREN	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
CharSequence	TokenNameIdentifier	 Char Sequence
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
fstReader	TokenNameIdentifier	 fst Reader
=	TokenNameEQUAL	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
&	TokenNameAND	
0xffff	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
fstReader	TokenNameIdentifier	 fst Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No matching prefixes, return an empty result. 	TokenNameCOMMENT_LINE	No matching prefixes, return an empty result. 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursive collect lookup results from the automaton subgraph starting at <code>arc</code>. * * @param num Maximum number of results needed (early termination). * @param weight Weight of all results found during this collection. */	TokenNameCOMMENT_JAVADOC	 Recursive collect lookup results from the automaton subgraph starting at <code>arc</code>. * @param num Maximum number of results needed (early termination). @param weight Weight of all results found during this collection. 
private	TokenNameprivate	
boolean	TokenNameboolean	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
LookupResult	TokenNameIdentifier	 Lookup Result
>	TokenNameGREATER	
res	TokenNameIdentifier	 res
,	TokenNameCOMMA	
int	TokenNameint	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
long	TokenNamelong	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
StringBuilder	TokenNameIdentifier	 String Builder
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
readFirstTargetArc	TokenNameIdentifier	 read First Target Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
END_LABEL	TokenNameIdentifier	 END  LABEL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
LookupResult	TokenNameIdentifier	 Lookup Result
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
save	TokenNameIdentifier	 save
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
,	TokenNameCOMMA	
num	TokenNameIdentifier	 num
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
new	TokenNamenew	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
save	TokenNameIdentifier	 save
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isLast	TokenNameIdentifier	 is Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
readNextArc	TokenNameIdentifier	 read Next Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds the final automaton from a list of entries. */	TokenNameCOMMENT_JAVADOC	 Builds the final automaton from a list of entries. 
private	TokenNameprivate	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
buildAutomaton	TokenNameIdentifier	 build Automaton
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Sort by utf16 (raw char value) 	TokenNameCOMMENT_LINE	Sort by utf16 (raw char value) 
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
comp	TokenNameIdentifier	 comp
=	TokenNameEQUAL	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
Entry	TokenNameIdentifier	 Entry
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ch1	TokenNameIdentifier	 ch1
=	TokenNameEQUAL	
o1	TokenNameIdentifier	 o1
.	TokenNameDOT	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ch2	TokenNameIdentifier	 ch2
=	TokenNameEQUAL	
o2	TokenNameIdentifier	 o2
.	TokenNameDOT	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
int	TokenNameint	
len1	TokenNameIdentifier	 len1
=	TokenNameEQUAL	
ch1	TokenNameIdentifier	 ch1
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
int	TokenNameint	
len2	TokenNameIdentifier	 len2
=	TokenNameEQUAL	
ch2	TokenNameIdentifier	 ch2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
len1	TokenNameIdentifier	 len1
,	TokenNameCOMMA	
len2	TokenNameIdentifier	 len2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
ch1	TokenNameIdentifier	 ch1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
-	TokenNameMINUS	
ch2	TokenNameIdentifier	 ch2
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
len1	TokenNameIdentifier	 len1
-	TokenNameMINUS	
len2	TokenNameIdentifier	 len2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
comp	TokenNameIdentifier	 comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Avoid duplicated identical entries, if possible. This is required because 	TokenNameCOMMENT_LINE	Avoid duplicated identical entries, if possible. This is required because 
// it breaks automaton construction otherwise. 	TokenNameCOMMENT_LINE	it breaks automaton construction otherwise. 
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comp	TokenNameIdentifier	 comp
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
,	TokenNameCOMMA	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Build the automaton. 	TokenNameCOMMENT_LINE	Build the automaton. 
final	TokenNamefinal	
Outputs	TokenNameIdentifier	 Outputs
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
empty	TokenNameIdentifier	 empty
=	TokenNameEQUAL	
outputs	TokenNameIdentifier	 outputs
.	TokenNameDOT	
getNoOutput	TokenNameIdentifier	 get No Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
termLength	TokenNameIdentifier	 term Length
=	TokenNameEQUAL	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
termLength	TokenNameIdentifier	 term Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ints	TokenNameIdentifier	 ints
=	TokenNameEQUAL	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chars	TokenNameIdentifier	 chars
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
termLength	TokenNameIdentifier	 term Length
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
,	TokenNameCOMMA	
empty	TokenNameIdentifier	 empty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Prepends the entry's weight to each entry, encoded as a single byte, so that the * root automaton node fans out to all possible priorities, starting with the arc that has * the highest weights. */	TokenNameCOMMENT_JAVADOC	 Prepends the entry's weight to each entry, encoded as a single byte, so that the root automaton node fans out to all possible priorities, starting with the arc that has the highest weights. 
private	TokenNameprivate	
void	TokenNamevoid	
encodeWeightPrefix	TokenNameIdentifier	 encode Weight Prefix
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
assert	TokenNameassert	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
weight	TokenNameIdentifier	 weight
<=	TokenNameLESS_EQUAL	
buckets	TokenNameIdentifier	 buckets
)	TokenNameRPAREN	
:	TokenNameCOLON	
"Weight out of range: "	TokenNameStringLiteral	Weight out of range: 
+	TokenNamePLUS	
weight	TokenNameIdentifier	 weight
+	TokenNamePLUS	
" ["	TokenNameStringLiteral	 [
+	TokenNamePLUS	
buckets	TokenNameIdentifier	 buckets
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
;	TokenNameSEMICOLON	
// There should be a single empty char reserved in front for the weight. 	TokenNameCOMMENT_LINE	There should be a single empty char reserved in front for the weight. 
e	TokenNameIdentifier	 e
.	TokenNameDOT	
term	TokenNameIdentifier	 term
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Split [min, max] range into buckets, reassigning weights. Entries' weights are * remapped to [0, buckets] range (so, buckets + 1 buckets, actually). */	TokenNameCOMMENT_JAVADOC	 Split [min, max] range into buckets, reassigning weights. Entries' weights are remapped to [0, buckets] range (so, buckets + 1 buckets, actually). 
private	TokenNameprivate	
void	TokenNamevoid	
redistributeWeightsProportionalMinMax	TokenNameIdentifier	 redistribute Weights Proportional Min Max
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
>	TokenNameGREATER	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
int	TokenNameint	
buckets	TokenNameIdentifier	 buckets
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
;	TokenNameSEMICOLON	
float	TokenNamefloat	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
min	TokenNameIdentifier	 min
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
float	TokenNamefloat	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
max	TokenNameIdentifier	 max
-	TokenNameMINUS	
min	TokenNameIdentifier	 min
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
buckets	TokenNameIdentifier	 buckets
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
weight	TokenNameIdentifier	 weight
-	TokenNameMINUS	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// int cast equiv. to floor() 	TokenNameCOMMENT_LINE	int cast equiv. to floor() 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
store	TokenNameIdentifier	 store
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
OutputStream	TokenNameIdentifier	 Output Stream
os	TokenNameIdentifier	 os
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedOutputStream	TokenNameIdentifier	 Buffered Output Stream
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
automaton	TokenNameIdentifier	 automaton
.	TokenNameDOT	
save	TokenNameIdentifier	 save
(	TokenNameLPAREN	
new	TokenNamenew	
OutputStreamDataOutput	TokenNameIdentifier	 Output Stream Data Output
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
os	TokenNameIdentifier	 os
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
InputStream	TokenNameIdentifier	 Input Stream
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
automaton	TokenNameIdentifier	 automaton
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
new	TokenNamenew	
InputStreamDataInput	TokenNameIdentifier	 Input Stream Data Input
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
,	TokenNameCOMMA	
NoOutputs	TokenNameIdentifier	 No Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cacheRootArcs	TokenNameIdentifier	 cache Root Arcs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
IOUtils	TokenNameIdentifier	 IO Utils
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
