/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
traversers	TokenNameIdentifier	 traversers
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
XMLEventReader	TokenNameIdentifier	 XML Event Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
XMLStreamException	TokenNameIdentifier	 XML Stream Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
XMLStreamReader	TokenNameIdentifier	 XML Stream Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
SchemaDVFactory	TokenNameIdentifier	 Schema DV Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSDDescription	TokenNameIdentifier	 XSD Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSDeclarationPool	TokenNameIdentifier	 XS Declaration Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
opti	TokenNameIdentifier	 opti
.	TokenNameDOT	
ElementImpl	TokenNameIdentifier	 Element Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
opti	TokenNameIdentifier	 opti
.	TokenNameDOT	
SchemaDOMParser	TokenNameIdentifier	 Schema DOM Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
opti	TokenNameIdentifier	 opti
.	TokenNameDOT	
SchemaParsingConfig	TokenNameIdentifier	 Schema Parsing Config
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SimpleLocator	TokenNameIdentifier	 Simple Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSInputSource	TokenNameIdentifier	 XS Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
SAXParser	TokenNameIdentifier	 SAX Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
XML11Configuration	TokenNameIdentifier	 XM L11 Configuration
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DOMUtil	TokenNameIdentifier	 DOM Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DefaultErrorHandler	TokenNameIdentifier	 Default Error Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ErrorHandlerWrapper	TokenNameIdentifier	 Error Handler Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StAXLocationWrapper	TokenNameIdentifier	 St AX Location Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolHash	TokenNameIdentifier	 Symbol Hash
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
URI	TokenNameIdentifier	 URI
.	TokenNameDOT	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
Grammar	TokenNameIdentifier	 Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLSchemaDescription	TokenNameIdentifier	 XML Schema Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLInputSource	TokenNameIdentifier	 XML Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLParseException	TokenNameIdentifier	 XML Parse Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
StringList	TokenNameIdentifier	 String List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeDeclaration	TokenNameIdentifier	 XS Attribute Declaration
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeGroupDefinition	TokenNameIdentifier	 XS Attribute Group Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSModelGroup	TokenNameIdentifier	 XS Model Group
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSModelGroupDefinition	TokenNameIdentifier	 XS Model Group Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSNamedMap	TokenNameIdentifier	 XS Named Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObject	TokenNameIdentifier	 XS Object
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticle	TokenNameIdentifier	 XS Particle
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTerm	TokenNameIdentifier	 XS Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
datatypes	TokenNameIdentifier	 datatypes
.	TokenNameDOT	
ObjectList	TokenNameIdentifier	 Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
InputSource	TokenNameIdentifier	 Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXParseException	TokenNameIdentifier	 SAX Parse Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
XMLReader	TokenNameIdentifier	 XML Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
helpers	TokenNameIdentifier	 helpers
.	TokenNameDOT	
XMLReaderFactory	TokenNameIdentifier	 XML Reader Factory
;	TokenNameSEMICOLON	
/** * The purpose of this class is to co-ordinate the construction of a * grammar object corresponding to a schema. To do this, it must be * prepared to parse several schema documents (for instance if the * schema document originally referred to contains <include> or * <redefined> information items). If any of the schemas imports a * schema, other grammars may be constructed as a side-effect. * * @xerces.internal * * @author Neil Graham, IBM * @author Pavani Mukthipudi, Sun Microsystems * * @version $Id: XSDHandler.java 1027805 2010-10-27 02:55:35Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 The purpose of this class is to co-ordinate the construction of a grammar object corresponding to a schema. To do this, it must be prepared to parse several schema documents (for instance if the schema document originally referred to contains <include> or <redefined> information items). If any of the schemas imports a schema, other grammars may be constructed as a side-effect. * @xerces.internal * @author Neil Graham, IBM @author Pavani Mukthipudi, Sun Microsystems * @version $Id: XSDHandler.java 1027805 2010-10-27 02:55:35Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
XSDHandler	TokenNameIdentifier	 XSD Handler
{	TokenNameLBRACE	
/** Feature identifier: validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION	TokenNameIdentifier	 VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_FEATURE	TokenNameIdentifier	 VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** feature identifier: XML Schema validation */	TokenNameCOMMENT_JAVADOC	 feature identifier: XML Schema validation 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XMLSCHEMA_VALIDATION	TokenNameIdentifier	 XMLSCHEMA  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_VALIDATION_FEATURE	TokenNameIdentifier	 SCHEMA  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: allow java encodings */	TokenNameCOMMENT_JAVADOC	 Feature identifier: allow java encodings 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ALLOW_JAVA_ENCODINGS	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ALLOW_JAVA_ENCODINGS_FEATURE	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: continue after fatal error */	TokenNameCOMMENT_JAVADOC	 Feature identifier: continue after fatal error 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
CONTINUE_AFTER_FATAL_ERROR	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
CONTINUE_AFTER_FATAL_ERROR_FEATURE	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: allow java encodings */	TokenNameCOMMENT_JAVADOC	 Feature identifier: allow java encodings 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
;	TokenNameSEMICOLON	
/** Feature: disallow doctype*/	TokenNameCOMMENT_JAVADOC	 Feature: disallow doctype
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DISALLOW_DOCTYPE	TokenNameIdentifier	 DISALLOW  DOCTYPE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DISALLOW_DOCTYPE_DECL_FEATURE	TokenNameIdentifier	 DISALLOW  DOCTYPE  DECL  FEATURE
;	TokenNameSEMICOLON	
/** Feature: generate synthetic annotations */	TokenNameCOMMENT_JAVADOC	 Feature: generate synthetic annotations 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
GENERATE_SYNTHETIC_ANNOTATIONS	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: validate annotations. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validate annotations. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATE_ANNOTATIONS	TokenNameIdentifier	 VALIDATE  ANNOTATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATE_ANNOTATIONS_FEATURE	TokenNameIdentifier	 VALIDATE  ANNOTATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: honour all schemaLocations */	TokenNameCOMMENT_JAVADOC	 Feature identifier: honour all schemaLocations 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
HONOUR_ALL_SCHEMALOCATIONS	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
HONOUR_ALL_SCHEMALOCATIONS_FEATURE	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: namespace growth */	TokenNameCOMMENT_JAVADOC	 Feature identifier: namespace growth 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NAMESPACE_GROWTH	TokenNameIdentifier	 NAMESPACE  GROWTH
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_GROWTH_FEATURE	TokenNameIdentifier	 NAMESPACE  GROWTH  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: tolerate duplicates */	TokenNameCOMMENT_JAVADOC	 Feature identifier: tolerate duplicates 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TOLERATE_DUPLICATES	TokenNameIdentifier	 TOLERATE  DUPLICATES
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
TOLERATE_DUPLICATES_FEATURE	TokenNameIdentifier	 TOLERATE  DUPLICATES  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: namespace prefixes. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: namespace prefixes. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NAMESPACE_PREFIXES	TokenNameIdentifier	 NAMESPACE  PREFIXES
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_PREFIXES_FEATURE	TokenNameIdentifier	 NAMESPACE  PREFIXES  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: string interning. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: string interning. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
STRING_INTERNING	TokenNameIdentifier	 STRING  INTERNING
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
STRING_INTERNING_FEATURE	TokenNameIdentifier	 STRING  INTERNING  FEATURE
;	TokenNameSEMICOLON	
/** Property identifier: error handler. */	TokenNameCOMMENT_JAVADOC	 Property identifier: error handler. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ERROR_HANDLER	TokenNameIdentifier	 ERROR  HANDLER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_HANDLER_PROPERTY	TokenNameIdentifier	 ERROR  HANDLER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: JAXP schema source. */	TokenNameCOMMENT_JAVADOC	 Property identifier: JAXP schema source. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
JAXP_SCHEMA_SOURCE	TokenNameIdentifier	 JAXP  SCHEMA  SOURCE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_SOURCE	TokenNameIdentifier	 SCHEMA  SOURCE
;	TokenNameSEMICOLON	
/** Property identifier: entity resolver. */	TokenNameCOMMENT_JAVADOC	 Property identifier: entity resolver. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_RESOLVER_PROPERTY	TokenNameIdentifier	 ENTITY  RESOLVER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: entity manager. */	TokenNameCOMMENT_JAVADOC	 Property identifier: entity manager. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ENTITY_MANAGER	TokenNameIdentifier	 ENTITY  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_MANAGER_PROPERTY	TokenNameIdentifier	 ENTITY  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: error reporter. */	TokenNameCOMMENT_JAVADOC	 Property identifier: error reporter. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: grammar pool. */	TokenNameCOMMENT_JAVADOC	 Property identifier: grammar pool. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XMLGRAMMAR_POOL	TokenNameIdentifier	 XMLGRAMMAR  POOL
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XMLGRAMMAR_POOL_PROPERTY	TokenNameIdentifier	 XMLGRAMMAR  POOL  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: symbol table. */	TokenNameCOMMENT_JAVADOC	 Property identifier: symbol table. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SYMBOL_TABLE_PROPERTY	TokenNameIdentifier	 SYMBOL  TABLE  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: security manager. */	TokenNameCOMMENT_JAVADOC	 Property identifier: security manager. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SECURITY_MANAGER_PROPERTY	TokenNameIdentifier	 SECURITY  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: locale. */	TokenNameCOMMENT_JAVADOC	 Property identifier: locale. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
LOCALE	TokenNameIdentifier	 LOCALE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
LOCALE_PROPERTY	TokenNameIdentifier	 LOCALE  PROPERTY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_NODE_POOL	TokenNameIdentifier	 DEBUG  NODE  POOL
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Data 	TokenNameCOMMENT_LINE	Data 
// different sorts of declarations; should make lookup and 	TokenNameCOMMENT_LINE	different sorts of declarations; should make lookup and 
// traverser calling more efficient/less bulky. 	TokenNameCOMMENT_LINE	traverser calling more efficient/less bulky. 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// this string gets appended to redefined names; it's purpose is to be 	TokenNameCOMMENT_LINE	this string gets appended to redefined names; it's purpose is to be 
// as unlikely as possible to cause collisions. 	TokenNameCOMMENT_LINE	as unlikely as possible to cause collisions. 
public	TokenNamepublic	
final	TokenNamefinal	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
REDEF_IDENTIFIER	TokenNameIdentifier	 REDEF  IDENTIFIER
=	TokenNameEQUAL	
"_fn3dktizrknc9pi"	TokenNameStringLiteral	_fn3dktizrknc9pi
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
//protected data that can be accessable by any traverser 	TokenNameCOMMENT_LINE	protected data that can be accessable by any traverser 
// stores <notation> decl 	TokenNameCOMMENT_LINE	stores <notation> decl 
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
fNotationRegistry	TokenNameIdentifier	 f Notation Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XSDeclarationPool	TokenNameIdentifier	 XS Declaration Pool
fDeclPool	TokenNameIdentifier	 f Decl Pool
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// These tables correspond to the symbol spaces defined in the 	TokenNameCOMMENT_LINE	These tables correspond to the symbol spaces defined in the 
// spec. 	TokenNameCOMMENT_LINE	spec. 
// They are keyed with a QName (that is, String("URI,localpart) and 	TokenNameCOMMENT_LINE	They are keyed with a QName (that is, String("URI,localpart) and 
// their values are nodes corresponding to the given name's decl. 	TokenNameCOMMENT_LINE	their values are nodes corresponding to the given name's decl. 
// By asking the node for its ownerDocument and looking in 	TokenNameCOMMENT_LINE	By asking the node for its ownerDocument and looking in 
// XSDocumentInfoRegistry we can easily get the corresponding 	TokenNameCOMMENT_LINE	XSDocumentInfoRegistry we can easily get the corresponding 
// XSDocumentInfo object. 	TokenNameCOMMENT_LINE	XSDocumentInfo object. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedAttributeRegistry	TokenNameIdentifier	 f Unparsed Attribute Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedAttributeGroupRegistry	TokenNameIdentifier	 f Unparsed Attribute Group Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedElementRegistry	TokenNameIdentifier	 f Unparsed Element Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedGroupRegistry	TokenNameIdentifier	 f Unparsed Group Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedIdentityConstraintRegistry	TokenNameIdentifier	 f Unparsed Identity Constraint Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedNotationRegistry	TokenNameIdentifier	 f Unparsed Notation Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedTypeRegistry	TokenNameIdentifier	 f Unparsed Type Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Compensation for the above hashtables to locate XSDocumentInfo, 	TokenNameCOMMENT_LINE	Compensation for the above hashtables to locate XSDocumentInfo, 
// Since we may take Schema Element directly, so can not get the 	TokenNameCOMMENT_LINE	Since we may take Schema Element directly, so can not get the 
// corresponding XSDocumentInfo object just using above hashtables. 	TokenNameCOMMENT_LINE	corresponding XSDocumentInfo object just using above hashtables. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedAttributeRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedAttributeGroupRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Group Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedElementRegistrySub	TokenNameIdentifier	 f Unparsed Element Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedGroupRegistrySub	TokenNameIdentifier	 f Unparsed Group Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedIdentityConstraintRegistrySub	TokenNameIdentifier	 f Unparsed Identity Constraint Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedNotationRegistrySub	TokenNameIdentifier	 f Unparsed Notation Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedTypeRegistrySub	TokenNameIdentifier	 f Unparsed Type Registry Sub
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Stores XSDocumentInfo (keyed by component name), to check for duplicate 	TokenNameCOMMENT_LINE	Stores XSDocumentInfo (keyed by component name), to check for duplicate 
// components declared within the same xsd document 	TokenNameCOMMENT_LINE	components declared within the same xsd document 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fUnparsedRegistriesExt	TokenNameIdentifier	 f Unparsed Registries Ext
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// ATTRIBUTE_TYPE 	TokenNameCOMMENT_LINE	ATTRIBUTE_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// ATTRIBUTEGROUP_TYPE 	TokenNameCOMMENT_LINE	ATTRIBUTEGROUP_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// ELEMENT_TYPE 	TokenNameCOMMENT_LINE	ELEMENT_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// GROUP_TYPE 	TokenNameCOMMENT_LINE	GROUP_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// IDENTITYCONSTRAINT_TYPE 	TokenNameCOMMENT_LINE	IDENTITYCONSTRAINT_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// NOTATION_TYPE 	TokenNameCOMMENT_LINE	NOTATION_TYPE 
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// TYPEDECL_TYPE 	TokenNameCOMMENT_LINE	TYPEDECL_TYPE 
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// this is keyed with a documentNode (or the schemaRoot nodes 	TokenNameCOMMENT_LINE	this is keyed with a documentNode (or the schemaRoot nodes 
// contained in the XSDocumentInfo objects) and its value is the 	TokenNameCOMMENT_LINE	contained in the XSDocumentInfo objects) and its value is the 
// XSDocumentInfo object corresponding to that document. 	TokenNameCOMMENT_LINE	XSDocumentInfo object corresponding to that document. 
// Basically, the function of this registry is to be a link 	TokenNameCOMMENT_LINE	Basically, the function of this registry is to be a link 
// between the nodes we fetch from calls to the fUnparsed* 	TokenNameCOMMENT_LINE	between the nodes we fetch from calls to the fUnparsed* 
// arrays and the XSDocumentInfos they live in. 	TokenNameCOMMENT_LINE	arrays and the XSDocumentInfos they live in. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fXSDocumentInfoRegistry	TokenNameIdentifier	 f XS Document Info Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this hashtable is keyed on by XSDocumentInfo objects. Its values 	TokenNameCOMMENT_LINE	this hashtable is keyed on by XSDocumentInfo objects. Its values 
// are Vectors containing the XSDocumentInfo objects <include>d, 	TokenNameCOMMENT_LINE	are Vectors containing the XSDocumentInfo objects <include>d, 
// <import>ed or <redefine>d by the key XSDocumentInfo. 	TokenNameCOMMENT_LINE	<import>ed or <redefine>d by the key XSDocumentInfo. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fDependencyMap	TokenNameIdentifier	 f Dependency Map
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this hashtable is keyed on by a target namespace. Its values 	TokenNameCOMMENT_LINE	this hashtable is keyed on by a target namespace. Its values 
// are Vectors containing namespaces imported by schema documents 	TokenNameCOMMENT_LINE	are Vectors containing namespaces imported by schema documents 
// with the key target namespace. 	TokenNameCOMMENT_LINE	with the key target namespace. 
// if an imprted schema has absent namespace, the value "null" is stored. 	TokenNameCOMMENT_LINE	if an imprted schema has absent namespace, the value "null" is stored. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fImportMap	TokenNameIdentifier	 f Import Map
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// all namespaces that imports other namespaces 	TokenNameCOMMENT_LINE	all namespaces that imports other namespaces 
// if the importing schema has absent namespace, empty string is stored. 	TokenNameCOMMENT_LINE	if the importing schema has absent namespace, empty string is stored. 
// (because the key of a hashtable can't be null.) 	TokenNameCOMMENT_LINE	(because the key of a hashtable can't be null.) 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
fAllTNSs	TokenNameIdentifier	 f All TN Ss
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// stores instance document mappings between namespaces and schema hints 	TokenNameCOMMENT_LINE	stores instance document mappings between namespaces and schema hints 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fLocationPairs	TokenNameIdentifier	 f Location Pairs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Hashtable	TokenNameIdentifier	 Hashtable
EMPTY_TABLE	TokenNameIdentifier	 EMPTY  TABLE
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Records which nodes are hidden when the input is a DOMInputSource. 	TokenNameCOMMENT_LINE	Records which nodes are hidden when the input is a DOMInputSource. 
Hashtable	TokenNameIdentifier	 Hashtable
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// convenience methods 	TokenNameCOMMENT_LINE	convenience methods 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ns	TokenNameIdentifier	 ns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ns	TokenNameIdentifier	 ns
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
:	TokenNameCOLON	
ns	TokenNameIdentifier	 ns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
emptyString2Null	TokenNameIdentifier	 empty String2 Null
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ns	TokenNameIdentifier	 ns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ns	TokenNameIdentifier	 ns
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
ns	TokenNameIdentifier	 ns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// use Schema Element to lookup the SystemId. 	TokenNameCOMMENT_LINE	use Schema Element to lookup the SystemId. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
doc2SystemId	TokenNameIdentifier	 doc2 System Id
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
ele	TokenNameIdentifier	 ele
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
documentURI	TokenNameIdentifier	 document URI
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * REVISIT: Casting until DOM Level 3 interfaces are available. -- mrglavas */	TokenNameCOMMENT_JAVADOC	 REVISIT: Casting until DOM Level 3 interfaces are available. -- mrglavas 
if	TokenNameif	
(	TokenNameLPAREN	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
opti	TokenNameIdentifier	 opti
.	TokenNameDOT	
SchemaDOM	TokenNameIdentifier	 Schema DOM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
documentURI	TokenNameIdentifier	 document URI
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
opti	TokenNameIdentifier	 opti
.	TokenNameDOT	
SchemaDOM	TokenNameIdentifier	 Schema DOM
)	TokenNameRPAREN	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDocumentURI	TokenNameIdentifier	 get Document URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
documentURI	TokenNameIdentifier	 document URI
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
documentURI	TokenNameIdentifier	 document URI
:	TokenNameCOLON	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ele	TokenNameIdentifier	 ele
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This vector stores strings which are combinations of the 	TokenNameCOMMENT_LINE	This vector stores strings which are combinations of the 
// publicId and systemId of the inputSource corresponding to a 	TokenNameCOMMENT_LINE	publicId and systemId of the inputSource corresponding to a 
// schema document. This combination is used so that the user's 	TokenNameCOMMENT_LINE	schema document. This combination is used so that the user's 
// EntityResolver can provide a consistent way of identifying a 	TokenNameCOMMENT_LINE	EntityResolver can provide a consistent way of identifying a 
// schema document that is included in multiple other schemas. 	TokenNameCOMMENT_LINE	schema document that is included in multiple other schemas. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fTraversed	TokenNameIdentifier	 f Traversed
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this hashtable contains a mapping from Schema Element to its systemId 	TokenNameCOMMENT_LINE	this hashtable contains a mapping from Schema Element to its systemId 
// this is useful to resolve a uri relative to the referring document 	TokenNameCOMMENT_LINE	this is useful to resolve a uri relative to the referring document 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the primary XSDocumentInfo we were called to parse 	TokenNameCOMMENT_LINE	the primary XSDocumentInfo we were called to parse 
private	TokenNameprivate	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
fRoot	TokenNameIdentifier	 f Root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// This hashtable's job is to act as a link between the Schema Element and its 	TokenNameCOMMENT_LINE	This hashtable's job is to act as a link between the Schema Element and its 
// XSDocumentInfo object. 	TokenNameCOMMENT_LINE	XSDocumentInfo object. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fDoc2XSDocumentMap	TokenNameIdentifier	 f Doc2 XS Document Map
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// map between <redefine> elements and the XSDocumentInfo 	TokenNameCOMMENT_LINE	map between <redefine> elements and the XSDocumentInfo 
// objects that correspond to the documents being redefined. 	TokenNameCOMMENT_LINE	objects that correspond to the documents being redefined. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fRedefine2XSDMap	TokenNameIdentifier	 f Redefine2 XSD Map
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// map between <redefine> elements and the namespace support 	TokenNameCOMMENT_LINE	map between <redefine> elements and the namespace support 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fRedefine2NSSupport	TokenNameIdentifier	 f Redefine2 NS Support
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// these objects store a mapping between the names of redefining 	TokenNameCOMMENT_LINE	these objects store a mapping between the names of redefining 
// groups/attributeGroups and the groups/AttributeGroups which 	TokenNameCOMMENT_LINE	groups/attributeGroups and the groups/AttributeGroups which 
// they redefine by restriction (implicitly). It is up to the 	TokenNameCOMMENT_LINE	they redefine by restriction (implicitly). It is up to the 
// Group and AttributeGroup traversers to check these restrictions for 	TokenNameCOMMENT_LINE	Group and AttributeGroup traversers to check these restrictions for 
// validity. 	TokenNameCOMMENT_LINE	validity. 
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fRedefinedRestrictedAttributeGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Attribute Group Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Hashtable	TokenNameIdentifier	 Hashtable
fRedefinedRestrictedGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Group Registry
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// a variable storing whether the last schema document 	TokenNameCOMMENT_LINE	a variable storing whether the last schema document 
// processed (by getSchema) was a duplicate. 	TokenNameCOMMENT_LINE	processed (by getSchema) was a duplicate. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
;	TokenNameSEMICOLON	
// validate annotations feature 	TokenNameCOMMENT_LINE	validate annotations feature 
private	TokenNameprivate	
boolean	TokenNameboolean	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
//handle multiple import feature 	TokenNameCOMMENT_LINE	handle multiple import feature 
private	TokenNameprivate	
boolean	TokenNameboolean	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
//handle namespace growth feature 	TokenNameCOMMENT_LINE	handle namespace growth feature 
boolean	TokenNameboolean	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// handle tolerate duplicates feature 	TokenNameCOMMENT_LINE	handle tolerate duplicates feature 
boolean	TokenNameboolean	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// the XMLErrorReporter 	TokenNameCOMMENT_LINE	the XMLErrorReporter 
private	TokenNameprivate	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fErrorReporter	TokenNameIdentifier	 f Error Reporter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
;	TokenNameSEMICOLON	
// the XSAttributeChecker 	TokenNameCOMMENT_LINE	the XSAttributeChecker 
private	TokenNameprivate	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
;	TokenNameSEMICOLON	
// the symbol table 	TokenNameCOMMENT_LINE	the symbol table 
private	TokenNameprivate	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
// the GrammarResolver 	TokenNameCOMMENT_LINE	the GrammarResolver 
private	TokenNameprivate	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
;	TokenNameSEMICOLON	
// the Grammar description 	TokenNameCOMMENT_LINE	the Grammar description 
private	TokenNameprivate	
XSDDescription	TokenNameIdentifier	 XSD Description
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
;	TokenNameSEMICOLON	
// the Grammar Pool 	TokenNameCOMMENT_LINE	the Grammar Pool 
private	TokenNameprivate	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
;	TokenNameSEMICOLON	
//************ Traversers ********** 	TokenNameCOMMENT_LINE	************ Traversers ********** 
XSDAttributeGroupTraverser	TokenNameIdentifier	 XSD Attribute Group Traverser
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
;	TokenNameSEMICOLON	
XSDAttributeTraverser	TokenNameIdentifier	 XSD Attribute Traverser
fAttributeTraverser	TokenNameIdentifier	 f Attribute Traverser
;	TokenNameSEMICOLON	
XSDComplexTypeTraverser	TokenNameIdentifier	 XSD Complex Type Traverser
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
;	TokenNameSEMICOLON	
XSDElementTraverser	TokenNameIdentifier	 XSD Element Traverser
fElementTraverser	TokenNameIdentifier	 f Element Traverser
;	TokenNameSEMICOLON	
XSDGroupTraverser	TokenNameIdentifier	 XSD Group Traverser
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
;	TokenNameSEMICOLON	
XSDKeyrefTraverser	TokenNameIdentifier	 XSD Keyref Traverser
fKeyrefTraverser	TokenNameIdentifier	 f Keyref Traverser
;	TokenNameSEMICOLON	
XSDNotationTraverser	TokenNameIdentifier	 XSD Notation Traverser
fNotationTraverser	TokenNameIdentifier	 f Notation Traverser
;	TokenNameSEMICOLON	
XSDSimpleTypeTraverser	TokenNameIdentifier	 XSD Simple Type Traverser
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
;	TokenNameSEMICOLON	
XSDUniqueOrKeyTraverser	TokenNameIdentifier	 XSD Unique Or Key Traverser
fUniqueOrKeyTraverser	TokenNameIdentifier	 f Unique Or Key Traverser
;	TokenNameSEMICOLON	
XSDWildcardTraverser	TokenNameIdentifier	 XSD Wildcard Traverser
fWildCardTraverser	TokenNameIdentifier	 f Wild Card Traverser
;	TokenNameSEMICOLON	
SchemaDVFactory	TokenNameIdentifier	 Schema DV Factory
fDVFactory	TokenNameIdentifier	 f DV Factory
;	TokenNameSEMICOLON	
SchemaDOMParser	TokenNameIdentifier	 Schema DOM Parser
fSchemaParser	TokenNameIdentifier	 f Schema Parser
;	TokenNameSEMICOLON	
SchemaContentHandler	TokenNameIdentifier	 Schema Content Handler
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
;	TokenNameSEMICOLON	
StAXSchemaParser	TokenNameIdentifier	 St AX Schema Parser
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
;	TokenNameSEMICOLON	
XML11Configuration	TokenNameIdentifier	 XM L11 Configuration
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
;	TokenNameSEMICOLON	
XSAnnotationGrammarPool	TokenNameIdentifier	 XS Annotation Grammar Pool
fGrammarBucketAdapter	TokenNameIdentifier	 f Grammar Bucket Adapter
;	TokenNameSEMICOLON	
// these data members are needed for the deferred traversal 	TokenNameCOMMENT_LINE	these data members are needed for the deferred traversal 
// of local elements. 	TokenNameCOMMENT_LINE	of local elements. 
// the initial size of the array to store deferred local elements 	TokenNameCOMMENT_LINE	the initial size of the array to store deferred local elements 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// the incremental size of the array to store deferred local elements 	TokenNameCOMMENT_LINE	the incremental size of the array to store deferred local elements 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// current position of the array (# of deferred local elements) 	TokenNameCOMMENT_LINE	current position of the array (# of deferred local elements) 
private	TokenNameprivate	
int	TokenNameint	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
=	TokenNameEQUAL	
new	TokenNamenew	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
=	TokenNameEQUAL	
new	TokenNamenew	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//JACK 	TokenNameCOMMENT_LINE	JACK 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fAllContext	TokenNameIdentifier	 f All Context
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fParent	TokenNameIdentifier	 f Parent
=	TokenNameEQUAL	
new	TokenNamenew	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INIT_STACK_SIZE	TokenNameIdentifier	 INIT  STACK  SIZE
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// these data members are needed for the deferred traversal 	TokenNameCOMMENT_LINE	these data members are needed for the deferred traversal 
// of keyrefs. 	TokenNameCOMMENT_LINE	of keyrefs. 
// the initial size of the array to store deferred keyrefs 	TokenNameCOMMENT_LINE	the initial size of the array to store deferred keyrefs 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INIT_KEYREF_STACK	TokenNameIdentifier	 INIT  KEYREF  STACK
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// the incremental size of the array to store deferred keyrefs 	TokenNameCOMMENT_LINE	the incremental size of the array to store deferred keyrefs 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INC_KEYREF_STACK_AMOUNT	TokenNameIdentifier	 INC  KEYREF  STACK  AMOUNT
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// current position of the array (# of deferred keyrefs) 	TokenNameCOMMENT_LINE	current position of the array (# of deferred keyrefs) 
private	TokenNameprivate	
int	TokenNameint	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
=	TokenNameEQUAL	
new	TokenNamenew	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
INIT_KEYREF_STACK	TokenNameIdentifier	 INIT  KEYREF  STACK
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
=	TokenNameEQUAL	
new	TokenNamenew	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
INIT_KEYREF_STACK	TokenNameIdentifier	 INIT  KEYREF  STACK
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
INIT_KEYREF_STACK	TokenNameIdentifier	 INIT  KEYREF  STACK
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
INIT_KEYREF_STACK	TokenNameIdentifier	 INIT  KEYREF  STACK
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// global decls: map from decl name to decl object 	TokenNameCOMMENT_LINE	global decls: map from decl name to decl object 
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalAttrDecls	TokenNameIdentifier	 f Global Attr Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalAttrGrpDecls	TokenNameIdentifier	 f Global Attr Grp Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalElemDecls	TokenNameIdentifier	 f Global Elem Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalGroupDecls	TokenNameIdentifier	 f Global Group Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalNotationDecls	TokenNameIdentifier	 f Global Notation Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalIDConstraintDecls	TokenNameIdentifier	 f Global ID Constraint Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SymbolHash	TokenNameIdentifier	 Symbol Hash
fGlobalTypeDecls	TokenNameIdentifier	 f Global Type Decls
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolHash	TokenNameIdentifier	 Symbol Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
public	TokenNamepublic	
XSDHandler	TokenNameIdentifier	 XSD Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaDOMParser	TokenNameIdentifier	 Schema DOM Parser
(	TokenNameLPAREN	
new	TokenNamenew	
SchemaParsingConfig	TokenNameIdentifier	 Schema Parsing Config
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// it should be possible to use the same XSDHandler to parse 	TokenNameCOMMENT_LINE	it should be possible to use the same XSDHandler to parse 
// multiple schema documents; this will allow one to be 	TokenNameCOMMENT_LINE	multiple schema documents; this will allow one to be 
// constructed. 	TokenNameCOMMENT_LINE	constructed. 
public	TokenNamepublic	
XSDHandler	TokenNameIdentifier	 XSD Handler
(	TokenNameLPAREN	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
gBucket	TokenNameIdentifier	 g Bucket
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
=	TokenNameEQUAL	
gBucket	TokenNameIdentifier	 g Bucket
;	TokenNameSEMICOLON	
// Note: don't use SchemaConfiguration internally 	TokenNameCOMMENT_LINE	Note: don't use SchemaConfiguration internally 
// we will get stack overflaw because 	TokenNameCOMMENT_LINE	we will get stack overflaw because 
// XMLSchemaValidator will be instantiating XSDHandler... 	TokenNameCOMMENT_LINE	XMLSchemaValidator will be instantiating XSDHandler... 
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end constructor 	TokenNameCOMMENT_LINE	end constructor 
/** * This method initiates the parse of a schema. It will likely be * called from the Validator and it will make the * resulting grammar available; it returns a reference to this object just * in case. A reset(XMLComponentManager) must be called before this methods is called. * @param is * @param desc * @param locationPairs * @return the SchemaGrammar * @throws IOException */	TokenNameCOMMENT_JAVADOC	 This method initiates the parse of a schema. It will likely be called from the Validator and it will make the resulting grammar available; it returns a reference to this object just in case. A reset(XMLComponentManager) must be called before this methods is called. @param is @param desc @param locationPairs @return the SchemaGrammar @throws IOException 
public	TokenNamepublic	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
parseSchema	TokenNameIdentifier	 parse Schema
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
locationPairs	TokenNameIdentifier	 location Pairs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
=	TokenNameEQUAL	
locationPairs	TokenNameIdentifier	 location Pairs
;	TokenNameSEMICOLON	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
resetNodePool	TokenNameIdentifier	 reset Node Pool
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if loading using JAXP schemaSource property, or using grammar caching loadGrammar 	TokenNameCOMMENT_LINE	if loading using JAXP schemaSource property, or using grammar caching loadGrammar 
// the desc.targetNamespace is always null. 	TokenNameCOMMENT_LINE	the desc.targetNamespace is always null. 
// Therefore we should not attempt to find out if 	TokenNameCOMMENT_LINE	Therefore we should not attempt to find out if 
// the schema is already in the bucket, since in the case we have 	TokenNameCOMMENT_LINE	the schema is already in the bucket, since in the case we have 
// no namespace schema in the bucket, findGrammar will always return the 	TokenNameCOMMENT_LINE	no namespace schema in the bucket, findGrammar will always return the 
// no namespace schema. 	TokenNameCOMMENT_LINE	no namespace schema. 
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first try to find it in the bucket/pool, return if one is found 	TokenNameCOMMENT_LINE	first try to find it in the bucket/pool, return if one is found 
if	TokenNameif	
(	TokenNameLPAREN	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
&&	TokenNameAND_AND	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_IMPORT	TokenNameIdentifier	 CONTEXT  IMPORT
&&	TokenNameAND_AND	
isExistingGrammar	TokenNameIdentifier	 is Existing Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//REVISIT: return the grammar? 	TokenNameCOMMENT_LINE	REVISIT: return the grammar? 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// handle empty string URI as null 	TokenNameCOMMENT_LINE	handle empty string URI as null 
if	TokenNameif	
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// before parsing a schema, need to clear registries associated with 	TokenNameCOMMENT_LINE	before parsing a schema, need to clear registries associated with 
// parsing schemas 	TokenNameCOMMENT_LINE	parsing schemas 
prepareForParse	TokenNameIdentifier	 prepare For Parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// first phase: construct trees. 	TokenNameCOMMENT_LINE	first phase: construct trees. 
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
instanceof	TokenNameinstanceof	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DOMInputSource 	TokenNameCOMMENT_LINE	DOMInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
instanceof	TokenNameinstanceof	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// SAXInputSource 	TokenNameCOMMENT_LINE	SAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
instanceof	TokenNameinstanceof	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// StAXInputSource 	TokenNameCOMMENT_LINE	StAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
instanceof	TokenNameinstanceof	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XSInputSource 	TokenNameCOMMENT_LINE	XSInputSource 
else	TokenNameelse	
{	TokenNameLBRACE	
schemaRoot	TokenNameIdentifier	 schema Root
=	TokenNameEQUAL	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
is	TokenNameIdentifier	 is
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//is instanceof XMLInputSource 	TokenNameCOMMENT_LINE	is instanceof XMLInputSource 
if	TokenNameif	
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// something went wrong right off the hop 	TokenNameCOMMENT_LINE	something went wrong right off the hop 
if	TokenNameif	
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
instanceof	TokenNameinstanceof	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
schemaElem	TokenNameIdentifier	 schema Elem
=	TokenNameEQUAL	
schemaRoot	TokenNameIdentifier	 schema Root
;	TokenNameSEMICOLON	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
schemaElem	TokenNameIdentifier	 schema Elem
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_TARGETNAMESPACE	TokenNameIdentifier	 ATT  TARGETNAMESPACE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
schemaNamespace	TokenNameIdentifier	 schema Namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Since now we've discovered a namespace, we need to update xsd key 	TokenNameCOMMENT_LINE	Since now we've discovered a namespace, we need to update xsd key 
// and store this schema in traversed schemas bucket 	TokenNameCOMMENT_LINE	and store this schema in traversed schemas bucket 
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// When namespace growth is enabled and a null location is provided we cannot tell 	TokenNameCOMMENT_LINE	When namespace growth is enabled and a null location is provided we cannot tell 
// whether we've loaded this schema document before so we must assume that we haven't. 	TokenNameCOMMENT_LINE	whether we've loaded this schema document before so we must assume that we haven't. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
||	TokenNameOR_OR	
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// before constructing trees and traversing a schema, need to reset 	TokenNameCOMMENT_LINE	before constructing trees and traversing a schema, need to reset 
// all traversers and clear all registries 	TokenNameCOMMENT_LINE	all traversers and clear all registries 
prepareForTraverse	TokenNameIdentifier	 prepare For Traverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRoot	TokenNameIdentifier	 f Root
=	TokenNameEQUAL	
constructTrees	TokenNameIdentifier	 construct Trees
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
,	TokenNameCOMMA	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fRoot	TokenNameIdentifier	 f Root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// second phase: fill global registries. 	TokenNameCOMMENT_LINE	second phase: fill global registries. 
buildGlobalNameRegistries	TokenNameIdentifier	 build Global Name Registries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// third phase: call traversers 	TokenNameCOMMENT_LINE	third phase: call traversers 
ArrayList	TokenNameIdentifier	 Array List
annotationInfo	TokenNameIdentifier	 annotation Info
=	TokenNameEQUAL	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
?	TokenNameQUESTION	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
traverseSchemas	TokenNameIdentifier	 traverse Schemas
(	TokenNameLPAREN	
annotationInfo	TokenNameIdentifier	 annotation Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fourth phase: handle local element decls 	TokenNameCOMMENT_LINE	fourth phase: handle local element decls 
traverseLocalElements	TokenNameIdentifier	 traverse Local Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fifth phase: handle Keyrefs 	TokenNameCOMMENT_LINE	fifth phase: handle Keyrefs 
resolveKeyRefs	TokenNameIdentifier	 resolve Key Refs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// sixth phase: validate attribute of non-schema namespaces 	TokenNameCOMMENT_LINE	sixth phase: validate attribute of non-schema namespaces 
// REVISIT: skip this for now. we really don't want to do it. 	TokenNameCOMMENT_LINE	REVISIT: skip this for now. we really don't want to do it. 
//fAttributeChecker.checkNonSchemaAttributes(fGrammarBucket); 	TokenNameCOMMENT_LINE	fAttributeChecker.checkNonSchemaAttributes(fGrammarBucket); 
// seventh phase: store imported grammars 	TokenNameCOMMENT_LINE	seventh phase: store imported grammars 
// for all grammars with <import>s 	TokenNameCOMMENT_LINE	for all grammars with <import>s 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fAllTNSs	TokenNameIdentifier	 f All TN Ss
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get its target namespace 	TokenNameCOMMENT_LINE	get its target namespace 
String	TokenNameIdentifier	 String
tns	TokenNameIdentifier	 tns
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fAllTNSs	TokenNameIdentifier	 f All TN Ss
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get all namespaces it imports 	TokenNameCOMMENT_LINE	get all namespaces it imports 
Vector	TokenNameIdentifier	 Vector
ins	TokenNameIdentifier	 ins
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
fImportMap	TokenNameIdentifier	 f Import Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get the grammar 	TokenNameCOMMENT_LINE	get the grammar 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
emptyString2Null	TokenNameIdentifier	 empty String2 Null
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg	TokenNameIdentifier	 isg
;	TokenNameSEMICOLON	
// for imported namespace 	TokenNameCOMMENT_LINE	for imported namespace 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get imported grammar 	TokenNameCOMMENT_LINE	get imported grammar 
isg	TokenNameIdentifier	 isg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// reuse the same vector 	TokenNameCOMMENT_LINE	reuse the same vector 
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set the imported grammars 	TokenNameCOMMENT_LINE	set the imported grammars 
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
setImportedGrammars	TokenNameIdentifier	 set Imported Grammars
(	TokenNameLPAREN	
ins	TokenNameIdentifier	 ins
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** validate annotations **/	TokenNameCOMMENT_JAVADOC	 validate annotations *
if	TokenNameif	
(	TokenNameLPAREN	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
&&	TokenNameAND_AND	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validateAnnotations	TokenNameIdentifier	 validate Annotations
(	TokenNameLPAREN	
annotationInfo	TokenNameIdentifier	 annotation Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// and return. 	TokenNameCOMMENT_LINE	and return. 
return	TokenNamereturn	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
fRoot	TokenNameIdentifier	 f Root
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end parseSchema 	TokenNameCOMMENT_LINE	end parseSchema 
private	TokenNameprivate	
void	TokenNamevoid	
validateAnnotations	TokenNameIdentifier	 validate Annotations
(	TokenNameLPAREN	
ArrayList	TokenNameIdentifier	 Array List
annotationInfo	TokenNameIdentifier	 annotation Info
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createAnnotationValidator	TokenNameIdentifier	 create Annotation Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XMLInputSource	TokenNameIdentifier	 XML Input Source
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
new	TokenNamenew	
XMLInputSource	TokenNameIdentifier	 XML Input Source
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucketAdapter	TokenNameIdentifier	 f Grammar Bucket Adapter
.	TokenNameDOT	
refreshGrammars	TokenNameIdentifier	 refresh Grammars
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
setSystemId	TokenNameIdentifier	 set System Id
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAnnotationInfo	TokenNameIdentifier	 XS Annotation Info
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAnnotationInfo	TokenNameIdentifier	 XS Annotation Info
)	TokenNameRPAREN	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
setCharacterStream	TokenNameIdentifier	 set Character Stream
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
fAnnotation	TokenNameIdentifier	 f Annotation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
exc	TokenNameIdentifier	 exc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
createAnnotationValidator	TokenNameIdentifier	 create Annotation Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
=	TokenNameEQUAL	
new	TokenNamenew	
XML11Configuration	TokenNameIdentifier	 XM L11 Configuration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucketAdapter	TokenNameIdentifier	 f Grammar Bucket Adapter
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationGrammarPool	TokenNameIdentifier	 XS Annotation Grammar Pool
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XMLSCHEMA_VALIDATION	TokenNameIdentifier	 XMLSCHEMA  VALIDATION
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
XMLGRAMMAR_POOL	TokenNameIdentifier	 XMLGRAMMAR  POOL
,	TokenNameCOMMA	
fGrammarBucketAdapter	TokenNameIdentifier	 f Grammar Bucket Adapter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Set error handler. **/	TokenNameCOMMENT_JAVADOC	 Set error handler. *
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
errorHandler	TokenNameIdentifier	 error Handler
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_HANDLER	TokenNameIdentifier	 ERROR  HANDLER
,	TokenNameCOMMA	
(	TokenNameLPAREN	
errorHandler	TokenNameIdentifier	 error Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
errorHandler	TokenNameIdentifier	 error Handler
:	TokenNameCOLON	
new	TokenNamenew	
DefaultErrorHandler	TokenNameIdentifier	 Default Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Set locale. **/	TokenNameCOMMENT_JAVADOC	 Set locale. *
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
LOCALE	TokenNameIdentifier	 LOCALE
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Pull the grammar out of the bucket simply using * its TNS as a key */	TokenNameCOMMENT_JAVADOC	 Pull the grammar out of the bucket simply using its TNS as a key 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * First try to find a grammar in the bucket, if failed, consult the * grammar pool. If a grammar is found in the pool, then add it (and all * imported ones) into the bucket. */	TokenNameCOMMENT_JAVADOC	 First try to find a grammar in the bucket, if failed, consult the grammar pool. If a grammar is found in the pool, then add it (and all imported ones) into the bucket. 
protected	TokenNameprotected	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoreConflict	TokenNameIdentifier	 ignore Conflict
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
.	TokenNameDOT	
retrieveGrammar	TokenNameIdentifier	 retrieve Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// put this grammar into the bucket, along with grammars 	TokenNameCOMMENT_LINE	put this grammar into the bucket, along with grammars 
// imported by it (directly or indirectly) 	TokenNameCOMMENT_LINE	imported by it (directly or indirectly) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
ignoreConflict	TokenNameIdentifier	 ignore Conflict
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: a conflict between new grammar(s) and grammars 	TokenNameCOMMENT_LINE	REVISIT: a conflict between new grammar(s) and grammars 
// in the bucket. What to do? A warning? An exception? 	TokenNameCOMMENT_LINE	in the bucket. What to do? A warning? An exception? 
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
"GrammarConflict"	TokenNameStringLiteral	GrammarConflict
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
sg	TokenNameIdentifier	 sg
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// may wish to have setter methods for ErrorHandler, 	TokenNameCOMMENT_LINE	may wish to have setter methods for ErrorHandler, 
// EntityResolver... 	TokenNameCOMMENT_LINE	EntityResolver... 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
NS_ERROR_CODES	TokenNameIdentifier	 NS  ERROR  CODES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
"src-include.2.1"	TokenNameStringLiteral	src-include.2.1
,	TokenNameCOMMA	
"src-include.2.1"	TokenNameStringLiteral	src-include.2.1
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"src-redefine.3.1"	TokenNameStringLiteral	src-redefine.3.1
,	TokenNameCOMMA	
"src-redefine.3.1"	TokenNameStringLiteral	src-redefine.3.1
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"src-import.3.1"	TokenNameStringLiteral	src-import.3.1
,	TokenNameCOMMA	
"src-import.3.2"	TokenNameStringLiteral	src-import.3.2
}	TokenNameRBRACE	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"TargetNamespace.1"	TokenNameStringLiteral	TargetNamespace.1
,	TokenNameCOMMA	
"TargetNamespace.2"	TokenNameStringLiteral	TargetNamespace.2
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"TargetNamespace.1"	TokenNameStringLiteral	TargetNamespace.1
,	TokenNameCOMMA	
"TargetNamespace.2"	TokenNameStringLiteral	TargetNamespace.2
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"TargetNamespace.1"	TokenNameStringLiteral	TargetNamespace.1
,	TokenNameCOMMA	
"TargetNamespace.2"	TokenNameStringLiteral	TargetNamespace.2
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
"TargetNamespace.1"	TokenNameStringLiteral	TargetNamespace.1
,	TokenNameCOMMA	
"TargetNamespace.2"	TokenNameStringLiteral	TargetNamespace.2
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ELE_ERROR_CODES	TokenNameIdentifier	 ELE  ERROR  CODES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"src-include.1"	TokenNameStringLiteral	src-include.1
,	TokenNameCOMMA	
"src-redefine.2"	TokenNameStringLiteral	src-redefine.2
,	TokenNameCOMMA	
"src-import.2"	TokenNameStringLiteral	src-import.2
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// This method does several things: 	TokenNameCOMMENT_LINE	This method does several things: 
// It constructs an instance of an XSDocumentInfo object using the 	TokenNameCOMMENT_LINE	It constructs an instance of an XSDocumentInfo object using the 
// schemaRoot node. Then, for each <include>, 	TokenNameCOMMENT_LINE	schemaRoot node. Then, for each <include>, 
// <redefine>, and <import> children, it attempts to resolve the 	TokenNameCOMMENT_LINE	<redefine>, and <import> children, it attempts to resolve the 
// requested schema document, initiates a DOM parse, and calls 	TokenNameCOMMENT_LINE	requested schema document, initiates a DOM parse, and calls 
// itself recursively on that document's root. It also records in 	TokenNameCOMMENT_LINE	itself recursively on that document's root. It also records in 
// the DependencyMap object what XSDocumentInfo objects its XSDocumentInfo 	TokenNameCOMMENT_LINE	the DependencyMap object what XSDocumentInfo objects its XSDocumentInfo 
// depends on. 	TokenNameCOMMENT_LINE	depends on. 
// It also makes sure the targetNamespace of the schema it was 	TokenNameCOMMENT_LINE	It also makes sure the targetNamespace of the schema it was 
// called to parse is correct. 	TokenNameCOMMENT_LINE	called to parse is correct. 
protected	TokenNameprotected	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
constructTrees	TokenNameIdentifier	 construct Trees
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
schemaRoot	TokenNameIdentifier	 schema Root
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
locationHint	TokenNameIdentifier	 location Hint
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
nsCollision	TokenNameIdentifier	 ns Collision
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
callerTNS	TokenNameIdentifier	 caller TNS
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// note that attributes are freed at end of traverseSchemas() 	TokenNameCOMMENT_LINE	note that attributes are freed at end of traverseSchemas() 
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
=	TokenNameEQUAL	
new	TokenNamenew	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
ELE_ERROR_CODES	TokenNameIdentifier	 ELE  ERROR  CODES
[	TokenNameLBRACKET	
referType	TokenNameIdentifier	 refer Type
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
locationHint	TokenNameIdentifier	 location Hint
}	TokenNameRBRACE	
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// targetNamespace="" is not valid, issue a warning, and ignore it 	TokenNameCOMMENT_LINE	targetNamespace="" is not valid, issue a warning, and ignore it 
if	TokenNameif	
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
"EmptyTargetNamespace"	TokenNameStringLiteral	EmptyTargetNamespace
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
locationHint	TokenNameIdentifier	 location Hint
}	TokenNameRBRACE	
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
callerTNS	TokenNameIdentifier	 caller TNS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the second index to the NS_ERROR_CODES array 	TokenNameCOMMENT_LINE	the second index to the NS_ERROR_CODES array 
// if the caller/expected NS is not absent, we use the first column 	TokenNameCOMMENT_LINE	if the caller/expected NS is not absent, we use the first column 
int	TokenNameint	
secondIdx	TokenNameIdentifier	 second Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// for include and redefine 	TokenNameCOMMENT_LINE	for include and redefine 
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_INCLUDE	TokenNameIdentifier	 CONTEXT  INCLUDE
||	TokenNameOR_OR	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_REDEFINE	TokenNameIdentifier	 CONTEXT  REDEFINE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the referred document has no targetNamespace, 	TokenNameCOMMENT_LINE	if the referred document has no targetNamespace, 
// it's a chameleon schema 	TokenNameCOMMENT_LINE	it's a chameleon schema 
if	TokenNameif	
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
callerTNS	TokenNameIdentifier	 caller TNS
;	TokenNameSEMICOLON	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fIsChameleonSchema	TokenNameIdentifier	 f Is Chameleon Schema
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if the referred document has a target namespace differing 	TokenNameCOMMENT_LINE	if the referred document has a target namespace differing 
// from the caller, it's an error 	TokenNameCOMMENT_LINE	from the caller, it's an error 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
callerTNS	TokenNameIdentifier	 caller TNS
!=	TokenNameNOT_EQUAL	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
NS_ERROR_CODES	TokenNameIdentifier	 NS  ERROR  CODES
[	TokenNameLBRACKET	
referType	TokenNameIdentifier	 refer Type
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
secondIdx	TokenNameIdentifier	 second Idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
callerTNS	TokenNameIdentifier	 caller TNS
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
}	TokenNameRBRACE	
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for instance and import, the two NS's must be the same 	TokenNameCOMMENT_LINE	for instance and import, the two NS's must be the same 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
&&	TokenNameAND_AND	
callerTNS	TokenNameIdentifier	 caller TNS
!=	TokenNameNOT_EQUAL	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
NS_ERROR_CODES	TokenNameIdentifier	 NS  ERROR  CODES
[	TokenNameLBRACKET	
referType	TokenNameIdentifier	 refer Type
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
secondIdx	TokenNameIdentifier	 second Idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
callerTNS	TokenNameIdentifier	 caller TNS
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
}	TokenNameRBRACE	
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now there is no caller/expected NS, it's an error for the referred 	TokenNameCOMMENT_LINE	now there is no caller/expected NS, it's an error for the referred 
// document to have a target namespace, unless we are preparsing a schema 	TokenNameCOMMENT_LINE	document to have a target namespace, unless we are preparsing a schema 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set the target namespace of the description 	TokenNameCOMMENT_LINE	set the target namespace of the description 
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
callerTNS	TokenNameIdentifier	 caller TNS
=	TokenNameEQUAL	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// the second index to the NS_ERROR_CODES array 	TokenNameCOMMENT_LINE	the second index to the NS_ERROR_CODES array 
// if the caller/expected NS is absent, we use the second column 	TokenNameCOMMENT_LINE	if the caller/expected NS is absent, we use the second column 
int	TokenNameint	
secondIdx	TokenNameIdentifier	 second Idx
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
NS_ERROR_CODES	TokenNameIdentifier	 NS  ERROR  CODES
[	TokenNameLBRACKET	
referType	TokenNameIdentifier	 refer Type
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
secondIdx	TokenNameIdentifier	 second Idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
callerTNS	TokenNameIdentifier	 caller TNS
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
}	TokenNameRBRACE	
,	TokenNameCOMMA	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// the other cases (callerTNS == currSchemaInfo.fTargetNamespce == null) 	TokenNameCOMMENT_LINE	the other cases (callerTNS == currSchemaInfo.fTargetNamespce == null) 
// are valid 	TokenNameCOMMENT_LINE	are valid 
// a schema document can always access it's own target namespace 	TokenNameCOMMENT_LINE	a schema document can always access it's own target namespace 
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
addAllowedNS	TokenNameIdentifier	 add Allowed NS
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// we have a namespace collision 	TokenNameCOMMENT_LINE	we have a namespace collision 
if	TokenNameif	
(	TokenNameLPAREN	
nsCollision	TokenNameIdentifier	 ns Collision
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg2	TokenNameIdentifier	 sg2
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg2	TokenNameIdentifier	 sg2
.	TokenNameDOT	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
(	TokenNameLPAREN	
sg2	TokenNameIdentifier	 sg2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// update all the grammars in the bucket to point to the new grammar. 	TokenNameCOMMENT_LINE	update all the grammars in the bucket to point to the new grammar. 
updateImportListWith	TokenNameIdentifier	 update Import List With
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
sg2	TokenNameIdentifier	 sg2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// update import list of the new grammar 	TokenNameCOMMENT_LINE	update import list of the new grammar 
updateImportListFor	TokenNameIdentifier	 update Import List For
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_INCLUDE	TokenNameIdentifier	 CONTEXT  INCLUDE
||	TokenNameOR_OR	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_REDEFINE	TokenNameIdentifier	 CONTEXT  REDEFINE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
&&	TokenNameAND_AND	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_IMPORT	TokenNameIdentifier	 CONTEXT  IMPORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
makeClone	TokenNameIdentifier	 make Clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
makeClone	TokenNameIdentifier	 make Clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the document and its location 	TokenNameCOMMENT_LINE	store the document and its location 
// REVISIT: don't expose the DOM tree 	TokenNameCOMMENT_LINE	REVISIT: don't expose the DOM tree 
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDoc2XSDocumentMap	TokenNameIdentifier	 f Doc2 XS Document Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
dependencies	TokenNameIdentifier	 dependencies
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
rootNode	TokenNameIdentifier	 root Node
=	TokenNameEQUAL	
schemaRoot	TokenNameIdentifier	 schema Root
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
newSchemaRoot	TokenNameIdentifier	 new Schema Root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaHint	TokenNameIdentifier	 schema Hint
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
importCollision	TokenNameIdentifier	 import Collision
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_IMPORT	TokenNameIdentifier	 ELT  IMPORT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_IMPORT	TokenNameIdentifier	 CONTEXT  IMPORT
;	TokenNameSEMICOLON	
// have to handle some validation here too! 	TokenNameCOMMENT_LINE	have to handle some validation here too! 
// call XSAttributeChecker to fill in attrs 	TokenNameCOMMENT_LINE	call XSAttributeChecker to fill in attrs 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
importAttrs	TokenNameIdentifier	 import Attrs
=	TokenNameEQUAL	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaHint	TokenNameIdentifier	 schema Hint
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
importAttrs	TokenNameIdentifier	 import Attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_SCHEMALOCATION	TokenNameIdentifier	 ATTIDX  SCHEMALOCATION
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
importAttrs	TokenNameIdentifier	 import Attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAMESPACE	TokenNameIdentifier	 ATTIDX  NAMESPACE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check contents and process optional annotations 	TokenNameCOMMENT_LINE	check contents and process optional annotations 
Element	TokenNameIdentifier	 Element
importChild	TokenNameIdentifier	 import Child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
importChild	TokenNameIdentifier	 import Child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
importComponentType	TokenNameIdentifier	 import Component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
importChild	TokenNameIdentifier	 import Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
importComponentType	TokenNameIdentifier	 import Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// promoting annotations to parent component 	TokenNameCOMMENT_LINE	promoting annotations to parent component 
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
importChild	TokenNameIdentifier	 import Child
,	TokenNameCOMMA	
importAttrs	TokenNameIdentifier	 import Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
"annotation?"	TokenNameStringLiteral	annotation?
,	TokenNameCOMMA	
importComponentType	TokenNameIdentifier	 import Component Type
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
importChild	TokenNameIdentifier	 import Child
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
"annotation?"	TokenNameStringLiteral	annotation?
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
importChild	TokenNameIdentifier	 import Child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
importAttrs	TokenNameIdentifier	 import Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
importAttrs	TokenNameIdentifier	 import Attrs
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// a document can't import another document with the same namespace 	TokenNameCOMMENT_LINE	a document can't import another document with the same namespace 
if	TokenNameif	
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
==	TokenNameEQUAL_EQUAL	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"src-import.1.1"	TokenNameStringLiteral	src-import.1.1
:	TokenNameCOLON	
"src-import.1.2"	TokenNameStringLiteral	src-import.1.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaNamespace	TokenNameIdentifier	 schema Namespace
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if this namespace has not been imported by this document, 	TokenNameCOMMENT_LINE	if this namespace has not been imported by this document, 
// then import if multiple imports support is enabled. 	TokenNameCOMMENT_LINE	then import if multiple imports support is enabled. 
if	TokenNameif	
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
isAllowedNS	TokenNameIdentifier	 is Allowed NS
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
&&	TokenNameAND_AND	
!	TokenNameNOT	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
addAllowedNS	TokenNameIdentifier	 add Allowed NS
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// also record the fact that one namespace imports another one 	TokenNameCOMMENT_LINE	also record the fact that one namespace imports another one 
// convert null to "" 	TokenNameCOMMENT_LINE	convert null to "" 
String	TokenNameIdentifier	 String
tns	TokenNameIdentifier	 tns
=	TokenNameEQUAL	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get all namespaces imported by this one 	TokenNameCOMMENT_LINE	get all namespaces imported by this one 
Vector	TokenNameIdentifier	 Vector
ins	TokenNameIdentifier	 ins
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
fImportMap	TokenNameIdentifier	 f Import Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if no namespace was imported, create new Vector 	TokenNameCOMMENT_LINE	if no namespace was imported, create new Vector 
if	TokenNameif	
(	TokenNameLPAREN	
ins	TokenNameIdentifier	 ins
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// record that this one imports other(s) 	TokenNameCOMMENT_LINE	record that this one imports other(s) 
fAllTNSs	TokenNameIdentifier	 f All TN Ss
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ins	TokenNameIdentifier	 ins
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fImportMap	TokenNameIdentifier	 f Import Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
,	TokenNameCOMMA	
ins	TokenNameIdentifier	 ins
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ins	TokenNameIdentifier	 ins
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setContextType	TokenNameIdentifier	 set Context Type
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_IMPORT	TokenNameIdentifier	 CONTEXT  IMPORT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
doc2SystemId	TokenNameIdentifier	 doc2 System Id
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setLiteralSystemId	TokenNameIdentifier	 set Literal System Id
(	TokenNameLPAREN	
schemaHint	TokenNameIdentifier	 schema Hint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaHint	TokenNameIdentifier	 schema Hint
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if a grammar with the same namespace and location exists (or being 	TokenNameCOMMENT_LINE	if a grammar with the same namespace and location exists (or being 
// built), ignore this one (don't traverse it). 	TokenNameCOMMENT_LINE	built), ignore this one (don't traverse it). 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg	TokenNameIdentifier	 isg
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
schemaHint	TokenNameIdentifier	 schema Hint
,	TokenNameCOMMA	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
importCollision	TokenNameIdentifier	 import Collision
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
||	TokenNameOR_OR	
isExistingGrammar	TokenNameIdentifier	 is Existing Grammar
(	TokenNameLPAREN	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//if ((!fHonourAllSchemaLocations && findGrammar(fSchemaGrammarDescription) != null) || isExistingGrammar(fSchemaGrammarDescription)) 	TokenNameCOMMENT_LINE	if ((!fHonourAllSchemaLocations && findGrammar(fSchemaGrammarDescription) != null) || isExistingGrammar(fSchemaGrammarDescription)) 
// continue; 	TokenNameCOMMENT_LINE	continue; 
// If "findGrammar" returns a grammar, then this is not the 	TokenNameCOMMENT_LINE	If "findGrammar" returns a grammar, then this is not the 
// the first time we see a location for a given namespace. 	TokenNameCOMMENT_LINE	the first time we see a location for a given namespace. 
// Don't consult the location pair hashtable in this case, 	TokenNameCOMMENT_LINE	Don't consult the location pair hashtable in this case, 
// otherwise the location will be ignored because it'll get 	TokenNameCOMMENT_LINE	otherwise the location will be ignored because it'll get 
// resolved to the same location as the first hint. 	TokenNameCOMMENT_LINE	resolved to the same location as the first hint. 
newSchemaRoot	TokenNameIdentifier	 new Schema Root
=	TokenNameEQUAL	
resolveSchema	TokenNameIdentifier	 resolve Schema
(	TokenNameLPAREN	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
isg	TokenNameIdentifier	 isg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_INCLUDE	TokenNameIdentifier	 ELT  INCLUDE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// validation for redefine/include will be the same here; just 	TokenNameCOMMENT_LINE	validation for redefine/include will be the same here; just 
// make sure TNS is right (don't care about redef contents 	TokenNameCOMMENT_LINE	make sure TNS is right (don't care about redef contents 
// yet). 	TokenNameCOMMENT_LINE	yet). 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
includeAttrs	TokenNameIdentifier	 include Attrs
=	TokenNameEQUAL	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaHint	TokenNameIdentifier	 schema Hint
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
includeAttrs	TokenNameIdentifier	 include Attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_SCHEMALOCATION	TokenNameIdentifier	 ATTIDX  SCHEMALOCATION
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// store the namespace decls of the redefine element 	TokenNameCOMMENT_LINE	store the namespace decls of the redefine element 
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRedefine2NSSupport	TokenNameIdentifier	 f Redefine2 NS Support
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
new	TokenNamenew	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check annotations. Must do this here to avoid having to 	TokenNameCOMMENT_LINE	check annotations. Must do this here to avoid having to 
// re-parse attributes later 	TokenNameCOMMENT_LINE	re-parse attributes later 
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_INCLUDE	TokenNameIdentifier	 ELT  INCLUDE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
includeChild	TokenNameIdentifier	 include Child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeChild	TokenNameIdentifier	 include Child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
includeComponentType	TokenNameIdentifier	 include Component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
includeChild	TokenNameIdentifier	 include Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeComponentType	TokenNameIdentifier	 include Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// promoting annotations to parent component 	TokenNameCOMMENT_LINE	promoting annotations to parent component 
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
includeChild	TokenNameIdentifier	 include Child
,	TokenNameCOMMA	
includeAttrs	TokenNameIdentifier	 include Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
"annotation?"	TokenNameStringLiteral	annotation?
,	TokenNameCOMMA	
includeComponentType	TokenNameIdentifier	 include Component Type
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
includeChild	TokenNameIdentifier	 include Child
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
"annotation?"	TokenNameStringLiteral	annotation?
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
includeChild	TokenNameIdentifier	 include Child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
includeAttrs	TokenNameIdentifier	 include Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
redefinedChild	TokenNameIdentifier	 redefined Child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
redefinedChild	TokenNameIdentifier	 redefined Child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
redefinedChild	TokenNameIdentifier	 redefined Child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
redefinedChild	TokenNameIdentifier	 redefined Child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
redefinedChild	TokenNameIdentifier	 redefined Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// promoting annotations to parent component 	TokenNameCOMMENT_LINE	promoting annotations to parent component 
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
redefinedChild	TokenNameIdentifier	 redefined Child
,	TokenNameCOMMA	
includeAttrs	TokenNameIdentifier	 include Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
redefinedChild	TokenNameIdentifier	 redefined Child
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
includeAttrs	TokenNameIdentifier	 include Attrs
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// catch all other content errors later 	TokenNameCOMMENT_LINE	catch all other content errors later 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
includeAttrs	TokenNameIdentifier	 include Attrs
,	TokenNameCOMMA	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// schemaLocation is required on <include> and <redefine> 	TokenNameCOMMENT_LINE	schemaLocation is required on <include> and <redefine> 
if	TokenNameif	
(	TokenNameLPAREN	
schemaHint	TokenNameIdentifier	 schema Hint
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"<include> or <redefine>"	TokenNameStringLiteral	<include> or <redefine>
,	TokenNameCOMMA	
"schemaLocation"	TokenNameStringLiteral	schemaLocation
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// pass the systemId of the current document as the base systemId 	TokenNameCOMMENT_LINE	pass the systemId of the current document as the base systemId 
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_INCLUDE	TokenNameIdentifier	 CONTEXT  INCLUDE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mustResolve	TokenNameIdentifier	 must Resolve
=	TokenNameEQUAL	
nonAnnotationContent	TokenNameIdentifier	 non Annotation Content
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_REDEFINE	TokenNameIdentifier	 CONTEXT  REDEFINE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setContextType	TokenNameIdentifier	 set Context Type
(	TokenNameLPAREN	
refType	TokenNameIdentifier	 ref Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
doc2SystemId	TokenNameIdentifier	 doc2 System Id
(	TokenNameLPAREN	
schemaRoot	TokenNameIdentifier	 schema Root
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaHint	TokenNameIdentifier	 schema Hint
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
callerTNS	TokenNameIdentifier	 caller TNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
alreadyTraversed	TokenNameIdentifier	 already Traversed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
=	TokenNameEQUAL	
resolveSchemaSource	TokenNameIdentifier	 resolve Schema Source
(	TokenNameLPAREN	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
&&	TokenNameAND_AND	
refType	TokenNameIdentifier	 ref Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_INCLUDE	TokenNameIdentifier	 CONTEXT  INCLUDE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
alreadyTraversed	TokenNameIdentifier	 already Traversed
=	TokenNameEQUAL	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
alreadyTraversed	TokenNameIdentifier	 already Traversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
=	TokenNameEQUAL	
resolveSchema	TokenNameIdentifier	 resolve Schema
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaNamespace	TokenNameIdentifier	 schema Namespace
=	TokenNameEQUAL	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no more possibility of schema references in well-formed 	TokenNameCOMMENT_LINE	no more possibility of schema references in well-formed 
// schema... 	TokenNameCOMMENT_LINE	schema... 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the schema is duplicate, we needn't call constructTrees() again. 	TokenNameCOMMENT_LINE	If the schema is duplicate, we needn't call constructTrees() again. 
// To handle mutual <include>s 	TokenNameCOMMENT_LINE	To handle mutual <include>s 
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
newSchemaInfo	TokenNameIdentifier	 new Schema Info
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
=	TokenNameEQUAL	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fDoc2XSDocumentMap	TokenNameIdentifier	 f Doc2 XS Document Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
=	TokenNameEQUAL	
constructTrees	TokenNameIdentifier	 construct Trees
(	TokenNameLPAREN	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
,	TokenNameCOMMA	
schemaHint	TokenNameIdentifier	 schema Hint
,	TokenNameCOMMA	
fSchemaGrammarDescription	TokenNameIdentifier	 f Schema Grammar Description
,	TokenNameCOMMA	
importCollision	TokenNameIdentifier	 import Collision
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// must record which schema we're redefining so that we can 	TokenNameCOMMENT_LINE	must record which schema we're redefining so that we can 
// rename the right things later! 	TokenNameCOMMENT_LINE	rename the right things later! 
fRedefine2XSDMap	TokenNameIdentifier	 f Redefine2 XSD Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
dependencies	TokenNameIdentifier	 dependencies
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
newSchemaInfo	TokenNameIdentifier	 new Schema Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSchemaRoot	TokenNameIdentifier	 new Schema Root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fDependencyMap	TokenNameIdentifier	 f Dependency Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
currSchemaInfo	TokenNameIdentifier	 curr Schema Info
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end constructTrees 	TokenNameCOMMENT_LINE	end constructTrees 
private	TokenNameprivate	
boolean	TokenNameboolean	
isExistingGrammar	TokenNameIdentifier	 is Existing Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
ignoreConflict	TokenNameIdentifier	 ignore Conflict
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
ignoreConflict	TokenNameIdentifier	 ignore Conflict
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getLiteralSystemId	TokenNameIdentifier	 get Literal System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Namespace growth * * Go through the import list of a given grammar and for each imported * grammar, check to see if the grammar bucket has a newer version. * If a new instance is found, we update the import list with the * newer version. */	TokenNameCOMMENT_JAVADOC	 Namespace growth * Go through the import list of a given grammar and for each imported grammar, check to see if the grammar bucket has a newer version. If a new instance is found, we update the import list with the newer version. 
private	TokenNameprivate	
void	TokenNamevoid	
updateImportListFor	TokenNameIdentifier	 update Import List For
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
importedGrammars	TokenNameIdentifier	 imported Grammars
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
importedGrammars	TokenNameIdentifier	 imported Grammars
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg1	TokenNameIdentifier	 isg1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg2	TokenNameIdentifier	 isg2
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
isg1	TokenNameIdentifier	 isg1
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isg2	TokenNameIdentifier	 isg2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
isg1	TokenNameIdentifier	 isg1
!=	TokenNameNOT_EQUAL	
isg2	TokenNameIdentifier	 isg2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
isg2	TokenNameIdentifier	 isg2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Namespace growth * * Go throuth the grammar bucket, and for each grammar in the bucket * check the import list. If there exists a grammar in import list * that has the same namespace as newGrammar, but a different instance, * then update the import list and replace the old grammar instance with * the new one */	TokenNameCOMMENT_JAVADOC	 Namespace growth * Go throuth the grammar bucket, and for each grammar in the bucket check the import list. If there exists a grammar in import list that has the same namespace as newGrammar, but a different instance, then update the import list and replace the old grammar instance with the new one 
private	TokenNameprivate	
void	TokenNamevoid	
updateImportListWith	TokenNameIdentifier	 update Import List With
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
schemaGrammars	TokenNameIdentifier	 schema Grammars
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammars	TokenNameIdentifier	 get Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
schemaGrammars	TokenNameIdentifier	 schema Grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
schemaGrammars	TokenNameIdentifier	 schema Grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
!=	TokenNameNOT_EQUAL	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
importedGrammars	TokenNameIdentifier	 imported Grammars
=	TokenNameEQUAL	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
importedGrammars	TokenNameIdentifier	 imported Grammars
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg	TokenNameIdentifier	 isg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
newGrammar	TokenNameIdentifier	 new Grammar
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
!=	TokenNameNOT_EQUAL	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
,	TokenNameCOMMA	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// This method builds registries for all globally-referenceable 	TokenNameCOMMENT_LINE	This method builds registries for all globally-referenceable 
// names. A registry will be built for each symbol space defined 	TokenNameCOMMENT_LINE	names. A registry will be built for each symbol space defined 
// by the spec. It is also this method's job to rename redefined 	TokenNameCOMMENT_LINE	by the spec. It is also this method's job to rename redefined 
// components, and to record which components redefine others (so 	TokenNameCOMMENT_LINE	components, and to record which components redefine others (so 
// that implicit redefinitions of groups and attributeGroups can be handled). 	TokenNameCOMMENT_LINE	that implicit redefinitions of groups and attributeGroups can be handled). 
protected	TokenNameprotected	
void	TokenNamevoid	
buildGlobalNameRegistries	TokenNameIdentifier	 build Global Name Registries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Starting with fRoot, we examine each child of the schema 	TokenNameCOMMENT_LINE	Starting with fRoot, we examine each child of the schema 
// element. Skipping all imports and includes, we record the names 	TokenNameCOMMENT_LINE	element. Skipping all imports and includes, we record the names 
// of all other global components (and children of <redefine>). We 	TokenNameCOMMENT_LINE	of all other global components (and children of <redefine>). We 
// also put <redefine> names in a registry that we look through in 	TokenNameCOMMENT_LINE	also put <redefine> names in a registry that we look through in 
// case something needs renaming. Once we're done with a schema we 	TokenNameCOMMENT_LINE	case something needs renaming. Once we're done with a schema we 
// set its Document node to hidden so that we don't try to traverse 	TokenNameCOMMENT_LINE	set its Document node to hidden so that we don't try to traverse 
// it again; then we look to its Dependency map entry. We keep a 	TokenNameCOMMENT_LINE	it again; then we look to its Dependency map entry. We keep a 
// stack of schemas that we haven't yet finished processing; this 	TokenNameCOMMENT_LINE	stack of schemas that we haven't yet finished processing; this 
// is a depth-first traversal. 	TokenNameCOMMENT_LINE	is a depth-first traversal. 
Stack	TokenNameIdentifier	 Stack
schemasToProcess	TokenNameIdentifier	 schemas To Process
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fRoot	TokenNameIdentifier	 f Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
empty	TokenNameIdentifier	 empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
currDoc	TokenNameIdentifier	 curr Doc
=	TokenNameEQUAL	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
isHidden	TokenNameIdentifier	 is Hidden
(	TokenNameLPAREN	
currDoc	TokenNameIdentifier	 curr Doc
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// must have processed this already! 	TokenNameCOMMENT_LINE	must have processed this already! 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
currRoot	TokenNameIdentifier	 curr Root
=	TokenNameEQUAL	
currDoc	TokenNameIdentifier	 curr Doc
;	TokenNameSEMICOLON	
// process this schema's global decls 	TokenNameCOMMENT_LINE	process this schema's global decls 
boolean	TokenNameboolean	
dependenciesCanOccur	TokenNameIdentifier	 dependencies Can Occur
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
globalComp	TokenNameIdentifier	 global Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
currRoot	TokenNameIdentifier	 curr Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
globalComp	TokenNameIdentifier	 global Comp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
globalComp	TokenNameIdentifier	 global Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this loop makes sure the <schema> element ordering is 	TokenNameCOMMENT_LINE	this loop makes sure the <schema> element ordering is 
// also valid. 	TokenNameCOMMENT_LINE	also valid. 
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//skip it; traverse it later 	TokenNameCOMMENT_LINE	skip it; traverse it later 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_INCLUDE	TokenNameIdentifier	 ELT  INCLUDE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_IMPORT	TokenNameIdentifier	 ELT  IMPORT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dependenciesCanOccur	TokenNameIdentifier	 dependencies Can Occur
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.3"	TokenNameStringLiteral	s4s-elt-invalid-content.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dependenciesCanOccur	TokenNameIdentifier	 dependencies Can Occur
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.3"	TokenNameStringLiteral	s4s-elt-invalid-content.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
redefineComp	TokenNameIdentifier	 redefine Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
redefineComp	TokenNameIdentifier	 redefine Comp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
redefineComp	TokenNameIdentifier	 redefine Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
lName	TokenNameIdentifier	 l Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lName	TokenNameIdentifier	 l Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// an error we'll catch later 	TokenNameCOMMENT_LINE	an error we'll catch later 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
qName	TokenNameIdentifier	 q Name
=	TokenNameEQUAL	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
lName	TokenNameIdentifier	 l Name
:	TokenNameCOLON	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
lName	TokenNameIdentifier	 l Name
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
,	TokenNameCOMMA	
fUnparsedAttributeGroupRegistry	TokenNameIdentifier	 f Unparsed Attribute Group Registry
,	TokenNameCOMMA	
fUnparsedAttributeGroupRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Group Registry Sub
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the check will have changed our name; 	TokenNameCOMMENT_LINE	the check will have changed our name; 
String	TokenNameIdentifier	 String
targetLName	TokenNameIdentifier	 target L Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
+	TokenNamePLUS	
REDEF_IDENTIFIER	TokenNameIdentifier	 REDEF  IDENTIFIER
;	TokenNameSEMICOLON	
// and all we need to do is error-check+rename our kkids: 	TokenNameCOMMENT_LINE	and all we need to do is error-check+rename our kkids: 
renameRedefiningComponents	TokenNameIdentifier	 rename Redefining Components
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
,	TokenNameCOMMA	
lName	TokenNameIdentifier	 l Name
,	TokenNameCOMMA	
targetLName	TokenNameIdentifier	 target L Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
fUnparsedTypeRegistry	TokenNameIdentifier	 f Unparsed Type Registry
,	TokenNameCOMMA	
fUnparsedTypeRegistrySub	TokenNameIdentifier	 f Unparsed Type Registry Sub
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the check will have changed our name; 	TokenNameCOMMENT_LINE	the check will have changed our name; 
String	TokenNameIdentifier	 String
targetLName	TokenNameIdentifier	 target L Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
+	TokenNamePLUS	
REDEF_IDENTIFIER	TokenNameIdentifier	 REDEF  IDENTIFIER
;	TokenNameSEMICOLON	
// and all we need to do is error-check+rename our kkids: 	TokenNameCOMMENT_LINE	and all we need to do is error-check+rename our kkids: 
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
renameRedefiningComponents	TokenNameIdentifier	 rename Redefining Components
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
,	TokenNameCOMMA	
lName	TokenNameIdentifier	 l Name
,	TokenNameCOMMA	
targetLName	TokenNameIdentifier	 target L Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// must be simpleType 	TokenNameCOMMENT_LINE	must be simpleType 
renameRedefiningComponents	TokenNameIdentifier	 rename Redefining Components
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
,	TokenNameCOMMA	
lName	TokenNameIdentifier	 l Name
,	TokenNameCOMMA	
targetLName	TokenNameIdentifier	 target L Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
,	TokenNameCOMMA	
fUnparsedGroupRegistry	TokenNameIdentifier	 f Unparsed Group Registry
,	TokenNameCOMMA	
fUnparsedGroupRegistrySub	TokenNameIdentifier	 f Unparsed Group Registry Sub
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the check will have changed our name; 	TokenNameCOMMENT_LINE	the check will have changed our name; 
String	TokenNameIdentifier	 String
targetLName	TokenNameIdentifier	 target L Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
+	TokenNamePLUS	
REDEF_IDENTIFIER	TokenNameIdentifier	 REDEF  IDENTIFIER
;	TokenNameSEMICOLON	
// and all we need to do is error-check+rename our kids: 	TokenNameCOMMENT_LINE	and all we need to do is error-check+rename our kids: 
renameRedefiningComponents	TokenNameIdentifier	 rename Redefining Components
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
redefineComp	TokenNameIdentifier	 redefine Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
,	TokenNameCOMMA	
lName	TokenNameIdentifier	 l Name
,	TokenNameCOMMA	
targetLName	TokenNameIdentifier	 target L Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end march through <redefine> children 	TokenNameCOMMENT_LINE	end march through <redefine> children 
// and now set as traversed 	TokenNameCOMMENT_LINE	and now set as traversed 
//DOMUtil.setHidden(globalComp); 	TokenNameCOMMENT_LINE	DOMUtil.setHidden(globalComp); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dependenciesCanOccur	TokenNameIdentifier	 dependencies Can Occur
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
lName	TokenNameIdentifier	 l Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lName	TokenNameIdentifier	 l Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// an error we'll catch later 	TokenNameCOMMENT_LINE	an error we'll catch later 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
qName	TokenNameIdentifier	 q Name
=	TokenNameEQUAL	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
lName	TokenNameIdentifier	 l Name
:	TokenNameCOLON	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
lName	TokenNameIdentifier	 l Name
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTE	TokenNameIdentifier	 ELT  ATTRIBUTE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
,	TokenNameCOMMA	
fUnparsedAttributeRegistry	TokenNameIdentifier	 f Unparsed Attribute Registry
,	TokenNameCOMMA	
fUnparsedAttributeRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
,	TokenNameCOMMA	
fUnparsedAttributeGroupRegistry	TokenNameIdentifier	 f Unparsed Attribute Group Registry
,	TokenNameCOMMA	
fUnparsedAttributeGroupRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Group Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
fUnparsedTypeRegistry	TokenNameIdentifier	 f Unparsed Type Registry
,	TokenNameCOMMA	
fUnparsedTypeRegistrySub	TokenNameIdentifier	 f Unparsed Type Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ELEMENT	TokenNameIdentifier	 ELT  ELEMENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
,	TokenNameCOMMA	
fUnparsedElementRegistry	TokenNameIdentifier	 f Unparsed Element Registry
,	TokenNameCOMMA	
fUnparsedElementRegistrySub	TokenNameIdentifier	 f Unparsed Element Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
,	TokenNameCOMMA	
fUnparsedGroupRegistry	TokenNameIdentifier	 f Unparsed Group Registry
,	TokenNameCOMMA	
fUnparsedGroupRegistrySub	TokenNameIdentifier	 f Unparsed Group Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_NOTATION	TokenNameIdentifier	 ELT  NOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
,	TokenNameCOMMA	
fUnparsedNotationRegistry	TokenNameIdentifier	 f Unparsed Notation Registry
,	TokenNameCOMMA	
fUnparsedNotationRegistrySub	TokenNameIdentifier	 f Unparsed Notation Registry Sub
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end for 	TokenNameCOMMENT_LINE	end for 
// now we're done with this one! 	TokenNameCOMMENT_LINE	now we're done with this one! 
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
currDoc	TokenNameIdentifier	 curr Doc
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now add the schemas this guy depends on 	TokenNameCOMMENT_LINE	now add the schemas this guy depends on 
Vector	TokenNameIdentifier	 Vector
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
fDependencyMap	TokenNameIdentifier	 f Dependency Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// while 	TokenNameCOMMENT_LINE	while 
}	TokenNameRBRACE	
// end buildGlobalNameRegistries 	TokenNameCOMMENT_LINE	end buildGlobalNameRegistries 
// Beginning at the first schema processing was requested for 	TokenNameCOMMENT_LINE	Beginning at the first schema processing was requested for 
// (fRoot), this method 	TokenNameCOMMENT_LINE	(fRoot), this method 
// examines each child (global schema information item) of each 	TokenNameCOMMENT_LINE	examines each child (global schema information item) of each 
// schema document (and of each <redefine> element) 	TokenNameCOMMENT_LINE	schema document (and of each <redefine> element) 
// corresponding to an XSDocumentInfo object. If the 	TokenNameCOMMENT_LINE	corresponding to an XSDocumentInfo object. If the 
// readOnly field on that node has not been set, it calls an 	TokenNameCOMMENT_LINE	readOnly field on that node has not been set, it calls an 
// appropriate traverser to traverse it. Once all global decls in 	TokenNameCOMMENT_LINE	appropriate traverser to traverse it. Once all global decls in 
// an XSDocumentInfo object have been traversed, it marks that object 	TokenNameCOMMENT_LINE	an XSDocumentInfo object have been traversed, it marks that object 
// as traversed (or hidden) in order to avoid infinite loops. It completes 	TokenNameCOMMENT_LINE	as traversed (or hidden) in order to avoid infinite loops. It completes 
// when it has visited all XSDocumentInfo objects in the 	TokenNameCOMMENT_LINE	when it has visited all XSDocumentInfo objects in the 
// DependencyMap and marked them as traversed. 	TokenNameCOMMENT_LINE	DependencyMap and marked them as traversed. 
protected	TokenNameprotected	
void	TokenNamevoid	
traverseSchemas	TokenNameIdentifier	 traverse Schemas
(	TokenNameLPAREN	
ArrayList	TokenNameIdentifier	 Array List
annotationInfo	TokenNameIdentifier	 annotation Info
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the process here is very similar to that in 	TokenNameCOMMENT_LINE	the process here is very similar to that in 
// buildGlobalRegistries, except we can't set our schemas as 	TokenNameCOMMENT_LINE	buildGlobalRegistries, except we can't set our schemas as 
// hidden for a second time; so make them all visible again 	TokenNameCOMMENT_LINE	hidden for a second time; so make them all visible again 
// first! 	TokenNameCOMMENT_LINE	first! 
setSchemasVisible	TokenNameIdentifier	 set Schemas Visible
(	TokenNameLPAREN	
fRoot	TokenNameIdentifier	 f Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Stack	TokenNameIdentifier	 Stack
schemasToProcess	TokenNameIdentifier	 schemas To Process
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fRoot	TokenNameIdentifier	 f Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
empty	TokenNameIdentifier	 empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
currDoc	TokenNameIdentifier	 curr Doc
=	TokenNameEQUAL	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
currSG	TokenNameIdentifier	 curr SG
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
isHidden	TokenNameIdentifier	 is Hidden
(	TokenNameLPAREN	
currDoc	TokenNameIdentifier	 curr Doc
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// must have processed this already! 	TokenNameCOMMENT_LINE	must have processed this already! 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
currRoot	TokenNameIdentifier	 curr Root
=	TokenNameEQUAL	
currDoc	TokenNameIdentifier	 curr Doc
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sawAnnotation	TokenNameIdentifier	 saw Annotation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// traverse this schema's global decls 	TokenNameCOMMENT_LINE	traverse this schema's global decls 
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
globalComp	TokenNameIdentifier	 global Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstVisibleChildElement	TokenNameIdentifier	 get First Visible Child Element
(	TokenNameLPAREN	
currRoot	TokenNameIdentifier	 curr Root
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
globalComp	TokenNameIdentifier	 global Comp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
globalComp	TokenNameIdentifier	 global Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextVisibleSiblingElement	TokenNameIdentifier	 get Next Visible Sibling Element
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// includes and imports will not show up here! 	TokenNameCOMMENT_LINE	includes and imports will not show up here! 
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use the namespace decls for the redefine, instead of for the parent <schema> 	TokenNameCOMMENT_LINE	use the namespace decls for the redefine, instead of for the parent <schema> 
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
backupNSSupport	TokenNameIdentifier	 backup NS Support
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
)	TokenNameRPAREN	
fRedefine2NSSupport	TokenNameIdentifier	 f Redefine2 NS Support
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
redefinedComp	TokenNameIdentifier	 redefined Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstVisibleChildElement	TokenNameIdentifier	 get First Visible Child Element
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
redefinedComp	TokenNameIdentifier	 redefined Comp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
redefinedComp	TokenNameIdentifier	 redefined Comp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextVisibleSiblingElement	TokenNameIdentifier	 get Next Visible Sibling Element
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
redefinedComp	TokenNameIdentifier	 redefined Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// annotations will have been processed already; this is now 	TokenNameCOMMENT_LINE	annotations will have been processed already; this is now 
// unnecessary 	TokenNameCOMMENT_LINE	unnecessary 
//else if (redefinedComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) { 	TokenNameCOMMENT_LINE	else if (redefinedComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) { 
// fElementTraverser.traverseAnnotationDecl(redefinedComp, null, true, currSchemaDoc); 	TokenNameCOMMENT_LINE	fElementTraverser.traverseAnnotationDecl(redefinedComp, null, true, currSchemaDoc); 
//} 	TokenNameCOMMENT_LINE	} 
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"(annotation | (simpleType | complexType | group | attributeGroup))*"	TokenNameStringLiteral	(annotation | (simpleType | complexType | group | attributeGroup))*
,	TokenNameCOMMA	
redefinedComponentType	TokenNameIdentifier	 redefined Component Type
}	TokenNameRBRACE	
,	TokenNameCOMMA	
redefinedComp	TokenNameIdentifier	 redefined Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end march through <redefine> children 	TokenNameCOMMENT_LINE	end march through <redefine> children 
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
restoreNSSupport	TokenNameIdentifier	 restore NS Support
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTE	TokenNameIdentifier	 ELT  ATTRIBUTE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeTraverser	TokenNameIdentifier	 f Attribute Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ELEMENT	TokenNameIdentifier	 ELT  ELEMENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_NOTATION	TokenNameIdentifier	 ELT  NOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNotationTraverser	TokenNameIdentifier	 f Notation Traverser
.	TokenNameDOT	
traverse	TokenNameIdentifier	 traverse
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
,	TokenNameCOMMA	
currSG	TokenNameIdentifier	 curr SG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currSG	TokenNameIdentifier	 curr SG
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
getSchemaAttrs	TokenNameIdentifier	 get Schema Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sawAnnotation	TokenNameIdentifier	 saw Annotation
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SCHEMA	TokenNameIdentifier	 ELT  SCHEMA
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
globalComp	TokenNameIdentifier	 global Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end for 	TokenNameCOMMENT_LINE	end for 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sawAnnotation	TokenNameIdentifier	 saw Annotation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
currRoot	TokenNameIdentifier	 curr Root
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currSG	TokenNameIdentifier	 curr SG
.	TokenNameDOT	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
currRoot	TokenNameIdentifier	 curr Root
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
getSchemaAttrs	TokenNameIdentifier	 get Schema Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Collect annotation information for validation. **/	TokenNameCOMMENT_JAVADOC	 Collect annotation information for validation. *
if	TokenNameif	
(	TokenNameLPAREN	
annotationInfo	TokenNameIdentifier	 annotation Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAnnotationInfo	TokenNameIdentifier	 XS Annotation Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
getAnnotations	TokenNameIdentifier	 get Annotations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Only add annotations to the list if there were any in this document. **/	TokenNameCOMMENT_JAVADOC	 Only add annotations to the list if there were any in this document. *
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
doc2SystemId	TokenNameIdentifier	 doc2 System Id
(	TokenNameLPAREN	
currDoc	TokenNameIdentifier	 curr Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
annotationInfo	TokenNameIdentifier	 annotation Info
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now we're done with this one! 	TokenNameCOMMENT_LINE	now we're done with this one! 
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
.	TokenNameDOT	
returnSchemaAttrs	TokenNameIdentifier	 return Schema Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
currDoc	TokenNameIdentifier	 curr Doc
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now add the schemas this guy depends on 	TokenNameCOMMENT_LINE	now add the schemas this guy depends on 
Vector	TokenNameIdentifier	 Vector
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
fDependencyMap	TokenNameIdentifier	 f Dependency Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currSchemaDoc	TokenNameIdentifier	 curr Schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemasToProcess	TokenNameIdentifier	 schemas To Process
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
currSchemaDepends	TokenNameIdentifier	 curr Schema Depends
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// while 	TokenNameCOMMENT_LINE	while 
}	TokenNameRBRACE	
// end traverseSchemas 	TokenNameCOMMENT_LINE	end traverseSchemas 
// store whether we have reported an error about that no grammar 	TokenNameCOMMENT_LINE	store whether we have reported an error about that no grammar 
// is found for the given namespace uri 	TokenNameCOMMENT_LINE	is found for the given namespace uri 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
fReportedTNS	TokenNameIdentifier	 f Reported TNS
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// check whether we need to report an error against the given uri. 	TokenNameCOMMENT_LINE	check whether we need to report an error against the given uri. 
// if we have reported an error, then we don't need to report again; 	TokenNameCOMMENT_LINE	if we have reported an error, then we don't need to report again; 
// otherwise we reported the error, and remember this fact. 	TokenNameCOMMENT_LINE	otherwise we reported the error, and remember this fact. 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
needReportTNSError	TokenNameIdentifier	 need Report TNS Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fReportedTNS	TokenNameIdentifier	 f Reported TNS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fReportedTNS	TokenNameIdentifier	 f Reported TNS
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fReportedTNS	TokenNameIdentifier	 f Reported TNS
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fReportedTNS	TokenNameIdentifier	 f Reported TNS
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
COMP_TYPE	TokenNameIdentifier	 COMP  TYPE
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
// index 0 	TokenNameCOMMENT_LINE	index 0 
"attribute declaration"	TokenNameStringLiteral	attribute declaration
,	TokenNameCOMMA	
"attribute group"	TokenNameStringLiteral	attribute group
,	TokenNameCOMMA	
"element declaration"	TokenNameStringLiteral	element declaration
,	TokenNameCOMMA	
"group"	TokenNameStringLiteral	group
,	TokenNameCOMMA	
"identity constraint"	TokenNameStringLiteral	identity constraint
,	TokenNameCOMMA	
"notation"	TokenNameStringLiteral	notation
,	TokenNameCOMMA	
"type definition"	TokenNameStringLiteral	type definition
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
CIRCULAR_CODES	TokenNameIdentifier	 CIRCULAR  CODES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
"src-attribute_group.3"	TokenNameStringLiteral	src-attribute_group.3
,	TokenNameCOMMA	
"e-props-correct.6"	TokenNameStringLiteral	e-props-correct.6
,	TokenNameCOMMA	
"mg-props-correct.2"	TokenNameStringLiteral	mg-props-correct.2
,	TokenNameCOMMA	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
"st-props-correct.2"	TokenNameStringLiteral	st-props-correct.2
,	TokenNameCOMMA	
//or ct-props-correct.3 	TokenNameCOMMENT_LINE	or ct-props-correct.3 
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// add a global attribute decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global attribute decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalAttributeDecl	TokenNameIdentifier	 add Global Attribute Decl
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalAttrDecls	TokenNameIdentifier	 f Global Attr Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalAttrDecls	TokenNameIdentifier	 f Global Attr Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a global attribute group decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global attribute group decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalAttributeGroupDecl	TokenNameIdentifier	 add Global Attribute Group Decl
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalAttrGrpDecls	TokenNameIdentifier	 f Global Attr Grp Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalAttrGrpDecls	TokenNameIdentifier	 f Global Attr Grp Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a global element decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global element decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalElemDecls	TokenNameIdentifier	 f Global Elem Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalElemDecls	TokenNameIdentifier	 f Global Elem Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a global group decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global group decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalGroupDecl	TokenNameIdentifier	 add Global Group Decl
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalGroupDecls	TokenNameIdentifier	 f Global Group Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalGroupDecls	TokenNameIdentifier	 f Global Group Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a global notation decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global notation decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalNotationDecl	TokenNameIdentifier	 add Global Notation Decl
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalNotationDecls	TokenNameIdentifier	 f Global Notation Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalNotationDecls	TokenNameIdentifier	 f Global Notation Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a global type decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a global type decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalTypeDecls	TokenNameIdentifier	 f Global Type Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalTypeDecls	TokenNameIdentifier	 f Global Type Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add a identity constraint decl from a current schema load (only if no existing decl is found) 	TokenNameCOMMENT_LINE	add a identity constraint decl from a current schema load (only if no existing decl is found) 
void	TokenNamevoid	
addIDConstraintDecl	TokenNameIdentifier	 add ID Constraint Decl
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalIDConstraintDecls	TokenNameIdentifier	 f Global ID Constraint Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalIDConstraintDecls	TokenNameIdentifier	 f Global ID Constraint Decls
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
fGlobalAttrDecls	TokenNameIdentifier	 f Global Attr Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
fGlobalAttrGrpDecls	TokenNameIdentifier	 f Global Attr Grp Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fGlobalElemDecls	TokenNameIdentifier	 f Global Elem Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
fGlobalGroupDecls	TokenNameIdentifier	 f Global Group Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
)	TokenNameRPAREN	
fGlobalNotationDecls	TokenNameIdentifier	 f Global Notation Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fGlobalTypeDecls	TokenNameIdentifier	 f Global Type Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
getIDConstraintDecl	TokenNameIdentifier	 get ID Constraint Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
)	TokenNameRPAREN	
fGlobalIDConstraintDecls	TokenNameIdentifier	 f Global ID Constraint Decls
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// since it is forbidden for traversers to talk to each other 	TokenNameCOMMENT_LINE	since it is forbidden for traversers to talk to each other 
// directly (except wen a traverser encounters a local declaration), 	TokenNameCOMMENT_LINE	directly (except wen a traverser encounters a local declaration), 
// this provides a generic means for a traverser to call 	TokenNameCOMMENT_LINE	this provides a generic means for a traverser to call 
// for the traversal of some declaration. An XSDocumentInfo is 	TokenNameCOMMENT_LINE	for the traversal of some declaration. An XSDocumentInfo is 
// required because the XSDocumentInfo that the traverser is traversing 	TokenNameCOMMENT_LINE	required because the XSDocumentInfo that the traverser is traversing 
// may bear no relation to the one the handler is operating on. 	TokenNameCOMMENT_LINE	may bear no relation to the one the handler is operating on. 
// This method will: 	TokenNameCOMMENT_LINE	This method will: 
// 1. See if a global definition matching declToTraverse exists; 	TokenNameCOMMENT_LINE	1. See if a global definition matching declToTraverse exists; 
// 2. if so, determine if there is a path from currSchema to the 	TokenNameCOMMENT_LINE	2. if so, determine if there is a path from currSchema to the 
// schema document where declToTraverse lives (i.e., do a lookup 	TokenNameCOMMENT_LINE	schema document where declToTraverse lives (i.e., do a lookup 
// in DependencyMap); 	TokenNameCOMMENT_LINE	in DependencyMap); 
// 3. depending on declType (which will be relevant to step 1 as 	TokenNameCOMMENT_LINE	3. depending on declType (which will be relevant to step 1 as 
// well), call the appropriate traverser with the appropriate 	TokenNameCOMMENT_LINE	well), call the appropriate traverser with the appropriate 
// XSDocumentInfo object. 	TokenNameCOMMENT_LINE	XSDocumentInfo object. 
// This method returns whatever the traverser it called returned; 	TokenNameCOMMENT_LINE	This method returns whatever the traverser it called returned; 
// this will be an Object of some kind 	TokenNameCOMMENT_LINE	this will be an Object of some kind 
// that lives in the Grammar. 	TokenNameCOMMENT_LINE	that lives in the Grammar. 
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
declToTraverse	TokenNameIdentifier	 decl To Traverse
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_NODE_POOL	TokenNameIdentifier	 DEBUG  NODE  POOL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"TRAVERSE_GL: "	TokenNameStringLiteral	TRAVERSE_GL: 
+	TokenNamePLUS	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// from the schema spec, all built-in types are present in all schemas, 	TokenNameCOMMENT_LINE	from the schema spec, all built-in types are present in all schemas, 
// so if the requested component is a type, and could be found in the 	TokenNameCOMMENT_LINE	so if the requested component is a type, and could be found in the 
// default schema grammar, we should return that type. 	TokenNameCOMMENT_LINE	default schema grammar, we should return that type. 
// otherwise (since we would support user-defined schema grammar) we'll 	TokenNameCOMMENT_LINE	otherwise (since we would support user-defined schema grammar) we'll 
// use the normal way to get the decl 	TokenNameCOMMENT_LINE	use the normal way to get the decl 
if	TokenNameif	
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
==	TokenNameEQUAL_EQUAL	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now check whether this document can access the requsted namespace 	TokenNameCOMMENT_LINE	now check whether this document can access the requsted namespace 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
isAllowedNS	TokenNameIdentifier	 is Allowed NS
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// cannot get to this schema from the one containing the requesting decl 	TokenNameCOMMENT_LINE	cannot get to this schema from the one containing the requesting decl 
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
needReportTNSError	TokenNameIdentifier	 need Report TNS Error
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"src-resolve.4.1"	TokenNameStringLiteral	src-resolve.4.1
:	TokenNameCOLON	
"src-resolve.4.2"	TokenNameStringLiteral	src-resolve.4.2
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
)	TokenNameRPAREN	
,	TokenNameCOMMA	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Recover and continue to look for the component. 	TokenNameCOMMENT_LINE	Recover and continue to look for the component. 
// return null; 	TokenNameCOMMENT_LINE	return null; 
}	TokenNameRBRACE	
// check whether there is grammar for the requested namespace 	TokenNameCOMMENT_LINE	check whether there is grammar for the requested namespace 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sGrammar	TokenNameIdentifier	 s Grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sGrammar	TokenNameIdentifier	 s Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
needReportTNSError	TokenNameIdentifier	 need Report TNS Error
(	TokenNameLPAREN	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-resolve"	TokenNameStringLiteral	src-resolve
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
COMP_TYPE	TokenNameIdentifier	 COMP  TYPE
[	TokenNameLBRACKET	
declType	TokenNameIdentifier	 decl Type
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if there is such grammar, check whether the requested component is in the grammar 	TokenNameCOMMENT_LINE	if there is such grammar, check whether the requested component is in the grammar 
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalDeclFromGrammar	TokenNameIdentifier	 get Global Decl From Grammar
(	TokenNameLPAREN	
sGrammar	TokenNameIdentifier	 s Grammar
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
=	TokenNameEQUAL	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
:	TokenNameCOLON	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
// if the component is parsed, return it 	TokenNameCOMMENT_LINE	if the component is parsed, return it 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj2	TokenNameIdentifier	 ret Obj2
=	TokenNameEQUAL	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
retObj2	TokenNameIdentifier	 ret Obj2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
retObj2	TokenNameIdentifier	 ret Obj2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaWithDecl	TokenNameIdentifier	 schema With Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the component is not parsed, try to find a DOM element for it 	TokenNameCOMMENT_LINE	the component is not parsed, try to find a DOM element for it 
switch	TokenNameswitch	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedAttributeRegistry	TokenNameIdentifier	 f Unparsed Attribute Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedAttributeRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedAttributeGroupRegistry	TokenNameIdentifier	 f Unparsed Attribute Group Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedAttributeGroupRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Group Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedElementRegistry	TokenNameIdentifier	 f Unparsed Element Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedElementRegistrySub	TokenNameIdentifier	 f Unparsed Element Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedGroupRegistry	TokenNameIdentifier	 f Unparsed Group Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedGroupRegistrySub	TokenNameIdentifier	 f Unparsed Group Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedIdentityConstraintRegistry	TokenNameIdentifier	 f Unparsed Identity Constraint Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedIdentityConstraintRegistrySub	TokenNameIdentifier	 f Unparsed Identity Constraint Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedNotationRegistry	TokenNameIdentifier	 f Unparsed Notation Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedNotationRegistrySub	TokenNameIdentifier	 f Unparsed Notation Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
:	TokenNameCOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fUnparsedTypeRegistry	TokenNameIdentifier	 f Unparsed Type Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
declDoc	TokenNameIdentifier	 decl Doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
fUnparsedTypeRegistrySub	TokenNameIdentifier	 f Unparsed Type Registry Sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"XSDHandler asked to locate component of type "	TokenNameStringLiteral	XSDHandler asked to locate component of type 
+	TokenNamePLUS	
declType	TokenNameIdentifier	 decl Type
+	TokenNamePLUS	
"; it does not recognize this type!"	TokenNameStringLiteral	; it does not recognize this type!
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// no DOM element found, so the component can't be located 	TokenNameCOMMENT_LINE	no DOM element found, so the component can't be located 
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-resolve"	TokenNameStringLiteral	src-resolve
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
COMP_TYPE	TokenNameIdentifier	 COMP  TYPE
[	TokenNameLBRACKET	
declType	TokenNameIdentifier	 decl Type
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get the schema doc containing the component to be parsed 	TokenNameCOMMENT_LINE	get the schema doc containing the component to be parsed 
// it should always return non-null value, but since null-checking 	TokenNameCOMMENT_LINE	it should always return non-null value, but since null-checking 
// comes for free, let's be safe and check again 	TokenNameCOMMENT_LINE	comes for free, let's be safe and check again 
schemaWithDecl	TokenNameIdentifier	 schema With Decl
=	TokenNameEQUAL	
findXSDocumentForDecl	TokenNameIdentifier	 find XS Document For Decl
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
declDoc	TokenNameIdentifier	 decl Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
schemaWithDecl	TokenNameIdentifier	 schema With Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// cannot get to this schema from the one containing the requesting decl 	TokenNameCOMMENT_LINE	cannot get to this schema from the one containing the requesting decl 
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"src-resolve.4.1"	TokenNameStringLiteral	src-resolve.4.1
:	TokenNameCOLON	
"src-resolve.4.2"	TokenNameStringLiteral	src-resolve.4.2
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
)	TokenNameRPAREN	
,	TokenNameCOMMA	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// a component is hidden, meaning either it's traversed, or being traversed. 	TokenNameCOMMENT_LINE	a component is hidden, meaning either it's traversed, or being traversed. 
// but we didn't find it in the grammar, so it's the latter case, and 	TokenNameCOMMENT_LINE	but we didn't find it in the grammar, so it's the latter case, and 
// a circular reference. error! 	TokenNameCOMMENT_LINE	a circular reference. error! 
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
isHidden	TokenNameIdentifier	 is Hidden
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
CIRCULAR_CODES	TokenNameIdentifier	 CIRCULAR  CODES
[	TokenNameLBRACKET	
declType	TokenNameIdentifier	 decl Type
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
==	TokenNameEQUAL_EQUAL	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"ct-props-correct.3"	TokenNameStringLiteral	ct-props-correct.3
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// decl must not be null if we're here... 	TokenNameCOMMENT_LINE	decl must not be null if we're here... 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
declToTraverse	TokenNameIdentifier	 decl To Traverse
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
traverseGlobalDecl	TokenNameIdentifier	 traverse Global Decl
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaWithDecl	TokenNameIdentifier	 schema With Decl
,	TokenNameCOMMA	
sGrammar	TokenNameIdentifier	 s Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getGlobalDecl(XSDocumentInfo, int, QName): Object 	TokenNameCOMMENT_LINE	getGlobalDecl(XSDocumentInfo, int, QName): Object 
// If we are tolerating duplicate declarations and allowing namespace growth 	TokenNameCOMMENT_LINE	If we are tolerating duplicate declarations and allowing namespace growth 
// use the declaration from the current schema load (if it exists) 	TokenNameCOMMENT_LINE	use the declaration from the current schema load (if it exists) 
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
declKey	TokenNameIdentifier	 decl Key
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getIDConstraintDecl	TokenNameIdentifier	 get ID Constraint Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
declKey	TokenNameIdentifier	 decl Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
getGlobalDeclFromGrammar	TokenNameIdentifier	 get Global Decl From Grammar
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sGrammar	TokenNameIdentifier	 s Grammar
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getIDConstraintDecl	TokenNameIdentifier	 get ID Constraint Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
getGlobalDeclFromGrammar	TokenNameIdentifier	 get Global Decl From Grammar
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sGrammar	TokenNameIdentifier	 s Grammar
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getIDConstraintDecl	TokenNameIdentifier	 get ID Constraint Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
localpart	TokenNameIdentifier	 localpart
,	TokenNameCOMMA	
schemaLoc	TokenNameIdentifier	 schema Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
traverseGlobalDecl	TokenNameIdentifier	 traverse Global Decl
(	TokenNameLPAREN	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
nsSupport	TokenNameIdentifier	 ns Support
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// if the parent is <redefine> use the namespace delcs for it. 	TokenNameCOMMENT_LINE	if the parent is <redefine> use the namespace delcs for it. 
Element	TokenNameIdentifier	 Element
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
nsSupport	TokenNameIdentifier	 ns Support
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
)	TokenNameRPAREN	
fRedefine2NSSupport	TokenNameIdentifier	 f Redefine2 NS Support
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// back up the current SchemaNamespaceSupport, because we need to provide 	TokenNameCOMMENT_LINE	back up the current SchemaNamespaceSupport, because we need to provide 
// a fresh one to the traverseGlobal methods. 	TokenNameCOMMENT_LINE	a fresh one to the traverseGlobal methods. 
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
backupNSSupport	TokenNameIdentifier	 backup NS Support
(	TokenNameLPAREN	
nsSupport	TokenNameIdentifier	 ns Support
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// traverse the referenced global component 	TokenNameCOMMENT_LINE	traverse the referenced global component 
switch	TokenNameswitch	
(	TokenNameLPAREN	
declType	TokenNameIdentifier	 decl Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTE_TYPE	TokenNameIdentifier	 ATTRIBUTE  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fAttributeTraverser	TokenNameIdentifier	 f Attribute Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT_TYPE	TokenNameIdentifier	 ELEMENT  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
.	TokenNameDOT	
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOTATION_TYPE	TokenNameIdentifier	 NOTATION  TYPE
:	TokenNameCOLON	
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
fNotationTraverser	TokenNameIdentifier	 f Notation Traverser
.	TokenNameDOT	
traverse	TokenNameIdentifier	 traverse
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
:	TokenNameCOLON	
// identity constraints should have been parsed already... 	TokenNameCOMMENT_LINE	identity constraints should have been parsed already... 
// we should never get here 	TokenNameCOMMENT_LINE	we should never get here 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// restore the previous SchemaNamespaceSupport, so that the caller can get 	TokenNameCOMMENT_LINE	restore the previous SchemaNamespaceSupport, so that the caller can get 
// proper namespace binding. 	TokenNameCOMMENT_LINE	proper namespace binding. 
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
restoreNSSupport	TokenNameIdentifier	 restore NS Support
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
schemaDocument2SystemId	TokenNameIdentifier	 schema Document2 System Id
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This method determines whether there is a group 	TokenNameCOMMENT_LINE	This method determines whether there is a group 
// (attributeGroup) which the given one has redefined by 	TokenNameCOMMENT_LINE	(attributeGroup) which the given one has redefined by 
// restriction. If so, it returns it; else it returns null. 	TokenNameCOMMENT_LINE	restriction. If so, it returns it; else it returns null. 
// @param type: whether what's been redefined is an 	TokenNameCOMMENT_LINE	@param type: whether what's been redefined is an 
// attributeGroup or a group; 	TokenNameCOMMENT_LINE	attributeGroup or a group; 
// @param name: the QName of the component doing the redefining. 	TokenNameCOMMENT_LINE	@param name: the QName of the component doing the redefining. 
// @param currSchema: schema doc in which the redefining component lives. 	TokenNameCOMMENT_LINE	@param currSchema: schema doc in which the redefining component lives. 
// @return: Object representing decl redefined if present, null 	TokenNameCOMMENT_LINE	@return: Object representing decl redefined if present, null 
// otherwise. 	TokenNameCOMMENT_LINE	otherwise. 
Object	TokenNameIdentifier	 Object
getGrpOrAttrGrpRedefinedByRestriction	TokenNameIdentifier	 get Grp Or Attr Grp Redefined By Restriction
(	TokenNameLPAREN	
int	TokenNameint	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
realName	TokenNameIdentifier	 real Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
:	TokenNameCOLON	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nameToFind	TokenNameIdentifier	 name To Find
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
nameToFind	TokenNameIdentifier	 name To Find
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fRedefinedRestrictedAttributeGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Attribute Group Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
realName	TokenNameIdentifier	 real Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
nameToFind	TokenNameIdentifier	 name To Find
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fRedefinedRestrictedGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Group Registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
realName	TokenNameIdentifier	 real Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nameToFind	TokenNameIdentifier	 name To Find
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
commaPos	TokenNameIdentifier	 comma Pos
=	TokenNameEQUAL	
nameToFind	TokenNameIdentifier	 name To Find
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
qNameToFind	TokenNameIdentifier	 q Name To Find
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
,	TokenNameCOMMA	
nameToFind	TokenNameIdentifier	 name To Find
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
commaPos	TokenNameIdentifier	 comma Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
nameToFind	TokenNameIdentifier	 name To Find
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
commaPos	TokenNameIdentifier	 comma Pos
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
commaPos	TokenNameIdentifier	 comma Pos
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
nameToFind	TokenNameIdentifier	 name To Find
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
commaPos	TokenNameIdentifier	 comma Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
retObj	TokenNameIdentifier	 ret Obj
=	TokenNameEQUAL	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
qNameToFind	TokenNameIdentifier	 q Name To Find
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
retObj	TokenNameIdentifier	 ret Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ATTRIBUTEGROUP_TYPE	TokenNameIdentifier	 ATTRIBUTEGROUP  TYPE
:	TokenNameCOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.7.2.1"	TokenNameStringLiteral	src-redefine.7.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GROUP_TYPE	TokenNameIdentifier	 GROUP  TYPE
:	TokenNameCOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.6.2.1"	TokenNameStringLiteral	src-redefine.6.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retObj	TokenNameIdentifier	 ret Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getGrpOrAttrGrpRedefinedByRestriction(int, QName, XSDocumentInfo): Object 	TokenNameCOMMENT_LINE	getGrpOrAttrGrpRedefinedByRestriction(int, QName, XSDocumentInfo): Object 
// Since ID constraints can occur in local elements, unless we 	TokenNameCOMMENT_LINE	Since ID constraints can occur in local elements, unless we 
// wish to completely traverse all our DOM trees looking for ID 	TokenNameCOMMENT_LINE	wish to completely traverse all our DOM trees looking for ID 
// constraints while we're building our global name registries, 	TokenNameCOMMENT_LINE	constraints while we're building our global name registries, 
// which seems terribly inefficient, we need to resolve keyrefs 	TokenNameCOMMENT_LINE	which seems terribly inefficient, we need to resolve keyrefs 
// after all parsing is complete. This we can simply do by running through 	TokenNameCOMMENT_LINE	after all parsing is complete. This we can simply do by running through 
// fIdentityConstraintRegistry and calling traverseKeyRef on all 	TokenNameCOMMENT_LINE	fIdentityConstraintRegistry and calling traverseKeyRef on all 
// of the KeyRef nodes. This unfortunately removes this knowledge 	TokenNameCOMMENT_LINE	of the KeyRef nodes. This unfortunately removes this knowledge 
// from the elementTraverser class (which must ignore keyrefs), 	TokenNameCOMMENT_LINE	from the elementTraverser class (which must ignore keyrefs), 
// but there seems to be no efficient way around this... 	TokenNameCOMMENT_LINE	but there seems to be no efficient way around this... 
protected	TokenNameprotected	
void	TokenNamevoid	
resolveKeyRefs	TokenNameIdentifier	 resolve Key Refs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
keyrefSchemaDoc	TokenNameIdentifier	 keyref Schema Doc
=	TokenNameEQUAL	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
keyrefSchemaDoc	TokenNameIdentifier	 keyref Schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
.	TokenNameDOT	
makeGlobal	TokenNameIdentifier	 make Global
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyrefSchemaDoc	TokenNameIdentifier	 keyref Schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
.	TokenNameDOT	
setEffectiveContext	TokenNameIdentifier	 set Effective Context
(	TokenNameLPAREN	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
keyrefGrammar	TokenNameIdentifier	 keyref Grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
keyrefSchemaDoc	TokenNameIdentifier	 keyref Schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to set <keyref> to hidden before traversing it, 	TokenNameCOMMENT_LINE	need to set <keyref> to hidden before traversing it, 
// because it has global scope 	TokenNameCOMMENT_LINE	because it has global scope 
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setHidden	TokenNameIdentifier	 set Hidden
(	TokenNameLPAREN	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefTraverser	TokenNameIdentifier	 f Keyref Traverser
.	TokenNameDOT	
traverse	TokenNameIdentifier	 traverse
(	TokenNameLPAREN	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
keyrefSchemaDoc	TokenNameIdentifier	 keyref Schema Doc
,	TokenNameCOMMA	
keyrefGrammar	TokenNameIdentifier	 keyref Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end resolveKeyRefs 	TokenNameCOMMENT_LINE	end resolveKeyRefs 
// an accessor method. Just makes sure callers 	TokenNameCOMMENT_LINE	an accessor method. Just makes sure callers 
// who want the Identity constraint registry vaguely know what they're about. 	TokenNameCOMMENT_LINE	who want the Identity constraint registry vaguely know what they're about. 
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
getIDRegistry	TokenNameIdentifier	 get ID Registry
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fUnparsedIdentityConstraintRegistry	TokenNameIdentifier	 f Unparsed Identity Constraint Registry
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// an accessor method. 	TokenNameCOMMENT_LINE	an accessor method. 
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
getIDRegistry_sub	TokenNameIdentifier	 get ID Registry sub
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fUnparsedIdentityConstraintRegistrySub	TokenNameIdentifier	 f Unparsed Identity Constraint Registry Sub
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This method squirrels away <keyref> declarations--along with the element 	TokenNameCOMMENT_LINE	This method squirrels away <keyref> declarations--along with the element 
// decls and namespace bindings they might find handy. 	TokenNameCOMMENT_LINE	decls and namespace bindings they might find handy. 
protected	TokenNameprotected	
void	TokenNamevoid	
storeKeyRef	TokenNameIdentifier	 store Key Ref
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
keyrefToStore	TokenNameIdentifier	 keyref To Store
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
currElemDecl	TokenNameIdentifier	 curr Elem Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
keyrefName	TokenNameIdentifier	 keyref Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getAttrValue	TokenNameIdentifier	 get Attr Value
(	TokenNameLPAREN	
keyrefToStore	TokenNameIdentifier	 keyref To Store
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyrefName	TokenNameIdentifier	 keyref Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
keyrefQName	TokenNameIdentifier	 keyref Q Name
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
keyrefName	TokenNameIdentifier	 keyref Name
:	TokenNameCOLON	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
keyrefName	TokenNameIdentifier	 keyref Name
;	TokenNameSEMICOLON	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
keyrefQName	TokenNameIdentifier	 keyref Q Name
,	TokenNameCOMMA	
IDENTITYCONSTRAINT_TYPE	TokenNameIdentifier	 IDENTITYCONSTRAINT  TYPE
,	TokenNameCOMMA	
fUnparsedIdentityConstraintRegistry	TokenNameIdentifier	 f Unparsed Identity Constraint Registry
,	TokenNameCOMMA	
fUnparsedIdentityConstraintRegistrySub	TokenNameIdentifier	 f Unparsed Identity Constraint Registry Sub
,	TokenNameCOMMA	
keyrefToStore	TokenNameIdentifier	 keyref To Store
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now set up all the registries we'll need... 	TokenNameCOMMENT_LINE	now set up all the registries we'll need... 
// check array sizes 	TokenNameCOMMENT_LINE	check array sizes 
if	TokenNameif	
(	TokenNameLPAREN	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
==	TokenNameEQUAL_EQUAL	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
elemArray	TokenNameIdentifier	 elem Array
=	TokenNameEQUAL	
new	TokenNamenew	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
+	TokenNamePLUS	
INC_KEYREF_STACK_AMOUNT	TokenNameIdentifier	 INC  KEYREF  STACK  AMOUNT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
elemArray	TokenNameIdentifier	 elem Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
=	TokenNameEQUAL	
elemArray	TokenNameIdentifier	 elem Array
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
declArray	TokenNameIdentifier	 decl Array
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
+	TokenNamePLUS	
INC_KEYREF_STACK_AMOUNT	TokenNameIdentifier	 INC  KEYREF  STACK  AMOUNT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
declArray	TokenNameIdentifier	 decl Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
=	TokenNameEQUAL	
declArray	TokenNameIdentifier	 decl Array
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stringArray	TokenNameIdentifier	 string Array
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
+	TokenNamePLUS	
INC_KEYREF_STACK_AMOUNT	TokenNameIdentifier	 INC  KEYREF  STACK  AMOUNT
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
stringArray	TokenNameIdentifier	 string Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
=	TokenNameEQUAL	
stringArray	TokenNameIdentifier	 string Array
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
xsDocumentInfo	TokenNameIdentifier	 xs Document Info
=	TokenNameEQUAL	
new	TokenNamenew	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
+	TokenNamePLUS	
INC_KEYREF_STACK_AMOUNT	TokenNameIdentifier	 INC  KEYREF  STACK  AMOUNT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
xsDocumentInfo	TokenNameIdentifier	 xs Document Info
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
=	TokenNameEQUAL	
xsDocumentInfo	TokenNameIdentifier	 xs Document Info
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
keyrefToStore	TokenNameIdentifier	 keyref To Store
;	TokenNameSEMICOLON	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
currElemDecl	TokenNameIdentifier	 curr Elem Decl
;	TokenNameSEMICOLON	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
.	TokenNameDOT	
getEffectiveLocalContext	TokenNameIdentifier	 get Effective Local Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
[	TokenNameLBRACKET	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// storeKeyref (Element, XSDocumentInfo, XSElementDecl): void 	TokenNameCOMMENT_LINE	storeKeyref (Element, XSDocumentInfo, XSElementDecl): void 
/** * resolveSchema method is responsible for resolving location of the schema (using XMLEntityResolver), * and if it was succefully resolved getting the schema Document. * @param desc * @param mustResolve * @param referElement * @return A schema Element or null. */	TokenNameCOMMENT_JAVADOC	 resolveSchema method is responsible for resolving location of the schema (using XMLEntityResolver), and if it was succefully resolved getting the schema Document. @param desc @param mustResolve @param referElement @return A schema Element or null. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
resolveSchema	TokenNameIdentifier	 resolve Schema
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
boolean	TokenNameboolean	
usePairs	TokenNameIdentifier	 use Pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Hashtable	TokenNameIdentifier	 Hashtable
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
usePairs	TokenNameIdentifier	 use Pairs
?	TokenNameQUESTION	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
:	TokenNameCOLON	
EMPTY_TABLE	TokenNameIdentifier	 EMPTY  TABLE
;	TokenNameSEMICOLON	
schemaSource	TokenNameIdentifier	 schema Source
=	TokenNameEQUAL	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
resolveDocument	TokenNameIdentifier	 resolve Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getLocationHints	TokenNameIdentifier	 get Location Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getLocationHints	TokenNameIdentifier	 get Location Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DOMInputSource 	TokenNameCOMMENT_LINE	DOMInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// SAXInputSource 	TokenNameCOMMENT_LINE	SAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// StAXInputSource 	TokenNameCOMMENT_LINE	StAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XSInputSource 	TokenNameCOMMENT_LINE	XSInputSource 
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchema(String, String, String, boolean, short): Document 	TokenNameCOMMENT_LINE	getSchema(String, String, String, boolean, short): Document 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
resolveSchema	TokenNameIdentifier	 resolve Schema
(	TokenNameLPAREN	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DOMInputSource 	TokenNameCOMMENT_LINE	DOMInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// SAXInputSource 	TokenNameCOMMENT_LINE	SAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// StAXInputSource 	TokenNameCOMMENT_LINE	StAXInputSource 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
instanceof	TokenNameinstanceof	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSInputSource	TokenNameIdentifier	 XS Input Source
)	TokenNameRPAREN	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// XSInputSource 	TokenNameCOMMENT_LINE	XSInputSource 
return	TokenNamereturn	
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XMLInputSource	TokenNameIdentifier	 XML Input Source
resolveSchemaSource	TokenNameIdentifier	 resolve Schema Source
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
boolean	TokenNameboolean	
usePairs	TokenNameIdentifier	 use Pairs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Hashtable	TokenNameIdentifier	 Hashtable
pairs	TokenNameIdentifier	 pairs
=	TokenNameEQUAL	
usePairs	TokenNameIdentifier	 use Pairs
?	TokenNameQUESTION	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
:	TokenNameCOLON	
EMPTY_TABLE	TokenNameIdentifier	 EMPTY  TABLE
;	TokenNameSEMICOLON	
schemaSource	TokenNameIdentifier	 schema Source
=	TokenNameEQUAL	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
resolveDocument	TokenNameIdentifier	 resolve Document
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
pairs	TokenNameIdentifier	 pairs
,	TokenNameCOMMA	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getLocationHints	TokenNameIdentifier	 get Location Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getLocationHints	TokenNameIdentifier	 get Location Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
schemaSource	TokenNameIdentifier	 schema Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * getSchemaDocument method uses XMLInputSource to parse a schema document. * @param schemaNamespace * @param schemaSource * @param mustResolve * @param referType * @param referElement * @return A schema Element. */	TokenNameCOMMENT_JAVADOC	 getSchemaDocument method uses XMLInputSource to parse a schema document. @param schemaNamespace @param schemaSource @param mustResolve @param referType @param referElement @return A schema Element. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
IOException	TokenNameIdentifier	 IO Exception
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// contents of this method will depend on the system we adopt for entity resolution--i.e., XMLEntityHandler, EntityHandler, etc. 	TokenNameCOMMENT_LINE	contents of this method will depend on the system we adopt for entity resolution--i.e., XMLEntityHandler, EntityHandler, etc. 
Element	TokenNameIdentifier	 Element
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// when the system id and byte stream and character stream 	TokenNameCOMMENT_LINE	when the system id and byte stream and character stream 
// of the input source are all null, it's 	TokenNameCOMMENT_LINE	of the input source are all null, it's 
// impossible to find the schema document. so we skip in 	TokenNameCOMMENT_LINE	impossible to find the schema document. so we skip in 
// this case. otherwise we'll receive some NPE or 	TokenNameCOMMENT_LINE	this case. otherwise we'll receive some NPE or 
// file not found errors. but schemaHint=="" is perfectly 	TokenNameCOMMENT_LINE	file not found errors. but schemaHint=="" is perfectly 
// legal for import. 	TokenNameCOMMENT_LINE	legal for import. 
if	TokenNameif	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getByteStream	TokenNameIdentifier	 get Byte Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getCharacterStream	TokenNameIdentifier	 get Character Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// When the system id of the input source is used, first try to 	TokenNameCOMMENT_LINE	When the system id of the input source is used, first try to 
// expand it, and check whether the same document has been 	TokenNameCOMMENT_LINE	expand it, and check whether the same document has been 
// parsed before. If so, return the document corresponding to 	TokenNameCOMMENT_LINE	parsed before. If so, return the document corresponding to 
// that system id. 	TokenNameCOMMENT_LINE	that system id. 
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
schemaElement	TokenNameIdentifier	 schema Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
schemaDocument	TokenNameIdentifier	 schema Document
=	TokenNameEQUAL	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
schemaDocument	TokenNameIdentifier	 schema Document
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
schemaDocument	TokenNameIdentifier	 schema Document
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSchemaDocument0	TokenNameIdentifier	 get Schema Document0
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
ex	TokenNameIdentifier	 ex
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getSchemaDocument1	TokenNameIdentifier	 get Schema Document1
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
hasInput	TokenNameIdentifier	 has Input
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument(String, XMLInputSource, boolean, short, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument(String, XMLInputSource, boolean, short, Element): Element 
/** * getSchemaDocument method uses SAXInputSource to parse a schema document. * @param schemaNamespace * @param schemaSource * @param mustResolve * @param referType * @param referElement * @return A schema Element. */	TokenNameCOMMENT_JAVADOC	 getSchemaDocument method uses SAXInputSource to parse a schema document. @param schemaNamespace @param schemaSource @param mustResolve @param referType @param referElement @return A schema Element. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
SAXInputSource	TokenNameIdentifier	 SAX Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLReader	TokenNameIdentifier	 XML Reader
parser	TokenNameIdentifier	 parser
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getXMLReader	TokenNameIdentifier	 get XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
InputSource	TokenNameIdentifier	 Input Source
inputSource	TokenNameIdentifier	 input Source
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getInputSource	TokenNameIdentifier	 get Input Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
IOException	TokenNameIdentifier	 IO Exception
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
inputSource	TokenNameIdentifier	 input Source
.	TokenNameDOT	
getByteStream	TokenNameIdentifier	 get Byte Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
inputSource	TokenNameIdentifier	 input Source
.	TokenNameDOT	
getCharacterStream	TokenNameIdentifier	 get Character Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check whether the same document has been parsed before. 	TokenNameCOMMENT_LINE	check whether the same document has been parsed before. 
// If so, return the document corresponding to that system id. 	TokenNameCOMMENT_LINE	If so, return the document corresponding to that system id. 
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
schemaElement	TokenNameIdentifier	 schema Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
namespacePrefixes	TokenNameIdentifier	 namespace Prefixes
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parser	TokenNameIdentifier	 parser
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
namespacePrefixes	TokenNameIdentifier	 namespace Prefixes
=	TokenNameEQUAL	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
NAMESPACE_PREFIXES	TokenNameIdentifier	 NAMESPACE  PREFIXES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
parser	TokenNameIdentifier	 parser
=	TokenNameEQUAL	
XMLReaderFactory	TokenNameIdentifier	 XML Reader Factory
.	TokenNameDOT	
createXMLReader	TokenNameIdentifier	 create XML Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If something went wrong with the factory 	TokenNameCOMMENT_LINE	If something went wrong with the factory 
// just use our own SAX parser. 	TokenNameCOMMENT_LINE	just use our own SAX parser. 
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parser	TokenNameIdentifier	 parser
=	TokenNameEQUAL	
new	TokenNamenew	
SAXParser	TokenNameIdentifier	 SAX Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
NAMESPACE_PREFIXES	TokenNameIdentifier	 NAMESPACE  PREFIXES
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
namespacePrefixes	TokenNameIdentifier	 namespace Prefixes
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// If this is a Xerces SAX parser set the security manager if there is one 	TokenNameCOMMENT_LINE	If this is a Xerces SAX parser set the security manager if there is one 
if	TokenNameif	
(	TokenNameLPAREN	
parser	TokenNameIdentifier	 parser
instanceof	TokenNameinstanceof	
SAXParser	TokenNameIdentifier	 SAX Parser
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
securityManager	TokenNameIdentifier	 security Manager
=	TokenNameEQUAL	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
securityManager	TokenNameIdentifier	 security Manager
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
,	TokenNameCOMMA	
securityManager	TokenNameIdentifier	 security Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If XML names and Namespace URIs are already internalized we 	TokenNameCOMMENT_LINE	If XML names and Namespace URIs are already internalized we 
// can avoid running them through the SymbolTable. 	TokenNameCOMMENT_LINE	can avoid running them through the SymbolTable. 
boolean	TokenNameboolean	
stringsInternalized	TokenNameIdentifier	 strings Internalized
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
stringsInternalized	TokenNameIdentifier	 strings Internalized
=	TokenNameEQUAL	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
STRING_INTERNING	TokenNameIdentifier	 STRING  INTERNING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
exc	TokenNameIdentifier	 exc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The feature isn't recognized or getting it is not supported. 	TokenNameCOMMENT_LINE	The feature isn't recognized or getting it is not supported. 
// In either case, assume that strings are not internalized. 	TokenNameCOMMENT_LINE	In either case, assume that strings are not internalized. 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaContentHandler	TokenNameIdentifier	 Schema Content Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
namespacePrefixes	TokenNameIdentifier	 namespace Prefixes
,	TokenNameCOMMA	
stringsInternalized	TokenNameIdentifier	 strings Internalized
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setErrorHandler	TokenNameIdentifier	 set Error Handler
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getSAXErrorHandler	TokenNameIdentifier	 get SAX Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
inputSource	TokenNameIdentifier	 input Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Disconnect the schema loader and other objects from the XMLReader 	TokenNameCOMMENT_LINE	Disconnect the schema loader and other objects from the XMLReader 
try	TokenNametry	
{	TokenNameLBRACE	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
setErrorHandler	TokenNameIdentifier	 set Error Handler
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Ignore any exceptions thrown by the XMLReader. Old versions of SAX 	TokenNameCOMMENT_LINE	Ignore any exceptions thrown by the XMLReader. Old versions of SAX 
// required an XMLReader to throw a NullPointerException if an attempt 	TokenNameCOMMENT_LINE	required an XMLReader to throw a NullPointerException if an attempt 
// to set a handler to null was made. 	TokenNameCOMMENT_LINE	to set a handler to null was made. 
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
Document	TokenNameIdentifier	 Document
schemaDocument	TokenNameIdentifier	 schema Document
=	TokenNameEQUAL	
fXSContentHandler	TokenNameIdentifier	 f XS Content Handler
.	TokenNameDOT	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
schemaDocument	TokenNameIdentifier	 schema Document
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
schemaDocument	TokenNameIdentifier	 schema Document
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSchemaDocument0	TokenNameIdentifier	 get Schema Document0
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXParseException	TokenNameIdentifier	 SAX Parse Exception
spe	TokenNameIdentifier	 spe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
SAX2XNIUtil	TokenNameIdentifier	 SA X2 XNI Util
.	TokenNameDOT	
createXMLParseException0	TokenNameIdentifier	 create XML Parse Exception0
(	TokenNameLPAREN	
spe	TokenNameIdentifier	 spe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
SAX2XNIUtil	TokenNameIdentifier	 SA X2 XNI Util
.	TokenNameDOT	
createXNIException0	TokenNameIdentifier	 create XNI Exception0
(	TokenNameLPAREN	
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
ioe	TokenNameIdentifier	 ioe
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getSchemaDocument1	TokenNameIdentifier	 get Schema Document1
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
hasInput	TokenNameIdentifier	 has Input
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument(String, SAXInputSource, boolean, short, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument(String, SAXInputSource, boolean, short, Element): Element 
/** * getSchemaDocument method uses DOMInputSource to parse a schema document. * @param schemaNamespace * @param schemaSource * @param mustResolve * @param referType * @param referElement * @return A schema Element. */	TokenNameCOMMENT_JAVADOC	 getSchemaDocument method uses DOMInputSource to parse a schema document. @param schemaNamespace @param schemaSource @param mustResolve @param referType @param referElement @return A schema Element. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
DOMInputSource	TokenNameIdentifier	 DOM Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
IOException	TokenNameIdentifier	 IO Exception
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
schemaRootElement	TokenNameIdentifier	 schema Root Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
nodeType	TokenNameIdentifier	 node Type
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeType	TokenNameIdentifier	 node Type
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeType	TokenNameIdentifier	 node Type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRootElement	TokenNameIdentifier	 schema Root Element
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeType	TokenNameIdentifier	 node Type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaRootElement	TokenNameIdentifier	 schema Root Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
schemaRootElement	TokenNameIdentifier	 schema Root Element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check whether the same document has been parsed before. 	TokenNameCOMMENT_LINE	check whether the same document has been parsed before. 
// If so, return the document corresponding to that system id. 	TokenNameCOMMENT_LINE	If so, return the document corresponding to that system id. 
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isDocument	TokenNameIdentifier	 is Document
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nodeType	TokenNameIdentifier	 node Type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isDocument	TokenNameIdentifier	 is Document
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
schemaRootElement	TokenNameIdentifier	 schema Root Element
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isDocument	TokenNameIdentifier	 is Document
=	TokenNameEQUAL	
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDocument	TokenNameIdentifier	 is Document
)	TokenNameRPAREN	
{	TokenNameLBRACE	
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
schemaElement	TokenNameIdentifier	 schema Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
schemaRootElement	TokenNameIdentifier	 schema Root Element
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSchemaDocument0	TokenNameIdentifier	 get Schema Document0
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
hasInput	TokenNameIdentifier	 has Input
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
ioe	TokenNameIdentifier	 ioe
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getSchemaDocument1	TokenNameIdentifier	 get Schema Document1
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
hasInput	TokenNameIdentifier	 has Input
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument(String, DOMInputSource, boolean, short, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument(String, DOMInputSource, boolean, short, Element): Element 
/** * getSchemaDocument method uses StAXInputSource to parse a schema document. * @param schemaNamespace * @param schemaSource * @param mustResolve * @param referType * @param referElement * @return A schema Element. */	TokenNameCOMMENT_JAVADOC	 getSchemaDocument method uses StAXInputSource to parse a schema document. @param schemaNamespace @param schemaSource @param mustResolve @param referType @param referElement @return A schema Element. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
schemaNamespace	TokenNameIdentifier	 schema Namespace
,	TokenNameCOMMA	
StAXInputSource	TokenNameIdentifier	 St AX Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IOException	TokenNameIdentifier	 IO Exception
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
consumeRemainingContent	TokenNameIdentifier	 consume Remaining Content
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
shouldConsumeRemainingContent	TokenNameIdentifier	 should Consume Remaining Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XMLStreamReader	TokenNameIdentifier	 XML Stream Reader
streamReader	TokenNameIdentifier	 stream Reader
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getXMLStreamReader	TokenNameIdentifier	 get XML Stream Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XMLEventReader	TokenNameIdentifier	 XML Event Reader
eventReader	TokenNameIdentifier	 event Reader
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getXMLEventReader	TokenNameIdentifier	 get XML Event Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check whether the same document has been parsed before. 	TokenNameCOMMENT_LINE	check whether the same document has been parsed before. 
// If so, return the document corresponding to that system id. 	TokenNameCOMMENT_LINE	If so, return the document corresponding to that system id. 
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
!=	TokenNameNOT_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemaId	TokenNameIdentifier	 schema Id
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isDocument	TokenNameIdentifier	 is Document
=	TokenNameEQUAL	
consumeRemainingContent	TokenNameIdentifier	 consume Remaining Content
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isDocument	TokenNameIdentifier	 is Document
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
streamReader	TokenNameIdentifier	 stream Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isDocument	TokenNameIdentifier	 is Document
=	TokenNameEQUAL	
(	TokenNameLPAREN	
streamReader	TokenNameIdentifier	 stream Reader
.	TokenNameDOT	
getEventType	TokenNameIdentifier	 get Event Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLStreamReader	TokenNameIdentifier	 XML Stream Reader
.	TokenNameDOT	
START_DOCUMENT	TokenNameIdentifier	 START  DOCUMENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
isDocument	TokenNameIdentifier	 is Document
=	TokenNameEQUAL	
eventReader	TokenNameIdentifier	 event Reader
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isStartDocument	TokenNameIdentifier	 is Start Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDocument	TokenNameIdentifier	 is Document
)	TokenNameRPAREN	
{	TokenNameLBRACE	
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
schemaNamespace	TokenNameIdentifier	 schema Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
schemaElement	TokenNameIdentifier	 schema Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
=	TokenNameEQUAL	
new	TokenNamenew	
StAXSchemaParser	TokenNameIdentifier	 St AX Schema Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
streamReader	TokenNameIdentifier	 stream Reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
streamReader	TokenNameIdentifier	 stream Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
consumeRemainingContent	TokenNameIdentifier	 consume Remaining Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
streamReader	TokenNameIdentifier	 stream Reader
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
streamReader	TokenNameIdentifier	 stream Reader
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
eventReader	TokenNameIdentifier	 event Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
consumeRemainingContent	TokenNameIdentifier	 consume Remaining Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
eventReader	TokenNameIdentifier	 event Reader
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eventReader	TokenNameIdentifier	 event Reader
.	TokenNameDOT	
nextEvent	TokenNameIdentifier	 next Event
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Document	TokenNameIdentifier	 Document
schemaDocument	TokenNameIdentifier	 schema Document
=	TokenNameEQUAL	
fStAXSchemaParser	TokenNameIdentifier	 f St AX Schema Parser
.	TokenNameDOT	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemaElement	TokenNameIdentifier	 schema Element
=	TokenNameEQUAL	
schemaDocument	TokenNameIdentifier	 schema Document
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
schemaDocument	TokenNameIdentifier	 schema Document
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSchemaDocument0	TokenNameIdentifier	 get Schema Document0
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLStreamException	TokenNameIdentifier	 XML Stream Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getNestedException	TokenNameIdentifier	 get Nested Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
instanceof	TokenNameinstanceof	
IOException	TokenNameIdentifier	 IO Exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
StAXLocationWrapper	TokenNameIdentifier	 St AX Location Wrapper
slw	TokenNameIdentifier	 slw
=	TokenNameEQUAL	
new	TokenNamenew	
StAXLocationWrapper	TokenNameIdentifier	 St AX Location Wrapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
slw	TokenNameIdentifier	 slw
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
XMLParseException	TokenNameIdentifier	 XML Parse Exception
(	TokenNameLPAREN	
slw	TokenNameIdentifier	 slw
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getSchemaDocument1	TokenNameIdentifier	 get Schema Document1
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument(String, StAXInputSource, boolean, short, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument(String, StAXInputSource, boolean, short, Element): Element 
/** * Code shared between the various getSchemaDocument() methods which * stores mapping information for the document. */	TokenNameCOMMENT_JAVADOC	 Code shared between the various getSchemaDocument() methods which stores mapping information for the document. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument0	TokenNameIdentifier	 get Schema Document0
(	TokenNameLPAREN	
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
schemaId	TokenNameIdentifier	 schema Id
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// now we need to store the mapping information from system id 	TokenNameCOMMENT_LINE	now we need to store the mapping information from system id 
// to the document. also from the document to the system id. 	TokenNameCOMMENT_LINE	to the document. also from the document to the system id. 
if	TokenNameif	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
schemaElement	TokenNameIdentifier	 schema Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
schemaId	TokenNameIdentifier	 schema Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
schemaElement	TokenNameIdentifier	 schema Element
,	TokenNameCOMMA	
schemaId	TokenNameIdentifier	 schema Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
schemaElement	TokenNameIdentifier	 schema Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument0(XSDKey, String, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument0(XSDKey, String, Element): Element 
/** * Error handling code shared between the various getSchemaDocument() methods. */	TokenNameCOMMENT_JAVADOC	 Error handling code shared between the various getSchemaDocument() methods. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument1	TokenNameIdentifier	 get Schema Document1
(	TokenNameLPAREN	
boolean	TokenNameboolean	
mustResolve	TokenNameIdentifier	 must Resolve
,	TokenNameCOMMA	
boolean	TokenNameboolean	
hasInput	TokenNameIdentifier	 has Input
,	TokenNameCOMMA	
XMLInputSource	TokenNameIdentifier	 XML Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// either an error occured (exception), or empty input source was 	TokenNameCOMMENT_LINE	either an error occured (exception), or empty input source was 
// returned, we need to report an error or a warning 	TokenNameCOMMENT_LINE	returned, we need to report an error or a warning 
if	TokenNameif	
(	TokenNameLPAREN	
mustResolve	TokenNameIdentifier	 must Resolve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
hasInput	TokenNameIdentifier	 has Input
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaSource	TokenNameIdentifier	 schema Source
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
hasInput	TokenNameIdentifier	 has Input
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
referElement	TokenNameIdentifier	 refer Element
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument1(boolean, boolean, XMLInputSource, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument1(boolean, boolean, XMLInputSource, Element): Element 
/** * getSchemaDocument method uses XMLInputSource to parse a schema document. * @param schemaNamespace * @param schemaSource * @param mustResolve * @param referType * @param referElement * @return A schema Element. */	TokenNameCOMMENT_JAVADOC	 getSchemaDocument method uses XMLInputSource to parse a schema document. @param schemaNamespace @param schemaSource @param mustResolve @param referType @param referElement @return A schema Element. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
getSchemaDocument	TokenNameIdentifier	 get Schema Document
(	TokenNameLPAREN	
XSInputSource	TokenNameIdentifier	 XS Input Source
schemaSource	TokenNameIdentifier	 schema Source
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getGrammars	TokenNameIdentifier	 get Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getContextType	TokenNameIdentifier	 get Context Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
expandedGrammars	TokenNameIdentifier	 expanded Grammars
=	TokenNameEQUAL	
expandGrammars	TokenNameIdentifier	 expand Grammars
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check for existing grammars in our bucket 	TokenNameCOMMENT_LINE	check for existing grammars in our bucket 
// and if there exist any, and namespace growth is 	TokenNameCOMMENT_LINE	and if there exist any, and namespace growth is 
// not enabled - we do nothing 	TokenNameCOMMENT_LINE	not enabled - we do nothing 
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
||	TokenNameOR_OR	
!	TokenNameNOT	
existingGrammars	TokenNameIdentifier	 existing Grammars
(	TokenNameLPAREN	
expandedGrammars	TokenNameIdentifier	 expanded Grammars
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addGrammars	TokenNameIdentifier	 add Grammars
(	TokenNameLPAREN	
expandedGrammars	TokenNameIdentifier	 expanded Grammars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
schemaSource	TokenNameIdentifier	 schema Source
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Hashtable	TokenNameIdentifier	 Hashtable
importDependencies	TokenNameIdentifier	 import Dependencies
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
expandedComponents	TokenNameIdentifier	 expanded Components
=	TokenNameEQUAL	
expandComponents	TokenNameIdentifier	 expand Components
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
importDependencies	TokenNameIdentifier	 import Dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
||	TokenNameOR_OR	
canAddComponents	TokenNameIdentifier	 can Add Components
(	TokenNameLPAREN	
expandedComponents	TokenNameIdentifier	 expanded Components
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addGlobalComponents	TokenNameIdentifier	 add Global Components
(	TokenNameLPAREN	
expandedComponents	TokenNameIdentifier	 expanded Components
,	TokenNameCOMMA	
importDependencies	TokenNameIdentifier	 import Dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
referType	TokenNameIdentifier	 refer Type
==	TokenNameEQUAL_EQUAL	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_PREPARSE	TokenNameIdentifier	 CONTEXT  PREPARSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setTargetNamespace	TokenNameIdentifier	 set Target Namespace
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getSchemaDocument(String, XSInputSource, boolean, short, Element): Element 	TokenNameCOMMENT_LINE	getSchemaDocument(String, XSInputSource, boolean, short, Element): Element 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
expandGrammars	TokenNameIdentifier	 expand Grammars
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
currGrammars	TokenNameIdentifier	 curr Grammars
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for all (recursively) imported grammars 	TokenNameCOMMENT_LINE	for all (recursively) imported grammars 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg1	TokenNameIdentifier	 sg1
,	TokenNameCOMMA	
sg2	TokenNameIdentifier	 sg2
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
gs	TokenNameIdentifier	 gs
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the grammar 	TokenNameCOMMENT_LINE	get the grammar 
sg1	TokenNameIdentifier	 sg1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we need to add grammars imported by sg1 too 	TokenNameCOMMENT_LINE	we need to add grammars imported by sg1 too 
gs	TokenNameIdentifier	 gs
=	TokenNameEQUAL	
sg1	TokenNameIdentifier	 sg1
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for all grammars imported by sg2, but not in the vector 	TokenNameCOMMENT_LINE	for all grammars imported by sg2, but not in the vector 
// we add them to the vector 	TokenNameCOMMENT_LINE	we add them to the vector 
if	TokenNameif	
(	TokenNameLPAREN	
gs	TokenNameIdentifier	 gs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
gs	TokenNameIdentifier	 gs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg2	TokenNameIdentifier	 sg2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
gs	TokenNameIdentifier	 gs
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
sg2	TokenNameIdentifier	 sg2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currGrammars	TokenNameIdentifier	 curr Grammars
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
sg2	TokenNameIdentifier	 sg2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
currGrammars	TokenNameIdentifier	 curr Grammars
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
existingGrammars	TokenNameIdentifier	 existing Grammars
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg1	TokenNameIdentifier	 sg1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
sg1	TokenNameIdentifier	 sg1
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg2	TokenNameIdentifier	 sg2
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg2	TokenNameIdentifier	 sg2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
canAddComponents	TokenNameIdentifier	 can Add Components
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObject	TokenNameIdentifier	 XS Object
component	TokenNameIdentifier	 component
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
canAddComponent	TokenNameIdentifier	 can Add Component
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
canAddComponent	TokenNameIdentifier	 can Add Component
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
short	TokenNameshort	
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARATION	TokenNameIdentifier	 ATTRIBUTE  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_GROUP	TokenNameIdentifier	 ATTRIBUTE  GROUP
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP_DEFINITION	TokenNameIdentifier	 MODEL  GROUP  DEFINITION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DECLARATION	TokenNameIdentifier	 NOTATION  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
IDENTITY_CONSTRAINT	TokenNameIdentifier	 IDENTITY  CONSTRAINT
:	TokenNameCOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_USE	TokenNameIdentifier	 ATTRIBUTE  USE
:	TokenNameCOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGrammars	TokenNameIdentifier	 add Grammars
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg1	TokenNameIdentifier	 sg1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
sg1	TokenNameIdentifier	 sg1
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg2	TokenNameIdentifier	 sg2
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg1	TokenNameIdentifier	 sg1
!=	TokenNameNOT_EQUAL	
sg2	TokenNameIdentifier	 sg2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addGrammarComponents	TokenNameIdentifier	 add Grammar Components
(	TokenNameLPAREN	
sg1	TokenNameIdentifier	 sg1
,	TokenNameCOMMA	
sg2	TokenNameIdentifier	 sg2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGrammarComponents	TokenNameIdentifier	 add Grammar Components
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dstGrammar	TokenNameIdentifier	 dst Grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createGrammarFrom	TokenNameIdentifier	 create Grammar From
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
tmpGrammar	TokenNameIdentifier	 tmp Grammar
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tmpGrammar	TokenNameIdentifier	 tmp Grammar
.	TokenNameDOT	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmpGrammar	TokenNameIdentifier	 tmp Grammar
=	TokenNameEQUAL	
createGrammarFrom	TokenNameIdentifier	 create Grammar From
(	TokenNameLPAREN	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// add any new locations 	TokenNameCOMMENT_LINE	add any new locations 
addNewGrammarLocations	TokenNameIdentifier	 add New Grammar Locations
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
tmpGrammar	TokenNameIdentifier	 tmp Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// add any new imported grammars 	TokenNameCOMMENT_LINE	add any new imported grammars 
addNewImportedGrammars	TokenNameIdentifier	 add New Imported Grammars
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
tmpGrammar	TokenNameIdentifier	 tmp Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// add any new global components 	TokenNameCOMMENT_LINE	add any new global components 
addNewGrammarComponents	TokenNameIdentifier	 add New Grammar Components
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
tmpGrammar	TokenNameIdentifier	 tmp Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
createGrammarFrom	TokenNameIdentifier	 create Grammar From
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
newGrammar	TokenNameIdentifier	 new Grammar
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// update all the grammars in the bucket to point to the new grammar. 	TokenNameCOMMENT_LINE	update all the grammars in the bucket to point to the new grammar. 
updateImportListWith	TokenNameIdentifier	 update Import List With
(	TokenNameLPAREN	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// update import list of the new grammar 	TokenNameCOMMENT_LINE	update import list of the new grammar 
updateImportListFor	TokenNameIdentifier	 update Import List For
(	TokenNameLPAREN	
newGrammar	TokenNameIdentifier	 new Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newGrammar	TokenNameIdentifier	 new Grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addNewGrammarLocations	TokenNameIdentifier	 add New Grammar Locations
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
StringList	TokenNameIdentifier	 String List
locations	TokenNameIdentifier	 locations
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
locSize	TokenNameIdentifier	 loc Size
=	TokenNameEQUAL	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
StringList	TokenNameIdentifier	 String List
locations2	TokenNameIdentifier	 locations2
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
locSize	TokenNameIdentifier	 loc Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
locations2	TokenNameIdentifier	 locations2
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addNewImportedGrammars	TokenNameIdentifier	 add New Imported Grammars
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Vector	TokenNameIdentifier	 Vector
igs1	TokenNameIdentifier	 igs1
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
igs1	TokenNameIdentifier	 igs1
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
igs2	TokenNameIdentifier	 igs2
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
igs2	TokenNameIdentifier	 igs2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
igs2	TokenNameIdentifier	 igs2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
igs1	TokenNameIdentifier	 igs1
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
setImportedGrammars	TokenNameIdentifier	 set Imported Grammars
(	TokenNameLPAREN	
igs2	TokenNameIdentifier	 igs2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
updateImportList	TokenNameIdentifier	 update Import List
(	TokenNameLPAREN	
igs1	TokenNameIdentifier	 igs1
,	TokenNameCOMMA	
igs2	TokenNameIdentifier	 igs2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
updateImportList	TokenNameIdentifier	 update Import List
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
importedSrc	TokenNameIdentifier	 imported Src
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
importedDst	TokenNameIdentifier	 imported Dst
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
importedSrc	TokenNameIdentifier	 imported Src
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
importedSrc	TokenNameIdentifier	 imported Src
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
containedImportedGrammar	TokenNameIdentifier	 contained Imported Grammar
(	TokenNameLPAREN	
importedDst	TokenNameIdentifier	 imported Dst
,	TokenNameCOMMA	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
importedDst	TokenNameIdentifier	 imported Dst
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addNewGrammarComponents	TokenNameIdentifier	 add New Grammar Components
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
resetComponents	TokenNameIdentifier	 reset Components
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalElementDecls	TokenNameIdentifier	 add Global Element Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalAttributeDecls	TokenNameIdentifier	 add Global Attribute Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalAttributeGroupDecls	TokenNameIdentifier	 add Global Attribute Group Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalGroupDecls	TokenNameIdentifier	 add Global Group Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalTypeDecls	TokenNameIdentifier	 add Global Type Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addGlobalNotationDecls	TokenNameIdentifier	 add Global Notation Decls
(	TokenNameLPAREN	
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalElementDecls	TokenNameIdentifier	 add Global Element Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: if not tolerating duplicate, generate an error message 	TokenNameCOMMENT_LINE	TODO: if not tolerating duplicate, generate an error message 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: if not tolerating duplicate, generate an error message 	TokenNameCOMMENT_LINE	TODO: if not tolerating duplicate, generate an error message 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalAttributeDecls	TokenNameIdentifier	 add Global Attribute Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARATION	TokenNameIdentifier	 ATTRIBUTE  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalAttributeDecl	TokenNameIdentifier	 add Global Attribute Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARATION	TokenNameIdentifier	 ATTRIBUTE  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalAttributeDecl	TokenNameIdentifier	 add Global Attribute Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT - do we report an error? 	TokenNameCOMMENT_LINE	REVISIT - do we report an error? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalAttributeGroupDecls	TokenNameIdentifier	 add Global Attribute Group Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_GROUP	TokenNameIdentifier	 ATTRIBUTE  GROUP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalAttributeGroupDecl	TokenNameIdentifier	 add Global Attribute Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_GROUP	TokenNameIdentifier	 ATTRIBUTE  GROUP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalAttributeGroupDecl	TokenNameIdentifier	 get Global Attribute Group Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalAttributeGroupDecl	TokenNameIdentifier	 add Global Attribute Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT - do we report an error? 	TokenNameCOMMENT_LINE	REVISIT - do we report an error? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalNotationDecls	TokenNameIdentifier	 add Global Notation Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DECLARATION	TokenNameIdentifier	 NOTATION  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalNotationDecl	TokenNameIdentifier	 add Global Notation Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DECLARATION	TokenNameIdentifier	 NOTATION  DECLARATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalNotationDecl	TokenNameIdentifier	 add Global Notation Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT - do we report an error? 	TokenNameCOMMENT_LINE	REVISIT - do we report an error? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalGroupDecls	TokenNameIdentifier	 add Global Group Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP_DEFINITION	TokenNameIdentifier	 MODEL  GROUP  DEFINITION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalGroupDecl	TokenNameIdentifier	 add Global Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
!=	TokenNameNOT_EQUAL	
dstDecl	TokenNameIdentifier	 dst Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP_DEFINITION	TokenNameIdentifier	 MODEL  GROUP  DEFINITION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalGroupDecl	TokenNameIdentifier	 add Global Group Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVIST - do we report an error? 	TokenNameCOMMENT_LINE	REVIST - do we report an error? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalTypeDecls	TokenNameIdentifier	 add Global Type Decls
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
srcGrammar	TokenNameIdentifier	 src Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
dstGrammar	TokenNameIdentifier	 dst Grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSNamedMap	TokenNameIdentifier	 XS Named Map
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponents	TokenNameIdentifier	 get Components
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
dstDecl	TokenNameIdentifier	 dst Decl
;	TokenNameSEMICOLON	
// add global components 	TokenNameCOMMENT_LINE	add global components 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcDecl	TokenNameIdentifier	 src Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// add any extended (duplicate) global components 	TokenNameCOMMENT_LINE	add any extended (duplicate) global components 
ObjectList	TokenNameIdentifier	 Object List
componentsExt	TokenNameIdentifier	 components Ext
=	TokenNameEQUAL	
srcGrammar	TokenNameIdentifier	 src Grammar
.	TokenNameDOT	
getComponentsExt	TokenNameIdentifier	 get Components Ext
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcDecl	TokenNameIdentifier	 src Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
componentsExt	TokenNameIdentifier	 components Ext
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstDecl	TokenNameIdentifier	 dst Decl
=	TokenNameEQUAL	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dstGrammar	TokenNameIdentifier	 dst Grammar
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
srcDecl	TokenNameIdentifier	 src Decl
,	TokenNameCOMMA	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT - do we report an error? 	TokenNameCOMMENT_LINE	REVISIT - do we report an error? 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dstDecl	TokenNameIdentifier	 dst Decl
!=	TokenNameNOT_EQUAL	
srcDecl	TokenNameIdentifier	 src Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
expandComponents	TokenNameIdentifier	 expand Components
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
newComponents	TokenNameIdentifier	 new Components
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
newComponents	TokenNameIdentifier	 new Components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newComponents	TokenNameIdentifier	 new Components
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newComponents	TokenNameIdentifier	 new Components
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
XSObject	TokenNameIdentifier	 XS Object
component	TokenNameIdentifier	 component
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
)	TokenNameRPAREN	
newComponents	TokenNameIdentifier	 new Components
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expandRelatedComponents	TokenNameIdentifier	 expand Related Components
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
newComponents	TokenNameIdentifier	 new Components
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
newComponents	TokenNameIdentifier	 new Components
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedComponents	TokenNameIdentifier	 expand Related Components
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
:	TokenNameCOLON	
expandRelatedTypeComponents	TokenNameIdentifier	 expand Related Type Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARATION	TokenNameIdentifier	 ATTRIBUTE  DECLARATION
:	TokenNameCOLON	
expandRelatedAttributeComponents	TokenNameIdentifier	 expand Related Attribute Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeDeclaration	TokenNameIdentifier	 XS Attribute Declaration
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_GROUP	TokenNameIdentifier	 ATTRIBUTE  GROUP
:	TokenNameCOLON	
expandRelatedAttributeGroupComponents	TokenNameIdentifier	 expand Related Attribute Group Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeGroupDefinition	TokenNameIdentifier	 XS Attribute Group Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
:	TokenNameCOLON	
expandRelatedElementComponents	TokenNameIdentifier	 expand Related Element Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP_DEFINITION	TokenNameIdentifier	 MODEL  GROUP  DEFINITION
:	TokenNameCOLON	
expandRelatedModelGroupDefinitionComponents	TokenNameIdentifier	 expand Related Model Group Definition Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupDefinition	TokenNameIdentifier	 XS Model Group Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_USE	TokenNameIdentifier	 ATTRIBUTE  USE
:	TokenNameCOLON	
//expandRelatedAttributeUseComponents((XSAttributeUse)component, componentList, dependencies); 	TokenNameCOMMENT_LINE	expandRelatedAttributeUseComponents((XSAttributeUse)component, componentList, dependencies); 
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DECLARATION	TokenNameIdentifier	 NOTATION  DECLARATION
:	TokenNameCOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
IDENTITY_CONSTRAINT	TokenNameIdentifier	 IDENTITY  CONSTRAINT
:	TokenNameCOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedAttributeComponents	TokenNameIdentifier	 expand Related Attribute Components
(	TokenNameLPAREN	
XSAttributeDeclaration	TokenNameIdentifier	 XS Attribute Declaration
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getTypeDefinition	TokenNameIdentifier	 get Type Definition
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/*final XSComplexTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); if (enclosingType != null) { addRelatedType(enclosingType, componentList, namespace, dependencies); }*/	TokenNameCOMMENT_BLOCK	final XSComplexTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); if (enclosingType != null) { addRelatedType(enclosingType, componentList, namespace, dependencies); }
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedElementComponents	TokenNameIdentifier	 expand Related Element Components
(	TokenNameLPAREN	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getTypeDefinition	TokenNameIdentifier	 get Type Definition
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/*final XSTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); if (enclosingType != null) { addRelatedType(enclosingType, componentList, namespace, dependencies); }*/	TokenNameCOMMENT_BLOCK	final XSTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); if (enclosingType != null) { addRelatedType(enclosingType, componentList, namespace, dependencies); }
final	TokenNamefinal	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
subElemDecl	TokenNameIdentifier	 sub Elem Decl
=	TokenNameEQUAL	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getSubstitutionGroupAffiliation	TokenNameIdentifier	 get Substitution Group Affiliation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subElemDecl	TokenNameIdentifier	 sub Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedElement	TokenNameIdentifier	 add Related Element
(	TokenNameLPAREN	
subElemDecl	TokenNameIdentifier	 sub Elem Decl
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedTypeComponents	TokenNameIdentifier	 expand Related Type Components
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedComplexTypeComponents	TokenNameIdentifier	 expand Related Complex Type Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedSimpleTypeComponents	TokenNameIdentifier	 expand Related Simple Type Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedModelGroupDefinitionComponents	TokenNameIdentifier	 expand Related Model Group Definition Components
(	TokenNameLPAREN	
XSModelGroupDefinition	TokenNameIdentifier	 XS Model Group Definition
modelGroupDef	TokenNameIdentifier	 model Group Def
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedModelGroupComponents	TokenNameIdentifier	 expand Related Model Group Components
(	TokenNameLPAREN	
modelGroupDef	TokenNameIdentifier	 model Group Def
.	TokenNameDOT	
getModelGroup	TokenNameIdentifier	 get Model Group
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedAttributeGroupComponents	TokenNameIdentifier	 expand Related Attribute Group Components
(	TokenNameLPAREN	
XSAttributeGroupDefinition	TokenNameIdentifier	 XS Attribute Group Definition
attrGroup	TokenNameIdentifier	 attr Group
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedAttributeUsesComponents	TokenNameIdentifier	 expand Related Attribute Uses Components
(	TokenNameLPAREN	
attrGroup	TokenNameIdentifier	 attr Group
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedComplexTypeComponents	TokenNameIdentifier	 expand Related Complex Type Components
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expandRelatedAttributeUsesComponents	TokenNameIdentifier	 expand Related Attribute Uses Components
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSParticle	TokenNameIdentifier	 XS Particle
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedParticleComponents	TokenNameIdentifier	 expand Related Particle Components
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedSimpleTypeComponents	TokenNameIdentifier	 expand Related Simple Type Components
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
baseType	TokenNameIdentifier	 base Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
itemType	TokenNameIdentifier	 item Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getItemType	TokenNameIdentifier	 get Item Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
itemType	TokenNameIdentifier	 item Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
itemType	TokenNameIdentifier	 item Type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
primitiveType	TokenNameIdentifier	 primitive Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getPrimitiveType	TokenNameIdentifier	 get Primitive Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
primitiveType	TokenNameIdentifier	 primitive Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
primitiveType	TokenNameIdentifier	 primitive Type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
XSObjectList	TokenNameIdentifier	 XS Object List
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedAttributeUsesComponents	TokenNameIdentifier	 expand Related Attribute Uses Components
(	TokenNameLPAREN	
XSObjectList	TokenNameIdentifier	 XS Object List
attrUses	TokenNameIdentifier	 attr Uses
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
attrUseSize	TokenNameIdentifier	 attr Use Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
attrUses	TokenNameIdentifier	 attr Uses
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrUseSize	TokenNameIdentifier	 attr Use Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedAttributeUseComponents	TokenNameIdentifier	 expand Related Attribute Use Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
)	TokenNameRPAREN	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedAttributeUseComponents	TokenNameIdentifier	 expand Related Attribute Use Components
(	TokenNameLPAREN	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addRelatedAttribute	TokenNameIdentifier	 add Related Attribute
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getAttrDeclaration	TokenNameIdentifier	 get Attr Declaration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedParticleComponents	TokenNameIdentifier	 expand Related Particle Components
(	TokenNameLPAREN	
XSParticle	TokenNameIdentifier	 XS Particle
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSTerm	TokenNameIdentifier	 XS Term
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
:	TokenNameCOLON	
addRelatedElement	TokenNameIdentifier	 add Related Element
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
)	TokenNameRPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP	TokenNameIdentifier	 MODEL  GROUP
:	TokenNameCOLON	
expandRelatedModelGroupComponents	TokenNameIdentifier	 expand Related Model Group Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroup	TokenNameIdentifier	 XS Model Group
)	TokenNameRPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandRelatedModelGroupComponents	TokenNameIdentifier	 expand Related Model Group Components
(	TokenNameLPAREN	
XSModelGroup	TokenNameIdentifier	 XS Model Group
modelGroup	TokenNameIdentifier	 model Group
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
particles	TokenNameIdentifier	 particles
=	TokenNameEQUAL	
modelGroup	TokenNameIdentifier	 model Group
.	TokenNameDOT	
getParticles	TokenNameIdentifier	 get Particles
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
(	TokenNameLPAREN	
particles	TokenNameIdentifier	 particles
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
particles	TokenNameIdentifier	 particles
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandRelatedParticleComponents	TokenNameIdentifier	 expand Related Particle Components
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSParticle	TokenNameIdentifier	 XS Particle
)	TokenNameRPAREN	
particles	TokenNameIdentifier	 particles
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addRelatedType	TokenNameIdentifier	 add Related Type
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//REVISIT - do we use == instead 	TokenNameCOMMENT_LINE	REVISIT - do we use == instead 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Vector	TokenNameIdentifier	 Vector
importedNamespaces	TokenNameIdentifier	 imported Namespaces
=	TokenNameEQUAL	
findDependentNamespaces	TokenNameIdentifier	 find Dependent Namespaces
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addNamespaceDependency	TokenNameIdentifier	 add Namespace Dependency
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
importedNamespaces	TokenNameIdentifier	 imported Namespaces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
expandRelatedTypeComponents	TokenNameIdentifier	 expand Related Type Components
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addRelatedElement	TokenNameIdentifier	 add Related Element
(	TokenNameLPAREN	
XSElementDeclaration	TokenNameIdentifier	 XS Element Declaration
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getScope	TokenNameIdentifier	 get Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
importedNamespaces	TokenNameIdentifier	 imported Namespaces
=	TokenNameEQUAL	
findDependentNamespaces	TokenNameIdentifier	 find Dependent Namespaces
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addNamespaceDependency	TokenNameIdentifier	 add Namespace Dependency
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
importedNamespaces	TokenNameIdentifier	 imported Namespaces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
expandRelatedElementComponents	TokenNameIdentifier	 expand Related Element Components
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addRelatedAttribute	TokenNameIdentifier	 add Related Attribute
(	TokenNameLPAREN	
XSAttributeDeclaration	TokenNameIdentifier	 XS Attribute Declaration
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getScope	TokenNameIdentifier	 get Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
importedNamespaces	TokenNameIdentifier	 imported Namespaces
=	TokenNameEQUAL	
findDependentNamespaces	TokenNameIdentifier	 find Dependent Namespaces
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addNamespaceDependency	TokenNameIdentifier	 add Namespace Dependency
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
importedNamespaces	TokenNameIdentifier	 imported Namespaces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
componentList	TokenNameIdentifier	 component List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
expandRelatedAttributeComponents	TokenNameIdentifier	 expand Related Attribute Components
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
componentList	TokenNameIdentifier	 component List
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
dependencies	TokenNameIdentifier	 dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalComponents	TokenNameIdentifier	 add Global Components
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
importDependencies	TokenNameIdentifier	 import Dependencies
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addGlobalComponent	TokenNameIdentifier	 add Global Component
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
)	TokenNameRPAREN	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
updateImportDependencies	TokenNameIdentifier	 update Import Dependencies
(	TokenNameLPAREN	
importDependencies	TokenNameIdentifier	 import Dependencies
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addGlobalComponent	TokenNameIdentifier	 add Global Component
(	TokenNameLPAREN	
XSObject	TokenNameIdentifier	 XS Object
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
getSchemaGrammar	TokenNameIdentifier	 get Schema Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
componentType	TokenNameIdentifier	 component Type
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
component	TokenNameIdentifier	 component
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
.	TokenNameDOT	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_DECLARATION	TokenNameIdentifier	 ATTRIBUTE  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
.	TokenNameDOT	
getScope	TokenNameIdentifier	 get Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalAttributeDecl	TokenNameIdentifier	 add Global Attribute Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalAttributeDecl	TokenNameIdentifier	 add Global Attribute Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_GROUP	TokenNameIdentifier	 ATTRIBUTE  GROUP
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalAttributeGroupDecl	TokenNameIdentifier	 add Global Attribute Group Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalAttributeGroupDecl	TokenNameIdentifier	 add Global Attribute Group Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ELEMENT_DECLARATION	TokenNameIdentifier	 ELEMENT  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
.	TokenNameDOT	
getScope	TokenNameIdentifier	 get Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
.	TokenNameDOT	
SCOPE_GLOBAL	TokenNameIdentifier	 SCOPE  GLOBAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalElementDeclAll	TokenNameIdentifier	 add Global Element Decl All
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalElementDecl	TokenNameIdentifier	 add Global Element Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MODEL_GROUP_DEFINITION	TokenNameIdentifier	 MODEL  GROUP  DEFINITION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalGroupDecl	TokenNameIdentifier	 add Global Group Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalGroupDecl	TokenNameIdentifier	 get Global Group Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalGroupDecl	TokenNameIdentifier	 add Global Group Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DECLARATION	TokenNameIdentifier	 NOTATION  DECLARATION
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalNotationDecl	TokenNameIdentifier	 add Global Notation Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the declaration in the extended map, using an empty location 	TokenNameCOMMENT_LINE	store the declaration in the extended map, using an empty location 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
addGlobalNotationDecl	TokenNameIdentifier	 add Global Notation Decl
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
)	TokenNameRPAREN	
component	TokenNameIdentifier	 component
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
IDENTITY_CONSTRAINT	TokenNameIdentifier	 IDENTITY  CONSTRAINT
:	TokenNameCOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ATTRIBUTE_USE	TokenNameIdentifier	 ATTRIBUTE  USE
:	TokenNameCOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
updateImportDependencies	TokenNameIdentifier	 update Import Dependencies
(	TokenNameLPAREN	
Hashtable	TokenNameIdentifier	 Hashtable
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
importList	TokenNameIdentifier	 import List
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
importList	TokenNameIdentifier	 import List
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
importList	TokenNameIdentifier	 import List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expandImportList	TokenNameIdentifier	 expand Import List
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
importList	TokenNameIdentifier	 import List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
expandImportList	TokenNameIdentifier	 expand Import List
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// shouldn't be null 	TokenNameCOMMENT_LINE	shouldn't be null 
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
isgs	TokenNameIdentifier	 isgs
=	TokenNameEQUAL	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getImportedGrammars	TokenNameIdentifier	 get Imported Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isgs	TokenNameIdentifier	 isgs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isgs	TokenNameIdentifier	 isgs
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addImportList	TokenNameIdentifier	 add Import List
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
,	TokenNameCOMMA	
isgs	TokenNameIdentifier	 isgs
,	TokenNameCOMMA	
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
setImportedGrammars	TokenNameIdentifier	 set Imported Grammars
(	TokenNameLPAREN	
isgs	TokenNameIdentifier	 isgs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
updateImportList	TokenNameIdentifier	 update Import List
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
,	TokenNameCOMMA	
isgs	TokenNameIdentifier	 isgs
,	TokenNameCOMMA	
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addImportList	TokenNameIdentifier	 add Import List
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
importedGrammars	TokenNameIdentifier	 imported Grammars
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
namespaceList	TokenNameIdentifier	 namespace List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg	TokenNameIdentifier	 isg
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isg	TokenNameIdentifier	 isg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
namespaceList	TokenNameIdentifier	 namespace List
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//REVIST: report an error message 	TokenNameCOMMENT_LINE	REVIST: report an error message 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
updateImportList	TokenNameIdentifier	 update Import List
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
importedGrammars	TokenNameIdentifier	 imported Grammars
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
namespaceList	TokenNameIdentifier	 namespace List
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
isg	TokenNameIdentifier	 isg
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isg	TokenNameIdentifier	 isg
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
namespaceList	TokenNameIdentifier	 namespace List
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
containedImportedGrammar	TokenNameIdentifier	 contained Imported Grammar
(	TokenNameLPAREN	
importedGrammars	TokenNameIdentifier	 imported Grammars
,	TokenNameCOMMA	
isg	TokenNameIdentifier	 isg
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
importedGrammars	TokenNameIdentifier	 imported Grammars
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
isg	TokenNameIdentifier	 isg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//REVIST: report an error message 	TokenNameCOMMENT_LINE	REVIST: report an error message 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
containedImportedGrammar	TokenNameIdentifier	 contained Imported Grammar
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
importedGrammar	TokenNameIdentifier	 imported Grammar
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
importedGrammar	TokenNameIdentifier	 imported Grammar
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
importedGrammar	TokenNameIdentifier	 imported Grammar
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// NOTE: always assuming that fNamespaceGrowth is enabled 	TokenNameCOMMENT_LINE	NOTE: always assuming that fNamespaceGrowth is enabled 
// otherwise the grammar should have existed 	TokenNameCOMMENT_LINE	otherwise the grammar should have existed 
private	TokenNameprivate	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
getSchemaGrammar	TokenNameIdentifier	 get Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
findGrammar	TokenNameIdentifier	 find Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
new	TokenNamenew	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
makeClone	TokenNameIdentifier	 make Clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
.	TokenNameDOT	
isImmutable	TokenNameIdentifier	 is Immutable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sg	TokenNameIdentifier	 sg
=	TokenNameEQUAL	
createGrammarFrom	TokenNameIdentifier	 create Grammar From
(	TokenNameLPAREN	
sg	TokenNameIdentifier	 sg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sg	TokenNameIdentifier	 sg
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
findDependentNamespaces	TokenNameIdentifier	 find Dependent Namespaces
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ns	TokenNameIdentifier	 ns
=	TokenNameEQUAL	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
namespaceList	TokenNameIdentifier	 namespace List
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ns	TokenNameIdentifier	 ns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
namespaceList	TokenNameIdentifier	 namespace List
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespaceList	TokenNameIdentifier	 namespace List
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
ns	TokenNameIdentifier	 ns
,	TokenNameCOMMA	
namespaceList	TokenNameIdentifier	 namespace List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
namespaceList	TokenNameIdentifier	 namespace List
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addNamespaceDependency	TokenNameIdentifier	 add Namespace Dependency
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace1	TokenNameIdentifier	 namespace1
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace2	TokenNameIdentifier	 namespace2
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ns1	TokenNameIdentifier	 ns1
=	TokenNameEQUAL	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
namespace1	TokenNameIdentifier	 namespace1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ns2	TokenNameIdentifier	 ns2
=	TokenNameEQUAL	
null2EmptyString	TokenNameIdentifier	 null2 Empty String
(	TokenNameLPAREN	
namespace2	TokenNameIdentifier	 namespace2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ns1	TokenNameIdentifier	 ns1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ns2	TokenNameIdentifier	 ns2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
ns2	TokenNameIdentifier	 ns2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ns2	TokenNameIdentifier	 ns2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
reportSharingError	TokenNameIdentifier	 report Sharing Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
qName	TokenNameIdentifier	 q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"sch-props-correct.2"	TokenNameStringLiteral	sch-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
qName	TokenNameIdentifier	 q Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// initialize all the traversers. 	TokenNameCOMMENT_LINE	initialize all the traversers. 
// this should only need to be called once during the construction 	TokenNameCOMMENT_LINE	this should only need to be called once during the construction 
// of this object; it creates the traversers that will be used to 	TokenNameCOMMENT_LINE	of this object; it creates the traversers that will be used to 
// construct schemaGrammars. 	TokenNameCOMMENT_LINE	construct schemaGrammars. 
private	TokenNameprivate	
void	TokenNamevoid	
createTraversers	TokenNameIdentifier	 create Traversers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
=	TokenNameEQUAL	
new	TokenNamenew	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDAttributeGroupTraverser	TokenNameIdentifier	 XSD Attribute Group Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeTraverser	TokenNameIdentifier	 f Attribute Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDAttributeTraverser	TokenNameIdentifier	 XSD Attribute Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDComplexTypeTraverser	TokenNameIdentifier	 XSD Complex Type Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDElementTraverser	TokenNameIdentifier	 XSD Element Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDGroupTraverser	TokenNameIdentifier	 XSD Group Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefTraverser	TokenNameIdentifier	 f Keyref Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDKeyrefTraverser	TokenNameIdentifier	 XSD Keyref Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationTraverser	TokenNameIdentifier	 f Notation Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDNotationTraverser	TokenNameIdentifier	 XSD Notation Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDSimpleTypeTraverser	TokenNameIdentifier	 XSD Simple Type Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUniqueOrKeyTraverser	TokenNameIdentifier	 f Unique Or Key Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDUniqueOrKeyTraverser	TokenNameIdentifier	 XSD Unique Or Key Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fWildCardTraverser	TokenNameIdentifier	 f Wild Card Traverser
=	TokenNameEQUAL	
new	TokenNamenew	
XSDWildcardTraverser	TokenNameIdentifier	 XSD Wildcard Traverser
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// createTraversers() 	TokenNameCOMMENT_LINE	createTraversers() 
// before parsing a schema, need to clear registries associated with 	TokenNameCOMMENT_LINE	before parsing a schema, need to clear registries associated with 
// parsing schemas 	TokenNameCOMMENT_LINE	parsing schemas 
void	TokenNamevoid	
prepareForParse	TokenNameIdentifier	 prepare For Parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTraversed	TokenNameIdentifier	 f Traversed
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLastSchemaWasDuplicate	TokenNameIdentifier	 f Last Schema Was Duplicate
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// before traversing a schema's parse tree, need to reset all traversers and 	TokenNameCOMMENT_LINE	before traversing a schema's parse tree, need to reset all traversers and 
// clear all registries 	TokenNameCOMMENT_LINE	clear all registries 
void	TokenNamevoid	
prepareForTraverse	TokenNameIdentifier	 prepare For Traverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUnparsedAttributeRegistry	TokenNameIdentifier	 f Unparsed Attribute Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedAttributeGroupRegistry	TokenNameIdentifier	 f Unparsed Attribute Group Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedElementRegistry	TokenNameIdentifier	 f Unparsed Element Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedGroupRegistry	TokenNameIdentifier	 f Unparsed Group Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedIdentityConstraintRegistry	TokenNameIdentifier	 f Unparsed Identity Constraint Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedNotationRegistry	TokenNameIdentifier	 f Unparsed Notation Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedTypeRegistry	TokenNameIdentifier	 f Unparsed Type Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedAttributeRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedAttributeGroupRegistrySub	TokenNameIdentifier	 f Unparsed Attribute Group Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedElementRegistrySub	TokenNameIdentifier	 f Unparsed Element Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedGroupRegistrySub	TokenNameIdentifier	 f Unparsed Group Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedIdentityConstraintRegistrySub	TokenNameIdentifier	 f Unparsed Identity Constraint Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedNotationRegistrySub	TokenNameIdentifier	 f Unparsed Notation Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUnparsedTypeRegistrySub	TokenNameIdentifier	 f Unparsed Type Registry Sub
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUnparsedRegistriesExt	TokenNameIdentifier	 f Unparsed Registries Ext
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fXSDocumentInfoRegistry	TokenNameIdentifier	 f XS Document Info Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDependencyMap	TokenNameIdentifier	 f Dependency Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDoc2XSDocumentMap	TokenNameIdentifier	 f Doc2 XS Document Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRedefine2XSDMap	TokenNameIdentifier	 f Redefine2 XSD Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRedefine2NSSupport	TokenNameIdentifier	 f Redefine2 NS Support
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAllTNSs	TokenNameIdentifier	 f All TN Ss
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fImportMap	TokenNameIdentifier	 f Import Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRoot	TokenNameIdentifier	 f Root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// clear local element stack 	TokenNameCOMMENT_LINE	clear local element stack 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fParticle	TokenNameIdentifier	 f Particle
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// and do same for keyrefs. 	TokenNameCOMMENT_LINE	and do same for keyrefs. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fKeyrefs	TokenNameIdentifier	 f Keyrefs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fKeyrefElems	TokenNameIdentifier	 f Keyref Elems
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fKeyrefNamespaceContext	TokenNameIdentifier	 f Keyref Namespace Context
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fKeyrefsMapXSDocumentInfo	TokenNameIdentifier	 f Keyrefs Map XS Document Info
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fKeyrefStackPos	TokenNameIdentifier	 f Keyref Stack Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// create traversers if necessary 	TokenNameCOMMENT_LINE	create traversers if necessary 
if	TokenNameif	
(	TokenNameLPAREN	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createTraversers	TokenNameIdentifier	 create Traversers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset traversers 	TokenNameCOMMENT_LINE	reset traversers 
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeGroupTraverser	TokenNameIdentifier	 f Attribute Group Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttributeTraverser	TokenNameIdentifier	 f Attribute Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fComplexTypeTraverser	TokenNameIdentifier	 f Complex Type Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyrefTraverser	TokenNameIdentifier	 f Keyref Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationTraverser	TokenNameIdentifier	 f Notation Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fUniqueOrKeyTraverser	TokenNameIdentifier	 f Unique Or Key Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fWildCardTraverser	TokenNameIdentifier	 f Wild Card Traverser
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRedefinedRestrictedAttributeGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Attribute Group Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fRedefinedRestrictedGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Group Registry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalAttrDecls	TokenNameIdentifier	 f Global Attr Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalAttrGrpDecls	TokenNameIdentifier	 f Global Attr Grp Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalElemDecls	TokenNameIdentifier	 f Global Elem Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalGroupDecls	TokenNameIdentifier	 f Global Group Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalNotationDecls	TokenNameIdentifier	 f Global Notation Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalIDConstraintDecls	TokenNameIdentifier	 f Global ID Constraint Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalTypeDecls	TokenNameIdentifier	 f Global Type Decls
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDeclPool	TokenNameIdentifier	 set Decl Pool
(	TokenNameLPAREN	
XSDeclarationPool	TokenNameIdentifier	 XS Declaration Pool
declPool	TokenNameIdentifier	 decl Pool
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDeclPool	TokenNameIdentifier	 f Decl Pool
=	TokenNameEQUAL	
declPool	TokenNameIdentifier	 decl Pool
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDVFactory	TokenNameIdentifier	 set DV Factory
(	TokenNameLPAREN	
SchemaDVFactory	TokenNameIdentifier	 Schema DV Factory
dvFactory	TokenNameIdentifier	 dv Factory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDVFactory	TokenNameIdentifier	 f DV Factory
=	TokenNameEQUAL	
dvFactory	TokenNameIdentifier	 dv Factory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set symbol table 	TokenNameCOMMENT_LINE	set symbol table 
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//set entity resolver 	TokenNameCOMMENT_LINE	set entity resolver 
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ENTITY_MANAGER	TokenNameIdentifier	 ENTITY  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
er	TokenNameIdentifier	 er
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
er	TokenNameIdentifier	 er
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setEntityResolver	TokenNameIdentifier	 set Entity Resolver
(	TokenNameLPAREN	
er	TokenNameIdentifier	 er
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set error reporter 	TokenNameCOMMENT_LINE	set error reporter 
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
currErrorHandler	TokenNameIdentifier	 curr Error Handler
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Setting a parser property can be much more expensive 	TokenNameCOMMENT_LINE	Setting a parser property can be much more expensive 
// than checking its value. Don't set the ERROR_HANDLER 	TokenNameCOMMENT_LINE	than checking its value. Don't set the ERROR_HANDLER 
// or LOCALE properties unless they've actually changed. 	TokenNameCOMMENT_LINE	or LOCALE properties unless they've actually changed. 
if	TokenNameif	
(	TokenNameLPAREN	
currErrorHandler	TokenNameIdentifier	 curr Error Handler
!=	TokenNameNOT_EQUAL	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ERROR_HANDLER	TokenNameIdentifier	 ERROR  HANDLER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_HANDLER	TokenNameIdentifier	 ERROR  HANDLER
,	TokenNameCOMMA	
(	TokenNameLPAREN	
currErrorHandler	TokenNameIdentifier	 curr Error Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
currErrorHandler	TokenNameIdentifier	 curr Error Handler
:	TokenNameCOLON	
new	TokenNamenew	
DefaultErrorHandler	TokenNameIdentifier	 Default Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
ERROR_HANDLER	TokenNameIdentifier	 ERROR  HANDLER
,	TokenNameCOMMA	
(	TokenNameLPAREN	
currErrorHandler	TokenNameIdentifier	 curr Error Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
currErrorHandler	TokenNameIdentifier	 curr Error Handler
:	TokenNameCOLON	
new	TokenNamenew	
DefaultErrorHandler	TokenNameIdentifier	 Default Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Locale	TokenNameIdentifier	 Locale
currentLocale	TokenNameIdentifier	 current Locale
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentLocale	TokenNameIdentifier	 current Locale
!=	TokenNameNOT_EQUAL	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
LOCALE	TokenNameIdentifier	 LOCALE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
LOCALE	TokenNameIdentifier	 LOCALE
,	TokenNameCOMMA	
currentLocale	TokenNameIdentifier	 current Locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnnotationValidator	TokenNameIdentifier	 f Annotation Validator
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
LOCALE	TokenNameIdentifier	 LOCALE
,	TokenNameCOMMA	
currentLocale	TokenNameIdentifier	 current Locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
VALIDATE_ANNOTATIONS	TokenNameIdentifier	 VALIDATE  ANNOTATIONS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidateAnnotations	TokenNameIdentifier	 f Validate Annotations
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
HONOUR_ALL_SCHEMALOCATIONS	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fHonourAllSchemaLocations	TokenNameIdentifier	 f Honour All Schema Locations
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
NAMESPACE_GROWTH	TokenNameIdentifier	 NAMESPACE  GROWTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
TOLERATE_DUPLICATES	TokenNameIdentifier	 TOLERATE  DUPLICATES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
CONTINUE_AFTER_FATAL_ERROR	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
CONTINUE_AFTER_FATAL_ERROR	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
ALLOW_JAVA_ENCODINGS	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS
,	TokenNameCOMMA	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
ALLOW_JAVA_ENCODINGS	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
,	TokenNameCOMMA	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
XMLGRAMMAR_POOL	TokenNameIdentifier	 XMLGRAMMAR  POOL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// security features 	TokenNameCOMMENT_LINE	security features 
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
DISALLOW_DOCTYPE	TokenNameIdentifier	 DISALLOW  DOCTYPE
,	TokenNameCOMMA	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
DISALLOW_DOCTYPE	TokenNameIdentifier	 DISALLOW  DOCTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
security	TokenNameIdentifier	 security
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
security	TokenNameIdentifier	 security
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
SECURITY_MANAGER	TokenNameIdentifier	 SECURITY  MANAGER
,	TokenNameCOMMA	
security	TokenNameIdentifier	 security
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reset(XMLComponentManager) 	TokenNameCOMMENT_LINE	reset(XMLComponentManager) 
/** * Traverse all the deferred local elements. This method should be called * by traverseSchemas after we've done with all the global declarations. */	TokenNameCOMMENT_JAVADOC	 Traverse all the deferred local elements. This method should be called by traverseSchemas after we've done with all the global declarations. 
void	TokenNamevoid	
traverseLocalElements	TokenNameIdentifier	 traverse Local Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
fDeferTraversingLocalElements	TokenNameIdentifier	 f Defer Traversing Local Elements
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
currElem	TokenNameIdentifier	 curr Elem
=	TokenNameEQUAL	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getDocument(currElem)); 	TokenNameCOMMENT_LINE	XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getDocument(currElem)); 
//XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getRoot(DOMUtil.getDocument(currElem))); 	TokenNameCOMMENT_LINE	XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getRoot(DOMUtil.getDocument(currElem))); 
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
=	TokenNameEQUAL	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
currGrammar	TokenNameIdentifier	 curr Grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElementTraverser	TokenNameIdentifier	 f Element Traverser
.	TokenNameDOT	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
currElem	TokenNameIdentifier	 curr Elem
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
currGrammar	TokenNameIdentifier	 curr Grammar
,	TokenNameCOMMA	
fAllContext	TokenNameIdentifier	 f All Context
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fParent	TokenNameIdentifier	 f Parent
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If it's an empty particle, remove it from the containing component. 	TokenNameCOMMENT_LINE	If it's an empty particle, remove it from the containing component. 
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_EMPTY	TokenNameIdentifier	 PARTICLE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fParent	TokenNameIdentifier	 f Parent
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticle	TokenNameIdentifier	 XS Particle
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fParent	TokenNameIdentifier	 f Parent
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSGroupDecl	TokenNameIdentifier	 XS Group Decl
)	TokenNameRPAREN	
fParent	TokenNameIdentifier	 f Parent
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
fModelGroup	TokenNameIdentifier	 f Model Group
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
removeParticle	TokenNameIdentifier	 remove Particle
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
,	TokenNameCOMMA	
fParticle	TokenNameIdentifier	 f Particle
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
removeParticle	TokenNameIdentifier	 remove Particle
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
member	TokenNameIdentifier	 member
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
member	TokenNameIdentifier	 member
=	TokenNameEQUAL	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
member	TokenNameIdentifier	 member
==	TokenNameEQUAL_EQUAL	
particle	TokenNameIdentifier	 particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
member	TokenNameIdentifier	 member
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
removeParticle	TokenNameIdentifier	 remove Particle
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
member	TokenNameIdentifier	 member
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
,	TokenNameCOMMA	
particle	TokenNameIdentifier	 particle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// the purpose of this method is to keep up-to-date structures 	TokenNameCOMMENT_LINE	the purpose of this method is to keep up-to-date structures 
// we'll need for the feferred traversal of local elements. 	TokenNameCOMMENT_LINE	we'll need for the feferred traversal of local elements. 
void	TokenNamevoid	
fillInLocalElemInfo	TokenNameIdentifier	 fill In Local Elem Info
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmDecl	TokenNameIdentifier	 elm Decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
int	TokenNameint	
allContextFlags	TokenNameIdentifier	 all Context Flags
,	TokenNameCOMMA	
XSObject	TokenNameIdentifier	 XS Object
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the stack is full, increase the size 	TokenNameCOMMENT_LINE	if the stack is full, increase the size 
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// increase size 	TokenNameCOMMENT_LINE	increase size 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackP	TokenNameIdentifier	 new Stack P
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackP	TokenNameIdentifier	 new Stack P
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
newStackP	TokenNameIdentifier	 new Stack P
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackE	TokenNameIdentifier	 new Stack E
=	TokenNameEQUAL	
new	TokenNamenew	
Element	TokenNameIdentifier	 Element
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackE	TokenNameIdentifier	 new Stack E
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
=	TokenNameEQUAL	
newStackE	TokenNameIdentifier	 new Stack E
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackE_schema	TokenNameIdentifier	 new Stack E schema
=	TokenNameEQUAL	
new	TokenNamenew	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackE_schema	TokenNameIdentifier	 new Stack E schema
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
=	TokenNameEQUAL	
newStackE_schema	TokenNameIdentifier	 new Stack E schema
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackI	TokenNameIdentifier	 new Stack I
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fAllContext	TokenNameIdentifier	 f All Context
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackI	TokenNameIdentifier	 new Stack I
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAllContext	TokenNameIdentifier	 f All Context
=	TokenNameEQUAL	
newStackI	TokenNameIdentifier	 new Stack I
;	TokenNameSEMICOLON	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackC	TokenNameIdentifier	 new Stack C
=	TokenNameEQUAL	
new	TokenNamenew	
XSObject	TokenNameIdentifier	 XS Object
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fParent	TokenNameIdentifier	 f Parent
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackC	TokenNameIdentifier	 new Stack C
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fParent	TokenNameIdentifier	 f Parent
=	TokenNameEQUAL	
newStackC	TokenNameIdentifier	 new Stack C
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newStackN	TokenNameIdentifier	 new Stack N
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newStackN	TokenNameIdentifier	 new Stack N
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
=	TokenNameEQUAL	
newStackN	TokenNameIdentifier	 new Stack N
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fParticle	TokenNameIdentifier	 f Particle
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
fLocalElementDecl	TokenNameIdentifier	 f Local Element Decl
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
elmDecl	TokenNameIdentifier	 elm Decl
;	TokenNameSEMICOLON	
fLocalElementDecl_schema	TokenNameIdentifier	 f Local Element Decl schema
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
;	TokenNameSEMICOLON	
fAllContext	TokenNameIdentifier	 f All Context
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
allContextFlags	TokenNameIdentifier	 all Context Flags
;	TokenNameSEMICOLON	
fParent	TokenNameIdentifier	 f Parent
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
fLocalElemNamespaceContext	TokenNameIdentifier	 f Local Elem Namespace Context
[	TokenNameLBRACKET	
fLocalElemStackPos	TokenNameIdentifier	 f Local Elem Stack Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
.	TokenNameDOT	
getEffectiveLocalContext	TokenNameIdentifier	 get Effective Local Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end fillInLocalElemInfo(...) 	TokenNameCOMMENT_LINE	end fillInLocalElemInfo(...) 
/** This method makes sure that * if this component is being redefined that it lives in the * right schema. It then renames the component correctly. If it * detects a collision--a duplicate definition--then it complains. * Note that redefines must be handled carefully: if there * is a collision, it may be because we're redefining something we know about * or because we've found the thing we're redefining. */	TokenNameCOMMENT_JAVADOC	 This method makes sure that if this component is being redefined that it lives in the right schema. It then renames the component correctly. If it detects a collision--a duplicate definition--then it complains. Note that redefines must be handled carefully: if there is a collision, it may be because we're redefining something we know about or because we've found the thing we're redefining. 
void	TokenNamevoid	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
registry	TokenNameIdentifier	 registry
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
registry_sub	TokenNameIdentifier	 registry sub
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
currComp	TokenNameIdentifier	 curr Comp
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
objElem	TokenNameIdentifier	 obj Elem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// REVISIT: when we add derivation checking, we'll have to make 	TokenNameCOMMENT_LINE	REVISIT: when we add derivation checking, we'll have to make 
// sure that ID constraint collisions don't necessarily result in error messages. 	TokenNameCOMMENT_LINE	sure that ID constraint collisions don't necessarily result in error messages. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
objElem	TokenNameIdentifier	 obj Elem
=	TokenNameEQUAL	
registry	TokenNameIdentifier	 registry
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// need to check whether we have a global declaration in the corresponding 	TokenNameCOMMENT_LINE	need to check whether we have a global declaration in the corresponding 
// grammar 	TokenNameCOMMENT_LINE	grammar 
if	TokenNameif	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
&&	TokenNameAND_AND	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// just add it in! 	TokenNameCOMMENT_LINE	just add it in! 
registry	TokenNameIdentifier	 registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
registry_sub	TokenNameIdentifier	 registry sub
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
collidingElem	TokenNameIdentifier	 colliding Elem
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
objElem	TokenNameIdentifier	 obj Elem
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
collidingElemSchema	TokenNameIdentifier	 colliding Elem Schema
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
registry_sub	TokenNameIdentifier	 registry sub
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
collidingElem	TokenNameIdentifier	 colliding Elem
==	TokenNameEQUAL_EQUAL	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
elemParent	TokenNameIdentifier	 elem Parent
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
redefinedSchema	TokenNameIdentifier	 redefined Schema
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// case where we've collided with a redefining element 	TokenNameCOMMENT_LINE	case where we've collided with a redefining element 
// (the parent of the colliding element is a redefine) 	TokenNameCOMMENT_LINE	(the parent of the colliding element is a redefine) 
boolean	TokenNameboolean	
collidedWithRedefine	TokenNameIdentifier	 collided With Redefine
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
(	TokenNameLPAREN	
elemParent	TokenNameIdentifier	 elem Parent
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
collidingElem	TokenNameIdentifier	 colliding Elem
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
redefinedSchema	TokenNameIdentifier	 redefined Schema
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fRedefine2XSDMap	TokenNameIdentifier	 f Redefine2 XSD Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
elemParent	TokenNameIdentifier	 elem Parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// case where we're a redefining element. 	TokenNameCOMMENT_LINE	case where we're a redefining element. 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_REDEFINE	TokenNameIdentifier	 ELT  REDEFINE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
redefinedSchema	TokenNameIdentifier	 redefined Schema
=	TokenNameEQUAL	
collidingElemSchema	TokenNameIdentifier	 colliding Elem Schema
;	TokenNameSEMICOLON	
collidedWithRedefine	TokenNameIdentifier	 collided With Redefine
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedSchema	TokenNameIdentifier	 redefined Schema
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//redefinition involved somehow 	TokenNameCOMMENT_LINE	redefinition involved somehow 
// If both components belong to the same document then 	TokenNameCOMMENT_LINE	If both components belong to the same document then 
// report an error and return. 	TokenNameCOMMENT_LINE	report an error and return. 
if	TokenNameif	
(	TokenNameLPAREN	
collidingElemSchema	TokenNameIdentifier	 colliding Elem Schema
==	TokenNameEQUAL_EQUAL	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"sch-props-correct.2"	TokenNameStringLiteral	sch-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
qName	TokenNameIdentifier	 q Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
newName	TokenNameIdentifier	 new Name
=	TokenNameEQUAL	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
REDEF_IDENTIFIER	TokenNameIdentifier	 REDEF  IDENTIFIER
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
redefinedSchema	TokenNameIdentifier	 redefined Schema
==	TokenNameEQUAL_EQUAL	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// object comp. okay here 	TokenNameCOMMENT_LINE	object comp. okay here 
// now have to do some renaming... 	TokenNameCOMMENT_LINE	now have to do some renaming... 
currComp	TokenNameIdentifier	 curr Comp
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
registry	TokenNameIdentifier	 registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
registry_sub	TokenNameIdentifier	 registry sub
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
registry	TokenNameIdentifier	 registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
registry_sub	TokenNameIdentifier	 registry sub
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// and take care of nested redefines by calling recursively: 	TokenNameCOMMENT_LINE	and take care of nested redefines by calling recursively: 
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
registry	TokenNameIdentifier	 registry
,	TokenNameCOMMA	
registry_sub	TokenNameIdentifier	 registry sub
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
registry	TokenNameIdentifier	 registry
,	TokenNameCOMMA	
registry_sub	TokenNameIdentifier	 registry sub
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// we may be redefining the wrong schema 	TokenNameCOMMENT_LINE	we may be redefining the wrong schema 
if	TokenNameif	
(	TokenNameLPAREN	
collidedWithRedefine	TokenNameIdentifier	 collided With Redefine
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
registry	TokenNameIdentifier	 registry
,	TokenNameCOMMA	
registry_sub	TokenNameIdentifier	 registry sub
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
registry	TokenNameIdentifier	 registry
,	TokenNameCOMMA	
registry_sub	TokenNameIdentifier	 registry sub
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// error that redefined element in wrong schema 	TokenNameCOMMENT_LINE	error that redefined element in wrong schema 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"sch-props-correct.2"	TokenNameStringLiteral	sch-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
qName	TokenNameIdentifier	 q Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// we've just got a flat-out collision (we tolerate duplicate 	TokenNameCOMMENT_LINE	we've just got a flat-out collision (we tolerate duplicate 
// declarations, only if they are defined in different schema 	TokenNameCOMMENT_LINE	declarations, only if they are defined in different schema 
// documents) 	TokenNameCOMMENT_LINE	documents) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
||	TokenNameOR_OR	
fUnparsedRegistriesExt	TokenNameIdentifier	 f Unparsed Registries Ext
[	TokenNameLBRACKET	
declType	TokenNameIdentifier	 decl Type
]	TokenNameRBRACKET	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"sch-props-correct.2"	TokenNameStringLiteral	sch-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
qName	TokenNameIdentifier	 q Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// store the lastest current document info 	TokenNameCOMMENT_LINE	store the lastest current document info 
if	TokenNameif	
(	TokenNameLPAREN	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUnparsedRegistriesExt	TokenNameIdentifier	 f Unparsed Registries Ext
[	TokenNameLBRACKET	
declType	TokenNameIdentifier	 decl Type
]	TokenNameRBRACKET	
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// checkForDuplicateNames(String, Hashtable, Element, XSDocumentInfo):void 	TokenNameCOMMENT_LINE	checkForDuplicateNames(String, Hashtable, Element, XSDocumentInfo):void 
void	TokenNamevoid	
checkForDuplicateNames	TokenNameIdentifier	 check For Duplicate Names
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
qName	TokenNameIdentifier	 q Name
,	TokenNameCOMMA	
int	TokenNameint	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
namespaceEnd	TokenNameIdentifier	 namespace End
=	TokenNameEQUAL	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
namespaceEnd	TokenNameIdentifier	 namespace End
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
emptyString2Null	TokenNameIdentifier	 empty String2 Null
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
=	TokenNameEQUAL	
getGlobalDeclFromGrammar	TokenNameIdentifier	 get Global Decl From Grammar
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
declType	TokenNameIdentifier	 decl Type
,	TokenNameCOMMA	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
namespaceEnd	TokenNameIdentifier	 namespace End
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"sch-props-correct.2"	TokenNameStringLiteral	sch-props-correct.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
qName	TokenNameIdentifier	 q Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
currComp	TokenNameIdentifier	 curr Comp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// the purpose of this method is to take the component of the 	TokenNameCOMMENT_LINE	the purpose of this method is to take the component of the 
// specified type and rename references to itself so that they 	TokenNameCOMMENT_LINE	specified type and rename references to itself so that they 
// refer to the object being redefined. It takes special care of 	TokenNameCOMMENT_LINE	refer to the object being redefined. It takes special care of 
// <group>s and <attributeGroup>s to ensure that information 	TokenNameCOMMENT_LINE	<group>s and <attributeGroup>s to ensure that information 
// relating to implicit restrictions is preserved for those 	TokenNameCOMMENT_LINE	relating to implicit restrictions is preserved for those 
// traversers. 	TokenNameCOMMENT_LINE	traversers. 
private	TokenNameprivate	
void	TokenNamevoid	
renameRedefiningComponents	TokenNameIdentifier	 rename Redefining Components
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
componentType	TokenNameIdentifier	 component Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldName	TokenNameIdentifier	 old Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
grandKid	TokenNameIdentifier	 grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.a.a"	TokenNameStringLiteral	src-redefine.5.a.a
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
grandKidName	TokenNameIdentifier	 grand Kid Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grandKidName	TokenNameIdentifier	 grand Kid Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grandKid	TokenNameIdentifier	 grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.a.a"	TokenNameStringLiteral	src-redefine.5.a.a
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
grandKidName	TokenNameIdentifier	 grand Kid Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
grandKidName	TokenNameIdentifier	 grand Kid Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.a.b"	TokenNameStringLiteral	src-redefine.5.a.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
grandKidName	TokenNameIdentifier	 grand Kid Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrs	TokenNameIdentifier	 attrs
=	TokenNameEQUAL	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
derivedBase	TokenNameIdentifier	 derived Base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
attrs	TokenNameIdentifier	 attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BASE	TokenNameIdentifier	 ATTIDX  BASE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
derivedBase	TokenNameIdentifier	 derived Base
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
||	TokenNameOR_OR	
!	TokenNameNOT	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
oldName	TokenNameIdentifier	 old Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.a.c"	TokenNameStringLiteral	src-redefine.5.a.c
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
grandKidName	TokenNameIdentifier	 grand Kid Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// now we have to do the renaming... 	TokenNameCOMMENT_LINE	now we have to do the renaming... 
if	TokenNameif	
(	TokenNameLPAREN	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
grandKid	TokenNameIdentifier	 grand Kid
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_BASE	TokenNameIdentifier	 ATT  BASE
,	TokenNameCOMMA	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
grandKid	TokenNameIdentifier	 grand Kid
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_BASE	TokenNameIdentifier	 ATT  BASE
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return true; 	TokenNameCOMMENT_LINE	return true; 
}	TokenNameRBRACE	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
grandKid	TokenNameIdentifier	 grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.a"	TokenNameStringLiteral	src-redefine.5.b.a
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grandKid	TokenNameIdentifier	 grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.a"	TokenNameStringLiteral	src-redefine.5.b.a
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// have to go one more level down; let another pass worry whether complexType is valid. 	TokenNameCOMMENT_LINE	have to go one more level down; let another pass worry whether complexType is valid. 
Element	TokenNameIdentifier	 Element
greatGrandKid	TokenNameIdentifier	 great Grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.b"	TokenNameStringLiteral	src-redefine.5.b.b
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.b"	TokenNameStringLiteral	src-redefine.5.b.b
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
grandKid	TokenNameIdentifier	 grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_EXTENSION	TokenNameIdentifier	 ELT  EXTENSION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.c"	TokenNameStringLiteral	src-redefine.5.b.c
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrs	TokenNameIdentifier	 attrs
=	TokenNameEQUAL	
fAttributeChecker	TokenNameIdentifier	 f Attribute Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
derivedBase	TokenNameIdentifier	 derived Base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
attrs	TokenNameIdentifier	 attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BASE	TokenNameIdentifier	 ATTIDX  BASE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
derivedBase	TokenNameIdentifier	 derived Base
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
||	TokenNameOR_OR	
!	TokenNameNOT	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
oldName	TokenNameIdentifier	 old Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.5.b.d"	TokenNameStringLiteral	src-redefine.5.b.d
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
greatGrandKidName	TokenNameIdentifier	 great Grand Kid Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// now we have to do the renaming... 	TokenNameCOMMENT_LINE	now we have to do the renaming... 
if	TokenNameif	
(	TokenNameLPAREN	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_BASE	TokenNameIdentifier	 ATT  BASE
,	TokenNameCOMMA	
derivedBase	TokenNameIdentifier	 derived Base
.	TokenNameDOT	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
greatGrandKid	TokenNameIdentifier	 great Grand Kid
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_BASE	TokenNameIdentifier	 ATT  BASE
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return true; 	TokenNameCOMMENT_LINE	return true; 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
processedBaseName	TokenNameIdentifier	 processed Base Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
:	TokenNameCOLON	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
;	TokenNameSEMICOLON	
int	TokenNameint	
attGroupRefsCount	TokenNameIdentifier	 att Group Refs Count
=	TokenNameEQUAL	
changeRedefineGroup	TokenNameIdentifier	 change Redefine Group
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
componentType	TokenNameIdentifier	 component Type
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attGroupRefsCount	TokenNameIdentifier	 att Group Refs Count
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.7.1"	TokenNameStringLiteral	src-redefine.7.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
attGroupRefsCount	TokenNameIdentifier	 att Group Refs Count
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
attGroupRefsCount	TokenNameIdentifier	 att Group Refs Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// return true; 	TokenNameCOMMENT_LINE	return true; 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fRedefinedRestrictedAttributeGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Attribute Group Registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
fRedefinedRestrictedAttributeGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Attribute Group Registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
componentType	TokenNameIdentifier	 component Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
processedBaseName	TokenNameIdentifier	 processed Base Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
:	TokenNameCOLON	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
oldName	TokenNameIdentifier	 old Name
;	TokenNameSEMICOLON	
int	TokenNameint	
groupRefsCount	TokenNameIdentifier	 group Refs Count
=	TokenNameEQUAL	
changeRedefineGroup	TokenNameIdentifier	 change Redefine Group
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
componentType	TokenNameIdentifier	 component Type
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
groupRefsCount	TokenNameIdentifier	 group Refs Count
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.6.1.1"	TokenNameStringLiteral	src-redefine.6.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
groupRefsCount	TokenNameIdentifier	 group Refs Count
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
groupRefsCount	TokenNameIdentifier	 group Refs Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// return true; 	TokenNameCOMMENT_LINE	return true; 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fRedefinedRestrictedGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Group Registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
fRedefinedRestrictedGroupRegistry	TokenNameIdentifier	 f Redefined Restricted Group Registry
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
processedBaseName	TokenNameIdentifier	 processed Base Name
,	TokenNameCOMMA	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"Internal-Error"	TokenNameStringLiteral	Internal-Error
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"could not handle this particular <redefine>; please submit your schemas and instance document in a bug report!"	TokenNameStringLiteral	could not handle this particular <redefine>; please submit your schemas and instance document in a bug report!
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we get here then we must have reported an error and failed somewhere... 	TokenNameCOMMENT_LINE	if we get here then we must have reported an error and failed somewhere... 
// return false; 	TokenNameCOMMENT_LINE	return false; 
}	TokenNameRBRACE	
// renameRedefiningComponents(XSDocumentInfo, Element, String, String, String):void 	TokenNameCOMMENT_LINE	renameRedefiningComponents(XSDocumentInfo, Element, String, String, String):void 
// this method takes a name of the form a:b, determines the URI mapped 	TokenNameCOMMENT_LINE	this method takes a name of the form a:b, determines the URI mapped 
// to by a in the current SchemaNamespaceSupport object, and returns this 	TokenNameCOMMENT_LINE	to by a in the current SchemaNamespaceSupport object, and returns this 
// information in the form (nsURI,b) suitable for lookups in the global 	TokenNameCOMMENT_LINE	information in the form (nsURI,b) suitable for lookups in the global 
// decl Hashtables. 	TokenNameCOMMENT_LINE	decl Hashtables. 
// REVISIT: should have it return QName, instead of String. this would 	TokenNameCOMMENT_LINE	REVISIT: should have it return QName, instead of String. this would 
// save lots of string concatenation time. we can use 	TokenNameCOMMENT_LINE	save lots of string concatenation time. we can use 
// QName#equals() to compare two QNames, and use QName directly 	TokenNameCOMMENT_LINE	QName#equals() to compare two QNames, and use QName directly 
// as a key to the SymbolHash. 	TokenNameCOMMENT_LINE	as a key to the SymbolHash. 
// And when the DV's are ready to return compiled values from 	TokenNameCOMMENT_LINE	And when the DV's are ready to return compiled values from 
// validate() method, we should just call QNameDV.validate() 	TokenNameCOMMENT_LINE	validate() method, we should just call QNameDV.validate() 
// in this method. 	TokenNameCOMMENT_LINE	in this method. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
findQName	TokenNameIdentifier	 find Q Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaNamespaceSupport	TokenNameIdentifier	 Schema Namespace Support
currNSMap	TokenNameIdentifier	 curr NS Map
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
;	TokenNameSEMICOLON	
int	TokenNameint	
colonPtr	TokenNameIdentifier	 colon Ptr
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colonPtr	TokenNameIdentifier	 colon Ptr
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
colonPtr	TokenNameIdentifier	 colon Ptr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
currNSMap	TokenNameIdentifier	 curr NS Map
.	TokenNameDOT	
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
localpart	TokenNameIdentifier	 localpart
=	TokenNameEQUAL	
(	TokenNameLPAREN	
colonPtr	TokenNameIdentifier	 colon Ptr
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
colonPtr	TokenNameIdentifier	 colon Ptr
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
&&	TokenNameAND_AND	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fIsChameleonSchema	TokenNameIdentifier	 f Is Chameleon Schema
)	TokenNameRPAREN	
uri	TokenNameIdentifier	 uri
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
return	TokenNamereturn	
uri	TokenNameIdentifier	 uri
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// findQName(String, XSDocumentInfo): String 	TokenNameCOMMENT_LINE	findQName(String, XSDocumentInfo): String 
// This function looks among the children of curr for an element of type elementSought. 	TokenNameCOMMENT_LINE	This function looks among the children of curr for an element of type elementSought. 
// If it finds one, it evaluates whether its ref attribute contains a reference 	TokenNameCOMMENT_LINE	If it finds one, it evaluates whether its ref attribute contains a reference 
// to originalQName. If it does, it returns 1 + the value returned by 	TokenNameCOMMENT_LINE	to originalQName. If it does, it returns 1 + the value returned by 
// calls to itself on all other children. In all other cases it returns 0 plus 	TokenNameCOMMENT_LINE	calls to itself on all other children. In all other cases it returns 0 plus 
// the sum of the values returned by calls to itself on curr's children. 	TokenNameCOMMENT_LINE	the sum of the values returned by calls to itself on curr's children. 
// It also resets the value of ref so that it will refer to the renamed type from the schema 	TokenNameCOMMENT_LINE	It also resets the value of ref so that it will refer to the renamed type from the schema 
// being redefined. 	TokenNameCOMMENT_LINE	being redefined. 
private	TokenNameprivate	
int	TokenNameint	
changeRedefineGroup	TokenNameIdentifier	 change Redefine Group
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
originalQName	TokenNameIdentifier	 original Q Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
elementSought	TokenNameIdentifier	 element Sought
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
curr	TokenNameIdentifier	 curr
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
curr	TokenNameIdentifier	 curr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
elementSought	TokenNameIdentifier	 element Sought
)	TokenNameRPAREN	
)	TokenNameRPAREN	
result	TokenNameIdentifier	 result
+=	TokenNamePLUS_EQUAL	
changeRedefineGroup	TokenNameIdentifier	 change Redefine Group
(	TokenNameLPAREN	
originalQName	TokenNameIdentifier	 original Q Name
,	TokenNameCOMMA	
elementSought	TokenNameIdentifier	 element Sought
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
ref	TokenNameIdentifier	 ref
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_REF	TokenNameIdentifier	 ATT  REF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
processedRef	TokenNameIdentifier	 processed Ref
=	TokenNameEQUAL	
findQName	TokenNameIdentifier	 find Q Name
(	TokenNameLPAREN	
ref	TokenNameIdentifier	 ref
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
originalQName	TokenNameIdentifier	 original Q Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
processedRef	TokenNameIdentifier	 processed Ref
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
int	TokenNameint	
colonptr	TokenNameIdentifier	 colonptr
=	TokenNameEQUAL	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colonptr	TokenNameIdentifier	 colonptr
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
colonptr	TokenNameIdentifier	 colonptr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_REF	TokenNameIdentifier	 ATT  REF
,	TokenNameCOMMA	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
setAttribute	TokenNameIdentifier	 set Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_REF	TokenNameIdentifier	 ATT  REF
,	TokenNameCOMMA	
newName	TokenNameIdentifier	 new Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementSought	TokenNameIdentifier	 element Sought
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
minOccurs	TokenNameIdentifier	 min Occurs
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_MINOCCURS	TokenNameIdentifier	 ATT  MINOCCURS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
maxOccurs	TokenNameIdentifier	 max Occurs
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_MAXOCCURS	TokenNameIdentifier	 ATT  MAXOCCURS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
maxOccurs	TokenNameIdentifier	 max Occurs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
maxOccurs	TokenNameIdentifier	 max Occurs
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"1"	TokenNameStringLiteral	1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
minOccurs	TokenNameIdentifier	 min Occurs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
minOccurs	TokenNameIdentifier	 min Occurs
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"1"	TokenNameStringLiteral	1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-redefine.6.1.2"	TokenNameStringLiteral	src-redefine.6.1.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
ref	TokenNameIdentifier	 ref
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if ref was null some other stage of processing will flag the error 	TokenNameCOMMENT_LINE	if ref was null some other stage of processing will flag the error 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// changeRedefineGroup 	TokenNameCOMMENT_LINE	changeRedefineGroup 
// this method returns the XSDocumentInfo object that contains the 	TokenNameCOMMENT_LINE	this method returns the XSDocumentInfo object that contains the 
// component corresponding to decl. If components from this 	TokenNameCOMMENT_LINE	component corresponding to decl. If components from this 
// document cannot be referred to from those of currSchema, this 	TokenNameCOMMENT_LINE	document cannot be referred to from those of currSchema, this 
// method returns null; it's up to the caller to throw an error. 	TokenNameCOMMENT_LINE	method returns null; it's up to the caller to throw an error. 
// @param: currSchema: the XSDocumentInfo object containing the 	TokenNameCOMMENT_LINE	@param: currSchema: the XSDocumentInfo object containing the 
// decl ref'ing us. 	TokenNameCOMMENT_LINE	decl ref'ing us. 
// @param: decl: the declaration being ref'd. 	TokenNameCOMMENT_LINE	@param: decl: the declaration being ref'd. 
// this method is superficial now. ---Jack 	TokenNameCOMMENT_LINE	this method is superficial now. ---Jack 
private	TokenNameprivate	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
findXSDocumentForDecl	TokenNameIdentifier	 find XS Document For Decl
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
currSchema	TokenNameIdentifier	 curr Schema
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
decl	TokenNameIdentifier	 decl
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
decl_Doc	TokenNameIdentifier	 decl  Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_NODE_POOL	TokenNameIdentifier	 DEBUG  NODE  POOL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"DOCUMENT NS:"	TokenNameStringLiteral	DOCUMENT NS:
+	TokenNamePLUS	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
" hashcode:"	TokenNameStringLiteral	 hashcode:
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
)	TokenNameRPAREN	
currSchema	TokenNameIdentifier	 curr Schema
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
)	TokenNameRPAREN	
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Object	TokenNameIdentifier	 Object
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
decl_Doc	TokenNameIdentifier	 decl  Doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
temp	TokenNameIdentifier	 temp
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// something went badly wrong; we don't know this doc? 	TokenNameCOMMENT_LINE	something went badly wrong; we don't know this doc? 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
declDocInfo	TokenNameIdentifier	 decl Doc Info
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
temp	TokenNameIdentifier	 temp
;	TokenNameSEMICOLON	
return	TokenNamereturn	
declDocInfo	TokenNameIdentifier	 decl Doc Info
;	TokenNameSEMICOLON	
/********* Logic here is unnecessary after schema WG's recent decision to allow schema components from one document to refer to components of any other, so long as there's some include/import/redefine path amongst them. If they rver reverse this decision the code's right here though... - neilg // now look in fDependencyMap to see if this is reachable if(((Vector)fDependencyMap.get(currSchema)).contains(declDocInfo)) { return declDocInfo; } // obviously the requesting doc didn't include, redefine or // import the one containing decl... return null; **********/	TokenNameCOMMENT_JAVADOC	******* Logic here is unnecessary after schema WG's recent decision to allow schema components from one document to refer to components of any other, so long as there's some include/import/redefine path amongst them. If they rver reverse this decision the code's right here though... - neilg // now look in fDependencyMap to see if this is reachable if(((Vector)fDependencyMap.get(currSchema)).contains(declDocInfo)) { return declDocInfo; } // obviously the requesting doc didn't include, redefine or // import the one containing decl... return null; *********
}	TokenNameRBRACE	
// findXSDocumentForDecl(XSDocumentInfo, Element): XSDocumentInfo 	TokenNameCOMMENT_LINE	findXSDocumentForDecl(XSDocumentInfo, Element): XSDocumentInfo 
// returns whether more than <annotation>s occur in children of elem 	TokenNameCOMMENT_LINE	returns whether more than <annotation>s occur in children of elem 
private	TokenNameprivate	
boolean	TokenNameboolean	
nonAnnotationContent	TokenNameIdentifier	 non Annotation Content
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// nonAnnotationContent(Element): boolean 	TokenNameCOMMENT_LINE	nonAnnotationContent(Element): boolean 
private	TokenNameprivate	
void	TokenNamevoid	
setSchemasVisible	TokenNameIdentifier	 set Schemas Visible
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
startSchema	TokenNameIdentifier	 start Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
isHidden	TokenNameIdentifier	 is Hidden
(	TokenNameLPAREN	
startSchema	TokenNameIdentifier	 start Schema
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make it visible 	TokenNameCOMMENT_LINE	make it visible 
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
setVisible	TokenNameIdentifier	 set Visible
(	TokenNameLPAREN	
startSchema	TokenNameIdentifier	 start Schema
.	TokenNameDOT	
fSchemaElement	TokenNameIdentifier	 f Schema Element
,	TokenNameCOMMA	
fHiddenNodes	TokenNameIdentifier	 f Hidden Nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
dependingSchemas	TokenNameIdentifier	 depending Schemas
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
fDependencyMap	TokenNameIdentifier	 f Dependency Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
startSchema	TokenNameIdentifier	 start Schema
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
dependingSchemas	TokenNameIdentifier	 depending Schemas
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setSchemasVisible	TokenNameIdentifier	 set Schemas Visible
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
)	TokenNameRPAREN	
dependingSchemas	TokenNameIdentifier	 depending Schemas
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if it's visible already than so must be its children 	TokenNameCOMMENT_LINE	if it's visible already than so must be its children 
}	TokenNameRBRACE	
// setSchemasVisible(XSDocumentInfo): void 	TokenNameCOMMENT_LINE	setSchemasVisible(XSDocumentInfo): void 
private	TokenNameprivate	
SimpleLocator	TokenNameIdentifier	 Simple Locator
xl	TokenNameIdentifier	 xl
=	TokenNameEQUAL	
new	TokenNamenew	
SimpleLocator	TokenNameIdentifier	 Simple Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Extract location information from an Element node, and create a * new SimpleLocator object from such information. Returning null means * no information can be retrieved from the element. */	TokenNameCOMMENT_JAVADOC	 Extract location information from an Element node, and create a new SimpleLocator object from such information. Returning null means no information can be retrieved from the element. 
public	TokenNamepublic	
SimpleLocator	TokenNameIdentifier	 Simple Locator
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
instanceof	TokenNameinstanceof	
ElementImpl	TokenNameIdentifier	 Element Impl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
SimpleLocator	TokenNameIdentifier	 Simple Locator
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
new	TokenNamenew	
SimpleLocator	TokenNameIdentifier	 Simple Locator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
?	TokenNameQUESTION	
l	TokenNameIdentifier	 l
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Extract location information from an Element node, store such * information in the passed-in SimpleLocator object, then return * true. Returning false means can't extract or store such information. */	TokenNameCOMMENT_JAVADOC	 Extract location information from an Element node, store such information in the passed-in SimpleLocator object, then return true. Returning false means can't extract or store such information. 
public	TokenNamepublic	
boolean	TokenNameboolean	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
SimpleLocator	TokenNameIdentifier	 Simple Locator
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
instanceof	TokenNameinstanceof	
ElementImpl	TokenNameIdentifier	 Element Impl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ElementImpl	TokenNameIdentifier	 Element Impl
ele	TokenNameIdentifier	 ele
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ElementImpl	TokenNameIdentifier	 Element Impl
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
// get system id from document object 	TokenNameCOMMENT_LINE	get system id from document object 
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
sid	TokenNameIdentifier	 sid
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fDoc2SystemId	TokenNameIdentifier	 f Doc2 System Id
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// line/column numbers are stored in the element node 	TokenNameCOMMENT_LINE	line/column numbers are stored in the element node 
int	TokenNameint	
line	TokenNameIdentifier	 line
=	TokenNameEQUAL	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getLineNumber	TokenNameIdentifier	 get Line Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getColumnNumber	TokenNameIdentifier	 get Column Number
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
sid	TokenNameIdentifier	 sid
,	TokenNameCOMMA	
sid	TokenNameIdentifier	 sid
,	TokenNameCOMMA	
line	TokenNameIdentifier	 line
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
ele	TokenNameIdentifier	 ele
.	TokenNameDOT	
getCharacterOffset	TokenNameIdentifier	 get Character Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
ele	TokenNameIdentifier	 ele
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
xl	TokenNameIdentifier	 xl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
xl	TokenNameIdentifier	 xl
,	TokenNameCOMMA	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
void	TokenNamevoid	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
ele	TokenNameIdentifier	 ele
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
reportSchemaWarning	TokenNameIdentifier	 report Schema Warning
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
ele	TokenNameIdentifier	 ele
,	TokenNameCOMMA	
xl	TokenNameIdentifier	 xl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
xl	TokenNameIdentifier	 xl
,	TokenNameCOMMA	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
,	TokenNameCOMMA	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Grammar pool used for validating annotations. This will return all of the * grammars from the grammar bucket. It will also return an object for the * schema for schemas which will contain at least the relevant declarations * for annotations. */	TokenNameCOMMENT_JAVADOC	 Grammar pool used for validating annotations. This will return all of the grammars from the grammar bucket. It will also return an object for the schema for schemas which will contain at least the relevant declarations for annotations. 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
XSAnnotationGrammarPool	TokenNameIdentifier	 XS Annotation Grammar Pool
implements	TokenNameimplements	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
{	TokenNameLBRACE	
private	TokenNameprivate	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
retrieveInitialGrammarSet	TokenNameIdentifier	 retrieve Initial Grammar Set
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
grammarType	TokenNameIdentifier	 grammar Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammarType	TokenNameIdentifier	 grammar Type
==	TokenNameEQUAL_EQUAL	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
.	TokenNameDOT	
XML_SCHEMA	TokenNameIdentifier	 XML  SCHEMA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
=	TokenNameEQUAL	
new	TokenNamenew	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
Schema4Annotations	TokenNameIdentifier	 Schema4 Annotations
.	TokenNameDOT	
INSTANCE	TokenNameIdentifier	 INSTANCE
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
schemaGrammars	TokenNameIdentifier	 schema Grammars
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammars	TokenNameIdentifier	 get Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * If the grammar bucket already contains the schema for schemas * then we already have the definitions for the parts relevant * to annotations. */	TokenNameCOMMENT_JAVADOC	 If the grammar bucket already contains the schema for schemas then we already have the definitions for the parts relevant to annotations. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
schemaGrammars	TokenNameIdentifier	 schema Grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
schemaGrammars	TokenNameIdentifier	 schema Grammars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
=	TokenNameEQUAL	
schemaGrammars	TokenNameIdentifier	 schema Grammars
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
new	TokenNamenew	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
schemaGrammars	TokenNameIdentifier	 schema Grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
schemaGrammars	TokenNameIdentifier	 schema Grammars
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
grammars	TokenNameIdentifier	 grammars
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
schemaGrammars	TokenNameIdentifier	 schema Grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
Schema4Annotations	TokenNameIdentifier	 Schema4 Annotations
.	TokenNameDOT	
INSTANCE	TokenNameIdentifier	 INSTANCE
;	TokenNameSEMICOLON	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
cacheGrammars	TokenNameIdentifier	 cache Grammars
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
grammarType	TokenNameIdentifier	 grammar Type
,	TokenNameCOMMA	
Grammar	TokenNameIdentifier	 Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Grammar	TokenNameIdentifier	 Grammar
retrieveGrammar	TokenNameIdentifier	 retrieve Grammar
(	TokenNameLPAREN	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
getGrammarType	TokenNameIdentifier	 get Grammar Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
.	TokenNameDOT	
XML_SCHEMA	TokenNameIdentifier	 XML  SCHEMA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tns	TokenNameIdentifier	 tns
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XMLSchemaDescription	TokenNameIdentifier	 XML Schema Description
)	TokenNameRPAREN	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
.	TokenNameDOT	
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Grammar	TokenNameIdentifier	 Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
tns	TokenNameIdentifier	 tns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
Schema4Annotations	TokenNameIdentifier	 Schema4 Annotations
.	TokenNameDOT	
INSTANCE	TokenNameIdentifier	 INSTANCE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
refreshGrammars	TokenNameIdentifier	 refresh Grammars
(	TokenNameLPAREN	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
gBucket	TokenNameIdentifier	 g Bucket
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
=	TokenNameEQUAL	
gBucket	TokenNameIdentifier	 g Bucket
;	TokenNameSEMICOLON	
fInitialGrammarSet	TokenNameIdentifier	 f Initial Grammar Set
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
lockPool	TokenNameIdentifier	 lock Pool
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
unlockPool	TokenNameIdentifier	 unlock Pool
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * used to identify a reference to a schema document * if the same document is referenced twice with the same key, then * we only need to parse it once. * * When 2 XSDKey's are compared, the following table can be used to * determine whether they are equal: * inc red imp pre ins * inc N/L ? N/L N/L N/L * red ? N/L ? ? ? * imp N/L ? N/P N/P N/P * pre N/L ? N/P N/P N/P * ins N/L ? N/P N/P N/P * * Where: N/L: duplicate when they have the same namespace and location. * ? : not clear from the spec. * REVISIT: to simplify the process, also considering * it's very rare, we treat them as not duplicate. * N/P: not possible. imp/pre/ins are referenced by namespace. * when the first time we encounter a schema document for a * namespace, we create a grammar and store it in the grammar * bucket. when we see another reference to the same namespace, * we first check whether a grammar with the same namespace is * already in the bucket, which is true in this case, so we * won't create another XSDKey. * * Conclusion from the table: two XSDKey's are duplicate only when all of * the following are true: * 1. They are both "redefine", or neither is "redefine"; * 2. They have the same namespace; * 3. They have the same non-null location. * * About 3: if neither has a non-null location, then it's the case where * 2 input streams are provided, but no system ID is provided. We can't tell * whether the 2 streams have the same content, so we treat them as not * duplicate. */	TokenNameCOMMENT_JAVADOC	 used to identify a reference to a schema document if the same document is referenced twice with the same key, then we only need to parse it once. * When 2 XSDKey's are compared, the following table can be used to determine whether they are equal: inc red imp pre ins inc N/L ? N/L N/L N/L red ? N/L ? ? ? imp N/L ? N/P N/P N/P pre N/L ? N/P N/P N/P ins N/L ? N/P N/P N/P * Where: N/L: duplicate when they have the same namespace and location. ? : not clear from the spec. REVISIT: to simplify the process, also considering it's very rare, we treat them as not duplicate. N/P: not possible. imp/pre/ins are referenced by namespace. when the first time we encounter a schema document for a namespace, we create a grammar and store it in the grammar bucket. when we see another reference to the same namespace, we first check whether a grammar with the same namespace is already in the bucket, which is true in this case, so we won't create another XSDKey. * Conclusion from the table: two XSDKey's are duplicate only when all of the following are true: 1. They are both "redefine", or neither is "redefine"; 2. They have the same namespace; 3. They have the same non-null location. * About 3: if neither has a non-null location, then it's the case where 2 input streams are provided, but no system ID is provided. We can't tell whether the 2 streams have the same content, so we treat them as not duplicate. 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
XSDKey	TokenNameIdentifier	 XSD Key
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
;	TokenNameSEMICOLON	
// for inclue/redefine, this is the enclosing namespace 	TokenNameCOMMENT_LINE	for inclue/redefine, this is the enclosing namespace 
// for import/preparse/instance, this is the target namespace 	TokenNameCOMMENT_LINE	for import/preparse/instance, this is the target namespace 
String	TokenNameIdentifier	 String
referNS	TokenNameIdentifier	 refer NS
;	TokenNameSEMICOLON	
XSDKey	TokenNameIdentifier	 XSD Key
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
short	TokenNameshort	
referType	TokenNameIdentifier	 refer Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
referNS	TokenNameIdentifier	 refer NS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
=	TokenNameEQUAL	
systemId	TokenNameIdentifier	 system Id
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
referType	TokenNameIdentifier	 refer Type
=	TokenNameEQUAL	
referType	TokenNameIdentifier	 refer Type
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
referNS	TokenNameIdentifier	 refer NS
=	TokenNameEQUAL	
referNS	TokenNameIdentifier	 refer NS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// according to the description at the beginning of this class, 	TokenNameCOMMENT_LINE	according to the description at the beginning of this class, 
// we use the hashcode of the namespace as the hashcoe of this key. 	TokenNameCOMMENT_LINE	we use the hashcode of the namespace as the hashcoe of this key. 
return	TokenNamereturn	
referNS	TokenNameIdentifier	 refer NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
referNS	TokenNameIdentifier	 refer NS
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
XSDKey	TokenNameIdentifier	 XSD Key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSDKey	TokenNameIdentifier	 XSD Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSDKey	TokenNameIdentifier	 XSD Key
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
// condition 1: both are redefine 	TokenNameCOMMENT_LINE	condition 1: both are redefine 
/** if (referType == XSDDescription.CONTEXT_REDEFINE || key.referType == XSDDescription.CONTEXT_REDEFINE) { if (referType != key.referType) return false; }**/	TokenNameCOMMENT_JAVADOC	 if (referType == XSDDescription.CONTEXT_REDEFINE || key.referType == XSDDescription.CONTEXT_REDEFINE) { if (referType != key.referType) return false; }*
// condition 2: same namespace 	TokenNameCOMMENT_LINE	condition 2: same namespace 
if	TokenNameif	
(	TokenNameLPAREN	
referNS	TokenNameIdentifier	 refer NS
!=	TokenNameNOT_EQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
referNS	TokenNameIdentifier	 refer NS
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// condition 3: same non-null location 	TokenNameCOMMENT_LINE	condition 3: same non-null location 
if	TokenNameif	
(	TokenNameLPAREN	
systemId	TokenNameIdentifier	 system Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
systemId	TokenNameIdentifier	 system Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
systemId	TokenNameIdentifier	 system Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
SAX2XNIUtil	TokenNameIdentifier	 SA X2 XNI Util
extends	TokenNameextends	
ErrorHandlerWrapper	TokenNameIdentifier	 Error Handler Wrapper
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
XMLParseException	TokenNameIdentifier	 XML Parse Exception
createXMLParseException0	TokenNameIdentifier	 create XML Parse Exception0
(	TokenNameLPAREN	
SAXParseException	TokenNameIdentifier	 SAX Parse Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createXMLParseException	TokenNameIdentifier	 create XML Parse Exception
(	TokenNameLPAREN	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
XNIException	TokenNameIdentifier	 XNI Exception
createXNIException0	TokenNameIdentifier	 create XNI Exception0
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createXNIException	TokenNameIdentifier	 create XNI Exception
(	TokenNameLPAREN	
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @param state */	TokenNameCOMMENT_JAVADOC	 @param state 
public	TokenNamepublic	
void	TokenNamevoid	
setGenerateSyntheticAnnotations	TokenNameIdentifier	 set Generate Synthetic Annotations
(	TokenNameLPAREN	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaParser	TokenNameIdentifier	 f Schema Parser
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
GENERATE_SYNTHETIC_ANNOTATIONS	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// XSDHandler 	TokenNameCOMMENT_LINE	XSDHandler 
