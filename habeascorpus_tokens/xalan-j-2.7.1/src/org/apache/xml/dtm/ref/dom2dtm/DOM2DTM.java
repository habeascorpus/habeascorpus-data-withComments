/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: DOM2DTM.java 478671 2006-11-23 21:00:31Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: DOM2DTM.java 478671 2006-11-23 21:00:31Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
dom2dtm	TokenNameIdentifier	 dom2dtm
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
SourceLocator	TokenNameIdentifier	 Source Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMSource	TokenNameIdentifier	 DOM Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTM	TokenNameIdentifier	 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMManager	TokenNameIdentifier	 DTM Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMDefaultBaseIterators	TokenNameIdentifier	 DTM Default Base Iterators
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
ExpandedNameTable	TokenNameIdentifier	 Expanded Name Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
IncrementalSAXSource	TokenNameIdentifier	 Incremental SAX Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLMessages	TokenNameIdentifier	 XML Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
TreeWalker	TokenNameIdentifier	 Tree Walker
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLCharacterRecognizer	TokenNameIdentifier	 XML Character Recognizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLStringFactory	TokenNameIdentifier	 XML String Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DocumentType	TokenNameIdentifier	 Document Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Entity	TokenNameIdentifier	 Entity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
;	TokenNameSEMICOLON	
/** The <code>DOM2DTM</code> class serves up a DOM's contents via the * DTM API. * * Note that it doesn't necessarily represent a full Document * tree. You can wrap a DOM2DTM around a specific node and its subtree * and the right things should happen. (I don't _think_ we currently * support DocumentFrgment nodes as roots, though that might be worth * considering.) * * Note too that we do not currently attempt to track document * mutation. If you alter the DOM after wrapping DOM2DTM around it, * all bets are off. * */	TokenNameCOMMENT_JAVADOC	 The <code>DOM2DTM</code> class serves up a DOM's contents via the DTM API. * Note that it doesn't necessarily represent a full Document tree. You can wrap a DOM2DTM around a specific node and its subtree and the right things should happen. (I don't _think_ we currently support DocumentFrgment nodes as roots, though that might be worth considering.) * Note too that we do not currently attempt to track document mutation. If you alter the DOM after wrapping DOM2DTM around it, all bets are off. 
public	TokenNamepublic	
class	TokenNameclass	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
extends	TokenNameextends	
DTMDefaultBaseIterators	TokenNameIdentifier	 DTM Default Base Iterators
{	TokenNameLBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
JJK_DEBUG	TokenNameIdentifier	 JJK  DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
JJK_NEWCODE	TokenNameIdentifier	 JJK  NEWCODE
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** Manefest constant */	TokenNameCOMMENT_JAVADOC	 Manefest constant 
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NAMESPACE_DECL_NS	TokenNameIdentifier	 NAMESPACE  DECL  NS
=	TokenNameEQUAL	
"http://www.w3.org/XML/1998/namespace"	TokenNameStringLiteral	http://www.w3.org/XML/1998/namespace
;	TokenNameSEMICOLON	
/** The current position in the DOM tree. Last node examined for * possible copying to DTM. */	TokenNameCOMMENT_JAVADOC	 The current position in the DOM tree. Last node examined for possible copying to DTM. 
transient	TokenNametransient	
private	TokenNameprivate	
Node	TokenNameIdentifier	 Node
m_pos	TokenNameIdentifier	 m pos
;	TokenNameSEMICOLON	
/** The current position in the DTM tree. Who children get appended to. */	TokenNameCOMMENT_JAVADOC	 The current position in the DTM tree. Who children get appended to. 
private	TokenNameprivate	
int	TokenNameint	
m_last_parent	TokenNameIdentifier	 m last parent
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** The current position in the DTM tree. Who children reference as their * previous sib. */	TokenNameCOMMENT_JAVADOC	 The current position in the DTM tree. Who children reference as their previous sib. 
private	TokenNameprivate	
int	TokenNameint	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
/** The top of the subtree. * %REVIEW%: 'may not be the same as m_context if "//foo" pattern.' * */	TokenNameCOMMENT_JAVADOC	 The top of the subtree. %REVIEW%: 'may not be the same as m_context if "//foo" pattern.' 
transient	TokenNametransient	
private	TokenNameprivate	
Node	TokenNameIdentifier	 Node
m_root	TokenNameIdentifier	 m root
;	TokenNameSEMICOLON	
/** True iff the first element has been processed. This is used to control synthesis of the implied xml: namespace declaration node. */	TokenNameCOMMENT_JAVADOC	 True iff the first element has been processed. This is used to control synthesis of the implied xml: namespace declaration node. 
boolean	TokenNameboolean	
m_processedFirstElement	TokenNameIdentifier	 m processed First Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** true if ALL the nodes in the m_root subtree have been processed; * false if our incremental build has not yet finished scanning the * DOM tree. */	TokenNameCOMMENT_JAVADOC	 true if ALL the nodes in the m_root subtree have been processed; false if our incremental build has not yet finished scanning the DOM tree. 
transient	TokenNametransient	
private	TokenNameprivate	
boolean	TokenNameboolean	
m_nodesAreProcessed	TokenNameIdentifier	 m nodes Are Processed
;	TokenNameSEMICOLON	
/** The node objects. The instance part of the handle indexes * directly into this vector. Each DTM node may actually be * composed of several DOM nodes (for example, if logically-adjacent * Text/CDATASection nodes in the DOM have been coalesced into a * single DTM Text node); this table points only to the first in * that sequence. */	TokenNameCOMMENT_JAVADOC	 The node objects. The instance part of the handle indexes directly into this vector. Each DTM node may actually be composed of several DOM nodes (for example, if logically-adjacent Text/CDATASection nodes in the DOM have been coalesced into a single DTM Text node); this table points only to the first in that sequence. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
m_nodes	TokenNameIdentifier	 m nodes
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Construct a DOM2DTM object from a DOM node. * * @param mgr The DTMManager who owns this DTM. * @param domSource the DOM source that this DTM will wrap. * @param dtmIdentity The DTM identity ID for this DTM. * @param whiteSpaceFilter The white space filter for this DTM, which may * be null. * @param xstringfactory XMLString factory for creating character content. * @param doIndexing true if the caller considers it worth it to use * indexing schemes. */	TokenNameCOMMENT_JAVADOC	 Construct a DOM2DTM object from a DOM node. * @param mgr The DTMManager who owns this DTM. @param domSource the DOM source that this DTM will wrap. @param dtmIdentity The DTM identity ID for this DTM. @param whiteSpaceFilter The white space filter for this DTM, which may be null. @param xstringfactory XMLString factory for creating character content. @param doIndexing true if the caller considers it worth it to use indexing schemes. 
public	TokenNamepublic	
DOM2DTM	TokenNameIdentifier	 DO M2 DTM
(	TokenNameLPAREN	
DTMManager	TokenNameIdentifier	 DTM Manager
mgr	TokenNameIdentifier	 mgr
,	TokenNameCOMMA	
DOMSource	TokenNameIdentifier	 DOM Source
domSource	TokenNameIdentifier	 dom Source
,	TokenNameCOMMA	
int	TokenNameint	
dtmIdentity	TokenNameIdentifier	 dtm Identity
,	TokenNameCOMMA	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
XMLStringFactory	TokenNameIdentifier	 XML String Factory
xstringfactory	TokenNameIdentifier	 xstringfactory
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
mgr	TokenNameIdentifier	 mgr
,	TokenNameCOMMA	
domSource	TokenNameIdentifier	 dom Source
,	TokenNameCOMMA	
dtmIdentity	TokenNameIdentifier	 dtm Identity
,	TokenNameCOMMA	
whiteSpaceFilter	TokenNameIdentifier	 white Space Filter
,	TokenNameCOMMA	
xstringfactory	TokenNameIdentifier	 xstringfactory
,	TokenNameCOMMA	
doIndexing	TokenNameIdentifier	 do Indexing
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Initialize DOM navigation 	TokenNameCOMMENT_LINE	Initialize DOM navigation 
m_pos	TokenNameIdentifier	 m pos
=	TokenNameEQUAL	
m_root	TokenNameIdentifier	 m root
=	TokenNameEQUAL	
domSource	TokenNameIdentifier	 dom Source
.	TokenNameDOT	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Initialize DTM navigation 	TokenNameCOMMENT_LINE	Initialize DTM navigation 
m_last_parent	TokenNameIdentifier	 m last parent
=	TokenNameEQUAL	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
,	TokenNameCOMMA	
m_last_parent	TokenNameIdentifier	 m last parent
,	TokenNameCOMMA	
m_last_kid	TokenNameIdentifier	 m last kid
,	TokenNameCOMMA	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Apparently the domSource root may not actually be the 	TokenNameCOMMENT_LINE	Apparently the domSource root may not actually be the 
// Document node. If it's an Element node, we need to immediately 	TokenNameCOMMENT_LINE	Document node. If it's an Element node, we need to immediately 
// add its attributes. Adapted from nextNode(). 	TokenNameCOMMENT_LINE	add its attributes. Adapted from nextNode(). 
// %REVIEW% Move this logic into addNode and recurse? Cleaner! 	TokenNameCOMMENT_LINE	%REVIEW% Move this logic into addNode and recurse? Cleaner! 
// 	TokenNameCOMMENT_LINE	 
// (If it's an EntityReference node, we're probably in 	TokenNameCOMMENT_LINE	(If it's an EntityReference node, we're probably in 
// seriously bad trouble. For now 	TokenNameCOMMENT_LINE	seriously bad trouble. For now 
// I'm just hoping nobody is ever quite that foolish... %REVIEW%) 	TokenNameCOMMENT_LINE	I'm just hoping nobody is ever quite that foolish... %REVIEW%) 
// 	TokenNameCOMMENT_LINE	 
// %ISSUE% What about inherited namespaces in this case? 	TokenNameCOMMENT_LINE	%ISSUE% What about inherited namespaces in this case? 
// Do we need to special-case initialize them into the DTM model? 	TokenNameCOMMENT_LINE	Do we need to special-case initialize them into the DTM model? 
if	TokenNameif	
(	TokenNameLPAREN	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
==	TokenNameEQUAL_EQUAL	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
attrs	TokenNameIdentifier	 attrs
=	TokenNameEQUAL	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
attrsize	TokenNameIdentifier	 attrsize
=	TokenNameEQUAL	
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attrsize	TokenNameIdentifier	 attrsize
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
// start with no previous sib 	TokenNameCOMMENT_LINE	start with no previous sib 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrsize	TokenNameIdentifier	 attrsize
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No need to force nodetype in this case; 	TokenNameCOMMENT_LINE	No need to force nodetype in this case; 
// addNode() will take care of switching it from 	TokenNameCOMMENT_LINE	addNode() will take care of switching it from 
// Attr to Namespace if necessary. 	TokenNameCOMMENT_LINE	Attr to Namespace if necessary. 
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
,	TokenNameCOMMA	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Terminate list of attrs, and make sure they aren't 	TokenNameCOMMENT_LINE	Terminate list of attrs, and make sure they aren't 
// considered children of the element 	TokenNameCOMMENT_LINE	considered children of the element 
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// IMPORTANT: This does NOT change m_last_parent or m_last_kid! 	TokenNameCOMMENT_LINE	IMPORTANT: This does NOT change m_last_parent or m_last_kid! 
}	TokenNameRBRACE	
// if attrs exist 	TokenNameCOMMENT_LINE	if attrs exist 
}	TokenNameRBRACE	
//if(ELEMENT_NODE) 	TokenNameCOMMENT_LINE	if(ELEMENT_NODE) 
// Initialize DTM-completed status 	TokenNameCOMMENT_LINE	Initialize DTM-completed status 
m_nodesAreProcessed	TokenNameIdentifier	 m nodes Are Processed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Construct the node map from the node. * * @param node The node that is to be added to the DTM. * @param parentIndex The current parent index. * @param previousSibling The previous sibling index. * @param forceNodeType If not DTM.NULL, overrides the DOM node type. * Used to force nodes to Text rather than CDATASection when their * coalesced value includes ordinary Text nodes (current DTM behavior). * * @return The index identity of the node that was added. */	TokenNameCOMMENT_JAVADOC	 Construct the node map from the node. * @param node The node that is to be added to the DTM. @param parentIndex The current parent index. @param previousSibling The previous sibling index. @param forceNodeType If not DTM.NULL, overrides the DOM node type. Used to force nodes to Text rather than CDATASection when their coalesced value includes ordinary Text nodes (current DTM behavior). * @return The index identity of the node that was added. 
protected	TokenNameprotected	
int	TokenNameint	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
parentIndex	TokenNameIdentifier	 parent Index
,	TokenNameCOMMA	
int	TokenNameint	
previousSibling	TokenNameIdentifier	 previous Sibling
,	TokenNameCOMMA	
int	TokenNameint	
forceNodeType	TokenNameIdentifier	 force Node Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeIndex	TokenNameIdentifier	 node Index
=	TokenNameEQUAL	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Have we overflowed a DTM Identity's addressing range? 	TokenNameCOMMENT_LINE	Have we overflowed a DTM Identity's addressing range? 
if	TokenNameif	
(	TokenNameLPAREN	
m_dtmIdent	TokenNameIdentifier	 m dtm Ident
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
nodeIndex	TokenNameIdentifier	 node Index
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
DTMManager	TokenNameIdentifier	 DTM Manager
.	TokenNameDOT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_mgr	TokenNameIdentifier	 m mgr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ClassCastException	TokenNameIdentifier	 Class Cast Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Handle as Extended Addressing 	TokenNameCOMMENT_LINE	Handle as Extended Addressing 
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
mgrD	TokenNameIdentifier	 mgr D
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
)	TokenNameRPAREN	
m_mgr	TokenNameIdentifier	 m mgr
;	TokenNameSEMICOLON	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
mgrD	TokenNameIdentifier	 mgr D
.	TokenNameDOT	
getFirstFreeDTMID	TokenNameIdentifier	 get First Free DTMID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mgrD	TokenNameIdentifier	 mgr D
.	TokenNameDOT	
addDTM	TokenNameIdentifier	 add DTM
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_dtmIdent	TokenNameIdentifier	 m dtm Ident
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
<<	TokenNameLEFT_SHIFT	
DTMManager	TokenNameIdentifier	 DTM Manager
.	TokenNameDOT	
IDENT_DTM_NODE_BITS	TokenNameIdentifier	 IDENT  DTM  NODE  BITS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ClassCastException	TokenNameIdentifier	 Class Cast Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %REVIEW% Wrong error message, but I've been told we're trying 	TokenNameCOMMENT_LINE	%REVIEW% Wrong error message, but I've been told we're trying 
// not to add messages right not for I18N reasons. 	TokenNameCOMMENT_LINE	not to add messages right not for I18N reasons. 
// %REVIEW% Should this be a Fatal Error? 	TokenNameCOMMENT_LINE	%REVIEW% Should this be a Fatal Error? 
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_NO_DTMIDS_AVAIL	TokenNameIdentifier	 ER  NO  DTMIDS  AVAIL
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"No more DTM IDs are available"; 	TokenNameCOMMENT_LINE	"No more DTM IDs are available"; 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
m_size	TokenNameIdentifier	 m size
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// ensureSize(nodeIndex); 	TokenNameCOMMENT_LINE	ensureSize(nodeIndex); 
int	TokenNameint	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
forceNodeType	TokenNameIdentifier	 force Node Type
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
forceNodeType	TokenNameIdentifier	 force Node Type
;	TokenNameSEMICOLON	
// %REVIEW% The Namespace Spec currently says that Namespaces are 	TokenNameCOMMENT_LINE	%REVIEW% The Namespace Spec currently says that Namespaces are 
// processed in a non-namespace-aware manner, by matching the 	TokenNameCOMMENT_LINE	processed in a non-namespace-aware manner, by matching the 
// QName, even though there is in fact a namespace assigned to 	TokenNameCOMMENT_LINE	QName, even though there is in fact a namespace assigned to 
// these nodes in the DOM. If and when that changes, we will have 	TokenNameCOMMENT_LINE	these nodes in the DOM. If and when that changes, we will have 
// to consider whether we check the namespace-for-namespaces 	TokenNameCOMMENT_LINE	to consider whether we check the namespace-for-namespaces 
// rather than the node name. 	TokenNameCOMMENT_LINE	rather than the node name. 
// 	TokenNameCOMMENT_LINE	 
// %TBD% Note that the DOM does not necessarily explicitly declare 	TokenNameCOMMENT_LINE	%TBD% Note that the DOM does not necessarily explicitly declare 
// all the namespaces it uses. DOM Level 3 will introduce a 	TokenNameCOMMENT_LINE	all the namespaces it uses. DOM Level 3 will introduce a 
// namespace-normalization operation which reconciles that, and we 	TokenNameCOMMENT_LINE	namespace-normalization operation which reconciles that, and we 
// can request that users invoke it or otherwise ensure that the 	TokenNameCOMMENT_LINE	can request that users invoke it or otherwise ensure that the 
// tree is namespace-well-formed before passing the DOM to Xalan. 	TokenNameCOMMENT_LINE	tree is namespace-well-formed before passing the DOM to Xalan. 
// But if they don't, what should we do about it? We probably 	TokenNameCOMMENT_LINE	But if they don't, what should we do about it? We probably 
// don't want to alter the source DOM (and may not be able to do 	TokenNameCOMMENT_LINE	don't want to alter the source DOM (and may not be able to do 
// so if it's read-only). The best available answer might be to 	TokenNameCOMMENT_LINE	so if it's read-only). The best available answer might be to 
// synthesize additional DTM Namespace Nodes that don't correspond 	TokenNameCOMMENT_LINE	synthesize additional DTM Namespace Nodes that don't correspond 
// to DOM Attr Nodes. 	TokenNameCOMMENT_LINE	to DOM Attr Nodes. 
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"xmlns:"	TokenNameStringLiteral	xmlns:
)	TokenNameRPAREN	
||	TokenNameOR_OR	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xmlns"	TokenNameStringLiteral	xmlns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NOTPROCESSED	TokenNameIdentifier	 NOTPROCESSED
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NOTPROCESSED	TokenNameIdentifier	 NOTPROCESSED
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_prevsib	TokenNameIdentifier	 m prevsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
previousSibling	TokenNameIdentifier	 previous Sibling
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_parent	TokenNameIdentifier	 m parent
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
parentIndex	TokenNameIdentifier	 parent Index
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
parentIndex	TokenNameIdentifier	 parent Index
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If the DTM parent had no children, this becomes its first child. 	TokenNameCOMMENT_LINE	If the DTM parent had no children, this becomes its first child. 
if	TokenNameif	
(	TokenNameLPAREN	
NOTPROCESSED	TokenNameIdentifier	 NOTPROCESSED
==	TokenNameEQUAL_EQUAL	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
parentIndex	TokenNameIdentifier	 parent Index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
nodeIndex	TokenNameIdentifier	 node Index
,	TokenNameCOMMA	
parentIndex	TokenNameIdentifier	 parent Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
nsURI	TokenNameIdentifier	 ns URI
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Deal with the difference between Namespace spec and XSLT 	TokenNameCOMMENT_LINE	Deal with the difference between Namespace spec and XSLT 
// definitions of local name. (The former says PIs don't have 	TokenNameCOMMENT_LINE	definitions of local name. (The former says PIs don't have 
// localnames; the latter says they do.) 	TokenNameCOMMENT_LINE	localnames; the latter says they do.) 
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Hack to make DOM1 sort of work... 	TokenNameCOMMENT_LINE	Hack to make DOM1 sort of work... 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
localName	TokenNameIdentifier	 local Name
)	TokenNameRPAREN	
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// -sb 	TokenNameCOMMENT_LINE	-sb 
ExpandedNameTable	TokenNameIdentifier	 Expanded Name Table
exnt	TokenNameIdentifier	 exnt
=	TokenNameEQUAL	
m_expandedNameTable	TokenNameIdentifier	 m expanded Name Table
;	TokenNameSEMICOLON	
// %TBD% Nodes created with the old non-namespace-aware DOM 	TokenNameCOMMENT_LINE	%TBD% Nodes created with the old non-namespace-aware DOM 
// calls createElement() and createAttribute() will never have a 	TokenNameCOMMENT_LINE	calls createElement() and createAttribute() will never have a 
// localname. That will cause their expandedNameID to be just the 	TokenNameCOMMENT_LINE	localname. That will cause their expandedNameID to be just the 
// nodeType... which will keep them from being matched 	TokenNameCOMMENT_LINE	nodeType... which will keep them from being matched 
// successfully by name. Since the DOM makes no promise that 	TokenNameCOMMENT_LINE	successfully by name. Since the DOM makes no promise that 
// those will participate in namespace processing, this is 	TokenNameCOMMENT_LINE	those will participate in namespace processing, this is 
// officially accepted as Not Our Fault. But it might be nice to 	TokenNameCOMMENT_LINE	officially accepted as Not Our Fault. But it might be nice to 
// issue a diagnostic message! 	TokenNameCOMMENT_LINE	issue a diagnostic message! 
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
||	TokenNameOR_OR	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// warning("DOM 'level 1' node "+node.getNodeName()+" won't be mapped properly in DOM2DTM."); 	TokenNameCOMMENT_LINE	warning("DOM 'level 1' node "+node.getNodeName()+" won't be mapped properly in DOM2DTM."); 
}	TokenNameRBRACE	
int	TokenNameint	
expandedNameID	TokenNameIdentifier	 expanded Name ID
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
localName	TokenNameIdentifier	 local Name
)	TokenNameRPAREN	
?	TokenNameQUESTION	
exnt	TokenNameIdentifier	 exnt
.	TokenNameDOT	
getExpandedTypeID	TokenNameIdentifier	 get Expanded Type ID
(	TokenNameLPAREN	
nsURI	TokenNameIdentifier	 ns URI
,	TokenNameCOMMA	
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
:	TokenNameCOLON	
exnt	TokenNameIdentifier	 exnt
.	TokenNameDOT	
getExpandedTypeID	TokenNameIdentifier	 get Expanded Type ID
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_exptype	TokenNameIdentifier	 m exptype
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
expandedNameID	TokenNameIdentifier	 expanded Name ID
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexNode	TokenNameIdentifier	 index Node
(	TokenNameLPAREN	
expandedNameID	TokenNameIdentifier	 expanded Name ID
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
previousSibling	TokenNameIdentifier	 previous Sibling
)	TokenNameRPAREN	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
nodeIndex	TokenNameIdentifier	 node Index
,	TokenNameCOMMA	
previousSibling	TokenNameIdentifier	 previous Sibling
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This should be done after m_exptype has been set, and probably should 	TokenNameCOMMENT_LINE	This should be done after m_exptype has been set, and probably should 
// always be the last thing we do 	TokenNameCOMMENT_LINE	always be the last thing we do 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
)	TokenNameRPAREN	
declareNamespaceInContext	TokenNameIdentifier	 declare Namespace In Context
(	TokenNameLPAREN	
parentIndex	TokenNameIdentifier	 parent Index
,	TokenNameCOMMA	
nodeIndex	TokenNameIdentifier	 node Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
nodeIndex	TokenNameIdentifier	 node Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the number of nodes that have been added. */	TokenNameCOMMENT_JAVADOC	 Get the number of nodes that have been added. 
public	TokenNamepublic	
int	TokenNameint	
getNumberOfNodes	TokenNameIdentifier	 get Number Of Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method iterates to the next node that will be added to the table. * Each call to this method adds a new node to the table, unless the end * is reached, in which case it returns null. * * @return The true if a next node is found or false if * there are no more nodes. */	TokenNameCOMMENT_JAVADOC	 This method iterates to the next node that will be added to the table. Each call to this method adds a new node to the table, unless the end is reached, in which case it returns null. * @return The true if a next node is found or false if there are no more nodes. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
nextNode	TokenNameIdentifier	 next Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Non-recursive one-fetch-at-a-time depth-first traversal with 	TokenNameCOMMENT_LINE	Non-recursive one-fetch-at-a-time depth-first traversal with 
// attribute/namespace nodes and white-space stripping. 	TokenNameCOMMENT_LINE	attribute/namespace nodes and white-space stripping. 
// Navigating the DOM is simple, navigating the DTM is simple; 	TokenNameCOMMENT_LINE	Navigating the DOM is simple, navigating the DTM is simple; 
// keeping track of both at once is a trifle baroque but at least 	TokenNameCOMMENT_LINE	keeping track of both at once is a trifle baroque but at least 
// we've avoided most of the special cases. 	TokenNameCOMMENT_LINE	we've avoided most of the special cases. 
if	TokenNameif	
(	TokenNameLPAREN	
m_nodesAreProcessed	TokenNameIdentifier	 m nodes Are Processed
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// %REVIEW% Is this local copy Really Useful from a performance 	TokenNameCOMMENT_LINE	%REVIEW% Is this local copy Really Useful from a performance 
// point of view? Or is this a false microoptimization? 	TokenNameCOMMENT_LINE	point of view? Or is this a false microoptimization? 
Node	TokenNameIdentifier	 Node
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
m_pos	TokenNameIdentifier	 m pos
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
nexttype	TokenNameIdentifier	 nexttype
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
// Navigate DOM tree 	TokenNameCOMMENT_LINE	Navigate DOM tree 
do	TokenNamedo	
{	TokenNameLBRACE	
// Look down to first child. 	TokenNameCOMMENT_LINE	Look down to first child. 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
hasChildNodes	TokenNameIdentifier	 has Child Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// %REVIEW% There's probably a more elegant way to skip 	TokenNameCOMMENT_LINE	%REVIEW% There's probably a more elegant way to skip 
// the doctype. (Just let it go and Suppress it? 	TokenNameCOMMENT_LINE	the doctype. (Just let it go and Suppress it? 
if	TokenNameif	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOCUMENT_TYPE_NODE	TokenNameIdentifier	 DOCUMENT  TYPE  NODE
==	TokenNameEQUAL_EQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Push DTM context -- except for children of Entity References, 	TokenNameCOMMENT_LINE	Push DTM context -- except for children of Entity References, 
// which have no DTM equivalent and cause no DTM navigation. 	TokenNameCOMMENT_LINE	which have no DTM equivalent and cause no DTM navigation. 
if	TokenNameif	
(	TokenNameLPAREN	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
!=	TokenNameNOT_EQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_last_parent	TokenNameIdentifier	 m last parent
=	TokenNameEQUAL	
m_last_kid	TokenNameIdentifier	 m last kid
;	TokenNameSEMICOLON	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
// Whitespace-handler context stacking 	TokenNameCOMMENT_LINE	Whitespace-handler context stacking 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_wsfilter	TokenNameIdentifier	 m wsfilter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
wsv	TokenNameIdentifier	 wsv
=	TokenNameEQUAL	
m_wsfilter	TokenNameIdentifier	 m wsfilter
.	TokenNameDOT	
getShouldStripSpace	TokenNameIdentifier	 get Should Strip Space
(	TokenNameLPAREN	
makeNodeHandle	TokenNameIdentifier	 make Node Handle
(	TokenNameLPAREN	
m_last_parent	TokenNameIdentifier	 m last parent
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
shouldStrip	TokenNameIdentifier	 should Strip
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
.	TokenNameDOT	
INHERIT	TokenNameIdentifier	 INHERIT
==	TokenNameEQUAL_EQUAL	
wsv	TokenNameIdentifier	 wsv
)	TokenNameRPAREN	
?	TokenNameQUESTION	
getShouldStripWhitespace	TokenNameIdentifier	 get Should Strip Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
DTMWSFilter	TokenNameIdentifier	 DTMWS Filter
.	TokenNameDOT	
STRIP	TokenNameIdentifier	 STRIP
==	TokenNameEQUAL_EQUAL	
wsv	TokenNameIdentifier	 wsv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pushShouldStripWhitespace	TokenNameIdentifier	 push Should Strip Whitespace
(	TokenNameLPAREN	
shouldStrip	TokenNameIdentifier	 should Strip
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if(m_wsfilter) 	TokenNameCOMMENT_LINE	if(m_wsfilter) 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If that fails, look up and right (but not past root!) 	TokenNameCOMMENT_LINE	If that fails, look up and right (but not past root!) 
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_last_kid	TokenNameIdentifier	 m last kid
!=	TokenNameNOT_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Last node posted at this level had no more children 	TokenNameCOMMENT_LINE	Last node posted at this level had no more children 
// If it has _no_ children, we need to record that. 	TokenNameCOMMENT_LINE	If it has _no_ children, we need to record that. 
if	TokenNameif	
(	TokenNameLPAREN	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
m_last_kid	TokenNameIdentifier	 m last kid
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
NOTPROCESSED	TokenNameIdentifier	 NOTPROCESSED
)	TokenNameRPAREN	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
m_last_kid	TokenNameIdentifier	 m last kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
m_last_parent	TokenNameIdentifier	 m last parent
!=	TokenNameNOT_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %REVIEW% There's probably a more elegant way to 	TokenNameCOMMENT_LINE	%REVIEW% There's probably a more elegant way to 
// skip the doctype. (Just let it go and Suppress it? 	TokenNameCOMMENT_LINE	skip the doctype. (Just let it go and Suppress it? 
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOCUMENT_TYPE_NODE	TokenNameIdentifier	 DOCUMENT  TYPE  NODE
==	TokenNameEQUAL_EQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// Found it! 	TokenNameCOMMENT_LINE	Found it! 
// No next-sibling found. Pop the DOM. 	TokenNameCOMMENT_LINE	No next-sibling found. Pop the DOM. 
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %TBD% Should never arise, but I want to be sure of that... 	TokenNameCOMMENT_LINE	%TBD% Should never arise, but I want to be sure of that... 
if	TokenNameif	
(	TokenNameLPAREN	
JJK_DEBUG	TokenNameIdentifier	 JJK  DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"***** DOM2DTM Pop Control Flow problem"	TokenNameStringLiteral	***** DOM2DTM Pop Control Flow problem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Freeze right here! 	TokenNameCOMMENT_LINE	Freeze right here! 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// The only parents in the DTM are Elements. However, 	TokenNameCOMMENT_LINE	The only parents in the DTM are Elements. However, 
// the DOM could contain EntityReferences. If we 	TokenNameCOMMENT_LINE	the DOM could contain EntityReferences. If we 
// encounter one, pop it _without_ popping DTM. 	TokenNameCOMMENT_LINE	encounter one, pop it _without_ popping DTM. 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
==	TokenNameEQUAL_EQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Nothing needs doing 	TokenNameCOMMENT_LINE	Nothing needs doing 
if	TokenNameif	
(	TokenNameLPAREN	
JJK_DEBUG	TokenNameIdentifier	 JJK  DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"***** DOM2DTM popping EntRef"	TokenNameStringLiteral	***** DOM2DTM popping EntRef
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
popShouldStripWhitespace	TokenNameIdentifier	 pop Should Strip Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Fix and pop DTM 	TokenNameCOMMENT_LINE	Fix and pop DTM 
if	TokenNameif	
(	TokenNameLPAREN	
m_last_kid	TokenNameIdentifier	 m last kid
==	TokenNameEQUAL_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
m_last_parent	TokenNameIdentifier	 m last parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Popping from an element 	TokenNameCOMMENT_LINE	Popping from an element 
else	TokenNameelse	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
m_last_kid	TokenNameIdentifier	 m last kid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Popping from anything else 	TokenNameCOMMENT_LINE	Popping from anything else 
m_last_parent	TokenNameIdentifier	 m last parent
=	TokenNameEQUAL	
m_parent	TokenNameIdentifier	 m parent
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
m_last_parent	TokenNameIdentifier	 m last parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_last_parent	TokenNameIdentifier	 m last parent
==	TokenNameEQUAL_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
nexttype	TokenNameIdentifier	 nexttype
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If it's an entity ref, advance past it. 	TokenNameCOMMENT_LINE	If it's an entity ref, advance past it. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% Should we let this out the door and just suppress it? 	TokenNameCOMMENT_LINE	%REVIEW% Should we let this out the door and just suppress it? 
// More work, but simpler code, more likely to be correct, and 	TokenNameCOMMENT_LINE	More work, but simpler code, more likely to be correct, and 
// it doesn't happen very often. We'd get rid of the loop too. 	TokenNameCOMMENT_LINE	it doesn't happen very often. We'd get rid of the loop too. 
if	TokenNameif	
(	TokenNameLPAREN	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Did we run out of the tree? 	TokenNameCOMMENT_LINE	Did we run out of the tree? 
if	TokenNameif	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_nodesAreProcessed	TokenNameIdentifier	 m nodes Are Processed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
m_pos	TokenNameIdentifier	 m pos
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
JJK_DEBUG	TokenNameIdentifier	 JJK  DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"***** DOM2DTM Crosscheck:"	TokenNameStringLiteral	***** DOM2DTM Crosscheck:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Text needs some special handling: 	TokenNameCOMMENT_LINE	Text needs some special handling: 
// 	TokenNameCOMMENT_LINE	 
// DTM may skip whitespace. This is handled by the suppressNode flag, which 	TokenNameCOMMENT_LINE	DTM may skip whitespace. This is handled by the suppressNode flag, which 
// when true will keep the DTM node from being created. 	TokenNameCOMMENT_LINE	when true will keep the DTM node from being created. 
// 	TokenNameCOMMENT_LINE	 
// DTM only directly records the first DOM node of any logically-contiguous 	TokenNameCOMMENT_LINE	DTM only directly records the first DOM node of any logically-contiguous 
// sequence. The lastTextNode value will be set to the last node in the 	TokenNameCOMMENT_LINE	sequence. The lastTextNode value will be set to the last node in the 
// contiguous sequence, and -- AFTER the DTM addNode -- can be used to 	TokenNameCOMMENT_LINE	contiguous sequence, and -- AFTER the DTM addNode -- can be used to 
// advance next over this whole block. Should be simpler than special-casing 	TokenNameCOMMENT_LINE	advance next over this whole block. Should be simpler than special-casing 
// the above loop for "Was the logically-preceeding sibling a text node". 	TokenNameCOMMENT_LINE	the above loop for "Was the logically-preceeding sibling a text node". 
// 	TokenNameCOMMENT_LINE	 
// Finally, a DTM node should be considered a CDATASection only if all the 	TokenNameCOMMENT_LINE	Finally, a DTM node should be considered a CDATASection only if all the 
// contiguous text it covers is CDATASections. The first Text should 	TokenNameCOMMENT_LINE	contiguous text it covers is CDATASections. The first Text should 
// force DTM to Text. 	TokenNameCOMMENT_LINE	force DTM to Text. 
boolean	TokenNameboolean	
suppressNode	TokenNameIdentifier	 suppress Node
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
lastTextNode	TokenNameIdentifier	 last Text Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
nexttype	TokenNameIdentifier	 nexttype
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// nexttype=pos.getNodeType(); 	TokenNameCOMMENT_LINE	nexttype=pos.getNodeType(); 
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
||	TokenNameOR_OR	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If filtering, initially assume we're going to suppress the node 	TokenNameCOMMENT_LINE	If filtering, initially assume we're going to suppress the node 
suppressNode	TokenNameIdentifier	 suppress Node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_wsfilter	TokenNameIdentifier	 m wsfilter
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
getShouldStripWhitespace	TokenNameIdentifier	 get Should Strip Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Scan logically contiguous text (siblings, plus "flattening" 	TokenNameCOMMENT_LINE	Scan logically contiguous text (siblings, plus "flattening" 
// of entity reference boundaries). 	TokenNameCOMMENT_LINE	of entity reference boundaries). 
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastTextNode	TokenNameIdentifier	 last Text Node
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
// Any Text node means DTM considers it all Text 	TokenNameCOMMENT_LINE	Any Text node means DTM considers it all Text 
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
nexttype	TokenNameIdentifier	 nexttype
=	TokenNameEQUAL	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
;	TokenNameSEMICOLON	
// Any non-whitespace in this sequence blocks whitespace 	TokenNameCOMMENT_LINE	Any non-whitespace in this sequence blocks whitespace 
// suppression 	TokenNameCOMMENT_LINE	suppression 
suppressNode	TokenNameIdentifier	 suppress Node
&=	TokenNameAND_EQUAL	
XMLCharacterRecognizer	TokenNameIdentifier	 XML Character Recognizer
.	TokenNameDOT	
isWhiteSpace	TokenNameIdentifier	 is White Space
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Special handling for PIs: Some DOMs represent the XML 	TokenNameCOMMENT_LINE	Special handling for PIs: Some DOMs represent the XML 
// Declaration as a PI. This is officially incorrect, per the DOM 	TokenNameCOMMENT_LINE	Declaration as a PI. This is officially incorrect, per the DOM 
// spec, but is considered a "wrong but tolerable" temporary 	TokenNameCOMMENT_LINE	spec, but is considered a "wrong but tolerable" temporary 
// workaround pending proper handling of these fields in DOM Level 	TokenNameCOMMENT_LINE	workaround pending proper handling of these fields in DOM Level 
// 3. We want to recognize and reject that case. 	TokenNameCOMMENT_LINE	3. We want to recognize and reject that case. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
suppressNode	TokenNameIdentifier	 suppress Node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xml"	TokenNameStringLiteral	xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
suppressNode	TokenNameIdentifier	 suppress Node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Inserting next. NOTE that we force the node type; for 	TokenNameCOMMENT_LINE	Inserting next. NOTE that we force the node type; for 
// coalesced Text, this records CDATASections adjacent to 	TokenNameCOMMENT_LINE	coalesced Text, this records CDATASections adjacent to 
// ordinary Text as Text. 	TokenNameCOMMENT_LINE	ordinary Text as Text. 
int	TokenNameint	
nextindex	TokenNameIdentifier	 nextindex
=	TokenNameEQUAL	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
,	TokenNameCOMMA	
m_last_parent	TokenNameIdentifier	 m last parent
,	TokenNameCOMMA	
m_last_kid	TokenNameIdentifier	 m last kid
,	TokenNameCOMMA	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_last_kid	TokenNameIdentifier	 m last kid
=	TokenNameEQUAL	
nextindex	TokenNameIdentifier	 nextindex
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
// start with no previous sib 	TokenNameCOMMENT_LINE	start with no previous sib 
// Process attributes _now_, rather than waiting. 	TokenNameCOMMENT_LINE	Process attributes _now_, rather than waiting. 
// Simpler control flow, makes NS cache available immediately. 	TokenNameCOMMENT_LINE	Simpler control flow, makes NS cache available immediately. 
NamedNodeMap	TokenNameIdentifier	 Named Node Map
attrs	TokenNameIdentifier	 attrs
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
attrsize	TokenNameIdentifier	 attrsize
=	TokenNameEQUAL	
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attrsize	TokenNameIdentifier	 attrsize
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrsize	TokenNameIdentifier	 attrsize
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No need to force nodetype in this case; 	TokenNameCOMMENT_LINE	No need to force nodetype in this case; 
// addNode() will take care of switching it from 	TokenNameCOMMENT_LINE	addNode() will take care of switching it from 
// Attr to Namespace if necessary. 	TokenNameCOMMENT_LINE	Attr to Namespace if necessary. 
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
nextindex	TokenNameIdentifier	 nextindex
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
,	TokenNameCOMMA	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the xml: prefix is explicitly declared 	TokenNameCOMMENT_LINE	If the xml: prefix is explicitly declared 
// we don't need to synthesize one. 	TokenNameCOMMENT_LINE	we don't need to synthesize one. 
// 	TokenNameCOMMENT_LINE	 
// NOTE that XML Namespaces were not originally 	TokenNameCOMMENT_LINE	NOTE that XML Namespaces were not originally 
// defined as being namespace-aware (grrr), and 	TokenNameCOMMENT_LINE	defined as being namespace-aware (grrr), and 
// while the W3C is planning to fix this it's 	TokenNameCOMMENT_LINE	while the W3C is planning to fix this it's 
// safer for now to test the QName and trust the 	TokenNameCOMMENT_LINE	safer for now to test the QName and trust the 
// parsers to prevent anyone from redefining the 	TokenNameCOMMENT_LINE	parsers to prevent anyone from redefining the 
// reserved xmlns: prefix 	TokenNameCOMMENT_LINE	reserved xmlns: prefix 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
m_processedFirstElement	TokenNameIdentifier	 m processed First Element
&&	TokenNameAND_AND	
"xmlns:xml"	TokenNameStringLiteral	xmlns:xml
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
m_processedFirstElement	TokenNameIdentifier	 m processed First Element
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Terminate list of attrs, and make sure they aren't 	TokenNameCOMMENT_LINE	Terminate list of attrs, and make sure they aren't 
// considered children of the element 	TokenNameCOMMENT_LINE	considered children of the element 
}	TokenNameRBRACE	
// if attrs exist 	TokenNameCOMMENT_LINE	if attrs exist 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
m_processedFirstElement	TokenNameIdentifier	 m processed First Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The DOM might not have an explicit declaration for the 	TokenNameCOMMENT_LINE	The DOM might not have an explicit declaration for the 
// implicit "xml:" prefix, but the XPath data model 	TokenNameCOMMENT_LINE	implicit "xml:" prefix, but the XPath data model 
// requires that this appear as a Namespace Node so we 	TokenNameCOMMENT_LINE	requires that this appear as a Namespace Node so we 
// have to synthesize one. You can think of this as 	TokenNameCOMMENT_LINE	have to synthesize one. You can think of this as 
// being a default attribute defined by the XML 	TokenNameCOMMENT_LINE	being a default attribute defined by the XML 
// Namespaces spec rather than by the DTD. 	TokenNameCOMMENT_LINE	Namespaces spec rather than by the DTD. 
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
addNode	TokenNameIdentifier	 add Node
(	TokenNameLPAREN	
new	TokenNamenew	
DOM2DTMdefaultNamespaceDeclarationNode	TokenNameIdentifier	 DO M2 DT Mdefault Namespace Declaration Node
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
next	TokenNameIdentifier	 next
,	TokenNameCOMMA	
"xml"	TokenNameStringLiteral	xml
,	TokenNameCOMMA	
NAMESPACE_DECL_NS	TokenNameIdentifier	 NAMESPACE  DECL  NS
,	TokenNameCOMMA	
makeNodeHandle	TokenNameIdentifier	 make Node Handle
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
attrIndex	TokenNameIdentifier	 attr Index
==	TokenNameEQUAL_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
nextindex	TokenNameIdentifier	 nextindex
:	TokenNameCOLON	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
nextindex	TokenNameIdentifier	 nextindex
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
,	TokenNameCOMMA	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_firstch	TokenNameIdentifier	 m firstch
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_processedFirstElement	TokenNameIdentifier	 m processed First Element
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attrIndex	TokenNameIdentifier	 attr Index
!=	TokenNameNOT_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
m_nextsib	TokenNameIdentifier	 m nextsib
.	TokenNameDOT	
setElementAt	TokenNameIdentifier	 set Element At
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
,	TokenNameCOMMA	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//if(ELEMENT_NODE) 	TokenNameCOMMENT_LINE	if(ELEMENT_NODE) 
}	TokenNameRBRACE	
// (if !suppressNode) 	TokenNameCOMMENT_LINE	(if !suppressNode) 
// Text postprocessing: Act on values stored above 	TokenNameCOMMENT_LINE	Text postprocessing: Act on values stored above 
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
||	TokenNameOR_OR	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
==	TokenNameEQUAL_EQUAL	
nexttype	TokenNameIdentifier	 nexttype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %TBD% If nexttype was forced to TEXT, patch the DTM node 	TokenNameCOMMENT_LINE	%TBD% If nexttype was forced to TEXT, patch the DTM node 
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
lastTextNode	TokenNameIdentifier	 last Text Node
;	TokenNameSEMICOLON	
// Advance the DOM cursor over contiguous text 	TokenNameCOMMENT_LINE	Advance the DOM cursor over contiguous text 
}	TokenNameRBRACE	
// Remember where we left off. 	TokenNameCOMMENT_LINE	Remember where we left off. 
m_pos	TokenNameIdentifier	 m pos
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return an DOM node for the given node. * * @param nodeHandle The node ID. * * @return A node representation of the DTM node. */	TokenNameCOMMENT_JAVADOC	 Return an DOM node for the given node. * @param nodeHandle The node ID. * @return A node representation of the DTM node. 
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
makeNodeIdentity	TokenNameIdentifier	 make Node Identity
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
)	TokenNameRPAREN	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get a Node from an identity index. * * NEEDSDOC @param nodeIdentity * * NEEDSDOC ($objectName$) @return */	TokenNameCOMMENT_JAVADOC	 Get a Node from an identity index. * NEEDSDOC @param nodeIdentity * NEEDSDOC ($objectName$) @return 
protected	TokenNameprotected	
Node	TokenNameIdentifier	 Node
lookupNode	TokenNameIdentifier	 lookup Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeIdentity	TokenNameIdentifier	 node Identity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
)	TokenNameRPAREN	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
nodeIdentity	TokenNameIdentifier	 node Identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the next node identity value in the list, and call the iterator * if it hasn't been added yet. * * @param identity The node identity (index). * @return identity+1, or DTM.NULL. */	TokenNameCOMMENT_JAVADOC	 Get the next node identity value in the list, and call the iterator if it hasn't been added yet. * @param identity The node identity (index). @return identity+1, or DTM.NULL. 
protected	TokenNameprotected	
int	TokenNameint	
getNextNodeIdentity	TokenNameIdentifier	 get Next Node Identity
(	TokenNameLPAREN	
int	TokenNameint	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
identity	TokenNameIdentifier	 identity
+=	TokenNamePLUS_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
>=	TokenNameGREATER_EQUAL	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
nextNode	TokenNameIdentifier	 next Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
identity	TokenNameIdentifier	 identity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the handle from a Node. * <p>%OPT% This will be pretty slow.</p> * * <p>%OPT% An XPath-like search (walk up DOM to root, tracking path; * walk down DTM reconstructing path) might be considerably faster * on later nodes in large documents. That might also imply improving * this call to handle nodes which would be in this DTM but * have not yet been built, which might or might not be a Good Thing.</p> * * %REVIEW% This relies on being able to test node-identity via * object-identity. DTM2DOM proxying is a great example of a case where * that doesn't work. DOM Level 3 will provide the isSameNode() method * to fix that, but until then this is going to be flaky. * * @param node A node, which may be null. * * @return The node handle or <code>DTM.NULL</code>. */	TokenNameCOMMENT_JAVADOC	 Get the handle from a Node. <p>%OPT% This will be pretty slow.</p> * <p>%OPT% An XPath-like search (walk up DOM to root, tracking path; walk down DTM reconstructing path) might be considerably faster on later nodes in large documents. That might also imply improving this call to handle nodes which would be in this DTM but have not yet been built, which might or might not be a Good Thing.</p> * %REVIEW% This relies on being able to test node-identity via object-identity. DTM2DOM proxying is a great example of a case where that doesn't work. DOM Level 3 will provide the isSameNode() method to fix that, but until then this is going to be flaky. * @param node A node, which may be null. * @return The node handle or <code>DTM.NULL</code>. 
private	TokenNameprivate	
int	TokenNameint	
getHandleFromNode	TokenNameIdentifier	 get Handle From Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isMore	TokenNameIdentifier	 is More
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
return	TokenNamereturn	
makeNodeHandle	TokenNameIdentifier	 make Node Handle
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isMore	TokenNameIdentifier	 is More
=	TokenNameEQUAL	
nextNode	TokenNameIdentifier	 next Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
isMore	TokenNameIdentifier	 is More
||	TokenNameOR_OR	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the handle from a Node. This is a more robust version of * getHandleFromNode, intended to be usable by the public. * * <p>%OPT% This will be pretty slow.</p> * * %REVIEW% This relies on being able to test node-identity via * object-identity. DTM2DOM proxying is a great example of a case where * that doesn't work. DOM Level 3 will provide the isSameNode() method * to fix that, but until then this is going to be flaky. * * @param node A node, which may be null. * * @return The node handle or <code>DTM.NULL</code>. */	TokenNameCOMMENT_JAVADOC	 Get the handle from a Node. This is a more robust version of getHandleFromNode, intended to be usable by the public. * <p>%OPT% This will be pretty slow.</p> * %REVIEW% This relies on being able to test node-identity via object-identity. DTM2DOM proxying is a great example of a case where that doesn't work. DOM Level 3 will provide the isSameNode() method to fix that, but until then this is going to be flaky. * @param node A node, which may be null. * @return The node handle or <code>DTM.NULL</code>. 
public	TokenNamepublic	
int	TokenNameint	
getHandleOfNode	TokenNameIdentifier	 get Handle Of Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Is Node actually within the same document? If not, don't search! 	TokenNameCOMMENT_LINE	Is Node actually within the same document? If not, don't search! 
// This would be easier if m_root was always the Document node, but 	TokenNameCOMMENT_LINE	This would be easier if m_root was always the Document node, but 
// we decided to allow wrapping a DTM around a subtree. 	TokenNameCOMMENT_LINE	we decided to allow wrapping a DTM around a subtree. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
&&	TokenNameAND_AND	
m_root	TokenNameIdentifier	 m root
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
&&	TokenNameAND_AND	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If node _is_ in m_root's tree, find its handle 	TokenNameCOMMENT_LINE	If node _is_ in m_root's tree, find its handle 
// 	TokenNameCOMMENT_LINE	 
// %OPT% This check may be improved significantly when DOM 	TokenNameCOMMENT_LINE	%OPT% This check may be improved significantly when DOM 
// Level 3 nodeKey and relative-order tests become 	TokenNameCOMMENT_LINE	Level 3 nodeKey and relative-order tests become 
// available! 	TokenNameCOMMENT_LINE	available! 
for	TokenNamefor	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
cursor	TokenNameIdentifier	 cursor
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
cursor	TokenNameIdentifier	 cursor
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
cursor	TokenNameIdentifier	 cursor
=	TokenNameEQUAL	
(	TokenNameLPAREN	
cursor	TokenNameIdentifier	 cursor
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
cursor	TokenNameIdentifier	 cursor
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
)	TokenNameRPAREN	
cursor	TokenNameIdentifier	 cursor
)	TokenNameRPAREN	
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cursor	TokenNameIdentifier	 cursor
==	TokenNameEQUAL_EQUAL	
m_root	TokenNameIdentifier	 m root
)	TokenNameRPAREN	
// We know this node; find its handle. 	TokenNameCOMMENT_LINE	We know this node; find its handle. 
return	TokenNamereturn	
getHandleFromNode	TokenNameIdentifier	 get Handle From Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// for ancestors of node 	TokenNameCOMMENT_LINE	for ancestors of node 
}	TokenNameRBRACE	
// if node and m_root in same Document 	TokenNameCOMMENT_LINE	if node and m_root in same Document 
}	TokenNameRBRACE	
// if node!=null 	TokenNameCOMMENT_LINE	if node!=null 
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieves an attribute node by by qualified name and namespace URI. * * @param nodeHandle int Handle of the node upon which to look up this attribute.. * @param namespaceURI The namespace URI of the attribute to * retrieve, or null. * @param name The local name of the attribute to * retrieve. * @return The attribute node handle with the specified name ( * <code>nodeName</code>) or <code>DTM.NULL</code> if there is no such * attribute. */	TokenNameCOMMENT_JAVADOC	 Retrieves an attribute node by by qualified name and namespace URI. * @param nodeHandle int Handle of the node upon which to look up this attribute.. @param namespaceURI The namespace URI of the attribute to retrieve, or null. @param name The local name of the attribute to retrieve. @return The attribute node handle with the specified name ( <code>nodeName</code>) or <code>DTM.NULL</code> if there is no such attribute. 
public	TokenNamepublic	
int	TokenNameint	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespaceURI	TokenNameIdentifier	 namespace URI
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// %OPT% This is probably slower than it needs to be. 	TokenNameCOMMENT_LINE	%OPT% This is probably slower than it needs to be. 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
namespaceURI	TokenNameIdentifier	 namespace URI
)	TokenNameRPAREN	
namespaceURI	TokenNameIdentifier	 namespace URI
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Assume that attributes immediately follow the element. 	TokenNameCOMMENT_LINE	Assume that attributes immediately follow the element. 
int	TokenNameint	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
makeNodeIdentity	TokenNameIdentifier	 make Node Identity
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
getNextNodeIdentity	TokenNameIdentifier	 get Next Node Identity
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Assume this can not be null. 	TokenNameCOMMENT_LINE	Assume this can not be null. 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
_type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// %REVIEW% 	TokenNameCOMMENT_LINE	%REVIEW% 
// Should namespace nodes be retrievable DOM-style as attrs? 	TokenNameCOMMENT_LINE	Should namespace nodes be retrievable DOM-style as attrs? 
// If not we need a separate function... which may be desirable 	TokenNameCOMMENT_LINE	If not we need a separate function... which may be desirable 
// architecturally, but which is ugly from a code point of view. 	TokenNameCOMMENT_LINE	architecturally, but which is ugly from a code point of view. 
// (If we REALLY insist on it, this code should become a subroutine 	TokenNameCOMMENT_LINE	(If we REALLY insist on it, this code should become a subroutine 
// of both -- retrieve the node, then test if the type matches 	TokenNameCOMMENT_LINE	of both -- retrieve the node, then test if the type matches 
// what you're looking for.) 	TokenNameCOMMENT_LINE	what you're looking for.) 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
||	TokenNameOR_OR	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
lookupNode	TokenNameIdentifier	 lookup Node
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nodeuri	TokenNameIdentifier	 nodeuri
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
nodeuri	TokenNameIdentifier	 nodeuri
)	TokenNameRPAREN	
nodeuri	TokenNameIdentifier	 nodeuri
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nodelocalname	TokenNameIdentifier	 nodelocalname
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeuri	TokenNameIdentifier	 nodeuri
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
namespaceURI	TokenNameIdentifier	 namespace URI
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
nodelocalname	TokenNameIdentifier	 nodelocalname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
makeNodeHandle	TokenNameIdentifier	 make Node Handle
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
// if (DTM.NAMESPACE_NODE != type) 	TokenNameCOMMENT_LINE	if (DTM.NAMESPACE_NODE != type) 
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the string-value of a node as a String object * (see http://www.w3.org/TR/xpath#data-model * for the definition of a node's string-value). * * @param nodeHandle The node ID. * * @return A string object that represents the string-value of the given node. */	TokenNameCOMMENT_JAVADOC	 Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value). * @param nodeHandle The node ID. * @return A string object that represents the string-value of the given node. 
public	TokenNamepublic	
XMLString	TokenNameIdentifier	 XML String
getStringValue	TokenNameIdentifier	 get String Value
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// %TBD% If an element only has one text node, we should just use it 	TokenNameCOMMENT_LINE	%TBD% If an element only has one text node, we should just use it 
// directly. 	TokenNameCOMMENT_LINE	directly. 
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
||	TokenNameOR_OR	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
||	TokenNameOR_OR	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
DOCUMENT_FRAGMENT_NODE	TokenNameIdentifier	 DOCUMENT  FRAGMENT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
m_xstrf	TokenNameIdentifier	 m xstrf
.	TokenNameDOT	
newstr	TokenNameIdentifier	 newstr
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
||	TokenNameOR_OR	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this is a DTM text node, it may be made of multiple DOM text 	TokenNameCOMMENT_LINE	If this is a DTM text node, it may be made of multiple DOM text 
// nodes -- including navigating into Entity References. DOM2DTM 	TokenNameCOMMENT_LINE	nodes -- including navigating into Entity References. DOM2DTM 
// records the first node in the sequence and requires that we 	TokenNameCOMMENT_LINE	records the first node in the sequence and requires that we 
// pick up the others when we retrieve the DTM node's value. 	TokenNameCOMMENT_LINE	pick up the others when we retrieve the DTM node's value. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% DOM Level 3 is expected to add a "whole text" 	TokenNameCOMMENT_LINE	%REVIEW% DOM Level 3 is expected to add a "whole text" 
// retrieval method which performs this function for us. 	TokenNameCOMMENT_LINE	retrieval method which performs this function for us. 
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
m_xstrf	TokenNameIdentifier	 m xstrf
.	TokenNameDOT	
newstr	TokenNameIdentifier	 newstr
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
m_xstrf	TokenNameIdentifier	 m xstrf
.	TokenNameDOT	
newstr	TokenNameIdentifier	 newstr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Determine if the string-value of a node is whitespace * * @param nodeHandle The node Handle. * * @return Return true if the given node is whitespace. */	TokenNameCOMMENT_JAVADOC	 Determine if the string-value of a node is whitespace * @param nodeHandle The node Handle. * @return Return true if the given node is whitespace. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isWhitespace	TokenNameIdentifier	 is Whitespace
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
||	TokenNameOR_OR	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this is a DTM text node, it may be made of multiple DOM text 	TokenNameCOMMENT_LINE	If this is a DTM text node, it may be made of multiple DOM text 
// nodes -- including navigating into Entity References. DOM2DTM 	TokenNameCOMMENT_LINE	nodes -- including navigating into Entity References. DOM2DTM 
// records the first node in the sequence and requires that we 	TokenNameCOMMENT_LINE	records the first node in the sequence and requires that we 
// pick up the others when we retrieve the DTM node's value. 	TokenNameCOMMENT_LINE	pick up the others when we retrieve the DTM node's value. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% DOM Level 3 is expected to add a "whole text" 	TokenNameCOMMENT_LINE	%REVIEW% DOM Level 3 is expected to add a "whole text" 
// retrieval method which performs this function for us. 	TokenNameCOMMENT_LINE	retrieval method which performs this function for us. 
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
isWhitespace	TokenNameIdentifier	 is Whitespace
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieve the text content of a DOM subtree, appending it into a * user-supplied FastStringBuffer object. Note that attributes are * not considered part of the content of an element. * <p> * There are open questions regarding whitespace stripping. * Currently we make no special effort in that regard, since the standard * DOM doesn't yet provide DTD-based information to distinguish * whitespace-in-element-context from genuine #PCDATA. Note that we * should probably also consider xml:space if/when we address this. * DOM Level 3 may solve the problem for us. * <p> * %REVIEW% Actually, since this method operates on the DOM side of the * fence rather than the DTM side, it SHOULDN'T do * any special handling. The DOM does what the DOM does; if you want * DTM-level abstractions, use DTM-level methods. * * @param node Node whose subtree is to be walked, gathering the * contents of all Text or CDATASection nodes. * @param buf FastStringBuffer into which the contents of the text * nodes are to be concatenated. */	TokenNameCOMMENT_JAVADOC	 Retrieve the text content of a DOM subtree, appending it into a user-supplied FastStringBuffer object. Note that attributes are not considered part of the content of an element. <p> There are open questions regarding whitespace stripping. Currently we make no special effort in that regard, since the standard DOM doesn't yet provide DTD-based information to distinguish whitespace-in-element-context from genuine #PCDATA. Note that we should probably also consider xml:space if/when we address this. DOM Level 3 may solve the problem for us. <p> %REVIEW% Actually, since this method operates on the DOM side of the fence rather than the DTM side, it SHOULDN'T do any special handling. The DOM does what the DOM does; if you want DTM-level abstractions, use DTM-level methods. * @param node Node whose subtree is to be walked, gathering the contents of all Text or CDATASection nodes. @param buf FastStringBuffer into which the contents of the text nodes are to be concatenated. 
protected	TokenNameprotected	
static	TokenNamestatic	
void	TokenNamevoid	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_FRAGMENT_NODE	TokenNameIdentifier	 DOCUMENT  FRAGMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
// Never a child but might be our starting node 	TokenNameCOMMENT_LINE	Never a child but might be our starting node 
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
// warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 	TokenNameCOMMENT_LINE	warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
// ignore 	TokenNameCOMMENT_LINE	ignore 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Given a node handle, return its DOM-style node name. This will * include names such as #text or #document. * * @param nodeHandle the id of the node. * @return String Name of this node, which may be an empty string. * %REVIEW% Document when empty string is possible... * %REVIEW-COMMENT% It should never be empty, should it? */	TokenNameCOMMENT_JAVADOC	 Given a node handle, return its DOM-style node name. This will include names such as #text or #document. * @param nodeHandle the id of the node. @return String Name of this node, which may be an empty string. %REVIEW% Document when empty string is possible... %REVIEW-COMMENT% It should never be empty, should it? 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Assume non-null. 	TokenNameCOMMENT_LINE	Assume non-null. 
return	TokenNamereturn	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a node handle, return the XPath node name. This should be * the name as described by the XPath data model, NOT the DOM-style * name. * * @param nodeHandle the id of the node. * @return String Name of this node, which may be an empty string. */	TokenNameCOMMENT_JAVADOC	 Given a node handle, return the XPath node name. This should be the name as described by the XPath data model, NOT the DOM-style name. * @param nodeHandle the id of the node. @return String Name of this node, which may be an empty string. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeNameX	TokenNameIdentifier	 get Node Name X
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
short	TokenNameshort	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"xmlns:"	TokenNameStringLiteral	xmlns:
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
QName	TokenNameIdentifier	 Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xmlns"	TokenNameStringLiteral	xmlns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a node handle, return its XPath-style localname. * (As defined in Namespaces, this is the portion of the name after any * colon character). * * @param nodeHandle the id of the node. * @return String Local name of this node. */	TokenNameCOMMENT_JAVADOC	 Given a node handle, return its XPath-style localname. (As defined in Namespaces, this is the portion of the name after any colon character). * @param nodeHandle the id of the node. @return String Local name of this node. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
JJK_NEWCODE	TokenNameIdentifier	 JJK  NEWCODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
makeNodeIdentity	TokenNameIdentifier	 make Node Identity
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
newnode	TokenNameIdentifier	 newnode
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
)	TokenNameRPAREN	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
newname	TokenNameIdentifier	 newname
=	TokenNameEQUAL	
newnode	TokenNameIdentifier	 newnode
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
newname	TokenNameIdentifier	 newname
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// XSLT treats PIs, and possibly other things, as having QNames. 	TokenNameCOMMENT_LINE	XSLT treats PIs, and possibly other things, as having QNames. 
String	TokenNameIdentifier	 String
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
newnode	TokenNameIdentifier	 newnode
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
'#'	TokenNameCharacterLiteral	
==	TokenNameEQUAL_EQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Match old default for this function 	TokenNameCOMMENT_LINE	Match old default for this function 
// This conversion may or may not be necessary 	TokenNameCOMMENT_LINE	This conversion may or may not be necessary 
newname	TokenNameIdentifier	 newname
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newname	TokenNameIdentifier	 newname
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
qname	TokenNameIdentifier	 qname
:	TokenNameCOLON	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
newname	TokenNameIdentifier	 newname
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
short	TokenNameshort	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
qname	TokenNameIdentifier	 qname
:	TokenNameCOLON	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Given a namespace handle, return the prefix that the namespace decl is * mapping. * Given a node handle, return the prefix used to map to the namespace. * * <p> %REVIEW% Are you sure you want "" for no prefix? </p> * <p> %REVIEW-COMMENT% I think so... not totally sure. -sb </p> * * @param nodeHandle the id of the node. * @return String prefix of this node's name, or "" if no explicit * namespace prefix was given. */	TokenNameCOMMENT_JAVADOC	 Given a namespace handle, return the prefix that the namespace decl is mapping. Given a node handle, return the prefix used to map to the namespace. * <p> %REVIEW% Are you sure you want "" for no prefix? </p> <p> %REVIEW-COMMENT% I think so... not totally sure. -sb </p> * @param nodeHandle the id of the node. @return String prefix of this node's name, or "" if no explicit namespace prefix was given. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
short	TokenNameshort	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
String	TokenNameIdentifier	 String
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
String	TokenNameIdentifier	 String
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a node handle, return its DOM-style namespace URI * (As defined in Namespaces, this is the declared URI which this node's * prefix -- or default in lieu thereof -- was mapped to.) * * <p>%REVIEW% Null or ""? -sb</p> * * @param nodeHandle the id of the node. * @return String URI value of this node's namespace, or null if no * namespace was resolved. */	TokenNameCOMMENT_JAVADOC	 Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.) * <p>%REVIEW% Null or ""? -sb</p> * @param nodeHandle the id of the node. @return String URI value of this node's namespace, or null if no namespace was resolved. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
JJK_NEWCODE	TokenNameIdentifier	 JJK  NEWCODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
makeNodeIdentity	TokenNameIdentifier	 make Node Identity
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
==	TokenNameEQUAL_EQUAL	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
)	TokenNameRPAREN	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
nsuri	TokenNameIdentifier	 nsuri
;	TokenNameSEMICOLON	
short	TokenNameshort	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NAMESPACE_NODE	TokenNameIdentifier	 NAMESPACE  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// assume not null. 	TokenNameCOMMENT_LINE	assume not null. 
nsuri	TokenNameIdentifier	 nsuri
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// %TBD% Handle DOM1? 	TokenNameCOMMENT_LINE	%TBD% Handle DOM1? 
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
nsuri	TokenNameIdentifier	 nsuri
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
nsuri	TokenNameIdentifier	 nsuri
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Utility function: Given a DOM Text node, determine whether it is * logically followed by another Text or CDATASection node. This may * involve traversing into Entity References. * * %REVIEW% DOM Level 3 is expected to add functionality which may * allow us to retire this. */	TokenNameCOMMENT_JAVADOC	 Utility function: Given a DOM Text node, determine whether it is logically followed by another Text or CDATASection node. This may involve traversing into Entity References. * %REVIEW% DOM Level 3 is expected to add functionality which may allow us to retire this. 
private	TokenNameprivate	
Node	TokenNameIdentifier	 Node
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Walk out of any EntityReferenceNodes that ended with text 	TokenNameCOMMENT_LINE	Walk out of any EntityReferenceNodes that ended with text 
for	TokenNamefor	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
==	TokenNameEQUAL_EQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
==	TokenNameEQUAL_EQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Walk into any EntityReferenceNodes that start with text 	TokenNameCOMMENT_LINE	Walk into any EntityReferenceNodes that start with text 
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
hasChildNodes	TokenNameIdentifier	 has Child Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Found a logical next sibling. Is it text? 	TokenNameCOMMENT_LINE	Found a logical next sibling. Is it text? 
int	TokenNameint	
ntype	TokenNameIdentifier	 ntype
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
!=	TokenNameNOT_EQUAL	
ntype	TokenNameIdentifier	 ntype
&&	TokenNameAND_AND	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
!=	TokenNameNOT_EQUAL	
ntype	TokenNameIdentifier	 ntype
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a node handle, return its node value. This is mostly * as defined by the DOM, but may ignore some conveniences. * <p> * * @param nodeHandle The node id. * @return String Value of this node, or null if not * meaningful for this node type. */	TokenNameCOMMENT_JAVADOC	 Given a node handle, return its node value. This is mostly as defined by the DOM, but may ignore some conveniences. <p> * @param nodeHandle The node id. @return String Value of this node, or null if not meaningful for this node type. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The _type(nodeHandle) call was taking the lion's share of our 	TokenNameCOMMENT_LINE	The _type(nodeHandle) call was taking the lion's share of our 
// time, and was wrong anyway since it wasn't coverting handle to 	TokenNameCOMMENT_LINE	time, and was wrong anyway since it wasn't coverting handle to 
// identity. Inlined it. 	TokenNameCOMMENT_LINE	identity. Inlined it. 
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
_exptype	TokenNameIdentifier	 exptype
(	TokenNameLPAREN	
makeNodeIdentity	TokenNameIdentifier	 make Node Identity
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
?	TokenNameQUESTION	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
:	TokenNameCOLON	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
!=	TokenNameNOT_EQUAL	
type	TokenNameIdentifier	 type
&&	TokenNameAND_AND	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
!=	TokenNameNOT_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
return	TokenNamereturn	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If this is a DTM text node, it may be made of multiple DOM text 	TokenNameCOMMENT_LINE	If this is a DTM text node, it may be made of multiple DOM text 
// nodes -- including navigating into Entity References. DOM2DTM 	TokenNameCOMMENT_LINE	nodes -- including navigating into Entity References. DOM2DTM 
// records the first node in the sequence and requires that we 	TokenNameCOMMENT_LINE	records the first node in the sequence and requires that we 
// pick up the others when we retrieve the DTM node's value. 	TokenNameCOMMENT_LINE	pick up the others when we retrieve the DTM node's value. 
// 	TokenNameCOMMENT_LINE	 
// %REVIEW% DOM Level 3 is expected to add a "whole text" 	TokenNameCOMMENT_LINE	%REVIEW% DOM Level 3 is expected to add a "whole text" 
// retrieval method which performs this function for us. 	TokenNameCOMMENT_LINE	retrieval method which performs this function for us. 
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A document type declaration information item has the following properties: * * 1. [system identifier] The system identifier of the external subset, if * it exists. Otherwise this property has no value. * * @return the system identifier String object, or null if there is none. */	TokenNameCOMMENT_JAVADOC	 A document type declaration information item has the following properties: * 1. [system identifier] The system identifier of the external subset, if it exists. Otherwise this property has no value. * @return the system identifier String object, or null if there is none. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentTypeDeclarationSystemIdentifier	TokenNameIdentifier	 get Document Type Declaration System Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
)	TokenNameRPAREN	
m_root	TokenNameIdentifier	 m root
;	TokenNameSEMICOLON	
else	TokenNameelse	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentType	TokenNameIdentifier	 Document Type
dtd	TokenNameIdentifier	 dtd
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getDoctype	TokenNameIdentifier	 get Doctype
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
dtd	TokenNameIdentifier	 dtd
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the public identifier of the external subset, * normalized as described in 4.2.2 External Entities [XML]. If there is * no external subset or if it has no public identifier, this property * has no value. * * @return the public identifier String object, or null if there is none. */	TokenNameCOMMENT_JAVADOC	 Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]. If there is no external subset or if it has no public identifier, this property has no value. * @return the public identifier String object, or null if there is none. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentTypeDeclarationPublicIdentifier	TokenNameIdentifier	 get Document Type Declaration Public Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
)	TokenNameRPAREN	
m_root	TokenNameIdentifier	 m root
;	TokenNameSEMICOLON	
else	TokenNameelse	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentType	TokenNameIdentifier	 Document Type
dtd	TokenNameIdentifier	 dtd
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getDoctype	TokenNameIdentifier	 get Doctype
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
dtd	TokenNameIdentifier	 dtd
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the <code>Element</code> whose <code>ID</code> is given by * <code>elementId</code>. If no such element exists, returns * <code>DTM.NULL</code>. Behavior is not defined if more than one element * has this <code>ID</code>. Attributes (including those * with the name "ID") are not of type ID unless so defined by DTD/Schema * information available to the DTM implementation. * Implementations that do not know whether attributes are of type ID or * not are expected to return <code>DTM.NULL</code>. * * <p>%REVIEW% Presumably IDs are still scoped to a single document, * and this operation searches only within a single document, right? * Wouldn't want collisions between DTMs in the same process.</p> * * @param elementId The unique <code>id</code> value for an element. * @return The handle of the matching element. */	TokenNameCOMMENT_JAVADOC	 Returns the <code>Element</code> whose <code>ID</code> is given by <code>elementId</code>. If no such element exists, returns <code>DTM.NULL</code>. Behavior is not defined if more than one element has this <code>ID</code>. Attributes (including those with the name "ID") are not of type ID unless so defined by DTD/Schema information available to the DTM implementation. Implementations that do not know whether attributes are of type ID or not are expected to return <code>DTM.NULL</code>. * <p>%REVIEW% Presumably IDs are still scoped to a single document, and this operation searches only within a single document, right? Wouldn't want collisions between DTMs in the same process.</p> * @param elementId The unique <code>id</code> value for an element. @return The handle of the matching element. 
public	TokenNamepublic	
int	TokenNameint	
getElementById	TokenNameIdentifier	 get Element By Id
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementId	TokenNameIdentifier	 element Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
)	TokenNameRPAREN	
m_root	TokenNameIdentifier	 m root
:	TokenNameCOLON	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
elem	TokenNameIdentifier	 elem
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getElementById	TokenNameIdentifier	 get Element By Id
(	TokenNameLPAREN	
elementId	TokenNameIdentifier	 element Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
elemHandle	TokenNameIdentifier	 elem Handle
=	TokenNameEQUAL	
getHandleFromNode	TokenNameIdentifier	 get Handle From Node
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
elemHandle	TokenNameIdentifier	 elem Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
m_nodes	TokenNameIdentifier	 m nodes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
=	TokenNameEQUAL	
getNextNodeIdentity	TokenNameIdentifier	 get Next Node Identity
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
identity	TokenNameIdentifier	 identity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
==	TokenNameEQUAL_EQUAL	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elemHandle	TokenNameIdentifier	 elem Handle
=	TokenNameEQUAL	
getHandleFromNode	TokenNameIdentifier	 get Handle From Node
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
elemHandle	TokenNameIdentifier	 elem Handle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The getUnparsedEntityURI function returns the URI of the unparsed * entity with the specified name in the same document as the context * node (see [3.3 Unparsed Entities]). It returns the empty string if * there is no such entity. * <p> * XML processors may choose to use the System Identifier (if one * is provided) to resolve the entity, rather than the URI in the * Public Identifier. The details are dependent on the processor, and * we would have to support some form of plug-in resolver to handle * this properly. Currently, we simply return the System Identifier if * present, and hope that it a usable URI or that our caller can * map it to one. * TODO: Resolve Public Identifiers... or consider changing function name. * <p> * If we find a relative URI * reference, XML expects it to be resolved in terms of the base URI * of the document. The DOM doesn't do that for us, and it isn't * entirely clear whether that should be done here; currently that's * pushed up to a higher level of our application. (Note that DOM Level * 1 didn't store the document's base URI.) * TODO: Consider resolving Relative URIs. * <p> * (The DOM's statement that "An XML processor may choose to * completely expand entities before the structure model is passed * to the DOM" refers only to parsed entities, not unparsed, and hence * doesn't affect this function.) * * @param name A string containing the Entity Name of the unparsed * entity. * * @return String containing the URI of the Unparsed Entity, or an * empty string if no such entity exists. */	TokenNameCOMMENT_JAVADOC	 The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]). It returns the empty string if there is no such entity. <p> XML processors may choose to use the System Identifier (if one is provided) to resolve the entity, rather than the URI in the Public Identifier. The details are dependent on the processor, and we would have to support some form of plug-in resolver to handle this properly. Currently, we simply return the System Identifier if present, and hope that it a usable URI or that our caller can map it to one. TODO: Resolve Public Identifiers... or consider changing function name. <p> If we find a relative URI reference, XML expects it to be resolved in terms of the base URI of the document. The DOM doesn't do that for us, and it isn't entirely clear whether that should be done here; currently that's pushed up to a higher level of our application. (Note that DOM Level 1 didn't store the document's base URI.) TODO: Consider resolving Relative URIs. <p> (The DOM's statement that "An XML processor may choose to completely expand entities before the structure model is passed to the DOM" refers only to parsed entities, not unparsed, and hence doesn't affect this function.) * @param name A string containing the Entity Name of the unparsed entity. * @return String containing the URI of the Unparsed Entity, or an empty string if no such entity exists. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getUnparsedEntityURI	TokenNameIdentifier	 get Unparsed Entity URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
)	TokenNameRPAREN	
m_root	TokenNameIdentifier	 m root
:	TokenNameCOLON	
m_root	TokenNameIdentifier	 m root
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentType	TokenNameIdentifier	 Document Type
doctype	TokenNameIdentifier	 doctype
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getDoctype	TokenNameIdentifier	 get Doctype
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doctype	TokenNameIdentifier	 doctype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
entities	TokenNameIdentifier	 entities
=	TokenNameEQUAL	
doctype	TokenNameIdentifier	 doctype
.	TokenNameDOT	
getEntities	TokenNameIdentifier	 get Entities
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
entities	TokenNameIdentifier	 entities
)	TokenNameRPAREN	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
Entity	TokenNameIdentifier	 Entity
entity	TokenNameIdentifier	 entity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Entity	TokenNameIdentifier	 Entity
)	TokenNameRPAREN	
entities	TokenNameIdentifier	 entities
.	TokenNameDOT	
getNamedItem	TokenNameIdentifier	 get Named Item
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
entity	TokenNameIdentifier	 entity
)	TokenNameRPAREN	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
notationName	TokenNameIdentifier	 notation Name
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getNotationName	TokenNameIdentifier	 get Notation Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
notationName	TokenNameIdentifier	 notation Name
)	TokenNameRPAREN	
// then it's unparsed 	TokenNameCOMMENT_LINE	then it's unparsed 
{	TokenNameLBRACE	
// The draft says: "The XSLT processor may use the public 	TokenNameCOMMENT_LINE	The draft says: "The XSLT processor may use the public 
// identifier to generate a URI for the entity instead of the URI 	TokenNameCOMMENT_LINE	identifier to generate a URI for the entity instead of the URI 
// specified in the system identifier. If the XSLT processor does 	TokenNameCOMMENT_LINE	specified in the system identifier. If the XSLT processor does 
// not use the public identifier to generate the URI, it must use 	TokenNameCOMMENT_LINE	not use the public identifier to generate the URI, it must use 
// the system identifier; if the system identifier is a relative 	TokenNameCOMMENT_LINE	the system identifier; if the system identifier is a relative 
// URI, it must be resolved into an absolute URI using the URI of 	TokenNameCOMMENT_LINE	URI, it must be resolved into an absolute URI using the URI of 
// the resource containing the entity declaration as the base 	TokenNameCOMMENT_LINE	the resource containing the entity declaration as the base 
// URI [RFC2396]." 	TokenNameCOMMENT_LINE	URI [RFC2396]." 
// So I'm falling a bit short here. 	TokenNameCOMMENT_LINE	So I'm falling a bit short here. 
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
url	TokenNameIdentifier	 url
)	TokenNameRPAREN	
{	TokenNameLBRACE	
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This should be resolved to an absolute URL, but that's hard 	TokenNameCOMMENT_LINE	This should be resolved to an absolute URL, but that's hard 
// to do from here. 	TokenNameCOMMENT_LINE	to do from here. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * 5. [specified] A flag indicating whether this attribute was actually * specified in the start-tag of its element, or was defaulted from the * DTD. * * @param attributeHandle the attribute handle * @return <code>true</code> if the attribute was specified; * <code>false</code> if it was defaulted. */	TokenNameCOMMENT_JAVADOC	 5. [specified] A flag indicating whether this attribute was actually specified in the start-tag of its element, or was defaulted from the DTD. * @param attributeHandle the attribute handle @return <code>true</code> if the attribute was specified; <code>false</code> if it was defaulted. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isAttributeSpecified	TokenNameIdentifier	 is Attribute Specified
(	TokenNameLPAREN	
int	TokenNameint	
attributeHandle	TokenNameIdentifier	 attribute Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
attributeHandle	TokenNameIdentifier	 attribute Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Attr	TokenNameIdentifier	 Attr
attr	TokenNameIdentifier	 attr
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Attr	TokenNameIdentifier	 Attr
)	TokenNameRPAREN	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
attributeHandle	TokenNameIdentifier	 attribute Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getSpecified	TokenNameIdentifier	 get Specified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Bind an IncrementalSAXSource to this DTM. NOT RELEVANT for DOM2DTM, since * we're wrapped around an existing DOM. * * @param source The IncrementalSAXSource that we want to recieve events from * on demand. */	TokenNameCOMMENT_JAVADOC	 Bind an IncrementalSAXSource to this DTM. NOT RELEVANT for DOM2DTM, since we're wrapped around an existing DOM. * @param source The IncrementalSAXSource that we want to recieve events from on demand. 
public	TokenNamepublic	
void	TokenNamevoid	
setIncrementalSAXSource	TokenNameIdentifier	 set Incremental SAX Source
(	TokenNameLPAREN	
IncrementalSAXSource	TokenNameIdentifier	 Incremental SAX Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** getContentHandler returns "our SAX builder" -- the thing that * someone else should send SAX events to in order to extend this * DTM model. * * @return null if this model doesn't respond to SAX events, * "this" if the DTM object has a built-in SAX ContentHandler, * the IncrmentalSAXSource if we're bound to one and should receive * the SAX stream via it for incremental build purposes... * */	TokenNameCOMMENT_JAVADOC	 getContentHandler returns "our SAX builder" -- the thing that someone else should send SAX events to in order to extend this DTM model. * @return null if this model doesn't respond to SAX events, "this" if the DTM object has a built-in SAX ContentHandler, the IncrmentalSAXSource if we're bound to one and should receive the SAX stream via it for incremental build purposes... 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
getContentHandler	TokenNameIdentifier	 get Content Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return this DTM's lexical handler. * * %REVIEW% Should this return null if constrution already done/begun? * * @return null if this model doesn't respond to lexical SAX events, * "this" if the DTM object has a built-in SAX ContentHandler, * the IncrementalSAXSource if we're bound to one and should receive * the SAX stream via it for incremental build purposes... */	TokenNameCOMMENT_JAVADOC	 Return this DTM's lexical handler. * %REVIEW% Should this return null if constrution already done/begun? * @return null if this model doesn't respond to lexical SAX events, "this" if the DTM object has a built-in SAX ContentHandler, the IncrementalSAXSource if we're bound to one and should receive the SAX stream via it for incremental build purposes... 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
LexicalHandler	TokenNameIdentifier	 Lexical Handler
getLexicalHandler	TokenNameIdentifier	 get Lexical Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return this DTM's EntityResolver. * * @return null if this model doesn't respond to SAX entity ref events. */	TokenNameCOMMENT_JAVADOC	 Return this DTM's EntityResolver. * @return null if this model doesn't respond to SAX entity ref events. 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
EntityResolver	TokenNameIdentifier	 Entity Resolver
getEntityResolver	TokenNameIdentifier	 get Entity Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return this DTM's DTDHandler. * * @return null if this model doesn't respond to SAX dtd events. */	TokenNameCOMMENT_JAVADOC	 Return this DTM's DTDHandler. * @return null if this model doesn't respond to SAX dtd events. 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
DTDHandler	TokenNameIdentifier	 DTD Handler
getDTDHandler	TokenNameIdentifier	 get DTD Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return this DTM's ErrorHandler. * * @return null if this model doesn't respond to SAX error events. */	TokenNameCOMMENT_JAVADOC	 Return this DTM's ErrorHandler. * @return null if this model doesn't respond to SAX error events. 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ErrorHandler	TokenNameIdentifier	 Error Handler
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return this DTM's DeclHandler. * * @return null if this model doesn't respond to SAX Decl events. */	TokenNameCOMMENT_JAVADOC	 Return this DTM's DeclHandler. * @return null if this model doesn't respond to SAX Decl events. 
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
DeclHandler	TokenNameIdentifier	 Decl Handler
getDeclHandler	TokenNameIdentifier	 get Decl Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** @return true iff we're building this model incrementally (eg * we're partnered with a IncrementalSAXSource) and thus require that the * transformation and the parse run simultaneously. Guidance to the * DTMManager. * */	TokenNameCOMMENT_JAVADOC	 @return true iff we're building this model incrementally (eg we're partnered with a IncrementalSAXSource) and thus require that the transformation and the parse run simultaneously. Guidance to the DTMManager. 
public	TokenNamepublic	
boolean	TokenNameboolean	
needsTwoThreads	TokenNameIdentifier	 needs Two Threads
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ========== Direct SAX Dispatch, for optimization purposes ======== 	TokenNameCOMMENT_LINE	========== Direct SAX Dispatch, for optimization purposes ======== 
/** * Returns whether the specified <var>ch</var> conforms to the XML 1.0 definition * of whitespace. Refer to <A href="http://www.w3.org/TR/1998/REC-xml-19980210#NT-S"> * the definition of <CODE>S</CODE></A> for details. * @param ch Character to check as XML whitespace. * @return =true if <var>ch</var> is XML whitespace; otherwise =false. */	TokenNameCOMMENT_JAVADOC	 Returns whether the specified <var>ch</var> conforms to the XML 1.0 definition of whitespace. Refer to <A href="http://www.w3.org/TR/1998/REC-xml-19980210#NT-S"> the definition of <CODE>S</CODE></A> for details. @param ch Character to check as XML whitespace. @return =true if <var>ch</var> is XML whitespace; otherwise =false. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLCharacterRecognizer	TokenNameIdentifier	 XML Character Recognizer
.	TokenNameDOT	
isWhiteSpace	TokenNameIdentifier	 is White Space
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Take the easy way out for now. 	TokenNameCOMMENT_LINE	Take the easy way out for now. 
}	TokenNameRBRACE	
/** * Directly call the * characters method on the passed ContentHandler for the * string-value of the given node (see http://www.w3.org/TR/xpath#data-model * for the definition of a node's string-value). Multiple calls to the * ContentHandler's characters methods may well occur for a single call to * this method. * * @param nodeHandle The node ID. * @param ch A non-null reference to a ContentHandler. * * @throws org.xml.sax.SAXException */	TokenNameCOMMENT_JAVADOC	 Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value). Multiple calls to the ContentHandler's characters methods may well occur for a single call to this method. * @param nodeHandle The node ID. @param ch A non-null reference to a ContentHandler. * @throws org.xml.sax.SAXException 
public	TokenNamepublic	
void	TokenNamevoid	
dispatchCharactersEvents	TokenNameIdentifier	 dispatch Characters Events
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
boolean	TokenNameboolean	
normalize	TokenNameIdentifier	 normalize
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
normalize	TokenNameIdentifier	 normalize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLString	TokenNameIdentifier	 XML String
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
getStringValue	TokenNameIdentifier	 get String Value
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
fixWhiteSpace	TokenNameIdentifier	 fix White Space
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
dispatchCharactersEvents	TokenNameIdentifier	 dispatch Characters Events
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchNodeData	TokenNameIdentifier	 dispatch Node Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Text coalition -- a DTM text node may represent multiple 	TokenNameCOMMENT_LINE	Text coalition -- a DTM text node may represent multiple 
// DOM nodes. 	TokenNameCOMMENT_LINE	DOM nodes. 
if	TokenNameif	
(	TokenNameLPAREN	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
||	TokenNameOR_OR	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
==	TokenNameEQUAL_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
logicalNextDOMTextNode	TokenNameIdentifier	 logical Next DOM Text Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchNodeData	TokenNameIdentifier	 dispatch Node Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Retrieve the text content of a DOM subtree, appending it into a * user-supplied FastStringBuffer object. Note that attributes are * not considered part of the content of an element. * <p> * There are open questions regarding whitespace stripping. * Currently we make no special effort in that regard, since the standard * DOM doesn't yet provide DTD-based information to distinguish * whitespace-in-element-context from genuine #PCDATA. Note that we * should probably also consider xml:space if/when we address this. * DOM Level 3 may solve the problem for us. * <p> * %REVIEW% Note that as a DOM-level operation, it can be argued that this * routine _shouldn't_ perform any processing beyond what the DOM already * does, and that whitespace stripping and so on belong at the DTM level. * If you want a stripped DOM view, wrap DTM2DOM around DOM2DTM. * * @param node Node whose subtree is to be walked, gathering the * contents of all Text or CDATASection nodes. */	TokenNameCOMMENT_JAVADOC	 Retrieve the text content of a DOM subtree, appending it into a user-supplied FastStringBuffer object. Note that attributes are not considered part of the content of an element. <p> There are open questions regarding whitespace stripping. Currently we make no special effort in that regard, since the standard DOM doesn't yet provide DTD-based information to distinguish whitespace-in-element-context from genuine #PCDATA. Note that we should probably also consider xml:space if/when we address this. DOM Level 3 may solve the problem for us. <p> %REVIEW% Note that as a DOM-level operation, it can be argued that this routine _shouldn't_ perform any processing beyond what the DOM already does, and that whitespace stripping and so on belong at the DTM level. If you want a stripped DOM view, wrap DTM2DOM around DOM2DTM. * @param node Node whose subtree is to be walked, gathering the contents of all Text or CDATASection nodes. 
protected	TokenNameprotected	
static	TokenNamestatic	
void	TokenNamevoid	
dispatchNodeData	TokenNameIdentifier	 dispatch Node Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_FRAGMENT_NODE	TokenNameIdentifier	 DOCUMENT  FRAGMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchNodeData	TokenNameIdentifier	 dispatch Node Data
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
// %REVIEW% 	TokenNameCOMMENT_LINE	%REVIEW% 
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
COMMENT_NODE	TokenNameIdentifier	 COMMENT  NODE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// NOTE: Because this operation works in the DOM space, it does _not_ attempt 	TokenNameCOMMENT_LINE	NOTE: Because this operation works in the DOM space, it does _not_ attempt 
// to perform Text Coalition. That should only be done in DTM space. 	TokenNameCOMMENT_LINE	to perform Text Coalition. That should only be done in DTM space. 
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
instanceof	TokenNameinstanceof	
CharacterNodeHandler	TokenNameIdentifier	 Character Node Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CharacterNodeHandler	TokenNameIdentifier	 Character Node Handler
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
toCharArray	TokenNameIdentifier	 to Char Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// /* case Node.PROCESSING_INSTRUCTION_NODE : 	TokenNameCOMMENT_LINE	/* case Node.PROCESSING_INSTRUCTION_NODE : 
// // warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 	TokenNameCOMMENT_LINE	// warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 
// break; */ 	TokenNameCOMMENT_LINE	break; */ 
default	TokenNamedefault	
:	TokenNameCOLON	
// ignore 	TokenNameCOMMENT_LINE	ignore 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
TreeWalker	TokenNameIdentifier	 Tree Walker
m_walker	TokenNameIdentifier	 m walker
=	TokenNameEQUAL	
new	TokenNamenew	
TreeWalker	TokenNameIdentifier	 Tree Walker
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Directly create SAX parser events from a subtree. * * @param nodeHandle The node ID. * @param ch A non-null reference to a ContentHandler. * * @throws org.xml.sax.SAXException */	TokenNameCOMMENT_JAVADOC	 Directly create SAX parser events from a subtree. * @param nodeHandle The node ID. @param ch A non-null reference to a ContentHandler. * @throws org.xml.sax.SAXException 
public	TokenNamepublic	
void	TokenNamevoid	
dispatchToEvents	TokenNameIdentifier	 dispatch To Events
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
TreeWalker	TokenNameIdentifier	 Tree Walker
treeWalker	TokenNameIdentifier	 tree Walker
=	TokenNameEQUAL	
m_walker	TokenNameIdentifier	 m walker
;	TokenNameSEMICOLON	
ContentHandler	TokenNameIdentifier	 Content Handler
prevCH	TokenNameIdentifier	 prev CH
=	TokenNameEQUAL	
treeWalker	TokenNameIdentifier	 tree Walker
.	TokenNameDOT	
getContentHandler	TokenNameIdentifier	 get Content Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
prevCH	TokenNameIdentifier	 prev CH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
treeWalker	TokenNameIdentifier	 tree Walker
=	TokenNameEQUAL	
new	TokenNamenew	
TreeWalker	TokenNameIdentifier	 Tree Walker
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
treeWalker	TokenNameIdentifier	 tree Walker
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
treeWalker	TokenNameIdentifier	 tree Walker
.	TokenNameDOT	
traverseFragment	TokenNameIdentifier	 traverse Fragment
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
treeWalker	TokenNameIdentifier	 tree Walker
.	TokenNameDOT	
setContentHandler	TokenNameIdentifier	 set Content Handler
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
interface	TokenNameinterface	
CharacterNodeHandler	TokenNameIdentifier	 Character Node Handler
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For the moment all the run time properties are ignored by this * class. * * @param property a <code>String</code> value * @param value an <code>Object</code> value */	TokenNameCOMMENT_JAVADOC	 For the moment all the run time properties are ignored by this class. * @param property a <code>String</code> value @param value an <code>Object</code> value 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
property	TokenNameIdentifier	 property
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * No source information is available for DOM2DTM, so return * <code>null</code> here. * * @param node an <code>int</code> value * @return null */	TokenNameCOMMENT_JAVADOC	 No source information is available for DOM2DTM, so return <code>null</code> here. * @param node an <code>int</code> value @return null 
public	TokenNamepublic	
SourceLocator	TokenNameIdentifier	 Source Locator
getSourceLocatorFor	TokenNameIdentifier	 get Source Locator For
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
