package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReadWriteLock	TokenNameIdentifier	 Read Write Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
logging	TokenNameIdentifier	 logging
.	TokenNameDOT	
Level	TokenNameIdentifier	 Level
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
logging	TokenNameIdentifier	 logging
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
CategoryPath	TokenNameIdentifier	 Category Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
InconsistentTaxonomyException	TokenNameIdentifier	 Inconsistent Taxonomy Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
TermDocs	TokenNameIdentifier	 Term Docs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
collections	TokenNameIdentifier	 collections
.	TokenNameDOT	
LRUHashMap	TokenNameIdentifier	 LRU Hash Map
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/** * A {@link TaxonomyReader} which retrieves stored taxonomy information from a * {@link Directory}. * <P> * Reading from the on-disk index on every method call is too slow, so this * implementation employs caching: Some methods cache recent requests and their * results, while other methods prefetch all the data into memory and then * provide answers directly from in-memory tables. See the documentation of * individual methods for comments on their performance. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 A {@link TaxonomyReader} which retrieves stored taxonomy information from a {@link Directory}. <P> Reading from the on-disk index on every method call is too slow, so this implementation employs caching: Some methods cache recent requests and their results, while other methods prefetch all the data into memory and then provide answers directly from in-memory tables. See the documentation of individual methods for comments on their performance. * @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
implements	TokenNameimplements	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
Logger	TokenNameIdentifier	 Logger
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IndexReader	TokenNameIdentifier	 Index Reader
indexReader	TokenNameIdentifier	 index Reader
;	TokenNameSEMICOLON	
// The following lock is used to allow multiple threads to read from the 	TokenNameCOMMENT_LINE	The following lock is used to allow multiple threads to read from the 
// index concurrently, while having them block during the very short 	TokenNameCOMMENT_LINE	index concurrently, while having them block during the very short 
// critical moment of refresh() (see comments below). Note, however, that 	TokenNameCOMMENT_LINE	critical moment of refresh() (see comments below). Note, however, that 
// we only read from the index when we don't have the entry in our cache, 	TokenNameCOMMENT_LINE	we only read from the index when we don't have the entry in our cache, 
// and the caches are locked separately. 	TokenNameCOMMENT_LINE	and the caches are locked separately. 
private	TokenNameprivate	
ReadWriteLock	TokenNameIdentifier	 Read Write Lock
indexReaderLock	TokenNameIdentifier	 index Reader Lock
=	TokenNameEQUAL	
new	TokenNamenew	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The following are the limited-size LRU caches used to cache the latest 	TokenNameCOMMENT_LINE	The following are the limited-size LRU caches used to cache the latest 
// results from getOrdinal() and getLabel(). 	TokenNameCOMMENT_LINE	results from getOrdinal() and getLabel(). 
// Because LRUHashMap is not thread-safe, we need to synchronize on this 	TokenNameCOMMENT_LINE	Because LRUHashMap is not thread-safe, we need to synchronize on this 
// object when using it. Unfortunately, this is not optimal under heavy 	TokenNameCOMMENT_LINE	object when using it. Unfortunately, this is not optimal under heavy 
// contention because it means that while one thread is using the cache 	TokenNameCOMMENT_LINE	contention because it means that while one thread is using the cache 
// (reading or modifying) others are blocked from using it - or even 	TokenNameCOMMENT_LINE	(reading or modifying) others are blocked from using it - or even 
// starting to do benign things like calculating the hash function. A more 	TokenNameCOMMENT_LINE	starting to do benign things like calculating the hash function. A more 
// efficient approach would be to use a non-locking (as much as possible) 	TokenNameCOMMENT_LINE	efficient approach would be to use a non-locking (as much as possible) 
// concurrent solution, along the lines of java.util.concurrent.ConcurrentHashMap 	TokenNameCOMMENT_LINE	concurrent solution, along the lines of java.util.concurrent.ConcurrentHashMap 
// but with LRU semantics. 	TokenNameCOMMENT_LINE	but with LRU semantics. 
// However, even in the current sub-optimal implementation we do not make 	TokenNameCOMMENT_LINE	However, even in the current sub-optimal implementation we do not make 
// the mistake of locking out readers while waiting for disk in a cache 	TokenNameCOMMENT_LINE	the mistake of locking out readers while waiting for disk in a cache 
// miss - below, we do not hold cache lock while reading missing data from 	TokenNameCOMMENT_LINE	miss - below, we do not hold cache lock while reading missing data from 
// disk. 	TokenNameCOMMENT_LINE	disk. 
private	TokenNameprivate	
final	TokenNamefinal	
LRUHashMap	TokenNameIdentifier	 LRU Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
ordinalCache	TokenNameIdentifier	 ordinal Cache
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
LRUHashMap	TokenNameIdentifier	 LRU Hash Map
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
categoryCache	TokenNameIdentifier	 category Cache
;	TokenNameSEMICOLON	
// getParent() needs to be extremely efficient, to the point that we need 	TokenNameCOMMENT_LINE	getParent() needs to be extremely efficient, to the point that we need 
// to fetch all the data in advance into memory, and answer these calls 	TokenNameCOMMENT_LINE	to fetch all the data in advance into memory, and answer these calls 
// from memory. Currently we use a large integer array, which is 	TokenNameCOMMENT_LINE	from memory. Currently we use a large integer array, which is 
// initialized when the taxonomy is opened, and potentially enlarged 	TokenNameCOMMENT_LINE	initialized when the taxonomy is opened, and potentially enlarged 
// when it is refresh()ed. 	TokenNameCOMMENT_LINE	when it is refresh()ed. 
// These arrays are not syncrhonized. Rather, the reference to the array 	TokenNameCOMMENT_LINE	These arrays are not syncrhonized. Rather, the reference to the array 
// is volatile, and the only writing operation (refreshPrefetchArrays) 	TokenNameCOMMENT_LINE	is volatile, and the only writing operation (refreshPrefetchArrays) 
// simply creates a new array and replaces the reference. The volatility 	TokenNameCOMMENT_LINE	simply creates a new array and replaces the reference. The volatility 
// of the reference ensures the correct atomic replacement and its 	TokenNameCOMMENT_LINE	of the reference ensures the correct atomic replacement and its 
// visibility properties (the content of the array is visible when the 	TokenNameCOMMENT_LINE	visibility properties (the content of the array is visible when the 
// new reference is visible). 	TokenNameCOMMENT_LINE	new reference is visible). 
private	TokenNameprivate	
ParentArray	TokenNameIdentifier	 Parent Array
parentArray	TokenNameIdentifier	 parent Array
;	TokenNameSEMICOLON	
private	TokenNameprivate	
char	TokenNamechar	
delimiter	TokenNameIdentifier	 delimiter
=	TokenNameEQUAL	
Consts	TokenNameIdentifier	 Consts
.	TokenNameDOT	
DEFAULT_DELIMITER	TokenNameIdentifier	 DEFAULT  DELIMITER
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
boolean	TokenNameboolean	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// set refCount to 1 at start 	TokenNameCOMMENT_LINE	set refCount to 1 at start 
private	TokenNameprivate	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
refCount	TokenNameIdentifier	 ref Count
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Open for reading a taxonomy stored in a given {@link Directory}. * @param directory * The {@link Directory} in which to the taxonomy lives. Note that * the taxonomy is read directly to that directory (not from a * subdirectory of it). * @throws CorruptIndexException if the Taxonomy is corrupted. * @throws IOException if another error occurred. */	TokenNameCOMMENT_JAVADOC	 Open for reading a taxonomy stored in a given {@link Directory}. @param directory The {@link Directory} in which to the taxonomy lives. Note that the taxonomy is read directly to that directory (not from a subdirectory of it). @throws CorruptIndexException if the Taxonomy is corrupted. @throws IOException if another error occurred. 
public	TokenNamepublic	
DirectoryTaxonomyReader	TokenNameIdentifier	 Directory Taxonomy Reader
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
indexReader	TokenNameIdentifier	 index Reader
=	TokenNameEQUAL	
openIndexReader	TokenNameIdentifier	 open Index Reader
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// These are the default cache sizes; they can be configured after 	TokenNameCOMMENT_LINE	These are the default cache sizes; they can be configured after 
// construction with the cache's setMaxSize() method 	TokenNameCOMMENT_LINE	construction with the cache's setMaxSize() method 
ordinalCache	TokenNameIdentifier	 ordinal Cache
=	TokenNameEQUAL	
new	TokenNamenew	
LRUHashMap	TokenNameIdentifier	 LRU Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
4000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
categoryCache	TokenNameIdentifier	 category Cache
=	TokenNameEQUAL	
new	TokenNamenew	
LRUHashMap	TokenNameIdentifier	 LRU Hash Map
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
4000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO (Facet): consider lazily create parent array when asked, not in the constructor 	TokenNameCOMMENT_LINE	TODO (Facet): consider lazily create parent array when asked, not in the constructor 
parentArray	TokenNameIdentifier	 parent Array
=	TokenNameEQUAL	
new	TokenNamenew	
ParentArray	TokenNameIdentifier	 Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parentArray	TokenNameIdentifier	 parent Array
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
indexReader	TokenNameIdentifier	 index Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
IndexReader	TokenNameIdentifier	 Index Reader
openIndexReader	TokenNameIdentifier	 open Index Reader
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @throws AlreadyClosedException if this IndexReader is closed */	TokenNameCOMMENT_JAVADOC	 @throws AlreadyClosedException if this IndexReader is closed 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getRefCount	TokenNameIdentifier	 get Ref Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
(	TokenNameLPAREN	
"this TaxonomyReader is closed"	TokenNameStringLiteral	this TaxonomyReader is closed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * setCacheSize controls the maximum allowed size of each of the caches * used by {@link #getPath(int)} and {@link #getOrdinal(CategoryPath)}. * <P> * Currently, if the given size is smaller than the current size of * a cache, it will not shrink, and rather we be limited to its current * size. * @param size the new maximum cache size, in number of entries. */	TokenNameCOMMENT_JAVADOC	 setCacheSize controls the maximum allowed size of each of the caches used by {@link #getPath(int)} and {@link #getOrdinal(CategoryPath)}. <P> Currently, if the given size is smaller than the current size of a cache, it will not shrink, and rather we be limited to its current size. @param size the new maximum cache size, in number of entries. 
public	TokenNamepublic	
void	TokenNamevoid	
setCacheSize	TokenNameIdentifier	 set Cache Size
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
categoryCache	TokenNameIdentifier	 category Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
categoryCache	TokenNameIdentifier	 category Cache
.	TokenNameDOT	
setMaxSize	TokenNameIdentifier	 set Max Size
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
ordinalCache	TokenNameIdentifier	 ordinal Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ordinalCache	TokenNameIdentifier	 ordinal Cache
.	TokenNameDOT	
setMaxSize	TokenNameIdentifier	 set Max Size
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * setDelimiter changes the character that the taxonomy uses in its * internal storage as a delimiter between category components. Do not * use this method unless you really know what you are doing. * <P> * If you do use this method, make sure you call it before any other * methods that actually queries the taxonomy. Moreover, make sure you * always pass the same delimiter for all LuceneTaxonomyWriter and * LuceneTaxonomyReader objects you create. */	TokenNameCOMMENT_JAVADOC	 setDelimiter changes the character that the taxonomy uses in its internal storage as a delimiter between category components. Do not use this method unless you really know what you are doing. <P> If you do use this method, make sure you call it before any other methods that actually queries the taxonomy. Moreover, make sure you always pass the same delimiter for all LuceneTaxonomyWriter and LuceneTaxonomyReader objects you create. 
public	TokenNamepublic	
void	TokenNamevoid	
setDelimiter	TokenNameIdentifier	 set Delimiter
(	TokenNameLPAREN	
char	TokenNamechar	
delimiter	TokenNameIdentifier	 delimiter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
delimiter	TokenNameIdentifier	 delimiter
=	TokenNameEQUAL	
delimiter	TokenNameIdentifier	 delimiter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
CategoryPath	TokenNameIdentifier	 Category Path
categoryPath	TokenNameIdentifier	 category Path
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
categoryPath	TokenNameIdentifier	 category Path
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ROOT_ORDINAL	TokenNameIdentifier	 ROOT  ORDINAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
categoryPath	TokenNameIdentifier	 category Path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
delimiter	TokenNameIdentifier	 delimiter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// First try to find the answer in the LRU cache: 	TokenNameCOMMENT_LINE	First try to find the answer in the LRU cache: 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
ordinalCache	TokenNameIdentifier	 ordinal Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
ordinalCache	TokenNameIdentifier	 ordinal Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If we're still here, we have a cache miss. We need to fetch the 	TokenNameCOMMENT_LINE	If we're still here, we have a cache miss. We need to fetch the 
// value from disk, and then also put it in the cache: 	TokenNameCOMMENT_LINE	value from disk, and then also put it in the cache: 
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TermDocs	TokenNameIdentifier	 Term Docs
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
termDocs	TokenNameIdentifier	 term Docs
(	TokenNameLPAREN	
Consts	TokenNameIdentifier	 Consts
.	TokenNameDOT	
FULL_TERM	TokenNameIdentifier	 FULL  TERM
.	TokenNameDOT	
createTerm	TokenNameIdentifier	 create Term
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Put the new value in the cache. Note that it is possible that while 	TokenNameCOMMENT_LINE	Put the new value in the cache. Note that it is possible that while 
// we were doing the above fetching (without the cache locked), some 	TokenNameCOMMENT_LINE	we were doing the above fetching (without the cache locked), some 
// other thread already added the same category to the cache. We do 	TokenNameCOMMENT_LINE	other thread already added the same category to the cache. We do 
// not care about this possibilty, as LRUCache replaces previous values 	TokenNameCOMMENT_LINE	not care about this possibilty, as LRUCache replaces previous values 
// of the same keys (it doesn't store duplicates). 	TokenNameCOMMENT_LINE	of the same keys (it doesn't store duplicates). 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
ordinalCache	TokenNameIdentifier	 ordinal Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// GB: new Integer(int); creates a new object each and every time. 	TokenNameCOMMENT_LINE	GB: new Integer(int); creates a new object each and every time. 
// Integer.valueOf(int) might not (See JavaDoc). 	TokenNameCOMMENT_LINE	Integer.valueOf(int) might not (See JavaDoc). 
ordinalCache	TokenNameIdentifier	 ordinal Cache
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
ret	TokenNameIdentifier	 ret
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
CategoryPath	TokenNameIdentifier	 Category Path
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO (Facet): Currently, the LRU cache we use (categoryCache) holds 	TokenNameCOMMENT_LINE	TODO (Facet): Currently, the LRU cache we use (categoryCache) holds 
// strings with delimiters, not CategoryPath objects, so even if 	TokenNameCOMMENT_LINE	strings with delimiters, not CategoryPath objects, so even if 
// we have a cache hit, we need to process the string and build a new 	TokenNameCOMMENT_LINE	we have a cache hit, we need to process the string and build a new 
// CategoryPath object every time. What is preventing us from putting 	TokenNameCOMMENT_LINE	CategoryPath object every time. What is preventing us from putting 
// the actual CategoryPath object in the cache is the fact that these 	TokenNameCOMMENT_LINE	the actual CategoryPath object in the cache is the fact that these 
// objects are mutable. So we should create an immutable (read-only) 	TokenNameCOMMENT_LINE	objects are mutable. So we should create an immutable (read-only) 
// interface that CategoryPath implements, and this method should 	TokenNameCOMMENT_LINE	interface that CategoryPath implements, and this method should 
// return this interface, not the writable CategoryPath. 	TokenNameCOMMENT_LINE	return this interface, not the writable CategoryPath. 
String	TokenNameIdentifier	 String
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
getLabel	TokenNameIdentifier	 get Label
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
CategoryPath	TokenNameIdentifier	 Category Path
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
delimiter	TokenNameIdentifier	 delimiter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
CategoryPath	TokenNameIdentifier	 Category Path
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
label	TokenNameIdentifier	 label
=	TokenNameEQUAL	
getLabel	TokenNameIdentifier	 get Label
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
delimiter	TokenNameIdentifier	 delimiter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getLabel	TokenNameIdentifier	 get Label
(	TokenNameLPAREN	
int	TokenNameint	
catID	TokenNameIdentifier	 cat ID
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// First try to find the answer in the LRU cache. It is very 	TokenNameCOMMENT_LINE	First try to find the answer in the LRU cache. It is very 
// unfortunate that we need to allocate an Integer object here - 	TokenNameCOMMENT_LINE	unfortunate that we need to allocate an Integer object here - 
// it would have been better if we used a hash table specifically 	TokenNameCOMMENT_LINE	it would have been better if we used a hash table specifically 
// designed for int keys... 	TokenNameCOMMENT_LINE	designed for int keys... 
// GB: new Integer(int); creates a new object each and every time. 	TokenNameCOMMENT_LINE	GB: new Integer(int); creates a new object each and every time. 
// Integer.valueOf(int) might not (See JavaDoc). 	TokenNameCOMMENT_LINE	Integer.valueOf(int) might not (See JavaDoc). 
Integer	TokenNameIdentifier	 Integer
catIDInteger	TokenNameIdentifier	 cat ID Integer
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
catID	TokenNameIdentifier	 cat ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
categoryCache	TokenNameIdentifier	 category Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
categoryCache	TokenNameIdentifier	 category Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
catIDInteger	TokenNameIdentifier	 cat ID Integer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If we're still here, we have a cache miss. We need to fetch the 	TokenNameCOMMENT_LINE	If we're still here, we have a cache miss. We need to fetch the 
// value from disk, and then also put it in the cache: 	TokenNameCOMMENT_LINE	value from disk, and then also put it in the cache: 
String	TokenNameIdentifier	 String
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The taxonomy API dictates that if we get an invalid category 	TokenNameCOMMENT_LINE	The taxonomy API dictates that if we get an invalid category 
// ID, we should return null, If we don't check this here, we 	TokenNameCOMMENT_LINE	ID, we should return null, If we don't check this here, we 
// can some sort of an exception from the document() call below. 	TokenNameCOMMENT_LINE	can some sort of an exception from the document() call below. 
// NOTE: Currently, we *do not* cache this return value; There 	TokenNameCOMMENT_LINE	NOTE: Currently, we *do not* cache this return value; There 
// isn't much point to do so, because checking the validity of 	TokenNameCOMMENT_LINE	isn't much point to do so, because checking the validity of 
// the docid doesn't require disk access - just comparing with 	TokenNameCOMMENT_LINE	the docid doesn't require disk access - just comparing with 
// the number indexReader.maxDoc(). 	TokenNameCOMMENT_LINE	the number indexReader.maxDoc(). 
if	TokenNameif	
(	TokenNameLPAREN	
catID	TokenNameIdentifier	 cat ID
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
catID	TokenNameIdentifier	 cat ID
>=	TokenNameGREATER_EQUAL	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
document	TokenNameIdentifier	 document
(	TokenNameLPAREN	
catID	TokenNameIdentifier	 cat ID
,	TokenNameCOMMA	
Consts	TokenNameIdentifier	 Consts
.	TokenNameDOT	
fullPathSelector	TokenNameIdentifier	 full Path Selector
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Consts	TokenNameIdentifier	 Consts
.	TokenNameDOT	
FULL	TokenNameIdentifier	 FULL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Put the new value in the cache. Note that it is possible that while 	TokenNameCOMMENT_LINE	Put the new value in the cache. Note that it is possible that while 
// we were doing the above fetching (without the cache locked), some 	TokenNameCOMMENT_LINE	we were doing the above fetching (without the cache locked), some 
// other thread already added the same category to the cache. We do 	TokenNameCOMMENT_LINE	other thread already added the same category to the cache. We do 
// not care about this possibility, as LRUCache replaces previous 	TokenNameCOMMENT_LINE	not care about this possibility, as LRUCache replaces previous 
// values of the same keys (it doesn't store duplicates). 	TokenNameCOMMENT_LINE	values of the same keys (it doesn't store duplicates). 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
categoryCache	TokenNameIdentifier	 category Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
categoryCache	TokenNameIdentifier	 category Cache
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
catIDInteger	TokenNameIdentifier	 cat ID Integer
,	TokenNameCOMMA	
ret	TokenNameIdentifier	 ret
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Note how we don't need to hold the read lock to do the following, 	TokenNameCOMMENT_LINE	Note how we don't need to hold the read lock to do the following, 
// because the array reference is volatile, ensuring the correct 	TokenNameCOMMENT_LINE	because the array reference is volatile, ensuring the correct 
// visibility and ordering: if we get the new reference, the new 	TokenNameCOMMENT_LINE	visibility and ordering: if we get the new reference, the new 
// data is also visible to this thread. 	TokenNameCOMMENT_LINE	data is also visible to this thread. 
return	TokenNamereturn	
getParentArray	TokenNameIdentifier	 get Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
ordinal	TokenNameIdentifier	 ordinal
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * getParentArray() returns an int array of size getSize() listing the * ordinal of the parent category of each category in the taxonomy. * <P> * The caller can hold on to the array it got indefinitely - it is * guaranteed that no-one else will modify it. The other side of the * same coin is that the caller must treat the array it got as read-only * and <B>not modify it</B>, because other callers might have gotten the * same array too, and getParent() calls are also answered from the * same array. * <P> * The getParentArray() call is extremely efficient, merely returning * a reference to an array that already exists. For a caller that plans * to call getParent() for many categories, using getParentArray() and * the array it returns is a somewhat faster approach because it avoids * the overhead of method calls and volatile dereferencing. * <P> * If you use getParentArray() instead of getParent(), remember that * the array you got is (naturally) not modified after a refresh(), * so you should always call getParentArray() again after a refresh(). */	TokenNameCOMMENT_JAVADOC	 getParentArray() returns an int array of size getSize() listing the ordinal of the parent category of each category in the taxonomy. <P> The caller can hold on to the array it got indefinitely - it is guaranteed that no-one else will modify it. The other side of the same coin is that the caller must treat the array it got as read-only and <B>not modify it</B>, because other callers might have gotten the same array too, and getParent() calls are also answered from the same array. <P> The getParentArray() call is extremely efficient, merely returning a reference to an array that already exists. For a caller that plans to call getParent() for many categories, using getParentArray() and the array it returns is a somewhat faster approach because it avoids the overhead of method calls and volatile dereferencing. <P> If you use getParentArray() instead of getParent(), remember that the array you got is (naturally) not modified after a refresh(), so you should always call getParentArray() again after a refresh(). 
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getParentArray	TokenNameIdentifier	 get Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Note how we don't need to hold the read lock to do the following, 	TokenNameCOMMENT_LINE	Note how we don't need to hold the read lock to do the following, 
// because the array reference is volatile, ensuring the correct 	TokenNameCOMMENT_LINE	because the array reference is volatile, ensuring the correct 
// visibility and ordering: if we get the new reference, the new 	TokenNameCOMMENT_LINE	visibility and ordering: if we get the new reference, the new 
// data is also visible to this thread. 	TokenNameCOMMENT_LINE	data is also visible to this thread. 
return	TokenNamereturn	
parentArray	TokenNameIdentifier	 parent Array
.	TokenNameDOT	
getArray	TokenNameIdentifier	 get Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Note that refresh() is synchronized (it is the only synchronized 	TokenNameCOMMENT_LINE	Note that refresh() is synchronized (it is the only synchronized 
// method in this class) to ensure that it never gets called concurrently 	TokenNameCOMMENT_LINE	method in this class) to ensure that it never gets called concurrently 
// with itself. 	TokenNameCOMMENT_LINE	with itself. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
InconsistentTaxonomyException	TokenNameIdentifier	 Inconsistent Taxonomy Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * Since refresh() can be a lengthy operation, it is very important that we * avoid locking out all readers for its duration. This is why we don't hold * the indexReaderLock write lock for the entire duration of this method. In * fact, it is enough to hold it only during a single assignment! Other * comments in this method will explain this. */	TokenNameCOMMENT_BLOCK	 Since refresh() can be a lengthy operation, it is very important that we avoid locking out all readers for its duration. This is why we don't hold the indexReaderLock write lock for the entire duration of this method. In fact, it is enough to hold it only during a single assignment! Other comments in this method will explain this. 
// note that the lengthy operation indexReader.reopen() does not 	TokenNameCOMMENT_LINE	note that the lengthy operation indexReader.reopen() does not 
// modify the reader, so we can do it without holding a lock. We can 	TokenNameCOMMENT_LINE	modify the reader, so we can do it without holding a lock. We can 
// safely read indexReader without holding the write lock, because 	TokenNameCOMMENT_LINE	safely read indexReader without holding the write lock, because 
// no other thread can be writing at this time (this method is the 	TokenNameCOMMENT_LINE	no other thread can be writing at this time (this method is the 
// only possible writer, and it is "synchronized" to avoid this case). 	TokenNameCOMMENT_LINE	only possible writer, and it is "synchronized" to avoid this case). 
IndexReader	TokenNameIdentifier	 Index Reader
r2	TokenNameIdentifier	 r2
=	TokenNameEQUAL	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
openIfChanged	TokenNameIdentifier	 open If Changed
(	TokenNameLPAREN	
indexReader	TokenNameIdentifier	 index Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r2	TokenNameIdentifier	 r2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// no changes, nothing to do 	TokenNameCOMMENT_LINE	no changes, nothing to do 
}	TokenNameRBRACE	
// validate that a refresh is valid at this point, i.e. that the taxonomy 	TokenNameCOMMENT_LINE	validate that a refresh is valid at this point, i.e. that the taxonomy 
// was not recreated since this reader was last opened or refresshed. 	TokenNameCOMMENT_LINE	was not recreated since this reader was last opened or refresshed. 
String	TokenNameIdentifier	 String
t1	TokenNameIdentifier	 t1
=	TokenNameEQUAL	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
getIndexCommit	TokenNameIdentifier	 get Index Commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
.	TokenNameDOT	
INDEX_CREATE_TIME	TokenNameIdentifier	 INDEX  CREATE  TIME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
t2	TokenNameIdentifier	 t2
=	TokenNameEQUAL	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
getIndexCommit	TokenNameIdentifier	 get Index Commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
DirectoryTaxonomyWriter	TokenNameIdentifier	 Directory Taxonomy Writer
.	TokenNameDOT	
INDEX_CREATE_TIME	TokenNameIdentifier	 INDEX  CREATE  TIME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t1	TokenNameIdentifier	 t1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t2	TokenNameIdentifier	 t2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
InconsistentTaxonomyException	TokenNameIdentifier	 Inconsistent Taxonomy Exception
(	TokenNameLPAREN	
"Taxonomy was recreated at: "	TokenNameStringLiteral	Taxonomy was recreated at: 
+	TokenNamePLUS	
t2	TokenNameIdentifier	 t2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
t1	TokenNameIdentifier	 t1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
t2	TokenNameIdentifier	 t2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r2	TokenNameIdentifier	 r2
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
InconsistentTaxonomyException	TokenNameIdentifier	 Inconsistent Taxonomy Exception
(	TokenNameLPAREN	
"Taxonomy was recreated at: "	TokenNameStringLiteral	Taxonomy was recreated at: 
+	TokenNamePLUS	
t2	TokenNameIdentifier	 t2
+	TokenNamePLUS	
" != "	TokenNameStringLiteral	 != 
+	TokenNamePLUS	
t1	TokenNameIdentifier	 t1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
oldreader	TokenNameIdentifier	 oldreader
=	TokenNameEQUAL	
indexReader	TokenNameIdentifier	 index Reader
;	TokenNameSEMICOLON	
// we can close the old searcher, but need to synchronize this 	TokenNameCOMMENT_LINE	we can close the old searcher, but need to synchronize this 
// so that we don't close it in the middle that another routine 	TokenNameCOMMENT_LINE	so that we don't close it in the middle that another routine 
// is reading from it. 	TokenNameCOMMENT_LINE	is reading from it. 
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexReader	TokenNameIdentifier	 index Reader
=	TokenNameEQUAL	
r2	TokenNameIdentifier	 r2
;	TokenNameSEMICOLON	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We can close the old reader, but need to be certain that we 	TokenNameCOMMENT_LINE	We can close the old reader, but need to be certain that we 
// don't close it while another method is reading from it. 	TokenNameCOMMENT_LINE	don't close it while another method is reading from it. 
// Luckily, we can be certain of that even without putting the 	TokenNameCOMMENT_LINE	Luckily, we can be certain of that even without putting the 
// oldreader.close() in the locked section. The reason is that 	TokenNameCOMMENT_LINE	oldreader.close() in the locked section. The reason is that 
// after lock() succeeded above, we know that all existing readers 	TokenNameCOMMENT_LINE	after lock() succeeded above, we know that all existing readers 
// had finished (this is what a read-write lock ensures). New 	TokenNameCOMMENT_LINE	had finished (this is what a read-write lock ensures). New 
// readers, starting after the unlock() we just did, already got 	TokenNameCOMMENT_LINE	readers, starting after the unlock() we just did, already got 
// the new indexReader we set above. So nobody can be possibly 	TokenNameCOMMENT_LINE	the new indexReader we set above. So nobody can be possibly 
// using the old indexReader, and we can close it: 	TokenNameCOMMENT_LINE	using the old indexReader, and we can close it: 
oldreader	TokenNameIdentifier	 oldreader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We prefetch some of the arrays to make requests much faster. 	TokenNameCOMMENT_LINE	We prefetch some of the arrays to make requests much faster. 
// Let's refresh these prefetched arrays; This refresh is much 	TokenNameCOMMENT_LINE	Let's refresh these prefetched arrays; This refresh is much 
// is made more efficient by assuming that it is enough to read 	TokenNameCOMMENT_LINE	is made more efficient by assuming that it is enough to read 
// the values for new categories (old categories could not have been 	TokenNameCOMMENT_LINE	the values for new categories (old categories could not have been 
// changed or deleted) 	TokenNameCOMMENT_LINE	changed or deleted) 
// Note that this this done without the write lock being held, 	TokenNameCOMMENT_LINE	Note that this this done without the write lock being held, 
// which means that it is possible that during a refresh(), a 	TokenNameCOMMENT_LINE	which means that it is possible that during a refresh(), a 
// reader will have some methods (like getOrdinal and getCategory) 	TokenNameCOMMENT_LINE	reader will have some methods (like getOrdinal and getCategory) 
// return fresh information, while getParent() 	TokenNameCOMMENT_LINE	return fresh information, while getParent() 
// (only to be prefetched now) still return older information. 	TokenNameCOMMENT_LINE	(only to be prefetched now) still return older information. 
// We consider this to be acceptable. The important thing, 	TokenNameCOMMENT_LINE	We consider this to be acceptable. The important thing, 
// however, is that refreshPrefetchArrays() itself writes to 	TokenNameCOMMENT_LINE	however, is that refreshPrefetchArrays() itself writes to 
// the arrays in a correct manner (see discussion there) 	TokenNameCOMMENT_LINE	the arrays in a correct manner (see discussion there) 
parentArray	TokenNameIdentifier	 parent Array
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
indexReader	TokenNameIdentifier	 index Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Remove any INVALID_ORDINAL values from the ordinal cache, 	TokenNameCOMMENT_LINE	Remove any INVALID_ORDINAL values from the ordinal cache, 
// because it is possible those are now answered by the new data! 	TokenNameCOMMENT_LINE	because it is possible those are now answered by the new data! 
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ordinalCache	TokenNameIdentifier	 ordinal Cache
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
decRef	TokenNameIdentifier	 dec Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Do the actual closing, free up resources */	TokenNameCOMMENT_JAVADOC	 Do the actual closing, free up resources 
private	TokenNameprivate	
void	TokenNamevoid	
doClose	TokenNameIdentifier	 do Close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
parentArray	TokenNameIdentifier	 parent Array
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
childrenArrays	TokenNameIdentifier	 children Arrays
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
categoryCache	TokenNameIdentifier	 category Cache
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ordinalCache	TokenNameIdentifier	 ordinal Cache
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
numDocs	TokenNameIdentifier	 num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
indexReaderLock	TokenNameIdentifier	 index Reader Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getCommitUserData	TokenNameIdentifier	 get Commit User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
getIndexCommit	TokenNameIdentifier	 get Index Commit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
childrenArrays	TokenNameIdentifier	 children Arrays
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
childrenArraysRebuild	TokenNameIdentifier	 children Arrays Rebuild
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check if the taxonomy grew since we built the array, and if it 	TokenNameCOMMENT_LINE	Check if the taxonomy grew since we built the array, and if it 
// did, create new (and larger) arrays and fill them as required. 	TokenNameCOMMENT_LINE	did, create new (and larger) arrays and fill them as required. 
// We do all this under a lock, two prevent to concurrent calls to 	TokenNameCOMMENT_LINE	We do all this under a lock, two prevent to concurrent calls to 
// needlessly do the same array building at the same time. 	TokenNameCOMMENT_LINE	needlessly do the same array building at the same time. 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
childrenArraysRebuild	TokenNameIdentifier	 children Arrays Rebuild
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childrenArrays	TokenNameIdentifier	 children Arrays
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
childrenArrays	TokenNameIdentifier	 children Arrays
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the taxonomy hasn't grown, we can return the existing object 	TokenNameCOMMENT_LINE	If the taxonomy hasn't grown, we can return the existing object 
// immediately 	TokenNameCOMMENT_LINE	immediately 
if	TokenNameif	
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
==	TokenNameEQUAL_EQUAL	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
childrenArrays	TokenNameIdentifier	 children Arrays
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Otherwise, build new arrays for a new ChildrenArray object. 	TokenNameCOMMENT_LINE	Otherwise, build new arrays for a new ChildrenArray object. 
// These arrays start with an enlarged copy of the previous arrays, 	TokenNameCOMMENT_LINE	These arrays start with an enlarged copy of the previous arrays, 
// and then are modified to take into account the new categories: 	TokenNameCOMMENT_LINE	and then are modified to take into account the new categories: 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
num	TokenNameIdentifier	 num
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newOlderSiblingArray	TokenNameIdentifier	 new Older Sibling Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
num	TokenNameIdentifier	 num
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// In Java 6, we could just do Arrays.copyOf()... 	TokenNameCOMMENT_LINE	In Java 6, we could just do Arrays.copyOf()... 
if	TokenNameif	
(	TokenNameLPAREN	
childrenArrays	TokenNameIdentifier	 children Arrays
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
childrenArrays	TokenNameIdentifier	 children Arrays
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
childrenArrays	TokenNameIdentifier	 children Arrays
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
childrenArrays	TokenNameIdentifier	 children Arrays
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newOlderSiblingArray	TokenNameIdentifier	 new Older Sibling Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
childrenArrays	TokenNameIdentifier	 children Arrays
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
parents	TokenNameIdentifier	 parents
=	TokenNameEQUAL	
getParentArray	TokenNameIdentifier	 get Parent Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// In the loop below we can ignore the root category (0) because 	TokenNameCOMMENT_LINE	In the loop below we can ignore the root category (0) because 
// it has no parent 	TokenNameCOMMENT_LINE	it has no parent 
if	TokenNameif	
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
newOlderSiblingArray	TokenNameIdentifier	 new Older Sibling Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
num	TokenNameIdentifier	 num
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Note that parents[i] is always < i, so the right-hand-side of 	TokenNameCOMMENT_LINE	Note that parents[i] is always < i, so the right-hand-side of 
// the following line is already set when we get here. 	TokenNameCOMMENT_LINE	the following line is already set when we get here. 
newOlderSiblingArray	TokenNameIdentifier	 new Older Sibling Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
[	TokenNameLBRACKET	
parents	TokenNameIdentifier	 parents
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
[	TokenNameLBRACKET	
parents	TokenNameIdentifier	 parents
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Finally switch to the new arrays 	TokenNameCOMMENT_LINE	Finally switch to the new arrays 
childrenArrays	TokenNameIdentifier	 children Arrays
=	TokenNameEQUAL	
new	TokenNamenew	
ChildrenArraysImpl	TokenNameIdentifier	 Children Arrays Impl
(	TokenNameLPAREN	
newYoungestChildArray	TokenNameIdentifier	 new Youngest Child Array
,	TokenNameCOMMA	
newOlderSiblingArray	TokenNameIdentifier	 new Older Sibling Array
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
childrenArrays	TokenNameIdentifier	 children Arrays
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
int	TokenNameint	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
upperl	TokenNameIdentifier	 upperl
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
indexReader	TokenNameIdentifier	 index Reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
upperl	TokenNameIdentifier	 upperl
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
CategoryPath	TokenNameIdentifier	 Category Path
category	TokenNameIdentifier	 category
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
category	TokenNameIdentifier	 category
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
": NULL!! "	TokenNameStringLiteral	: NULL!! 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
category	TokenNameIdentifier	 category
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
": EMPTY STRING!! "	TokenNameStringLiteral	: EMPTY STRING!! 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
category	TokenNameIdentifier	 category
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isLoggable	TokenNameIdentifier	 is Loggable
(	TokenNameLPAREN	
Level	TokenNameIdentifier	 Level
.	TokenNameDOT	
FINEST	TokenNameIdentifier	 FINEST
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
Level	TokenNameIdentifier	 Level
.	TokenNameDOT	
FINEST	TokenNameIdentifier	 FINEST
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
ChildrenArraysImpl	TokenNameIdentifier	 Children Arrays Impl
implements	TokenNameimplements	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
{	TokenNameLBRACE	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
,	TokenNameCOMMA	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ChildrenArraysImpl	TokenNameIdentifier	 Children Arrays Impl
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
=	TokenNameEQUAL	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
=	TokenNameEQUAL	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
olderSiblingArray	TokenNameIdentifier	 older Sibling Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
youngestChildArray	TokenNameIdentifier	 youngest Child Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Expert: This method is only for expert use. * Note also that any call to refresh() will invalidate the returned reader, * so the caller needs to take care of appropriate locking. * * @return lucene indexReader */	TokenNameCOMMENT_JAVADOC	 Expert: This method is only for expert use. Note also that any call to refresh() will invalidate the returned reader, so the caller needs to take care of appropriate locking. * @return lucene indexReader 
IndexReader	TokenNameIdentifier	 Index Reader
getInternalIndexReader	TokenNameIdentifier	 get Internal Index Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
indexReader	TokenNameIdentifier	 index Reader
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Expert: decreases the refCount of this TaxonomyReader instance. If the * refCount drops to 0, then this reader is closed. */	TokenNameCOMMENT_JAVADOC	 Expert: decreases the refCount of this TaxonomyReader instance. If the refCount drops to 0, then this reader is closed. 
public	TokenNamepublic	
void	TokenNamevoid	
decRef	TokenNameIdentifier	 dec Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
refCount	TokenNameIdentifier	 ref Count
.	TokenNameDOT	
decrementAndGet	TokenNameIdentifier	 decrement And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
doClose	TokenNameIdentifier	 do Close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Put reference back on failure 	TokenNameCOMMENT_LINE	Put reference back on failure 
refCount	TokenNameIdentifier	 ref Count
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"too many decRef calls: refCount is "	TokenNameStringLiteral	too many decRef calls: refCount is 
+	TokenNamePLUS	
rc	TokenNameIdentifier	 rc
+	TokenNamePLUS	
" after decrement"	TokenNameStringLiteral	 after decrement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Expert: returns the current refCount for this taxonomy reader */	TokenNameCOMMENT_JAVADOC	 Expert: returns the current refCount for this taxonomy reader 
public	TokenNamepublic	
int	TokenNameint	
getRefCount	TokenNameIdentifier	 get Ref Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
refCount	TokenNameIdentifier	 ref Count
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Expert: increments the refCount of this TaxonomyReader instance. * RefCounts are used to determine when a taxonomy reader can be closed * safely, i.e. as soon as there are no more references. * Be sure to always call a corresponding decRef(), in a finally clause; * otherwise the reader may never be closed. */	TokenNameCOMMENT_JAVADOC	 Expert: increments the refCount of this TaxonomyReader instance. RefCounts are used to determine when a taxonomy reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef(), in a finally clause; otherwise the reader may never be closed. 
public	TokenNamepublic	
void	TokenNamevoid	
incRef	TokenNameIdentifier	 inc Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureOpen	TokenNameIdentifier	 ensure Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
refCount	TokenNameIdentifier	 ref Count
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
