/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
math	TokenNameIdentifier	 math
.	TokenNameDOT	
BigInteger	TokenNameIdentifier	 Big Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
AbstractList	TokenNameIdentifier	 Abstract List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
DatatypeException	TokenNameIdentifier	 Datatype Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidationContext	TokenNameIdentifier	 Validation Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSFacets	TokenNameIdentifier	 XS Facets
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
regex	TokenNameIdentifier	 regex
.	TokenNameDOT	
RegularExpression	TokenNameIdentifier	 Regular Expression
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ObjectListImpl	TokenNameIdentifier	 Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ShortListImpl	TokenNameIdentifier	 Short List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringListImpl	TokenNameIdentifier	 String List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
NamespaceContext	TokenNameIdentifier	 Namespace Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
ShortList	TokenNameIdentifier	 Short List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
StringList	TokenNameIdentifier	 String List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAnnotation	TokenNameIdentifier	 XS Annotation
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSFacet	TokenNameIdentifier	 XS Facet
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSMultiValueFacet	TokenNameIdentifier	 XS Multi Value Facet
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObject	TokenNameIdentifier	 XS Object
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
datatypes	TokenNameIdentifier	 datatypes
.	TokenNameDOT	
ObjectList	TokenNameIdentifier	 Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
TypeInfo	TokenNameIdentifier	 Type Info
;	TokenNameSEMICOLON	
/** * @xerces.internal * * @author Sandy Gao, IBM * @author Neeraj Bajaj, Sun Microsystems, inc. * * @version $Id: XSSimpleTypeDecl.java 1026362 2010-10-22 15:15:18Z sandygao $ */	TokenNameCOMMENT_JAVADOC	 @xerces.internal * @author Sandy Gao, IBM @author Neeraj Bajaj, Sun Microsystems, inc. * @version $Id: XSSimpleTypeDecl.java 1026362 2010-10-22 15:15:18Z sandygao $ 
public	TokenNamepublic	
class	TokenNameclass	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
implements	TokenNameimplements	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
,	TokenNameCOMMA	
TypeInfo	TokenNameIdentifier	 Type Info
{	TokenNameLBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_STRING	TokenNameIdentifier	 DV  STRING
=	TokenNameEQUAL	
PRIMITIVE_STRING	TokenNameIdentifier	 PRIMITIVE  STRING
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_BOOLEAN	TokenNameIdentifier	 DV  BOOLEAN
=	TokenNameEQUAL	
PRIMITIVE_BOOLEAN	TokenNameIdentifier	 PRIMITIVE  BOOLEAN
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DECIMAL	TokenNameIdentifier	 DV  DECIMAL
=	TokenNameEQUAL	
PRIMITIVE_DECIMAL	TokenNameIdentifier	 PRIMITIVE  DECIMAL
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_FLOAT	TokenNameIdentifier	 DV  FLOAT
=	TokenNameEQUAL	
PRIMITIVE_FLOAT	TokenNameIdentifier	 PRIMITIVE  FLOAT
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DOUBLE	TokenNameIdentifier	 DV  DOUBLE
=	TokenNameEQUAL	
PRIMITIVE_DOUBLE	TokenNameIdentifier	 PRIMITIVE  DOUBLE
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DURATION	TokenNameIdentifier	 DV  DURATION
=	TokenNameEQUAL	
PRIMITIVE_DURATION	TokenNameIdentifier	 PRIMITIVE  DURATION
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DATETIME	TokenNameIdentifier	 DV  DATETIME
=	TokenNameEQUAL	
PRIMITIVE_DATETIME	TokenNameIdentifier	 PRIMITIVE  DATETIME
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_TIME	TokenNameIdentifier	 DV  TIME
=	TokenNameEQUAL	
PRIMITIVE_TIME	TokenNameIdentifier	 PRIMITIVE  TIME
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DATE	TokenNameIdentifier	 DV  DATE
=	TokenNameEQUAL	
PRIMITIVE_DATE	TokenNameIdentifier	 PRIMITIVE  DATE
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_GYEARMONTH	TokenNameIdentifier	 DV  GYEARMONTH
=	TokenNameEQUAL	
PRIMITIVE_GYEARMONTH	TokenNameIdentifier	 PRIMITIVE  GYEARMONTH
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_GYEAR	TokenNameIdentifier	 DV  GYEAR
=	TokenNameEQUAL	
PRIMITIVE_GYEAR	TokenNameIdentifier	 PRIMITIVE  GYEAR
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_GMONTHDAY	TokenNameIdentifier	 DV  GMONTHDAY
=	TokenNameEQUAL	
PRIMITIVE_GMONTHDAY	TokenNameIdentifier	 PRIMITIVE  GMONTHDAY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_GDAY	TokenNameIdentifier	 DV  GDAY
=	TokenNameEQUAL	
PRIMITIVE_GDAY	TokenNameIdentifier	 PRIMITIVE  GDAY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_GMONTH	TokenNameIdentifier	 DV  GMONTH
=	TokenNameEQUAL	
PRIMITIVE_GMONTH	TokenNameIdentifier	 PRIMITIVE  GMONTH
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_HEXBINARY	TokenNameIdentifier	 DV  HEXBINARY
=	TokenNameEQUAL	
PRIMITIVE_HEXBINARY	TokenNameIdentifier	 PRIMITIVE  HEXBINARY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_BASE64BINARY	TokenNameIdentifier	 DV  BAS E64 BINARY
=	TokenNameEQUAL	
PRIMITIVE_BASE64BINARY	TokenNameIdentifier	 PRIMITIVE  BAS E64 BINARY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_ANYURI	TokenNameIdentifier	 DV  ANYURI
=	TokenNameEQUAL	
PRIMITIVE_ANYURI	TokenNameIdentifier	 PRIMITIVE  ANYURI
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_QNAME	TokenNameIdentifier	 DV  QNAME
=	TokenNameEQUAL	
PRIMITIVE_QNAME	TokenNameIdentifier	 PRIMITIVE  QNAME
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_PRECISIONDECIMAL	TokenNameIdentifier	 DV  PRECISIONDECIMAL
=	TokenNameEQUAL	
PRIMITIVE_PRECISIONDECIMAL	TokenNameIdentifier	 PRIMITIVE  PRECISIONDECIMAL
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
=	TokenNameEQUAL	
PRIMITIVE_NOTATION	TokenNameIdentifier	 PRIMITIVE  NOTATION
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_ID	TokenNameIdentifier	 DV  ID
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_IDREF	TokenNameIdentifier	 DV  IDREF
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_ENTITY	TokenNameIdentifier	 DV  ENTITY
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_LIST	TokenNameIdentifier	 DV  LIST
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_UNION	TokenNameIdentifier	 DV  UNION
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_YEARMONTHDURATION	TokenNameIdentifier	 DV  YEARMONTHDURATION
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_DAYTIMEDURATION	TokenNameIdentifier	 DV  DAYTIMEDURATION
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
=	TokenNameEQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
+	TokenNamePLUS	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
TypeValidator	TokenNameIdentifier	 Type Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gDVs	TokenNameIdentifier	 g D Vs
=	TokenNameEQUAL	
{	TokenNameLBRACE	
new	TokenNamenew	
AnySimpleDV	TokenNameIdentifier	 Any Simple DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
StringDV	TokenNameIdentifier	 String DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
BooleanDV	TokenNameIdentifier	 Boolean DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalDV	TokenNameIdentifier	 Decimal DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
FloatDV	TokenNameIdentifier	 Float DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DoubleDV	TokenNameIdentifier	 Double DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DurationDV	TokenNameIdentifier	 Duration DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DateTimeDV	TokenNameIdentifier	 Date Time DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
TimeDV	TokenNameIdentifier	 Time DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DateDV	TokenNameIdentifier	 Date DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
YearMonthDV	TokenNameIdentifier	 Year Month DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
YearDV	TokenNameIdentifier	 Year DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
MonthDayDV	TokenNameIdentifier	 Month Day DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DayDV	TokenNameIdentifier	 Day DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
MonthDV	TokenNameIdentifier	 Month DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
HexBinaryDV	TokenNameIdentifier	 Hex Binary DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
Base64BinaryDV	TokenNameIdentifier	 Base64 Binary DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
AnyURIDV	TokenNameIdentifier	 Any URIDV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
QNameDV	TokenNameIdentifier	 Q Name DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
PrecisionDecimalDV	TokenNameIdentifier	 Precision Decimal DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// XML Schema 1.1 type 	TokenNameCOMMENT_LINE	XML Schema 1.1 type 
new	TokenNamenew	
QNameDV	TokenNameIdentifier	 Q Name DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// notation use the same one as qname 	TokenNameCOMMENT_LINE	notation use the same one as qname 
new	TokenNamenew	
IDDV	TokenNameIdentifier	 IDDV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IDREFDV	TokenNameIdentifier	 IDREFDV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
EntityDV	TokenNameIdentifier	 Entity DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
IntegerDV	TokenNameIdentifier	 Integer DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
ListDV	TokenNameIdentifier	 List DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
UnionDV	TokenNameIdentifier	 Union DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
YearMonthDurationDV	TokenNameIdentifier	 Year Month Duration DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// XML Schema 1.1 type 	TokenNameCOMMENT_LINE	XML Schema 1.1 type 
new	TokenNamenew	
DayTimeDurationDV	TokenNameIdentifier	 Day Time Duration DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
// XML Schema 1.1 type 	TokenNameCOMMENT_LINE	XML Schema 1.1 type 
new	TokenNamenew	
AnyAtomicDV	TokenNameIdentifier	 Any Atomic DV
(	TokenNameLPAREN	
)	TokenNameRPAREN	
// XML Schema 1.1 type 	TokenNameCOMMENT_LINE	XML Schema 1.1 type 
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
NORMALIZE_FULL	TokenNameIdentifier	 NORMALIZE  FULL
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fDVNormalizeType	TokenNameIdentifier	 f DV Normalize Type
=	TokenNameEQUAL	
{	TokenNameLBRACE	
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
,	TokenNameCOMMA	
//AnySimpleDV(), 	TokenNameCOMMENT_LINE	AnySimpleDV(), 
NORMALIZE_FULL	TokenNameIdentifier	 NORMALIZE  FULL
,	TokenNameCOMMA	
//StringDV(), 	TokenNameCOMMENT_LINE	StringDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//BooleanDV(), 	TokenNameCOMMENT_LINE	BooleanDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DecimalDV(), 	TokenNameCOMMENT_LINE	DecimalDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//FloatDV(), 	TokenNameCOMMENT_LINE	FloatDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DoubleDV(), 	TokenNameCOMMENT_LINE	DoubleDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DurationDV(), 	TokenNameCOMMENT_LINE	DurationDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DateTimeDV(), 	TokenNameCOMMENT_LINE	DateTimeDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//TimeDV(), 	TokenNameCOMMENT_LINE	TimeDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DateDV(), 	TokenNameCOMMENT_LINE	DateDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//YearMonthDV(), 	TokenNameCOMMENT_LINE	YearMonthDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//YearDV(), 	TokenNameCOMMENT_LINE	YearDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//MonthDayDV(), 	TokenNameCOMMENT_LINE	MonthDayDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DayDV(), 	TokenNameCOMMENT_LINE	DayDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//MonthDV(), 	TokenNameCOMMENT_LINE	MonthDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//HexBinaryDV(), 	TokenNameCOMMENT_LINE	HexBinaryDV(), 
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
,	TokenNameCOMMA	
//Base64BinaryDV(), // Base64 know how to deal with spaces 	TokenNameCOMMENT_LINE	Base64BinaryDV(), // Base64 know how to deal with spaces 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//AnyURIDV(), 	TokenNameCOMMENT_LINE	AnyURIDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//QNameDV(), 	TokenNameCOMMENT_LINE	QNameDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//PrecisionDecimalDV() (Schema 1.1) 	TokenNameCOMMENT_LINE	PrecisionDecimalDV() (Schema 1.1) 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//QNameDV(), // notation 	TokenNameCOMMENT_LINE	QNameDV(), // notation 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//IDDV(), 	TokenNameCOMMENT_LINE	IDDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//IDREFDV(), 	TokenNameCOMMENT_LINE	IDREFDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//EntityDV(), 	TokenNameCOMMENT_LINE	EntityDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//IntegerDV(), 	TokenNameCOMMENT_LINE	IntegerDV(), 
NORMALIZE_FULL	TokenNameIdentifier	 NORMALIZE  FULL
,	TokenNameCOMMA	
//ListDV(), 	TokenNameCOMMENT_LINE	ListDV(), 
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
,	TokenNameCOMMA	
//UnionDV(), 	TokenNameCOMMENT_LINE	UnionDV(), 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//YearMonthDurationDV() (Schema 1.1) 	TokenNameCOMMENT_LINE	YearMonthDurationDV() (Schema 1.1) 
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
,	TokenNameCOMMA	
//DayTimeDurationDV() (Schema 1.1) 	TokenNameCOMMENT_LINE	DayTimeDurationDV() (Schema 1.1) 
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
,	TokenNameCOMMA	
//AnyAtomicDV() (Schema 1.1) 	TokenNameCOMMENT_LINE	AnyAtomicDV() (Schema 1.1) 
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier	 SPECIAL  PATTERN  NMTOKEN
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
SPECIAL_PATTERN_NAME	TokenNameIdentifier	 SPECIAL  PATTERN  NAME
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier	 SPECIAL  PATTERN  NCNAME
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
SPECIAL_PATTERN_STRING	TokenNameIdentifier	 SPECIAL  PATTERN  STRING
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"NONE"	TokenNameStringLiteral	NONE
,	TokenNameCOMMA	
"NMTOKEN"	TokenNameStringLiteral	NMTOKEN
,	TokenNameCOMMA	
"Name"	TokenNameStringLiteral	Name
,	TokenNameCOMMA	
"NCName"	TokenNameStringLiteral	NCName
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
WS_FACET_STRING	TokenNameIdentifier	 WS  FACET  STRING
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"preserve"	TokenNameStringLiteral	preserve
,	TokenNameCOMMA	
"replace"	TokenNameStringLiteral	replace
,	TokenNameCOMMA	
"collapse"	TokenNameStringLiteral	collapse
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
=	TokenNameEQUAL	
"http://www.w3.org/2001/XMLSchema"	TokenNameStringLiteral	http://www.w3.org/2001/XMLSchema
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ANY_TYPE	TokenNameIdentifier	 ANY  TYPE
=	TokenNameEQUAL	
"anyType"	TokenNameStringLiteral	anyType
;	TokenNameSEMICOLON	
// XML Schema 1.1 type constants 	TokenNameCOMMENT_LINE	XML Schema 1.1 type constants 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
YEARMONTHDURATION_DT	TokenNameIdentifier	 YEARMONTHDURATION  DT
=	TokenNameEQUAL	
46	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
DAYTIMEDURATION_DT	TokenNameIdentifier	 DAYTIMEDURATION  DT
=	TokenNameEQUAL	
47	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
PRECISIONDECIMAL_DT	TokenNameIdentifier	 PRECISIONDECIMAL  DT
=	TokenNameEQUAL	
48	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
ANYATOMICTYPE_DT	TokenNameIdentifier	 ANYATOMICTYPE  DT
=	TokenNameEQUAL	
49	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// DOM Level 3 TypeInfo Derivation Method constants 	TokenNameCOMMENT_LINE	DOM Level 3 TypeInfo Derivation Method constants 
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_ANY	TokenNameIdentifier	 DERIVATION  ANY
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
ValidationContext	TokenNameIdentifier	 Validation Context
fEmptyContext	TokenNameIdentifier	 f Empty Context
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationContext	TokenNameIdentifier	 Validation Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needExtraChecking	TokenNameIdentifier	 need Extra Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
useNamespaces	TokenNameIdentifier	 use Namespaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityDeclared	TokenNameIdentifier	 is Entity Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityUnparsed	TokenNameIdentifier	 is Entity Unparsed
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIdDeclared	TokenNameIdentifier	 is Id Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addId	TokenNameIdentifier	 add Id
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addIdRef	TokenNameIdentifier	 add Id Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSymbol	TokenNameIdentifier	 get Symbol
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
symbol	TokenNameIdentifier	 symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
symbol	TokenNameIdentifier	 symbol
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Locale	TokenNameIdentifier	 Locale
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
TypeValidator	TokenNameIdentifier	 Type Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getGDVs	TokenNameIdentifier	 get GD Vs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
TypeValidator	TokenNameIdentifier	 Type Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
gDVs	TokenNameIdentifier	 g D Vs
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
TypeValidator	TokenNameIdentifier	 Type Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fDVs	TokenNameIdentifier	 f D Vs
=	TokenNameEQUAL	
gDVs	TokenNameIdentifier	 g D Vs
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
void	TokenNamevoid	
setDVs	TokenNameIdentifier	 set D Vs
(	TokenNameLPAREN	
TypeValidator	TokenNameIdentifier	 Type Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dvs	TokenNameIdentifier	 dvs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDVs	TokenNameIdentifier	 f D Vs
=	TokenNameEQUAL	
dvs	TokenNameIdentifier	 dvs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this will be true if this is a static XSSimpleTypeDecl 	TokenNameCOMMENT_LINE	this will be true if this is a static XSSimpleTypeDecl 
// and hence must remain immutable (i.e., applyFacets 	TokenNameCOMMENT_LINE	and hence must remain immutable (i.e., applyFacets 
// may not be permitted to have any effect). 	TokenNameCOMMENT_LINE	may not be permitted to have any effect). 
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
fItemType	TokenNameIdentifier	 f Item Type
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
// The most specific built-in type kind. 	TokenNameCOMMENT_LINE	The most specific built-in type kind. 
private	TokenNameprivate	
short	TokenNameshort	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fTypeName	TokenNameIdentifier	 f Type Name
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
fBase	TokenNameIdentifier	 f Base
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//for constraining facets 	TokenNameCOMMENT_LINE	for constraining facets 
private	TokenNameprivate	
short	TokenNameshort	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
fPattern	TokenNameIdentifier	 f Pattern
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
fPatternStr	TokenNameIdentifier	 f Pattern Str
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ValidatedInfo	TokenNameIdentifier	 Validated Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fEnumeration	TokenNameIdentifier	 f Enumeration
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ShortList	TokenNameIdentifier	 Short List
fEnumerationTypeList	TokenNameIdentifier	 f Enumeration Type List
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ObjectList	TokenNameIdentifier	 Object List
fEnumerationItemTypeList	TokenNameIdentifier	 f Enumeration Item Type List
;	TokenNameSEMICOLON	
private	TokenNameprivate	
StringList	TokenNameIdentifier	 String List
fLexicalPattern	TokenNameIdentifier	 f Lexical Pattern
;	TokenNameSEMICOLON	
private	TokenNameprivate	
StringList	TokenNameIdentifier	 String List
fLexicalEnumeration	TokenNameIdentifier	 f Lexical Enumeration
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ObjectList	TokenNameIdentifier	 Object List
fActualEnumeration	TokenNameIdentifier	 f Actual Enumeration
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
;	TokenNameSEMICOLON	
// annotations for constraining facets 	TokenNameCOMMENT_LINE	annotations for constraining facets 
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
lengthAnnotation	TokenNameIdentifier	 length Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
patternAnnotations	TokenNameIdentifier	 pattern Annotations
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
;	TokenNameSEMICOLON	
// facets as objects 	TokenNameCOMMENT_LINE	facets as objects 
private	TokenNameprivate	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
fFacets	TokenNameIdentifier	 f Facets
;	TokenNameSEMICOLON	
// enumeration and pattern facets 	TokenNameCOMMENT_LINE	enumeration and pattern facets 
private	TokenNameprivate	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
fMultiValueFacets	TokenNameIdentifier	 f Multi Value Facets
;	TokenNameSEMICOLON	
// simpleType annotations 	TokenNameCOMMENT_LINE	simpleType annotations 
private	TokenNameprivate	
XSObjectList	TokenNameIdentifier	 XS Object List
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
;	TokenNameSEMICOLON	
// for fundamental facets 	TokenNameCOMMENT_LINE	for fundamental facets 
private	TokenNameprivate	
short	TokenNameshort	
fOrdered	TokenNameIdentifier	 f Ordered
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fFinite	TokenNameIdentifier	 f Finite
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fBounded	TokenNameIdentifier	 f Bounded
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fNumeric	TokenNameIdentifier	 f Numeric
;	TokenNameSEMICOLON	
// The namespace schema information item corresponding to the target namespace 	TokenNameCOMMENT_LINE	The namespace schema information item corresponding to the target namespace 
// of the simple type definition, if it is globally declared; or null otherwise. 	TokenNameCOMMENT_LINE	of the simple type definition, if it is globally declared; or null otherwise. 
private	TokenNameprivate	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// default constructor 	TokenNameCOMMENT_LINE	default constructor 
public	TokenNamepublic	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
//Create a new built-in primitive types (and id/idref/entity/integer/yearMonthDuration) 	TokenNameCOMMENT_LINE	Create a new built-in primitive types (and id/idref/entity/integer/yearMonthDuration) 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
short	TokenNameshort	
validateDV	TokenNameIdentifier	 validate DV
,	TokenNameCOMMA	
short	TokenNameshort	
ordered	TokenNameIdentifier	 ordered
,	TokenNameCOMMA	
boolean	TokenNameboolean	
bounded	TokenNameIdentifier	 bounded
,	TokenNameCOMMA	
boolean	TokenNameboolean	
finite	TokenNameIdentifier	 finite
,	TokenNameCOMMA	
boolean	TokenNameboolean	
numeric	TokenNameIdentifier	 numeric
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isImmutable	TokenNameIdentifier	 is Immutable
,	TokenNameCOMMA	
short	TokenNameshort	
builtInKind	TokenNameIdentifier	 built In Kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
isImmutable	TokenNameIdentifier	 is Immutable
;	TokenNameSEMICOLON	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
;	TokenNameSEMICOLON	
// To simplify the code for anySimpleType, we treat it as an atomic type 	TokenNameCOMMENT_LINE	To simplify the code for anySimpleType, we treat it as an atomic type 
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
validateDV	TokenNameIdentifier	 validate DV
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
validateDV	TokenNameIdentifier	 validate DV
==	TokenNameEQUAL_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
||	TokenNameOR_OR	
validateDV	TokenNameIdentifier	 validate DV
==	TokenNameEQUAL_EQUAL	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
||	TokenNameOR_OR	
validateDV	TokenNameIdentifier	 validate DV
==	TokenNameEQUAL_EQUAL	
DV_STRING	TokenNameIdentifier	 DV  STRING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
ordered	TokenNameIdentifier	 ordered
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
bounded	TokenNameIdentifier	 bounded
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
finite	TokenNameIdentifier	 finite
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
=	TokenNameEQUAL	
numeric	TokenNameIdentifier	 numeric
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Specify the build in kind for this primitive type 	TokenNameCOMMENT_LINE	Specify the build in kind for this primitive type 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
builtInKind	TokenNameIdentifier	 built In Kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//Create a new simple type for restriction for built-in types 	TokenNameCOMMENT_LINE	Create a new simple type for restriction for built-in types 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isImmutable	TokenNameIdentifier	 is Immutable
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
,	TokenNameCOMMA	
short	TokenNameshort	
builtInKind	TokenNameIdentifier	 built In Kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
isImmutable	TokenNameIdentifier	 is Immutable
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Specify the build in kind for this built-in type 	TokenNameCOMMENT_LINE	Specify the build in kind for this built-in type 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
builtInKind	TokenNameIdentifier	 built In Kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//Create a new simple type for restriction. 	TokenNameCOMMENT_LINE	Create a new simple type for restriction. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isImmutable	TokenNameIdentifier	 is Immutable
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fVariety	TokenNameIdentifier	 f Variety
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
:	TokenNameCOLON	
fItemType	TokenNameIdentifier	 f Item Type
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fItemType	TokenNameIdentifier	 f Item Type
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
:	TokenNameCOLON	
fMemberTypes	TokenNameIdentifier	 f Member Types
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// always inherit facets from the base. 	TokenNameCOMMENT_LINE	always inherit facets from the base. 
// in case a type is created, but applyFacets is not called 	TokenNameCOMMENT_LINE	in case a type is created, but applyFacets is not called 
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
;	TokenNameSEMICOLON	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
;	TokenNameSEMICOLON	
fPattern	TokenNameIdentifier	 f Pattern
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPattern	TokenNameIdentifier	 f Pattern
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternStr	TokenNameIdentifier	 f Pattern Str
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumeration	TokenNameIdentifier	 f Enumeration
;	TokenNameSEMICOLON	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
;	TokenNameSEMICOLON	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
;	TokenNameSEMICOLON	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
;	TokenNameSEMICOLON	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
;	TokenNameSEMICOLON	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
;	TokenNameSEMICOLON	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
;	TokenNameSEMICOLON	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
;	TokenNameSEMICOLON	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternType	TokenNameIdentifier	 f Pattern Type
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
;	TokenNameSEMICOLON	
// always inherit facet annotations in case applyFacets is not called. 	TokenNameCOMMENT_LINE	always inherit facet annotations in case applyFacets is not called. 
lengthAnnotation	TokenNameIdentifier	 length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
lengthAnnotation	TokenNameIdentifier	 length Annotation
;	TokenNameSEMICOLON	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
;	TokenNameSEMICOLON	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
;	TokenNameSEMICOLON	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
;	TokenNameSEMICOLON	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
;	TokenNameSEMICOLON	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
;	TokenNameSEMICOLON	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
;	TokenNameSEMICOLON	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
;	TokenNameSEMICOLON	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
;	TokenNameSEMICOLON	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
;	TokenNameSEMICOLON	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
;	TokenNameSEMICOLON	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
;	TokenNameSEMICOLON	
//we also set fundamental facets information in case applyFacets is not called. 	TokenNameCOMMENT_LINE	we also set fundamental facets information in case applyFacets is not called. 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
isImmutable	TokenNameIdentifier	 is Immutable
;	TokenNameSEMICOLON	
// Inherit from the base type 	TokenNameCOMMENT_LINE	Inherit from the base type 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//Create a new simple type for list. 	TokenNameCOMMENT_LINE	Create a new simple type for list. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
itemType	TokenNameIdentifier	 item Type
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isImmutable	TokenNameIdentifier	 is Immutable
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
;	TokenNameSEMICOLON	
fItemType	TokenNameIdentifier	 f Item Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
itemType	TokenNameIdentifier	 item Type
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
DV_LIST	TokenNameIdentifier	 DV  LIST
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
;	TokenNameSEMICOLON	
//setting fundamental facets 	TokenNameCOMMENT_LINE	setting fundamental facets 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
isImmutable	TokenNameIdentifier	 is Immutable
;	TokenNameSEMICOLON	
// Values of this type are lists 	TokenNameCOMMENT_LINE	Values of this type are lists 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//Create a new simple type for union. 	TokenNameCOMMENT_LINE	Create a new simple type for union. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
;	TokenNameSEMICOLON	
fMemberTypes	TokenNameIdentifier	 f Member Types
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
DV_UNION	TokenNameIdentifier	 DV  UNION
;	TokenNameSEMICOLON	
// even for union, we set whitespace to something 	TokenNameCOMMENT_LINE	even for union, we set whitespace to something 
// this will never be used, but we can use fFacetsDefined to check 	TokenNameCOMMENT_LINE	this will never be used, but we can use fFacetsDefined to check 
// whether applyFacets() is allwwed: it's not allowed 	TokenNameCOMMENT_LINE	whether applyFacets() is allwwed: it's not allowed 
// if fFacetsDefined != 0 	TokenNameCOMMENT_LINE	if fFacetsDefined != 0 
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
;	TokenNameSEMICOLON	
//setting fundamental facets 	TokenNameCOMMENT_LINE	setting fundamental facets 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// none of the schema-defined types are unions, so just set 	TokenNameCOMMENT_LINE	none of the schema-defined types are unions, so just set 
// fIsImmutable to false. 	TokenNameCOMMENT_LINE	fIsImmutable to false. 
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// No value can be of this type, so it's unavailable. 	TokenNameCOMMENT_LINE	No value can be of this type, so it's unavailable. 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
UNAVAILABLE_DT	TokenNameIdentifier	 UNAVAILABLE  DT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//set values for restriction. 	TokenNameCOMMENT_LINE	set values for restriction. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
setRestrictionValues	TokenNameIdentifier	 set Restriction Values
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//decline to do anything if the object is immutable. 	TokenNameCOMMENT_LINE	decline to do anything if the object is immutable. 
if	TokenNameif	
(	TokenNameLPAREN	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
fAnonymous	TokenNameIdentifier	 f Anonymous
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fVariety	TokenNameIdentifier	 f Variety
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
:	TokenNameCOLON	
fItemType	TokenNameIdentifier	 f Item Type
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fItemType	TokenNameIdentifier	 f Item Type
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
:	TokenNameCOLON	
fMemberTypes	TokenNameIdentifier	 f Member Types
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// always inherit facets from the base. 	TokenNameCOMMENT_LINE	always inherit facets from the base. 
// in case a type is created, but applyFacets is not called 	TokenNameCOMMENT_LINE	in case a type is created, but applyFacets is not called 
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
;	TokenNameSEMICOLON	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
;	TokenNameSEMICOLON	
fPattern	TokenNameIdentifier	 f Pattern
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPattern	TokenNameIdentifier	 f Pattern
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternStr	TokenNameIdentifier	 f Pattern Str
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumeration	TokenNameIdentifier	 f Enumeration
;	TokenNameSEMICOLON	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
;	TokenNameSEMICOLON	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
;	TokenNameSEMICOLON	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
;	TokenNameSEMICOLON	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
;	TokenNameSEMICOLON	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
;	TokenNameSEMICOLON	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
;	TokenNameSEMICOLON	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
;	TokenNameSEMICOLON	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternType	TokenNameIdentifier	 f Pattern Type
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
;	TokenNameSEMICOLON	
//we also set fundamental facets information in case applyFacets is not called. 	TokenNameCOMMENT_LINE	we also set fundamental facets information in case applyFacets is not called. 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Inherit from the base type 	TokenNameCOMMENT_LINE	Inherit from the base type 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//set values for list. 	TokenNameCOMMENT_LINE	set values for list. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
setListValues	TokenNameIdentifier	 set List Values
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
itemType	TokenNameIdentifier	 item Type
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//decline to do anything if the object is immutable. 	TokenNameCOMMENT_LINE	decline to do anything if the object is immutable. 
if	TokenNameif	
(	TokenNameLPAREN	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
fAnonymous	TokenNameIdentifier	 f Anonymous
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
;	TokenNameSEMICOLON	
fItemType	TokenNameIdentifier	 f Item Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
itemType	TokenNameIdentifier	 item Type
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
DV_LIST	TokenNameIdentifier	 DV  LIST
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
;	TokenNameSEMICOLON	
//setting fundamental facets 	TokenNameCOMMENT_LINE	setting fundamental facets 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Values of this type are lists 	TokenNameCOMMENT_LINE	Values of this type are lists 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//set values for union. 	TokenNameCOMMENT_LINE	set values for union. 
protected	TokenNameprotected	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
setUnionValues	TokenNameIdentifier	 set Union Values
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
short	TokenNameshort	
finalSet	TokenNameIdentifier	 final Set
,	TokenNameCOMMA	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//decline to do anything if the object is immutable. 	TokenNameCOMMENT_LINE	decline to do anything if the object is immutable. 
if	TokenNameif	
(	TokenNameLPAREN	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
fAnonymous	TokenNameIdentifier	 f Anonymous
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
uri	TokenNameIdentifier	 uri
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
finalSet	TokenNameIdentifier	 final Set
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
;	TokenNameSEMICOLON	
fMemberTypes	TokenNameIdentifier	 f Member Types
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
DV_UNION	TokenNameIdentifier	 DV  UNION
;	TokenNameSEMICOLON	
// even for union, we set whitespace to something 	TokenNameCOMMENT_LINE	even for union, we set whitespace to something 
// this will never be used, but we can use fFacetsDefined to check 	TokenNameCOMMENT_LINE	this will never be used, but we can use fFacetsDefined to check 
// whether applyFacets() is allwwed: it's not allowed 	TokenNameCOMMENT_LINE	whether applyFacets() is allwwed: it's not allowed 
// if fFacetsDefined != 0 	TokenNameCOMMENT_LINE	if fFacetsDefined != 0 
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
;	TokenNameSEMICOLON	
//setting fundamental facets 	TokenNameCOMMENT_LINE	setting fundamental facets 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// No value can be of this type, so it's unavailable. 	TokenNameCOMMENT_LINE	No value can be of this type, so it's unavailable. 
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
UNAVAILABLE_DT	TokenNameIdentifier	 UNAVAILABLE  DT
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fTypeName	TokenNameIdentifier	 f Type Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTypeName	TokenNameIdentifier	 get Type Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fTypeName	TokenNameIdentifier	 f Type Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fFinalSet	TokenNameIdentifier	 f Final Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
short	TokenNameshort	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fFinalSet	TokenNameIdentifier	 f Final Set
&	TokenNameAND	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fBase	TokenNameIdentifier	 f Base
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fAnonymous	TokenNameIdentifier	 f Anonymous
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fTypeName	TokenNameIdentifier	 f Type Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for anySimpleType, return absent variaty 	TokenNameCOMMENT_LINE	for anySimpleType, return absent variaty 
return	TokenNamereturn	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
?	TokenNameQUESTION	
VARIETY_ABSENT	TokenNameIdentifier	 VARIETY  ABSENT
:	TokenNameCOLON	
fVariety	TokenNameIdentifier	 f Variety
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIDType	TokenNameIdentifier	 is ID Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
:	TokenNameCOLON	
return	TokenNamereturn	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ID	TokenNameIdentifier	 DV  ID
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
:	TokenNameCOLON	
return	TokenNamereturn	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
isIDType	TokenNameIdentifier	 is ID Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isIDType	TokenNameIdentifier	 is ID Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getWhitespace	TokenNameIdentifier	 get Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
DatatypeException	TokenNameIdentifier	 Datatype Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
DatatypeException	TokenNameIdentifier	 Datatype Exception
(	TokenNameLPAREN	
"dt-whitespace"	TokenNameStringLiteral	dt-whitespace
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fWhiteSpace	TokenNameIdentifier	 f White Space
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getPrimitiveKind	TokenNameIdentifier	 get Primitive Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ID	TokenNameIdentifier	 DV  ID
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_IDREF	TokenNameIdentifier	 DV  IDREF
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ENTITY	TokenNameIdentifier	 DV  ENTITY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_STRING	TokenNameIdentifier	 DV  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_DECIMAL	TokenNameIdentifier	 DV  DECIMAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_1_1_SUPPORT	TokenNameIdentifier	 SCHEMA 1 1  SUPPORT
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_YEARMONTHDURATION	TokenNameIdentifier	 DV  YEARMONTHDURATION
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_DAYTIMEDURATION	TokenNameIdentifier	 DV  DAYTIMEDURATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_DURATION	TokenNameIdentifier	 DV  DURATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
fValidationDV	TokenNameIdentifier	 f Validation DV
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// REVISIT: error situation. runtime exception? 	TokenNameCOMMENT_LINE	REVISIT: error situation. runtime exception? 
return	TokenNamereturn	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the closest built-in type category this type represents or * derived from. For example, if this simple type is a built-in derived * type integer the <code>INTEGER_DV</code> is returned. */	TokenNameCOMMENT_JAVADOC	 Returns the closest built-in type category this type represents or derived from. For example, if this simple type is a built-in derived type integer the <code>INTEGER_DV</code> is returned. 
public	TokenNamepublic	
short	TokenNameshort	
getBuiltInKind	TokenNameIdentifier	 get Built In Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If variety is <code>atomic</code> the primitive type definition (a * built-in primitive datatype definition or the simple ur-type * definition) is available, otherwise <code>null</code>. */	TokenNameCOMMENT_JAVADOC	 If variety is <code>atomic</code> the primitive type definition (a built-in primitive datatype definition or the simple ur-type definition) is available, otherwise <code>null</code>. 
public	TokenNamepublic	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
getPrimitiveType	TokenNameIdentifier	 get Primitive Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
pri	TokenNameIdentifier	 pri
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
// recursively get base, until we reach anySimpleType 	TokenNameCOMMENT_LINE	recursively get base, until we reach anySimpleType 
while	TokenNamewhile	
(	TokenNameLPAREN	
pri	TokenNameIdentifier	 pri
.	TokenNameDOT	
fBase	TokenNameIdentifier	 f Base
!=	TokenNameNOT_EQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
pri	TokenNameIdentifier	 pri
=	TokenNameEQUAL	
pri	TokenNameIdentifier	 pri
.	TokenNameDOT	
fBase	TokenNameIdentifier	 f Base
;	TokenNameSEMICOLON	
return	TokenNamereturn	
pri	TokenNameIdentifier	 pri
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// REVISIT: error situation. runtime exception? 	TokenNameCOMMENT_LINE	REVISIT: error situation. runtime exception? 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * If variety is <code>list</code> the item type definition (an atomic or * union simple type definition) is available, otherwise * <code>null</code>. */	TokenNameCOMMENT_JAVADOC	 If variety is <code>list</code> the item type definition (an atomic or union simple type definition) is available, otherwise <code>null</code>. 
public	TokenNamepublic	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
getItemType	TokenNameIdentifier	 get Item Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fItemType	TokenNameIdentifier	 f Item Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// REVISIT: error situation. runtime exception? 	TokenNameCOMMENT_LINE	REVISIT: error situation. runtime exception? 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * If variety is <code>union</code> the list of member type definitions (a * non-empty sequence of simple type definitions) is available, * otherwise an empty <code>XSObjectList</code>. */	TokenNameCOMMENT_JAVADOC	 If variety is <code>union</code> the list of member type definitions (a non-empty sequence of simple type definitions) is available, otherwise an empty <code>XSObjectList</code>. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
,	TokenNameCOMMA	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * If <restriction> is chosen */	TokenNameCOMMENT_JAVADOC	 If <restriction> is chosen 
public	TokenNamepublic	
void	TokenNamevoid	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
XSFacets	TokenNameIdentifier	 XS Facets
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
short	TokenNameshort	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
short	TokenNameshort	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
fEmptyContext	TokenNameIdentifier	 f Empty Context
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * built-in derived types by restriction */	TokenNameCOMMENT_JAVADOC	 built-in derived types by restriction 
void	TokenNamevoid	
applyFacets1	TokenNameIdentifier	 apply Facets1
(	TokenNameLPAREN	
XSFacets	TokenNameIdentifier	 XS Facets
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
short	TokenNameshort	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
short	TokenNameshort	
fixedFacet	TokenNameIdentifier	 fixed Facet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
,	TokenNameCOMMA	
fDummyContext	TokenNameIdentifier	 f Dummy Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should never gets here, internel error 	TokenNameCOMMENT_LINE	should never gets here, internel error 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"internal error"	TokenNameStringLiteral	internal error
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we've now applied facets; so lock this object: 	TokenNameCOMMENT_LINE	we've now applied facets; so lock this object: 
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * built-in derived types by restriction */	TokenNameCOMMENT_JAVADOC	 built-in derived types by restriction 
void	TokenNamevoid	
applyFacets1	TokenNameIdentifier	 apply Facets1
(	TokenNameLPAREN	
XSFacets	TokenNameIdentifier	 XS Facets
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
short	TokenNameshort	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
short	TokenNameshort	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
short	TokenNameshort	
patternType	TokenNameIdentifier	 pattern Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
patternType	TokenNameIdentifier	 pattern Type
,	TokenNameCOMMA	
fDummyContext	TokenNameIdentifier	 f Dummy Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// should never gets here, internel error 	TokenNameCOMMENT_LINE	should never gets here, internel error 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"internal error"	TokenNameStringLiteral	internal error
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we've now applied facets; so lock this object: 	TokenNameCOMMENT_LINE	we've now applied facets; so lock this object: 
fIsImmutable	TokenNameIdentifier	 f Is Immutable
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If <restriction> is chosen, or built-in derived types by restriction */	TokenNameCOMMENT_JAVADOC	 If <restriction> is chosen, or built-in derived types by restriction 
void	TokenNamevoid	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
XSFacets	TokenNameIdentifier	 XS Facets
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
short	TokenNameshort	
presentFacet	TokenNameIdentifier	 present Facet
,	TokenNameCOMMA	
short	TokenNameshort	
fixedFacet	TokenNameIdentifier	 fixed Facet
,	TokenNameCOMMA	
short	TokenNameshort	
patternType	TokenNameIdentifier	 pattern Type
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
{	TokenNameLBRACE	
// if the object is immutable, should not apply facets... 	TokenNameCOMMENT_LINE	if the object is immutable, should not apply facets... 
if	TokenNameif	
(	TokenNameLPAREN	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
ValidatedInfo	TokenNameIdentifier	 Validated Info
tempInfo	TokenNameIdentifier	 temp Info
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// clear facets. because we always inherit facets in the constructor 	TokenNameCOMMENT_LINE	clear facets. because we always inherit facets in the constructor 
// REVISIT: in fact, we don't need to clear them. 	TokenNameCOMMENT_LINE	REVISIT: in fact, we don't need to clear them. 
// we can convert 5 string values (4 bounds + 1 enum) to actual values, 	TokenNameCOMMENT_LINE	we can convert 5 string values (4 bounds + 1 enum) to actual values, 
// store them somewhere, then do facet checking at once, instead of 	TokenNameCOMMENT_LINE	store them somewhere, then do facet checking at once, instead of 
// going through the following steps. (lots of checking are redundant: 	TokenNameCOMMENT_LINE	going through the following steps. (lots of checking are redundant: 
// for example, ((presentFacet & FACET_XXX) != 0)) 	TokenNameCOMMENT_LINE	for example, ((presentFacet & FACET_XXX) != 0)) 
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// step 1: parse present facets 	TokenNameCOMMENT_LINE	step 1: parse present facets 
short	TokenNameshort	
allowedFacet	TokenNameIdentifier	 allowed Facet
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
getAllowedFacets	TokenNameIdentifier	 get Allowed Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// length 	TokenNameCOMMENT_LINE	length 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"length"	TokenNameStringLiteral	length
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
lengthAnnotation	TokenNameIdentifier	 length Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
lengthAnnotation	TokenNameIdentifier	 length Annotation
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// minLength 	TokenNameCOMMENT_LINE	minLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minLength"	TokenNameStringLiteral	minLength
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minLength	TokenNameIdentifier	 min Length
;	TokenNameSEMICOLON	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// maxLength 	TokenNameCOMMENT_LINE	maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxLength"	TokenNameStringLiteral	maxLength
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxLength	TokenNameIdentifier	 max Length
;	TokenNameSEMICOLON	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// pattern 	TokenNameCOMMENT_LINE	pattern 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"pattern"	TokenNameStringLiteral	pattern
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
;	TokenNameSEMICOLON	
RegularExpression	TokenNameIdentifier	 Regular Expression
regex	TokenNameIdentifier	 regex
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
regex	TokenNameIdentifier	 regex
=	TokenNameEQUAL	
new	TokenNamenew	
RegularExpression	TokenNameIdentifier	 Regular Expression
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
"X"	TokenNameStringLiteral	X
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidRegex"	TokenNameStringLiteral	InvalidRegex
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getLocalizedMessage	TokenNameIdentifier	 get Localized Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
regex	TokenNameIdentifier	 regex
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fPattern	TokenNameIdentifier	 f Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
regex	TokenNameIdentifier	 regex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// whiteSpace 	TokenNameCOMMENT_LINE	whiteSpace 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"whiteSpace"	TokenNameStringLiteral	whiteSpace
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
whiteSpace	TokenNameIdentifier	 white Space
;	TokenNameSEMICOLON	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// enumeration 	TokenNameCOMMENT_LINE	enumeration 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"enumeration"	TokenNameStringLiteral	enumeration
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
enumVals	TokenNameIdentifier	 enum Vals
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
enumeration	TokenNameIdentifier	 enumeration
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
enumVals	TokenNameIdentifier	 enum Vals
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
enumNSDecls	TokenNameIdentifier	 enum NS Decls
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
enumNSDecls	TokenNameIdentifier	 enum NS Decls
;	TokenNameSEMICOLON	
ValidationContextImpl	TokenNameIdentifier	 Validation Context Impl
ctx	TokenNameIdentifier	 ctx
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationContextImpl	TokenNameIdentifier	 Validation Context Impl
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
enumAnnotations	TokenNameIdentifier	 enum Annotations
;	TokenNameSEMICOLON	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
enumNSDecls	TokenNameIdentifier	 enum NS Decls
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
ctx	TokenNameIdentifier	 ctx
.	TokenNameDOT	
setNSContext	TokenNameIdentifier	 set NS Context
(	TokenNameLPAREN	
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
)	TokenNameRPAREN	
enumNSDecls	TokenNameIdentifier	 enum NS Decls
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ValidatedInfo	TokenNameIdentifier	 Validated Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
getActualEnumValue	TokenNameIdentifier	 get Actual Enum Value
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
enumVals	TokenNameIdentifier	 enum Vals
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ctx	TokenNameIdentifier	 ctx
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check 4.3.5.c0 must: enumeration values from the value space of base 	TokenNameCOMMENT_LINE	check 4.3.5.c0 must: enumeration values from the value space of base 
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"enumeration-valid-restriction"	TokenNameStringLiteral	enumeration-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
enumVals	TokenNameIdentifier	 enum Vals
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// maxInclusive 	TokenNameCOMMENT_LINE	maxInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxInclusive"	TokenNameStringLiteral	maxInclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxInclusive	TokenNameIdentifier	 max Inclusive
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxInclusive	TokenNameIdentifier	 max Inclusive
,	TokenNameCOMMA	
"maxInclusive"	TokenNameStringLiteral	maxInclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check against fixed value in base 	TokenNameCOMMENT_LINE	check against fixed value in base 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxInclusive"	TokenNameStringLiteral	maxInclusive
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// maxInclusive from base 	TokenNameCOMMENT_LINE	maxInclusive from base 
try	TokenNametry	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxInclusive	TokenNameIdentifier	 max Inclusive
,	TokenNameCOMMA	
"maxInclusive"	TokenNameStringLiteral	maxInclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// maxExclusive 	TokenNameCOMMENT_LINE	maxExclusive 
boolean	TokenNameboolean	
needCheckBase	TokenNameIdentifier	 need Check Base
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxExclusive"	TokenNameStringLiteral	maxExclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusive	TokenNameIdentifier	 max Exclusive
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusive	TokenNameIdentifier	 max Exclusive
,	TokenNameCOMMA	
"maxExclusive"	TokenNameStringLiteral	maxExclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check against fixed value in base 	TokenNameCOMMENT_LINE	check against fixed value in base 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxExclusive"	TokenNameStringLiteral	maxExclusive
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusive	TokenNameIdentifier	 max Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
needCheckBase	TokenNameIdentifier	 need Check Base
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// maxExclusive from base 	TokenNameCOMMENT_LINE	maxExclusive from base 
if	TokenNameif	
(	TokenNameLPAREN	
needCheckBase	TokenNameIdentifier	 need Check Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusive	TokenNameIdentifier	 max Exclusive
,	TokenNameCOMMA	
"maxExclusive"	TokenNameStringLiteral	maxExclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If maxExclusive == base.maxExclusive, then we only need to check 	TokenNameCOMMENT_LINE	If maxExclusive == base.maxExclusive, then we only need to check 
// maxExclusive <= base.maxInclusive 	TokenNameCOMMENT_LINE	maxExclusive <= base.maxInclusive 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"maxExclusive-valid-restriction.2"	TokenNameStringLiteral	maxExclusive-valid-restriction.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
maxExclusive	TokenNameIdentifier	 max Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// minExclusive 	TokenNameCOMMENT_LINE	minExclusive 
needCheckBase	TokenNameIdentifier	 need Check Base
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minExclusive"	TokenNameStringLiteral	minExclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusive	TokenNameIdentifier	 min Exclusive
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusive	TokenNameIdentifier	 min Exclusive
,	TokenNameCOMMA	
"minExclusive"	TokenNameStringLiteral	minExclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check against fixed value in base 	TokenNameCOMMENT_LINE	check against fixed value in base 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minExclusive"	TokenNameStringLiteral	minExclusive
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusive	TokenNameIdentifier	 min Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
needCheckBase	TokenNameIdentifier	 need Check Base
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// minExclusive from base 	TokenNameCOMMENT_LINE	minExclusive from base 
if	TokenNameif	
(	TokenNameLPAREN	
needCheckBase	TokenNameIdentifier	 need Check Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusive	TokenNameIdentifier	 min Exclusive
,	TokenNameCOMMA	
"minExclusive"	TokenNameStringLiteral	minExclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If minExclusive == base.minExclusive, then we only need to check 	TokenNameCOMMENT_LINE	If minExclusive == base.minExclusive, then we only need to check 
// minExclusive >= base.minInclusive 	TokenNameCOMMENT_LINE	minExclusive >= base.minInclusive 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minExclusive-valid-restriction.3"	TokenNameStringLiteral	minExclusive-valid-restriction.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minExclusive	TokenNameIdentifier	 min Exclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// minInclusive 	TokenNameCOMMENT_LINE	minInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minInclusive"	TokenNameStringLiteral	minInclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minInclusive	TokenNameIdentifier	 min Inclusive
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minInclusive	TokenNameIdentifier	 min Inclusive
,	TokenNameCOMMA	
"minInclusive"	TokenNameStringLiteral	minInclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check against fixed value in base 	TokenNameCOMMENT_LINE	check against fixed value in base 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minInclusive"	TokenNameStringLiteral	minInclusive
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minInclusive	TokenNameIdentifier	 min Inclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// minInclusive from base 	TokenNameCOMMENT_LINE	minInclusive from base 
try	TokenNametry	
{	TokenNameLBRACE	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
tempInfo	TokenNameIdentifier	 temp Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
ide	TokenNameIdentifier	 ide
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ide	TokenNameIdentifier	 ide
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FacetValueFromBase"	TokenNameStringLiteral	FacetValueFromBase
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
minInclusive	TokenNameIdentifier	 min Inclusive
,	TokenNameCOMMA	
"minInclusive"	TokenNameStringLiteral	minInclusive
,	TokenNameCOMMA	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// totalDigits 	TokenNameCOMMENT_LINE	totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"totalDigits"	TokenNameStringLiteral	totalDigits
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
;	TokenNameSEMICOLON	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
totalDigits	TokenNameIdentifier	 total Digits
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// fractionDigits 	TokenNameCOMMENT_LINE	fractionDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
presentFacet	TokenNameIdentifier	 present Facet
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
allowedFacet	TokenNameIdentifier	 allowed Facet
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"cos-applicable-facets"	TokenNameStringLiteral	cos-applicable-facets
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"fractionDigits"	TokenNameStringLiteral	fractionDigits
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
fractionDigits	TokenNameIdentifier	 fraction Digits
;	TokenNameSEMICOLON	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
=	TokenNameEQUAL	
facets	TokenNameIdentifier	 facets
.	TokenNameDOT	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fixedFacet	TokenNameIdentifier	 fixed Facet
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// token type: internal use, so do less checking 	TokenNameCOMMENT_LINE	token type: internal use, so do less checking 
if	TokenNameif	
(	TokenNameLPAREN	
patternType	TokenNameIdentifier	 pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
patternType	TokenNameIdentifier	 pattern Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// step 2: check facets against each other: length, bounds 	TokenNameCOMMENT_LINE	step 2: check facets against each other: length, bounds 
if	TokenNameif	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check 4.3.2.c1 must: minLength <= maxLength 	TokenNameCOMMENT_LINE	check 4.3.2.c1 must: minLength <= maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
>	TokenNameGREATER	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral	minLength-less-than-equal-to-maxLength
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.8.c1 error: maxInclusive + maxExclusive 	TokenNameCOMMENT_LINE	check 4.3.8.c1 error: maxInclusive + maxExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"maxInclusive-maxExclusive"	TokenNameStringLiteral	maxInclusive-maxExclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.9.c1 error: minInclusive + minExclusive 	TokenNameCOMMENT_LINE	check 4.3.9.c1 error: minInclusive + minExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minInclusive-minExclusive"	TokenNameStringLiteral	minInclusive-minExclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.7.c1 must: minInclusive <= maxInclusive 	TokenNameCOMMENT_LINE	check 4.3.7.c1 must: minInclusive <= maxInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minInclusive-less-than-equal-to-maxInclusive"	TokenNameStringLiteral	minInclusive-less-than-equal-to-maxInclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.8.c2 must: minExclusive <= maxExclusive ??? minExclusive < maxExclusive 	TokenNameCOMMENT_LINE	check 4.3.8.c2 must: minExclusive <= maxExclusive ??? minExclusive < maxExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minExclusive-less-than-equal-to-maxExclusive"	TokenNameStringLiteral	minExclusive-less-than-equal-to-maxExclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.9.c2 must: minExclusive < maxInclusive 	TokenNameCOMMENT_LINE	check 4.3.9.c2 must: minExclusive < maxInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minExclusive-less-than-maxInclusive"	TokenNameStringLiteral	minExclusive-less-than-maxInclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.10.c1 must: minInclusive < maxExclusive 	TokenNameCOMMENT_LINE	check 4.3.10.c1 must: minInclusive < maxExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minInclusive-less-than-maxExclusive"	TokenNameStringLiteral	minInclusive-less-than-maxExclusive
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.12.c1 must: fractionDigits <= totalDigits 	TokenNameCOMMENT_LINE	check 4.3.12.c1 must: fractionDigits <= totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
>	TokenNameGREATER	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"fractionDigits-totalDigits"	TokenNameStringLiteral	fractionDigits-totalDigits
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// step 3: check facets against base 	TokenNameCOMMENT_LINE	step 3: check facets against base 
// check 4.3.1.c1 error: length & (fBase.maxLength | fBase.minLength) 	TokenNameCOMMENT_LINE	check 4.3.1.c1 error: length & (fBase.maxLength | fBase.minLength) 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fLength	TokenNameIdentifier	 f Length
<	TokenNameLESS	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// length, fBase.minLength and fBase.maxLength defined 	TokenNameCOMMENT_LINE	length, fBase.minLength and fBase.maxLength defined 
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.1.1"	TokenNameStringLiteral	length-minLength-maxLength.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fLength	TokenNameIdentifier	 f Length
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// length and fBase.maxLength defined 	TokenNameCOMMENT_LINE	length and fBase.maxLength defined 
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.2.1"	TokenNameStringLiteral	length-minLength-maxLength.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check 4.3.1.c2 error: length != fBase.length 	TokenNameCOMMENT_LINE	check 4.3.1.c2 error: length != fBase.length 
if	TokenNameif	
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-valid-restriction"	TokenNameStringLiteral	length-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.1.c1 error: fBase.length & (maxLength | minLength) 	TokenNameCOMMENT_LINE	check 4.3.1.c1 error: fBase.length & (maxLength | minLength) 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
<	TokenNameLESS	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// fBase.length, minLength and maxLength defined 	TokenNameCOMMENT_LINE	fBase.length, minLength and maxLength defined 
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.1.1"	TokenNameStringLiteral	length-minLength-maxLength.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.1.2.a"	TokenNameStringLiteral	length-minLength-maxLength.1.2.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.1.2.b"	TokenNameStringLiteral	length-minLength-maxLength.1.2.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
>	TokenNameGREATER	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// fBase.length, minLength and maxLength defined 	TokenNameCOMMENT_LINE	fBase.length, minLength and maxLength defined 
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.2.1"	TokenNameStringLiteral	length-minLength-maxLength.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.2.2.a"	TokenNameStringLiteral	length-minLength-maxLength.2.2.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"length-minLength-maxLength.2.2.b"	TokenNameStringLiteral	length-minLength-maxLength.2.2.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.2.c1 must: minLength <= fBase.maxLength 	TokenNameCOMMENT_LINE	check 4.3.2.c1 must: minLength <= fBase.maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral	minLength-less-than-equal-to-maxLength
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fMinLength	TokenNameIdentifier	 f Min Length
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"minLength"	TokenNameStringLiteral	minLength
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check 4.3.2.c2 error: minLength < fBase.minLength 	TokenNameCOMMENT_LINE	check 4.3.2.c2 error: minLength < fBase.minLength 
if	TokenNameif	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
<	TokenNameLESS	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minLength-valid-restriction"	TokenNameStringLiteral	minLength-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.2.c1 must: maxLength < fBase.minLength 	TokenNameCOMMENT_LINE	check 4.3.2.c1 must: maxLength < fBase.minLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
<	TokenNameLESS	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral	minLength-less-than-equal-to-maxLength
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.3.c1 error: maxLength > fBase.maxLength 	TokenNameCOMMENT_LINE	check 4.3.3.c1 error: maxLength > fBase.maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fMaxLength	TokenNameIdentifier	 f Max Length
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"maxLength"	TokenNameStringLiteral	maxLength
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"maxLength-valid-restriction"	TokenNameStringLiteral	maxLength-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* // check 4.3.7.c2 error: // maxInclusive > fBase.maxInclusive // maxInclusive >= fBase.maxExclusive // maxInclusive < fBase.minInclusive // maxInclusive <= fBase.minExclusive if (((fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { if (((fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMaxInclusive); if ((fBase.fFixedFacet & FACET_MAXINCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"maxInclusive", fMaxInclusive, fBase.fMaxInclusive, fTypeName}); } if (result != -1 && result != 0) { reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMaxInclusive, fTypeName}); } } if (((fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMaxExclusive) != -1){ reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMaxExclusive, fTypeName}); } if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMinInclusive); if (result != 1 && result != 0) { reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMinExclusive ) != 1) reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMinExclusive, fTypeName}); } // check 4.3.8.c3 error: // maxExclusive > fBase.maxExclusive // maxExclusive > fBase.maxInclusive // maxExclusive <= fBase.minInclusive // maxExclusive <= fBase.minExclusive if (((fFacetsDefined & FACET_MAXEXCLUSIVE) != 0)) { if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMaxExclusive); if ((fBase.fFixedFacet & FACET_MAXEXCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"maxExclusive", fMaxExclusive, fBase.fMaxExclusive, fTypeName}); } if (result != -1 && result != 0) { reportError( "maxExclusive-valid-restriction.1", new Object[]{fMaxExclusive, fBase.fMaxExclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "maxExclusive-valid-restriction.2", new Object[]{fMaxExclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMinExclusive ) != 1) reportError( "maxExclusive-valid-restriction.3", new Object[]{fMaxExclusive, fBase.fMinExclusive, fTypeName}); if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMinInclusive) != 1) reportError( "maxExclusive-valid-restriction.4", new Object[]{fMaxExclusive, fBase.fMinInclusive, fTypeName}); } // check 4.3.9.c3 error: // minExclusive < fBase.minExclusive // minExclusive > fBase.maxInclusive // minExclusive < fBase.minInclusive // minExclusive >= fBase.maxExclusive if (((fFacetsDefined & FACET_MINEXCLUSIVE) != 0)) { if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMinExclusive, fBase.fMinExclusive); if ((fBase.fFixedFacet & FACET_MINEXCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"minExclusive", fMinExclusive, fBase.fMinExclusive, fTypeName}); } if (result != 1 && result != 0) { reportError( "minExclusive-valid-restriction.1", new Object[]{fMinExclusive, fBase.fMinExclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result=fDVs[fValidationDV].compare(fMinExclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "minExclusive-valid-restriction.2", new Object[]{fMinExclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMinExclusive, fBase.fMinInclusive); if (result != 1 && result != 0) { reportError( "minExclusive-valid-restriction.3", new Object[]{fMinExclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinExclusive, fBase.fMaxExclusive) != -1) reportError( "minExclusive-valid-restriction.4", new Object[]{fMinExclusive, fBase.fMaxExclusive, fTypeName}); } // check 4.3.10.c2 error: // minInclusive < fBase.minInclusive // minInclusive > fBase.maxInclusive // minInclusive <= fBase.minExclusive // minInclusive >= fBase.maxExclusive if (((fFacetsDefined & FACET_MININCLUSIVE) != 0)) { if (((fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMinInclusive, fBase.fMinInclusive); if ((fBase.fFixedFacet & FACET_MININCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"minInclusive", fMinInclusive, fBase.fMinInclusive, fTypeName}); } if (result != 1 && result != 0) { reportError( "minInclusive-valid-restriction.1", new Object[]{fMinInclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result=fDVs[fValidationDV].compare(fMinInclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "minInclusive-valid-restriction.2", new Object[]{fMinInclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinInclusive, fBase.fMinExclusive ) != 1) reportError( "minInclusive-valid-restriction.3", new Object[]{fMinInclusive, fBase.fMinExclusive, fTypeName}); if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinInclusive, fBase.fMaxExclusive) != -1) reportError( "minInclusive-valid-restriction.4", new Object[]{fMinInclusive, fBase.fMaxExclusive, fTypeName}); } */	TokenNameCOMMENT_BLOCK	 // check 4.3.7.c2 error: // maxInclusive > fBase.maxInclusive // maxInclusive >= fBase.maxExclusive // maxInclusive < fBase.minInclusive // maxInclusive <= fBase.minExclusive if (((fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { if (((fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMaxInclusive); if ((fBase.fFixedFacet & FACET_MAXINCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"maxInclusive", fMaxInclusive, fBase.fMaxInclusive, fTypeName}); } if (result != -1 && result != 0) { reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMaxInclusive, fTypeName}); } } if (((fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMaxExclusive) != -1){ reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMaxExclusive, fTypeName}); } if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMinInclusive); if (result != 1 && result != 0) { reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxInclusive, fBase.fMinExclusive ) != 1) reportError( "maxInclusive-valid-restriction.1", new Object[]{fMaxInclusive, fBase.fMinExclusive, fTypeName}); } // check 4.3.8.c3 error: // maxExclusive > fBase.maxExclusive // maxExclusive > fBase.maxInclusive // maxExclusive <= fBase.minInclusive // maxExclusive <= fBase.minExclusive if (((fFacetsDefined & FACET_MAXEXCLUSIVE) != 0)) { if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMaxExclusive); if ((fBase.fFixedFacet & FACET_MAXEXCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"maxExclusive", fMaxExclusive, fBase.fMaxExclusive, fTypeName}); } if (result != -1 && result != 0) { reportError( "maxExclusive-valid-restriction.1", new Object[]{fMaxExclusive, fBase.fMaxExclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "maxExclusive-valid-restriction.2", new Object[]{fMaxExclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMinExclusive ) != 1) reportError( "maxExclusive-valid-restriction.3", new Object[]{fMaxExclusive, fBase.fMinExclusive, fTypeName}); if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMaxExclusive, fBase.fMinInclusive) != 1) reportError( "maxExclusive-valid-restriction.4", new Object[]{fMaxExclusive, fBase.fMinInclusive, fTypeName}); } // check 4.3.9.c3 error: // minExclusive < fBase.minExclusive // minExclusive > fBase.maxInclusive // minExclusive < fBase.minInclusive // minExclusive >= fBase.maxExclusive if (((fFacetsDefined & FACET_MINEXCLUSIVE) != 0)) { if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0)) { result= fDVs[fValidationDV].compare(fMinExclusive, fBase.fMinExclusive); if ((fBase.fFixedFacet & FACET_MINEXCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"minExclusive", fMinExclusive, fBase.fMinExclusive, fTypeName}); } if (result != 1 && result != 0) { reportError( "minExclusive-valid-restriction.1", new Object[]{fMinExclusive, fBase.fMinExclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result=fDVs[fValidationDV].compare(fMinExclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "minExclusive-valid-restriction.2", new Object[]{fMinExclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMinExclusive, fBase.fMinInclusive); if (result != 1 && result != 0) { reportError( "minExclusive-valid-restriction.3", new Object[]{fMinExclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinExclusive, fBase.fMaxExclusive) != -1) reportError( "minExclusive-valid-restriction.4", new Object[]{fMinExclusive, fBase.fMaxExclusive, fTypeName}); } // check 4.3.10.c2 error: // minInclusive < fBase.minInclusive // minInclusive > fBase.maxInclusive // minInclusive <= fBase.minExclusive // minInclusive >= fBase.maxExclusive if (((fFacetsDefined & FACET_MININCLUSIVE) != 0)) { if (((fBase.fFacetsDefined & FACET_MININCLUSIVE) != 0)) { result = fDVs[fValidationDV].compare(fMinInclusive, fBase.fMinInclusive); if ((fBase.fFixedFacet & FACET_MININCLUSIVE) != 0 && result != 0) { reportError( "FixedFacetValue", new Object[]{"minInclusive", fMinInclusive, fBase.fMinInclusive, fTypeName}); } if (result != 1 && result != 0) { reportError( "minInclusive-valid-restriction.1", new Object[]{fMinInclusive, fBase.fMinInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MAXINCLUSIVE) != 0)) { result=fDVs[fValidationDV].compare(fMinInclusive, fBase.fMaxInclusive); if (result != -1 && result != 0) { reportError( "minInclusive-valid-restriction.2", new Object[]{fMinInclusive, fBase.fMaxInclusive, fTypeName}); } } if ((( fBase.fFacetsDefined & FACET_MINEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinInclusive, fBase.fMinExclusive ) != 1) reportError( "minInclusive-valid-restriction.3", new Object[]{fMinInclusive, fBase.fMinExclusive, fTypeName}); if ((( fBase.fFacetsDefined & FACET_MAXEXCLUSIVE) != 0) && fDVs[fValidationDV].compare(fMinInclusive, fBase.fMaxExclusive) != -1) reportError( "minInclusive-valid-restriction.4", new Object[]{fMinInclusive, fBase.fMaxExclusive, fTypeName}); } 
// check 4.3.11.c1 error: totalDigits > fBase.totalDigits 	TokenNameCOMMENT_LINE	check 4.3.11.c1 error: totalDigits > fBase.totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fTotalDigits	TokenNameIdentifier	 f Total Digits
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"totalDigits"	TokenNameStringLiteral	totalDigits
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"totalDigits-valid-restriction"	TokenNameStringLiteral	totalDigits-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.12.c1 must: fractionDigits <= base.totalDigits 	TokenNameCOMMENT_LINE	check 4.3.12.c1 must: fractionDigits <= base.totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"fractionDigits-totalDigits"	TokenNameStringLiteral	fractionDigits-totalDigits
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.12.c2 error: fractionDigits > fBase.fractionDigits 	TokenNameCOMMENT_LINE	check 4.3.12.c2 error: fractionDigits > fBase.fractionDigits 
// check fixed value for fractionDigits 	TokenNameCOMMENT_LINE	check fixed value for fractionDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
&&	TokenNameAND_AND	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"fractionDigits"	TokenNameStringLiteral	fractionDigits
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
>	TokenNameGREATER	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"fractionDigits-valid-restriction"	TokenNameStringLiteral	fractionDigits-valid-restriction
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
&&	TokenNameAND_AND	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"fractionDigits"	TokenNameStringLiteral	fractionDigits
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"0"	TokenNameStringLiteral	0
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check 4.3.6.c1 error: 	TokenNameCOMMENT_LINE	check 4.3.6.c1 error: 
// (whiteSpace = preserve || whiteSpace = replace) && fBase.whiteSpace = collapese or 	TokenNameCOMMENT_LINE	(whiteSpace = preserve || whiteSpace = replace) && fBase.whiteSpace = collapese or 
// whiteSpace = preserve && fBase.whiteSpace = replace 	TokenNameCOMMENT_LINE	whiteSpace = preserve && fBase.whiteSpace = replace 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fWhiteSpace	TokenNameIdentifier	 f White Space
!=	TokenNameNOT_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"FixedFacetValue"	TokenNameStringLiteral	FixedFacetValue
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
"whiteSpace"	TokenNameStringLiteral	whiteSpace
,	TokenNameCOMMA	
whiteSpaceValue	TokenNameIdentifier	 white Space Value
(	TokenNameLPAREN	
fWhiteSpace	TokenNameIdentifier	 f White Space
)	TokenNameRPAREN	
,	TokenNameCOMMA	
whiteSpaceValue	TokenNameIdentifier	 white Space Value
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
&&	TokenNameAND_AND	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"whiteSpace-valid-restriction.1"	TokenNameStringLiteral	whiteSpace-valid-restriction.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
"preserve"	TokenNameStringLiteral	preserve
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_REPLACE	TokenNameIdentifier	 WS  REPLACE
&&	TokenNameAND_AND	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"whiteSpace-valid-restriction.1"	TokenNameStringLiteral	whiteSpace-valid-restriction.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
"replace"	TokenNameStringLiteral	replace
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
&&	TokenNameAND_AND	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
WS_REPLACE	TokenNameIdentifier	 WS  REPLACE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"whiteSpace-valid-restriction.2"	TokenNameStringLiteral	whiteSpace-valid-restriction.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//fFacetsDefined != null 	TokenNameCOMMENT_LINE	fFacetsDefined != null 
// step 4: inherit other facets from base (including fTokeyType) 	TokenNameCOMMENT_LINE	step 4: inherit other facets from base (including fTokeyType) 
// inherit length 	TokenNameCOMMENT_LINE	inherit length 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
;	TokenNameSEMICOLON	
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
lengthAnnotation	TokenNameIdentifier	 length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
lengthAnnotation	TokenNameIdentifier	 length Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit minLength 	TokenNameCOMMENT_LINE	inherit minLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
;	TokenNameSEMICOLON	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinLength	TokenNameIdentifier	 f Min Length
;	TokenNameSEMICOLON	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit maxLength 	TokenNameCOMMENT_LINE	inherit maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
;	TokenNameSEMICOLON	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxLength	TokenNameIdentifier	 f Max Length
;	TokenNameSEMICOLON	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit pattern 	TokenNameCOMMENT_LINE	inherit pattern 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
;	TokenNameSEMICOLON	
fPattern	TokenNameIdentifier	 f Pattern
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPattern	TokenNameIdentifier	 f Pattern
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternStr	TokenNameIdentifier	 f Pattern Str
;	TokenNameSEMICOLON	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
.	TokenNameDOT	
addXSObject	TokenNameIdentifier	 add XS Object
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// inherit whiteSpace 	TokenNameCOMMENT_LINE	inherit whiteSpace 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fWhiteSpace	TokenNameIdentifier	 f White Space
;	TokenNameSEMICOLON	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit enumeration 	TokenNameCOMMENT_LINE	inherit enumeration 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumeration	TokenNameIdentifier	 f Enumeration
;	TokenNameSEMICOLON	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit maxExclusive 	TokenNameCOMMENT_LINE	inherit maxExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
;	TokenNameSEMICOLON	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
;	TokenNameSEMICOLON	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit maxInclusive 	TokenNameCOMMENT_LINE	inherit maxInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
;	TokenNameSEMICOLON	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
;	TokenNameSEMICOLON	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit minExclusive 	TokenNameCOMMENT_LINE	inherit minExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
;	TokenNameSEMICOLON	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
;	TokenNameSEMICOLON	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit minExclusive 	TokenNameCOMMENT_LINE	inherit minExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
;	TokenNameSEMICOLON	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
;	TokenNameSEMICOLON	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit totalDigits 	TokenNameCOMMENT_LINE	inherit totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
;	TokenNameSEMICOLON	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fTotalDigits	TokenNameIdentifier	 f Total Digits
;	TokenNameSEMICOLON	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// inherit fractionDigits 	TokenNameCOMMENT_LINE	inherit fractionDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|=	TokenNameOR_EQUAL	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
;	TokenNameSEMICOLON	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
;	TokenNameSEMICOLON	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//inherit tokeytype 	TokenNameCOMMENT_LINE	inherit tokeytype 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fPatternType	TokenNameIdentifier	 f Pattern Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// step 5: mark fixed values 	TokenNameCOMMENT_LINE	step 5: mark fixed values 
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|=	TokenNameOR_EQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
;	TokenNameSEMICOLON	
//step 6: setting fundamental facets 	TokenNameCOMMENT_LINE	step 6: setting fundamental facets 
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//applyFacets() 	TokenNameCOMMENT_LINE	applyFacets() 
/** * validate a value, and return the compiled form */	TokenNameCOMMENT_JAVADOC	 validate a value, and return the compiled form 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
fEmptyContext	TokenNameIdentifier	 f Empty Context
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// first normalize string value, and convert it to actual value 	TokenNameCOMMENT_LINE	first normalize string value, and convert it to actual value 
boolean	TokenNameboolean	
needNormalize	TokenNameIdentifier	 need Normalize
=	TokenNameEQUAL	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
ob	TokenNameIdentifier	 ob
=	TokenNameEQUAL	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
needNormalize	TokenNameIdentifier	 need Normalize
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ob	TokenNameIdentifier	 ob
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
ValidatedInfo	TokenNameIdentifier	 Validated Info
getActualEnumValue	TokenNameIdentifier	 get Actual Enum Value
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
lexical	TokenNameIdentifier	 lexical
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
ctx	TokenNameIdentifier	 ctx
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
validateWithInfo	TokenNameIdentifier	 validate With Info
(	TokenNameLPAREN	
lexical	TokenNameIdentifier	 lexical
,	TokenNameCOMMA	
ctx	TokenNameIdentifier	 ctx
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * validate a value, and return the compiled form */	TokenNameCOMMENT_JAVADOC	 validate a value, and return the compiled form 
public	TokenNamepublic	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validateWithInfo	TokenNameIdentifier	 validate With Info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
fEmptyContext	TokenNameIdentifier	 f Empty Context
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// first normalize string value, and convert it to actual value 	TokenNameCOMMENT_LINE	first normalize string value, and convert it to actual value 
boolean	TokenNameboolean	
needNormalize	TokenNameIdentifier	 need Normalize
=	TokenNameEQUAL	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
needNormalize	TokenNameIdentifier	 need Normalize
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
validatedInfo	TokenNameIdentifier	 validated Info
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * validate a value, and return the compiled form */	TokenNameCOMMENT_JAVADOC	 validate a value, and return the compiled form 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
fEmptyContext	TokenNameIdentifier	 f Empty Context
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// first normalize string value, and convert it to actual value 	TokenNameCOMMENT_LINE	first normalize string value, and convert it to actual value 
boolean	TokenNameboolean	
needNormalize	TokenNameIdentifier	 need Normalize
=	TokenNameEQUAL	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
ob	TokenNameIdentifier	 ob
=	TokenNameEQUAL	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
needNormalize	TokenNameIdentifier	 need Normalize
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ob	TokenNameIdentifier	 ob
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * validate an actual value against this DV * * @param context the validation context * @param validatedInfo used to provide the actual value and member types */	TokenNameCOMMENT_JAVADOC	 validate an actual value against this DV * @param context the validation context @param validatedInfo used to provide the actual value and member types 
public	TokenNamepublic	
void	TokenNamevoid	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
fEmptyContext	TokenNameIdentifier	 f Empty Context
;	TokenNameSEMICOLON	
// then validate the actual value against the facets 	TokenNameCOMMENT_LINE	then validate the actual value against the facets 
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkFacets	TokenNameIdentifier	 check Facets
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now check extra rules: for ID/IDREF/ENTITY 	TokenNameCOMMENT_LINE	now check extra rules: for ID/IDREF/ENTITY 
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needExtraChecking	TokenNameIdentifier	 need Extra Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkFacets	TokenNameIdentifier	 check Facets
(	TokenNameLPAREN	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
ob	TokenNameIdentifier	 ob
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
;	TokenNameSEMICOLON	
short	TokenNameshort	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
;	TokenNameSEMICOLON	
ShortList	TokenNameIdentifier	 Short List
itemType	TokenNameIdentifier	 item Type
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
;	TokenNameSEMICOLON	
// For QName and NOTATION types, we don't check length facets 	TokenNameCOMMENT_LINE	For QName and NOTATION types, we don't check length facets 
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_QNAME	TokenNameIdentifier	 DV  QNAME
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_NOTATION	TokenNameIdentifier	 DV  NOTATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
getDataLength	TokenNameIdentifier	 get Data Length
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// maxLength 	TokenNameCOMMENT_LINE	maxLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-maxLength-valid"	TokenNameStringLiteral	cvc-maxLength-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//minLength 	TokenNameCOMMENT_LINE	minLength 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-minLength-valid"	TokenNameStringLiteral	cvc-minLength-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//length 	TokenNameCOMMENT_LINE	length 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-length-valid"	TokenNameStringLiteral	cvc-length-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//enumeration 	TokenNameCOMMENT_LINE	enumeration 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
present	TokenNameIdentifier	 present
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
enumSize	TokenNameIdentifier	 enum Size
=	TokenNameEQUAL	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
final	TokenNamefinal	
short	TokenNameshort	
primitiveType1	TokenNameIdentifier	 primitive Type1
=	TokenNameEQUAL	
convertToPrimitiveKind	TokenNameIdentifier	 convert To Primitive Kind
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
enumSize	TokenNameIdentifier	 enum Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
short	TokenNameshort	
primitiveType2	TokenNameIdentifier	 primitive Type2
=	TokenNameEQUAL	
convertToPrimitiveKind	TokenNameIdentifier	 convert To Primitive Kind
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
primitiveType1	TokenNameIdentifier	 primitive Type1
==	TokenNameEQUAL_EQUAL	
primitiveType2	TokenNameIdentifier	 primitive Type2
||	TokenNameOR_OR	
primitiveType1	TokenNameIdentifier	 primitive Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ANYSIMPLETYPE_DT	TokenNameIdentifier	 ANYSIMPLETYPE  DT
&&	TokenNameAND_AND	
primitiveType2	TokenNameIdentifier	 primitive Type2
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
STRING_DT	TokenNameIdentifier	 STRING  DT
||	TokenNameOR_OR	
primitiveType1	TokenNameIdentifier	 primitive Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
STRING_DT	TokenNameIdentifier	 STRING  DT
&&	TokenNameAND_AND	
primitiveType2	TokenNameIdentifier	 primitive Type2
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ANYSIMPLETYPE_DT	TokenNameIdentifier	 ANYSIMPLETYPE  DT
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
primitiveType1	TokenNameIdentifier	 primitive Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
||	TokenNameOR_OR	
primitiveType1	TokenNameIdentifier	 primitive Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LISTOFUNION_DT	TokenNameIdentifier	 LISTOFUNION  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ShortList	TokenNameIdentifier	 Short List
enumItemType	TokenNameIdentifier	 enum Item Type
=	TokenNameEQUAL	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
typeList1Length	TokenNameIdentifier	 type List1 Length
=	TokenNameEQUAL	
itemType	TokenNameIdentifier	 item Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
itemType	TokenNameIdentifier	 item Type
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
typeList2Length	TokenNameIdentifier	 type List2 Length
=	TokenNameEQUAL	
enumItemType	TokenNameIdentifier	 enum Item Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
enumItemType	TokenNameIdentifier	 enum Item Type
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
typeList1Length	TokenNameIdentifier	 type List1 Length
==	TokenNameEQUAL_EQUAL	
typeList2Length	TokenNameIdentifier	 type List2 Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
typeList1Length	TokenNameIdentifier	 type List1 Length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
short	TokenNameshort	
primitiveItem1	TokenNameIdentifier	 primitive Item1
=	TokenNameEQUAL	
convertToPrimitiveKind	TokenNameIdentifier	 convert To Primitive Kind
(	TokenNameLPAREN	
itemType	TokenNameIdentifier	 item Type
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
short	TokenNameshort	
primitiveItem2	TokenNameIdentifier	 primitive Item2
=	TokenNameEQUAL	
convertToPrimitiveKind	TokenNameIdentifier	 convert To Primitive Kind
(	TokenNameLPAREN	
enumItemType	TokenNameIdentifier	 enum Item Type
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
primitiveItem1	TokenNameIdentifier	 primitive Item1
!=	TokenNameNOT_EQUAL	
primitiveItem2	TokenNameIdentifier	 primitive Item2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
primitiveItem1	TokenNameIdentifier	 primitive Item1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ANYSIMPLETYPE_DT	TokenNameIdentifier	 ANYSIMPLETYPE  DT
&&	TokenNameAND_AND	
primitiveItem2	TokenNameIdentifier	 primitive Item2
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
STRING_DT	TokenNameIdentifier	 STRING  DT
||	TokenNameOR_OR	
primitiveItem1	TokenNameIdentifier	 primitive Item1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
STRING_DT	TokenNameIdentifier	 STRING  DT
&&	TokenNameAND_AND	
primitiveItem2	TokenNameIdentifier	 primitive Item2
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ANYSIMPLETYPE_DT	TokenNameIdentifier	 ANYSIMPLETYPE  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
==	TokenNameEQUAL_EQUAL	
typeList1Length	TokenNameIdentifier	 type List1 Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
present	TokenNameIdentifier	 present
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
present	TokenNameIdentifier	 present
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
present	TokenNameIdentifier	 present
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendEnumString	TokenNameIdentifier	 append Enum String
(	TokenNameLPAREN	
sb	TokenNameIdentifier	 sb
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-enumeration-valid"	TokenNameStringLiteral	cvc-enumeration-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//fractionDigits 	TokenNameCOMMENT_LINE	fractionDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
scale	TokenNameIdentifier	 scale
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
getFractionDigits	TokenNameIdentifier	 get Fraction Digits
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scale	TokenNameIdentifier	 scale
>	TokenNameGREATER	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-fractionDigits-valid"	TokenNameStringLiteral	cvc-fractionDigits-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
scale	TokenNameIdentifier	 scale
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//totalDigits 	TokenNameCOMMENT_LINE	totalDigits 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
totalDigits	TokenNameIdentifier	 total Digits
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
getTotalDigits	TokenNameIdentifier	 get Total Digits
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalDigits	TokenNameIdentifier	 total Digits
>	TokenNameGREATER	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-totalDigits-valid"	TokenNameStringLiteral	cvc-totalDigits-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
totalDigits	TokenNameIdentifier	 total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
;	TokenNameSEMICOLON	
//maxinclusive 	TokenNameCOMMENT_LINE	maxinclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compare	TokenNameIdentifier	 compare
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-maxInclusive-valid"	TokenNameStringLiteral	cvc-maxInclusive-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//maxExclusive 	TokenNameCOMMENT_LINE	maxExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compare	TokenNameIdentifier	 compare
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-maxExclusive-valid"	TokenNameStringLiteral	cvc-maxExclusive-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//minInclusive 	TokenNameCOMMENT_LINE	minInclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compare	TokenNameIdentifier	 compare
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
,	TokenNameCOMMA	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-minInclusive-valid"	TokenNameStringLiteral	cvc-minInclusive-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//minExclusive 	TokenNameCOMMENT_LINE	minExclusive 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compare	TokenNameIdentifier	 compare
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
,	TokenNameCOMMA	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compare	TokenNameIdentifier	 compare
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-minExclusive-valid"	TokenNameStringLiteral	cvc-minExclusive-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
ob	TokenNameIdentifier	 ob
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
ob	TokenNameIdentifier	 ob
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ListDV	TokenNameIdentifier	 List DV
.	TokenNameDOT	
ListData	TokenNameIdentifier	 List Data
values	TokenNameIdentifier	 values
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ListDV	TokenNameIdentifier	 List DV
.	TokenNameDOT	
ListData	TokenNameIdentifier	 List Data
)	TokenNameRPAREN	
ob	TokenNameIdentifier	 ob
;	TokenNameSEMICOLON	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberTypes	TokenNameIdentifier	 member Types
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// (fVariety == VARIETY_ATOMIC) 	TokenNameCOMMENT_LINE	(fVariety == VARIETY_ATOMIC) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
memberType	TokenNameIdentifier	 member Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// (fVariety == VARIETY_UNION) 	TokenNameCOMMENT_LINE	(fVariety == VARIETY_UNION) 
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
)	TokenNameRPAREN	
.	TokenNameDOT	
checkExtraRules	TokenNameIdentifier	 check Extra Rules
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// checkExtraRules() 	TokenNameCOMMENT_LINE	checkExtraRules() 
//we can still return object for internal use. 	TokenNameCOMMENT_LINE	we can still return object for internal use. 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
ValidationContext	TokenNameIdentifier	 Validation Context
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ValidatedInfo	TokenNameIdentifier	 Validated Info
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
boolean	TokenNameboolean	
needNormalize	TokenNameIdentifier	 need Normalize
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
nvalue	TokenNameIdentifier	 nvalue
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needNormalize	TokenNameIdentifier	 need Normalize
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nvalue	TokenNameIdentifier	 nvalue
=	TokenNameEQUAL	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fWhiteSpace	TokenNameIdentifier	 f White Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
nvalue	TokenNameIdentifier	 nvalue
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RegularExpression	TokenNameIdentifier	 Regular Expression
regex	TokenNameIdentifier	 regex
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
regex	TokenNameIdentifier	 regex
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RegularExpression	TokenNameIdentifier	 Regular Expression
)	TokenNameRPAREN	
fPattern	TokenNameIdentifier	 f Pattern
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
regex	TokenNameIdentifier	 regex
.	TokenNameDOT	
matches	TokenNameIdentifier	 matches
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-pattern-valid"	TokenNameStringLiteral	cvc-pattern-valid
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// validate special kinds of token, in place of old pattern matching 	TokenNameCOMMENT_LINE	validate special kinds of token, in place of old pattern matching 
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
seenErr	TokenNameIdentifier	 seen Err
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier	 SPECIAL  PATTERN  NMTOKEN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PATTERN "\\c+" 	TokenNameCOMMENT_LINE	PATTERN "\\c+" 
seenErr	TokenNameIdentifier	 seen Err
=	TokenNameEQUAL	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isValidNmtoken	TokenNameIdentifier	 is Valid Nmtoken
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NAME	TokenNameIdentifier	 SPECIAL  PATTERN  NAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PATTERN "\\i\\c*" 	TokenNameCOMMENT_LINE	PATTERN "\\i\\c*" 
seenErr	TokenNameIdentifier	 seen Err
=	TokenNameEQUAL	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isValidName	TokenNameIdentifier	 is Valid Name
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier	 SPECIAL  PATTERN  NCNAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PATTERN "[\\i-[:]][\\c-[:]]*" 	TokenNameCOMMENT_LINE	PATTERN "[\\i-[:]][\\c-[:]]*" 
seenErr	TokenNameIdentifier	 seen Err
=	TokenNameEQUAL	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isValidNCName	TokenNameIdentifier	 is Valid NC Name
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
seenErr	TokenNameIdentifier	 seen Err
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-datatype-valid.1.2.1"	TokenNameStringLiteral	cvc-datatype-valid.1.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
nvalue	TokenNameIdentifier	 nvalue
,	TokenNameCOMMA	
SPECIAL_PATTERN_STRING	TokenNameIdentifier	 SPECIAL  PATTERN  STRING
[	TokenNameLBRACKET	
fPatternType	TokenNameIdentifier	 f Pattern Type
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
=	TokenNameEQUAL	
nvalue	TokenNameIdentifier	 nvalue
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
avalue	TokenNameIdentifier	 avalue
=	TokenNameEQUAL	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
avalue	TokenNameIdentifier	 avalue
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
=	TokenNameEQUAL	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualType	TokenNameIdentifier	 actual Type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
avalue	TokenNameIdentifier	 avalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
parsedList	TokenNameIdentifier	 parsed List
=	TokenNameEQUAL	
new	TokenNamenew	
StringTokenizer	TokenNameIdentifier	 String Tokenizer
(	TokenNameLPAREN	
nvalue	TokenNameIdentifier	 nvalue
,	TokenNameCOMMA	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
countOfTokens	TokenNameIdentifier	 count Of Tokens
=	TokenNameEQUAL	
parsedList	TokenNameIdentifier	 parsed List
.	TokenNameDOT	
countTokens	TokenNameIdentifier	 count Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
avalue	TokenNameIdentifier	 avalue
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
countOfTokens	TokenNameIdentifier	 count Of Tokens
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isUnion	TokenNameIdentifier	 is Union
=	TokenNameEQUAL	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
;	TokenNameSEMICOLON	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
itemTypes	TokenNameIdentifier	 item Types
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
isUnion	TokenNameIdentifier	 is Union
?	TokenNameQUESTION	
countOfTokens	TokenNameIdentifier	 count Of Tokens
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isUnion	TokenNameIdentifier	 is Union
)	TokenNameRPAREN	
itemTypes	TokenNameIdentifier	 item Types
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
new	TokenNamenew	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
countOfTokens	TokenNameIdentifier	 count Of Tokens
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
countOfTokens	TokenNameIdentifier	 count Of Tokens
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we can't call fItemType.validate(), otherwise checkExtraRules() 	TokenNameCOMMENT_LINE	we can't call fItemType.validate(), otherwise checkExtraRules() 
// will be called twice: once in fItemType.validate, once in 	TokenNameCOMMENT_LINE	will be called twice: once in fItemType.validate, once in 
// validate method of this type. 	TokenNameCOMMENT_LINE	validate method of this type. 
// so we take two steps to get the actual value: 	TokenNameCOMMENT_LINE	so we take two steps to get the actual value: 
// 1. fItemType.getActualValue() 	TokenNameCOMMENT_LINE	1. fItemType.getActualValue() 
// 2. fItemType.chekcFacets() 	TokenNameCOMMENT_LINE	2. fItemType.chekcFacets() 
avalue	TokenNameIdentifier	 avalue
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
parsedList	TokenNameIdentifier	 parsed List
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemType	TokenNameIdentifier	 f Item Type
.	TokenNameDOT	
checkFacets	TokenNameIdentifier	 check Facets
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isUnion	TokenNameIdentifier	 is Union
)	TokenNameRPAREN	
itemTypes	TokenNameIdentifier	 item Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fBuiltInKind	TokenNameIdentifier	 f Built In Kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ListDV	TokenNameIdentifier	 List DV
.	TokenNameDOT	
ListData	TokenNameIdentifier	 List Data
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
new	TokenNamenew	
ListDV	TokenNameIdentifier	 List DV
.	TokenNameDOT	
ListData	TokenNameIdentifier	 List Data
(	TokenNameLPAREN	
avalue	TokenNameIdentifier	 avalue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
=	TokenNameEQUAL	
isUnion	TokenNameIdentifier	 is Union
?	TokenNameQUESTION	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LISTOFUNION_DT	TokenNameIdentifier	 LISTOFUNION  DT
:	TokenNameCOLON	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
=	TokenNameEQUAL	
new	TokenNamenew	
ShortListImpl	TokenNameIdentifier	 Short List Impl
(	TokenNameLPAREN	
itemTypes	TokenNameIdentifier	 item Types
,	TokenNameCOMMA	
itemTypes	TokenNameIdentifier	 item Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
=	TokenNameEQUAL	
nvalue	TokenNameIdentifier	 nvalue
;	TokenNameSEMICOLON	
// Need to set it here or it will become the item type 	TokenNameCOMMENT_LINE	Need to set it here or it will become the item type 
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualType	TokenNameIdentifier	 actual Type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// (fVariety == VARIETY_UNION) 	TokenNameCOMMENT_LINE	(fVariety == VARIETY_UNION) 
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
_content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
content	TokenNameIdentifier	 content
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// we can't call fMemberType[i].validate(), otherwise checkExtraRules() 	TokenNameCOMMENT_LINE	we can't call fMemberType[i].validate(), otherwise checkExtraRules() 
// will be called twice: once in fMemberType[i].validate, once in 	TokenNameCOMMENT_LINE	will be called twice: once in fMemberType[i].validate, once in 
// validate method of this type. 	TokenNameCOMMENT_LINE	validate method of this type. 
// so we take two steps to get the actual value: 	TokenNameCOMMENT_LINE	so we take two steps to get the actual value: 
// 1. fMemberType[i].getActualValue() 	TokenNameCOMMENT_LINE	1. fMemberType[i].getActualValue() 
// 2. fMemberType[i].chekcFacets() 	TokenNameCOMMENT_LINE	2. fMemberType[i].chekcFacets() 
Object	TokenNameIdentifier	 Object
aValue	TokenNameIdentifier	 a Value
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
_content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
validatedInfo	TokenNameIdentifier	 validated Info
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
checkFacets	TokenNameIdentifier	 check Facets
(	TokenNameLPAREN	
validatedInfo	TokenNameIdentifier	 validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
memberType	TokenNameIdentifier	 member Type
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Need to set it here or it will become the member type 	TokenNameCOMMENT_LINE	Need to set it here or it will become the member type 
validatedInfo	TokenNameIdentifier	 validated Info
.	TokenNameDOT	
actualType	TokenNameIdentifier	 actual Type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
aValue	TokenNameIdentifier	 a Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
invalidValue	TokenNameIdentifier	 invalid Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
typesBuffer	TokenNameIdentifier	 types Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
decl	TokenNameIdentifier	 decl
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" | "	TokenNameStringLiteral	 | 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'{'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'}'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
fTypeName	TokenNameIdentifier	 f Type Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
fEnumeration	TokenNameIdentifier	 f Enumeration
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" : "	TokenNameStringLiteral	 : 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
decl	TokenNameIdentifier	 decl
.	TokenNameDOT	
appendEnumString	TokenNameIdentifier	 append Enum String
(	TokenNameLPAREN	
typesBuffer	TokenNameIdentifier	 types Buffer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
(	TokenNameLPAREN	
"cvc-datatype-valid.1.2.3"	TokenNameStringLiteral	cvc-datatype-valid.1.2.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fTypeName	TokenNameIdentifier	 f Type Name
,	TokenNameCOMMA	
typesBuffer	TokenNameIdentifier	 types Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//getActualValue() 	TokenNameCOMMENT_LINE	getActualValue() 
public	TokenNamepublic	
boolean	TokenNameboolean	
isEqual	TokenNameIdentifier	 is Equal
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
value1	TokenNameIdentifier	 value1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
value1	TokenNameIdentifier	 value1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//isEqual() 	TokenNameCOMMENT_LINE	isEqual() 
// determine whether the two values are identical 	TokenNameCOMMENT_LINE	determine whether the two values are identical 
public	TokenNamepublic	
boolean	TokenNameboolean	
isIdentical	TokenNameIdentifier	 is Identical
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
value1	TokenNameIdentifier	 value1
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fDVs	TokenNameIdentifier	 f D Vs
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
.	TokenNameDOT	
isIdentical	TokenNameIdentifier	 is Identical
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
,	TokenNameCOMMA	
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//isIdentical() 	TokenNameCOMMENT_LINE	isIdentical() 
// normalize the string according to the whiteSpace facet 	TokenNameCOMMENT_LINE	normalize the string according to the whiteSpace facet 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
short	TokenNameshort	
ws	TokenNameIdentifier	 ws
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ws	TokenNameIdentifier	 ws
==	TokenNameEQUAL_EQUAL	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
)	TokenNameRPAREN	
return	TokenNamereturn	
content	TokenNameIdentifier	 content
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ws	TokenNameIdentifier	 ws
==	TokenNameEQUAL_EQUAL	
WS_REPLACE	TokenNameIdentifier	 WS  REPLACE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
// when it's replace, just replace #x9, #xa, #xd by #x20 	TokenNameCOMMENT_LINE	when it's replace, just replace #x9, #xa, #xd by #x20 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x9	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xa	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xd	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isLeading	TokenNameIdentifier	 is Leading
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// when it's collapse 	TokenNameCOMMENT_LINE	when it's collapse 
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// append real characters, so we passed leading ws 	TokenNameCOMMENT_LINE	append real characters, so we passed leading ws 
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x9	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xa	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xd	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isLeading	TokenNameIdentifier	 is Leading
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// for whitespaces, we skip all following ws 	TokenNameCOMMENT_LINE	for whitespaces, we skip all following ws 
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x9	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xa	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xd	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if it's not a leading or tailing ws, then append a space 	TokenNameCOMMENT_LINE	if it's not a leading or tailing ws, then append a space 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isLeading	TokenNameIdentifier	 is Leading
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// normalize the string according to the whiteSpace facet 	TokenNameCOMMENT_LINE	normalize the string according to the whiteSpace facet 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
short	TokenNameshort	
ws	TokenNameIdentifier	 ws
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// If pattern is not defined, we can skip some of the normalization. 	TokenNameCOMMENT_LINE	If pattern is not defined, we can skip some of the normalization. 
// Otherwise we have to normalize the data for correct result of 	TokenNameCOMMENT_LINE	Otherwise we have to normalize the data for correct result of 
// pattern validation. 	TokenNameCOMMENT_LINE	pattern validation. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
norm_type	TokenNameIdentifier	 norm type
=	TokenNameEQUAL	
fDVNormalizeType	TokenNameIdentifier	 f DV Normalize Type
[	TokenNameLBRACKET	
fValidationDV	TokenNameIdentifier	 f Validation DV
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
norm_type	TokenNameIdentifier	 norm type
==	TokenNameEQUAL_EQUAL	
NORMALIZE_NONE	TokenNameIdentifier	 NORMALIZE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
norm_type	TokenNameIdentifier	 norm type
==	TokenNameEQUAL_EQUAL	
NORMALIZE_TRIM	TokenNameIdentifier	 NORMALIZE  TRIM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
instanceof	TokenNameinstanceof	
StringBuffer	TokenNameIdentifier	 String Buffer
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
strContent	TokenNameIdentifier	 str Content
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
strContent	TokenNameIdentifier	 str Content
,	TokenNameCOMMA	
ws	TokenNameIdentifier	 ws
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
(	TokenNameLPAREN	
StringBuffer	TokenNameIdentifier	 String Buffer
)	TokenNameRPAREN	
content	TokenNameIdentifier	 content
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ws	TokenNameIdentifier	 ws
==	TokenNameEQUAL_EQUAL	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
)	TokenNameRPAREN	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ws	TokenNameIdentifier	 ws
==	TokenNameEQUAL_EQUAL	
WS_REPLACE	TokenNameIdentifier	 WS  REPLACE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
// when it's replace, just replace #x9, #xa, #xd by #x20 	TokenNameCOMMENT_LINE	when it's replace, just replace #x9, #xa, #xd by #x20 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0x9	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0xa	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0xd	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
setCharAt	TokenNameIdentifier	 set Char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isLeading	TokenNameIdentifier	 is Leading
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// when it's collapse 	TokenNameCOMMENT_LINE	when it's collapse 
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// append real characters, so we passed leading ws 	TokenNameCOMMENT_LINE	append real characters, so we passed leading ws 
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x9	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xa	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xd	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
setCharAt	TokenNameIdentifier	 set Char At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
,	TokenNameCOMMA	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isLeading	TokenNameIdentifier	 is Leading
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// for whitespaces, we skip all following ws 	TokenNameCOMMENT_LINE	for whitespaces, we skip all following ws 
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x9	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xa	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0xd	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
!=	TokenNameNOT_EQUAL	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if it's not a leading or tailing ws, then append a space 	TokenNameCOMMENT_LINE	if it's not a leading or tailing ws, then append a space 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isLeading	TokenNameIdentifier	 is Leading
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
setCharAt	TokenNameIdentifier	 set Char At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
0x20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
whiteSpaceValue	TokenNameIdentifier	 white Space Value
(	TokenNameLPAREN	
short	TokenNameshort	
ws	TokenNameIdentifier	 ws
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
WS_FACET_STRING	TokenNameIdentifier	 WS  FACET  STRING
[	TokenNameLBRACKET	
ws	TokenNameIdentifier	 ws
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fundamental Facet: ordered. */	TokenNameCOMMENT_JAVADOC	 Fundamental Facet: ordered. 
public	TokenNamepublic	
short	TokenNameshort	
getOrdered	TokenNameIdentifier	 get Ordered
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fOrdered	TokenNameIdentifier	 f Ordered
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fundamental Facet: bounded. */	TokenNameCOMMENT_JAVADOC	 Fundamental Facet: bounded. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getBounded	TokenNameIdentifier	 get Bounded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fBounded	TokenNameIdentifier	 f Bounded
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fundamental Facet: cardinality. */	TokenNameCOMMENT_JAVADOC	 Fundamental Facet: cardinality. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getFinite	TokenNameIdentifier	 get Finite
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fFinite	TokenNameIdentifier	 f Finite
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fundamental Facet: numeric. */	TokenNameCOMMENT_JAVADOC	 Fundamental Facet: numeric. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getNumeric	TokenNameIdentifier	 get Numeric
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fNumeric	TokenNameIdentifier	 f Numeric
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method. [Facets]: check whether a facet is defined on this * type. * @param facetName The name of the facet. * @return True if the facet is defined, false otherwise. */	TokenNameCOMMENT_JAVADOC	 Convenience method. [Facets]: check whether a facet is defined on this type. @param facetName The name of the facet. @return True if the facet is defined, false otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isDefinedFacet	TokenNameIdentifier	 is Defined Facet
(	TokenNameLPAREN	
short	TokenNameshort	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
facetName	TokenNameIdentifier	 facet Name
==	TokenNameEQUAL_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
facetName	TokenNameIdentifier	 facet Name
==	TokenNameEQUAL_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
||	TokenNameOR_OR	
facetName	TokenNameIdentifier	 facet Name
==	TokenNameEQUAL_EQUAL	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * [facets]: all facets defined on this type. The value is a bit * combination of FACET_XXX constants of all defined facets. */	TokenNameCOMMENT_JAVADOC	 [facets]: all facets defined on this type. The value is a bit combination of FACET_XXX constants of all defined facets. 
public	TokenNamepublic	
short	TokenNameshort	
getDefinedFacets	TokenNameIdentifier	 get Defined Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FACET_NONE	TokenNameIdentifier	 FACET  NONE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|	TokenNameOR	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
|	TokenNameOR	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
|	TokenNameOR	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method. [Facets]: check whether a facet is defined and * fixed on this type. * @param facetName The name of the facet. * @return True if the facet is fixed, false otherwise. */	TokenNameCOMMENT_JAVADOC	 Convenience method. [Facets]: check whether a facet is defined and fixed on this type. @param facetName The name of the facet. @return True if the facet is fixed, false otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isFixedFacet	TokenNameIdentifier	 is Fixed Facet
(	TokenNameLPAREN	
short	TokenNameshort	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
return	TokenNamereturn	
facetName	TokenNameIdentifier	 facet Name
==	TokenNameEQUAL_EQUAL	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * [facets]: all defined facets for this type which are fixed. */	TokenNameCOMMENT_JAVADOC	 [facets]: all defined facets for this type which are fixed. 
public	TokenNamepublic	
short	TokenNameshort	
getFixedFacets	TokenNameIdentifier	 get Fixed Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
|	TokenNameOR	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method. Returns a value of a single constraining facet for * this simple type definition. This method must not be used to retrieve * values for <code>enumeration</code> and <code>pattern</code> facets. * @param facetName The name of the facet, i.e. * <code>FACET_LENGTH, FACET_TOTALDIGITS </code> (see * <code>XSConstants</code>). To retrieve the value for a pattern or * an enumeration, see <code>enumeration</code> and * <code>pattern</code>. * @return A value of the facet specified in <code>facetName</code> for * this simple type definition or <code>null</code>. */	TokenNameCOMMENT_JAVADOC	 Convenience method. Returns a value of a single constraining facet for this simple type definition. This method must not be used to retrieve values for <code>enumeration</code> and <code>pattern</code> facets. @param facetName The name of the facet, i.e. <code>FACET_LENGTH, FACET_TOTALDIGITS </code> (see <code>XSConstants</code>). To retrieve the value for a pattern or an enumeration, see <code>enumeration</code> and <code>pattern</code>. @return A value of the facet specified in <code>facetName</code> for this simple type definition or <code>null</code>. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLexicalFacetValue	TokenNameIdentifier	 get Lexical Facet Value
(	TokenNameLPAREN	
short	TokenNameshort	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
facetName	TokenNameIdentifier	 facet Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
WS_FACET_STRING	TokenNameIdentifier	 WS  FACET  STRING
[	TokenNameLBRACKET	
fWhiteSpace	TokenNameIdentifier	 f White Space
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"0"	TokenNameStringLiteral	0
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of enumeration values if it exists, otherwise an empty * <code>StringList</code>. */	TokenNameCOMMENT_JAVADOC	 A list of enumeration values if it exists, otherwise an empty <code>StringList</code>. 
public	TokenNamepublic	
StringList	TokenNameIdentifier	 String List
getLexicalEnumeration	TokenNameIdentifier	 get Lexical Enumeration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fLexicalEnumeration	TokenNameIdentifier	 f Lexical Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
StringListImpl	TokenNameIdentifier	 String List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
;	TokenNameSEMICOLON	
fLexicalEnumeration	TokenNameIdentifier	 f Lexical Enumeration
=	TokenNameEQUAL	
new	TokenNamenew	
StringListImpl	TokenNameIdentifier	 String List Impl
(	TokenNameLPAREN	
strs	TokenNameIdentifier	 strs
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fLexicalEnumeration	TokenNameIdentifier	 f Lexical Enumeration
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of actual enumeration values if it exists, otherwise an empty * <code>ObjectList</code>. */	TokenNameCOMMENT_JAVADOC	 A list of actual enumeration values if it exists, otherwise an empty <code>ObjectList</code>. 
public	TokenNamepublic	
ObjectList	TokenNameIdentifier	 Object List
getActualEnumeration	TokenNameIdentifier	 get Actual Enumeration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fActualEnumeration	TokenNameIdentifier	 f Actual Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fActualEnumeration	TokenNameIdentifier	 f Actual Enumeration
=	TokenNameEQUAL	
new	TokenNamenew	
AbstractObjectList	TokenNameIdentifier	 Abstract Object List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
item	TokenNameIdentifier	 item
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
item	TokenNameIdentifier	 item
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
getActualValue	TokenNameIdentifier	 get Actual Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fActualEnumeration	TokenNameIdentifier	 f Actual Enumeration
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of enumeration type values (as a list of ShortList objects) if it exists, otherwise returns * null */	TokenNameCOMMENT_JAVADOC	 A list of enumeration type values (as a list of ShortList objects) if it exists, otherwise returns null 
public	TokenNamepublic	
ObjectList	TokenNameIdentifier	 Object List
getEnumerationItemTypeList	TokenNameIdentifier	 get Enumeration Item Type List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumerationItemTypeList	TokenNameIdentifier	 f Enumeration Item Type List
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEnumerationItemTypeList	TokenNameIdentifier	 f Enumeration Item Type List
=	TokenNameEQUAL	
new	TokenNamenew	
AbstractObjectList	TokenNameIdentifier	 Abstract Object List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
item	TokenNameIdentifier	 item
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
(	TokenNameLPAREN	
item	TokenNameIdentifier	 item
instanceof	TokenNameinstanceof	
ShortList	TokenNameIdentifier	 Short List
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
==	TokenNameEQUAL_EQUAL	
item	TokenNameIdentifier	 item
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEnumerationItemTypeList	TokenNameIdentifier	 f Enumeration Item Type List
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ShortList	TokenNameIdentifier	 Short List
getEnumerationTypeList	TokenNameIdentifier	 get Enumeration Type List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumerationTypeList	TokenNameIdentifier	 f Enumeration Type List
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ShortListImpl	TokenNameIdentifier	 Short List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEnumerationTypeList	TokenNameIdentifier	 f Enumeration Type List
=	TokenNameEQUAL	
new	TokenNamenew	
ShortListImpl	TokenNameIdentifier	 Short List Impl
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
,	TokenNameCOMMA	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fEnumerationTypeList	TokenNameIdentifier	 f Enumeration Type List
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of pattern values if it exists, otherwise an empty * <code>StringList</code>. */	TokenNameCOMMENT_JAVADOC	 A list of pattern values if it exists, otherwise an empty <code>StringList</code>. 
public	TokenNamepublic	
StringList	TokenNameIdentifier	 String List
getLexicalPattern	TokenNameIdentifier	 get Lexical Pattern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
&&	TokenNameAND_AND	
fPatternStr	TokenNameIdentifier	 f Pattern Str
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
StringListImpl	TokenNameIdentifier	 String List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fLexicalPattern	TokenNameIdentifier	 f Lexical Pattern
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fPatternStr	TokenNameIdentifier	 f Pattern Str
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
strs	TokenNameIdentifier	 strs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier	 SPECIAL  PATTERN  NMTOKEN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
"\c+"	TokenNameStringLiteral	\c+
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NAME	TokenNameIdentifier	 SPECIAL  PATTERN  NAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
"\i\c*"	TokenNameStringLiteral	\i\c*
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fPatternType	TokenNameIdentifier	 f Pattern Type
==	TokenNameEQUAL_EQUAL	
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier	 SPECIAL  PATTERN  NCNAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
"\i\c*"	TokenNameStringLiteral	\i\c*
;	TokenNameSEMICOLON	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
"[\i-[:]][\c-[:]]*"	TokenNameStringLiteral	[\i-[:]][\c-[:]]*
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
"[\-+]?[0-9]+"	TokenNameStringLiteral	[\-+]?[0-9]+
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
strs	TokenNameIdentifier	 strs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
strs	TokenNameIdentifier	 strs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fPatternStr	TokenNameIdentifier	 f Pattern Str
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLexicalPattern	TokenNameIdentifier	 f Lexical Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
StringListImpl	TokenNameIdentifier	 String List Impl
(	TokenNameLPAREN	
strs	TokenNameIdentifier	 strs
,	TokenNameCOMMA	
strs	TokenNameIdentifier	 strs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fLexicalPattern	TokenNameIdentifier	 f Lexical Pattern
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * [annotations]: a set of annotations for this simple type component if * it exists, otherwise an empty <code>XSObjectList</code>. */	TokenNameCOMMENT_JAVADOC	 [annotations]: a set of annotations for this simple type component if it exists, otherwise an empty <code>XSObjectList</code>. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getAnnotations	TokenNameIdentifier	 get Annotations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fAnnotations	TokenNameIdentifier	 f Annotations
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
calcFundamentalFacets	TokenNameIdentifier	 calc Fundamental Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setOrdered	TokenNameIdentifier	 set Ordered
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setNumeric	TokenNameIdentifier	 set Numeric
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setBounded	TokenNameIdentifier	 set Bounded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setCardinality	TokenNameIdentifier	 set Cardinality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
setOrdered	TokenNameIdentifier	 set Ordered
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// When {variety} is atomic, {value} is inherited from {value} of {base type definition}. For all "primitive" types {value} is as specified in the table in Fundamental Facets (C.1). 	TokenNameCOMMENT_LINE	When {variety} is atomic, {value} is inherited from {value} of {base type definition}. For all "primitive" types {value} is as specified in the table in Fundamental Facets (C.1). 
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// When {variety} is list, {value} is false. 	TokenNameCOMMENT_LINE	When {variety} is list, {value} is false. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// When {variety} is union, the {value} is partial unless one of the following: 	TokenNameCOMMENT_LINE	When {variety} is union, the {value} is partial unless one of the following: 
// 1. If every member of {member type definitions} is derived from a common ancestor other than the simple ur-type, then {value} is the same as that ancestor's ordered facet. 	TokenNameCOMMENT_LINE	1. If every member of {member type definitions} is derived from a common ancestor other than the simple ur-type, then {value} is the same as that ancestor's ordered facet. 
// 2. If every member of {member type definitions} has a {value} of false for the ordered facet, then {value} is false. 	TokenNameCOMMENT_LINE	2. If every member of {member type definitions} has a {value} of false for the ordered facet, then {value} is false. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
// REVISIT: is the length possible to be 0? 	TokenNameCOMMENT_LINE	REVISIT: is the length possible to be 0? 
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
ORDERED_PARTIAL	TokenNameIdentifier	 ORDERED  PARTIAL
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we need to process the first member type before entering the loop 	TokenNameCOMMENT_LINE	we need to process the first member type before entering the loop 
short	TokenNameshort	
ancestorId	TokenNameIdentifier	 ancestor Id
=	TokenNameEQUAL	
getPrimitiveDV	TokenNameIdentifier	 get Primitive DV
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
commonAnc	TokenNameIdentifier	 common Anc
=	TokenNameEQUAL	
ancestorId	TokenNameIdentifier	 ancestor Id
!=	TokenNameNOT_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
allFalse	TokenNameIdentifier	 all False
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
==	TokenNameEQUAL_EQUAL	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
;	TokenNameSEMICOLON	
// for the other member types, check whether the value is false 	TokenNameCOMMENT_LINE	for the other member types, check whether the value is false 
// and whether they have the same ancestor as the first one 	TokenNameCOMMENT_LINE	and whether they have the same ancestor as the first one 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fMemberTypes	TokenNameIdentifier	 f Member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
commonAnc	TokenNameIdentifier	 common Anc
||	TokenNameOR_OR	
allFalse	TokenNameIdentifier	 all False
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
commonAnc	TokenNameIdentifier	 common Anc
)	TokenNameRPAREN	
commonAnc	TokenNameIdentifier	 common Anc
=	TokenNameEQUAL	
ancestorId	TokenNameIdentifier	 ancestor Id
==	TokenNameEQUAL_EQUAL	
getPrimitiveDV	TokenNameIdentifier	 get Primitive DV
(	TokenNameLPAREN	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
allFalse	TokenNameIdentifier	 all False
)	TokenNameRPAREN	
allFalse	TokenNameIdentifier	 all False
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
==	TokenNameEQUAL_EQUAL	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
commonAnc	TokenNameIdentifier	 common Anc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: all member types should have the same ordered value 	TokenNameCOMMENT_LINE	REVISIT: all member types should have the same ordered value 
// just use the first one. Can we assume this? 	TokenNameCOMMENT_LINE	just use the first one. Can we assume this? 
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
allFalse	TokenNameIdentifier	 all False
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fOrdered	TokenNameIdentifier	 f Ordered
=	TokenNameEQUAL	
ORDERED_PARTIAL	TokenNameIdentifier	 ORDERED  PARTIAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//setOrdered 	TokenNameCOMMENT_LINE	setOrdered 
private	TokenNameprivate	
void	TokenNamevoid	
setNumeric	TokenNameIdentifier	 set Numeric
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
=	TokenNameEQUAL	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getNumeric	TokenNameIdentifier	 get Numeric
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fNumeric	TokenNameIdentifier	 f Numeric
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//setNumeric 	TokenNameCOMMENT_LINE	setNumeric 
private	TokenNameprivate	
void	TokenNamevoid	
setBounded	TokenNameIdentifier	 set Bounded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
short	TokenNameshort	
ancestorId	TokenNameIdentifier	 ancestor Id
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestorId	TokenNameIdentifier	 ancestor Id
=	TokenNameEQUAL	
getPrimitiveDV	TokenNameIdentifier	 get Primitive DV
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounded	TokenNameIdentifier	 get Bounded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorId	TokenNameIdentifier	 ancestor Id
!=	TokenNameNOT_EQUAL	
getPrimitiveDV	TokenNameIdentifier	 get Primitive DV
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fBounded	TokenNameIdentifier	 f Bounded
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//setBounded 	TokenNameCOMMENT_LINE	setBounded 
private	TokenNameprivate	
boolean	TokenNameboolean	
specialCardinalityCheck	TokenNameIdentifier	 special Cardinality Check
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_DATE	TokenNameIdentifier	 DV  DATE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_GYEARMONTH	TokenNameIdentifier	 DV  GYEARMONTH
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_GYEAR	TokenNameIdentifier	 DV  GYEAR
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_GMONTHDAY	TokenNameIdentifier	 DV  GMONTHDAY
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_GDAY	TokenNameIdentifier	 DV  GDAY
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
DV_GMONTH	TokenNameIdentifier	 DV  GMONTH
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//specialCardinalityCheck() 	TokenNameCOMMENT_LINE	specialCardinalityCheck() 
private	TokenNameprivate	
void	TokenNamevoid	
setCardinality	TokenNameIdentifier	 set Cardinality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBase	TokenNameIdentifier	 f Base
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// (!fBase.fFinite) 	TokenNameCOMMENT_LINE	(!fBase.fFinite) 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
specialCardinalityCheck	TokenNameIdentifier	 special Cardinality Check
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fVariety	TokenNameIdentifier	 f Variety
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
fMemberTypes	TokenNameIdentifier	 f Member Types
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getFinite	TokenNameIdentifier	 get Finite
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fFinite	TokenNameIdentifier	 f Finite
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//setCardinality 	TokenNameCOMMENT_LINE	setCardinality 
private	TokenNameprivate	
short	TokenNameshort	
getPrimitiveDV	TokenNameIdentifier	 get Primitive DV
(	TokenNameLPAREN	
short	TokenNameshort	
validationDV	TokenNameIdentifier	 validation DV
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_ID	TokenNameIdentifier	 DV  ID
||	TokenNameOR_OR	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_IDREF	TokenNameIdentifier	 DV  IDREF
||	TokenNameOR_OR	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_ENTITY	TokenNameIdentifier	 DV  ENTITY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_STRING	TokenNameIdentifier	 DV  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_DECIMAL	TokenNameIdentifier	 DV  DECIMAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_1_1_SUPPORT	TokenNameIdentifier	 SCHEMA 1 1  SUPPORT
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_YEARMONTHDURATION	TokenNameIdentifier	 DV  YEARMONTHDURATION
||	TokenNameOR_OR	
validationDV	TokenNameIdentifier	 validation DV
==	TokenNameEQUAL_EQUAL	
DV_DAYTIMEDURATION	TokenNameIdentifier	 DV  DAYTIMEDURATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DV_DURATION	TokenNameIdentifier	 DV  DURATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
validationDV	TokenNameIdentifier	 validation DV
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//getPrimitiveDV() 	TokenNameCOMMENT_LINE	getPrimitiveDV() 
public	TokenNamepublic	
boolean	TokenNameboolean	
derivedFromType	TokenNameIdentifier	 derived From Type
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
ancestor	TokenNameIdentifier	 ancestor
,	TokenNameCOMMA	
short	TokenNameshort	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: implement according to derivation 	TokenNameCOMMENT_LINE	REVISIT: implement according to derivation 
// ancestor is null, return false 	TokenNameCOMMENT_LINE	ancestor is null, return false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestor	TokenNameIdentifier	 ancestor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// extract the actual XSTypeDefinition if the given ancestor is a delegate. 	TokenNameCOMMENT_LINE	extract the actual XSTypeDefinition if the given ancestor is a delegate. 
while	TokenNamewhile	
(	TokenNameLPAREN	
ancestor	TokenNameIdentifier	 ancestor
instanceof	TokenNameinstanceof	
XSSimpleTypeDelegate	TokenNameIdentifier	 XS Simple Type Delegate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestor	TokenNameIdentifier	 ancestor
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDelegate	TokenNameIdentifier	 XS Simple Type Delegate
)	TokenNameRPAREN	
ancestor	TokenNameIdentifier	 ancestor
)	TokenNameRPAREN	
.	TokenNameDOT	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
// anyType is the only type whose base type is itself 	TokenNameCOMMENT_LINE	anyType is the only type whose base type is itself 
if	TokenNameif	
(	TokenNameLPAREN	
ancestor	TokenNameIdentifier	 ancestor
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ancestor	TokenNameIdentifier	 ancestor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// recursively get base, and compare it with ancestor 	TokenNameCOMMENT_LINE	recursively get base, and compare it with ancestor 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
ancestor	TokenNameIdentifier	 ancestor
&&	TokenNameAND_AND	
// compare with ancestor 	TokenNameCOMMENT_LINE	compare with ancestor 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reached anySimpleType 	TokenNameCOMMENT_LINE	reached anySimpleType 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
ancestor	TokenNameIdentifier	 ancestor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
derivedFrom	TokenNameIdentifier	 derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
short	TokenNameshort	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: implement according to derivation 	TokenNameCOMMENT_LINE	REVISIT: implement according to derivation 
// ancestor is null, retur false 	TokenNameCOMMENT_LINE	ancestor is null, retur false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
if	TokenNameif	
(	TokenNameLPAREN	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ANY_TYPE	TokenNameIdentifier	 ANY  TYPE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// recursively get base, and compare it with ancestor 	TokenNameCOMMENT_LINE	recursively get base, and compare it with ancestor 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
// compare with ancestor 	TokenNameCOMMENT_LINE	compare with ancestor 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reached anySimpleType 	TokenNameCOMMENT_LINE	reached anySimpleType 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by restriction, given the name * and namespace. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param derivationMethod * The derivation method * * @return boolean True if the ancestor type is derived from the reference type by the specifiied derivation method. */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by restriction, given the name and namespace. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param derivationMethod The derivation method * @return boolean True if the ancestor type is derived from the reference type by the specifiied derivation method. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ancestor is null, return false 	TokenNameCOMMENT_LINE	ancestor is null, return false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
if	TokenNameif	
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
==	TokenNameEQUAL_EQUAL	
DERIVATION_ANY	TokenNameIdentifier	 DERIVATION  ANY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// restriction 	TokenNameCOMMENT_LINE	restriction 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// list 	TokenNameCOMMENT_LINE	list 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByList	TokenNameIdentifier	 is Derived By List
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// union 	TokenNameCOMMENT_LINE	union 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByUnion	TokenNameIdentifier	 is Derived By Union
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// extension 	TokenNameCOMMENT_LINE	extension 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the value of the parameter is 0 i.e. no bit (corresponding to 	TokenNameCOMMENT_LINE	If the value of the parameter is 0 i.e. no bit (corresponding to 
// restriction, list, extension or union) is set to 1 for the 	TokenNameCOMMENT_LINE	restriction, list, extension or union) is set to 1 for the 
// derivationMethod parameter. 	TokenNameCOMMENT_LINE	derivationMethod parameter. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isDerivedByAny	TokenNameIdentifier	 is Derived By Any
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by any combination of restriction, list ir union. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param type * The reference type definition * * @return boolean True if the type is derived by restriciton for the reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by any combination of restriction, list ir union. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param type The reference type definition * @return boolean True if the type is derived by restriciton for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByAny	TokenNameIdentifier	 is Derived By Any
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
derivedFrom	TokenNameIdentifier	 derived From
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// for each base, item or member type 	TokenNameCOMMENT_LINE	for each base, item or member type 
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
oldType	TokenNameIdentifier	 old Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If the ancestor type is reached or is the same as this type. 	TokenNameCOMMENT_LINE	If the ancestor type is reached or is the same as this type. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
derivedFrom	TokenNameIdentifier	 derived From
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check if derived by restriction or list or union 	TokenNameCOMMENT_LINE	check if derived by restriction or list or union 
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByList	TokenNameIdentifier	 is Derived By List
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByUnion	TokenNameIdentifier	 is Derived By Union
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
// get the base, item or member type depending on the variety 	TokenNameCOMMENT_LINE	get the base, item or member type depending on the variety 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_ABSENT	TokenNameIdentifier	 VARIETY  ABSENT
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isDerivedByAny	TokenNameIdentifier	 is Derived By Any
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getItemType	TokenNameIdentifier	 get Item Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
derivedFrom	TokenNameIdentifier	 derived From
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * DOM Level 3 * Checks if a type is derived from another by restriction. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param type * The reference type definition * * @return boolean True if the type is derived by restriciton for the * reference type */	TokenNameCOMMENT_JAVADOC	 DOM Level 3 Checks if a type is derived from another by restriction. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param type The reference type definition * @return boolean True if the type is derived by restriciton for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
oldType	TokenNameIdentifier	 old Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by list. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param type * The reference type definition * * @return boolean True if the type is derived by list for the reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by list. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param type The reference type definition * @return boolean True if the type is derived by list for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByList	TokenNameIdentifier	 is Derived By List
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If the variety is union 	TokenNameCOMMENT_LINE	If the variety is union 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the {item type} 	TokenNameCOMMENT_LINE	get the {item type} 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
itemType	TokenNameIdentifier	 item Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getItemType	TokenNameIdentifier	 get Item Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// T2 is the {item type definition} 	TokenNameCOMMENT_LINE	T2 is the {item type definition} 
if	TokenNameif	
(	TokenNameLPAREN	
itemType	TokenNameIdentifier	 item Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// T2 is derived from the other type definition by DERIVATION_RESTRICTION 	TokenNameCOMMENT_LINE	T2 is derived from the other type definition by DERIVATION_RESTRICTION 
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
itemType	TokenNameIdentifier	 item Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by union. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param type * The reference type definition * * @return boolean True if the type is derived by union for the reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by union. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param type The reference type definition * @return boolean True if the type is derived by union for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByUnion	TokenNameIdentifier	 is Derived By Union
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If the variety is union 	TokenNameCOMMENT_LINE	If the variety is union 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get member types 	TokenNameCOMMENT_LINE	get member types 
XSObjectList	TokenNameIdentifier	 XS Object List
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// One of the {member type definitions} is T2. 	TokenNameCOMMENT_LINE	One of the {member type definitions} is T2. 
if	TokenNameif	
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// T2 is derived from the other type definition by DERIVATION_RESTRICTION 	TokenNameCOMMENT_LINE	T2 is derived from the other type definition by DERIVATION_RESTRICTION 
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
)	TokenNameRPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
=	TokenNameEQUAL	
new	TokenNamenew	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
"anySimpleType"	TokenNameStringLiteral	anySimpleType
,	TokenNameCOMMA	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
,	TokenNameCOMMA	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ANYSIMPLETYPE_DT	TokenNameIdentifier	 ANYSIMPLETYPE  DT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
fAnyAtomicType	TokenNameIdentifier	 f Any Atomic Type
=	TokenNameEQUAL	
new	TokenNamenew	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
(	TokenNameLPAREN	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
,	TokenNameCOMMA	
"anyAtomicType"	TokenNameStringLiteral	anyAtomicType
,	TokenNameCOMMA	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
,	TokenNameCOMMA	
ORDERED_FALSE	TokenNameIdentifier	 ORDERED  FALSE
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
.	TokenNameDOT	
ANYATOMICTYPE_DT	TokenNameIdentifier	 ANYATOMICTYPE  DT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Validation context used to validate facet values. */	TokenNameCOMMENT_JAVADOC	 Validation context used to validate facet values. 
static	TokenNamestatic	
final	TokenNamefinal	
ValidationContext	TokenNameIdentifier	 Validation Context
fDummyContext	TokenNameIdentifier	 f Dummy Context
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationContext	TokenNameIdentifier	 Validation Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needExtraChecking	TokenNameIdentifier	 need Extra Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
useNamespaces	TokenNameIdentifier	 use Namespaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityDeclared	TokenNameIdentifier	 is Entity Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityUnparsed	TokenNameIdentifier	 is Entity Unparsed
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIdDeclared	TokenNameIdentifier	 is Id Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addId	TokenNameIdentifier	 add Id
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addIdRef	TokenNameIdentifier	 add Id Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSymbol	TokenNameIdentifier	 get Symbol
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
symbol	TokenNameIdentifier	 symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
symbol	TokenNameIdentifier	 symbol
.	TokenNameDOT	
intern	TokenNameIdentifier	 intern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Locale	TokenNameIdentifier	 Locale
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fAnonymous	TokenNameIdentifier	 f Anonymous
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * A wrapper of ValidationContext, to provide a way of switching to a * different Namespace declaration context. */	TokenNameCOMMENT_JAVADOC	 A wrapper of ValidationContext, to provide a way of switching to a different Namespace declaration context. 
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
ValidationContextImpl	TokenNameIdentifier	 Validation Context Impl
implements	TokenNameimplements	
ValidationContext	TokenNameIdentifier	 Validation Context
{	TokenNameLBRACE	
final	TokenNamefinal	
ValidationContext	TokenNameIdentifier	 Validation Context
fExternal	TokenNameIdentifier	 f External
;	TokenNameSEMICOLON	
ValidationContextImpl	TokenNameIdentifier	 Validation Context Impl
(	TokenNameLPAREN	
ValidationContext	TokenNameIdentifier	 Validation Context
external	TokenNameIdentifier	 external
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExternal	TokenNameIdentifier	 f External
=	TokenNameEQUAL	
external	TokenNameIdentifier	 external
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
NamespaceContext	TokenNameIdentifier	 Namespace Context
fNSContext	TokenNameIdentifier	 f NS Context
;	TokenNameSEMICOLON	
void	TokenNamevoid	
setNSContext	TokenNameIdentifier	 set NS Context
(	TokenNameLPAREN	
NamespaceContext	TokenNameIdentifier	 Namespace Context
nsContext	TokenNameIdentifier	 ns Context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNSContext	TokenNameIdentifier	 f NS Context
=	TokenNameEQUAL	
nsContext	TokenNameIdentifier	 ns Context
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
needFacetChecking	TokenNameIdentifier	 need Facet Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needExtraChecking	TokenNameIdentifier	 need Extra Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
needExtraChecking	TokenNameIdentifier	 need Extra Checking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
needToNormalize	TokenNameIdentifier	 need To Normalize
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// schema validation is predicated upon namespaces 	TokenNameCOMMENT_LINE	schema validation is predicated upon namespaces 
public	TokenNamepublic	
boolean	TokenNameboolean	
useNamespaces	TokenNameIdentifier	 use Namespaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityDeclared	TokenNameIdentifier	 is Entity Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
isEntityDeclared	TokenNameIdentifier	 is Entity Declared
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEntityUnparsed	TokenNameIdentifier	 is Entity Unparsed
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
isEntityUnparsed	TokenNameIdentifier	 is Entity Unparsed
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIdDeclared	TokenNameIdentifier	 is Id Declared
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
isIdDeclared	TokenNameIdentifier	 is Id Declared
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addId	TokenNameIdentifier	 add Id
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
addId	TokenNameIdentifier	 add Id
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addIdRef	TokenNameIdentifier	 add Id Ref
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
addIdRef	TokenNameIdentifier	 add Id Ref
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getSymbol	TokenNameIdentifier	 get Symbol
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
symbol	TokenNameIdentifier	 symbol
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
getSymbol	TokenNameIdentifier	 get Symbol
(	TokenNameLPAREN	
symbol	TokenNameIdentifier	 symbol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNSContext	TokenNameIdentifier	 f NS Context
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
fNSContext	TokenNameIdentifier	 f NS Context
.	TokenNameDOT	
getURI	TokenNameIdentifier	 get URI
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Locale	TokenNameIdentifier	 Locale
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fExternal	TokenNameIdentifier	 f External
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if it's immutable, can't be reset: 	TokenNameCOMMENT_LINE	if it's immutable, can't be reset: 
if	TokenNameif	
(	TokenNameLPAREN	
fIsImmutable	TokenNameIdentifier	 f Is Immutable
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
fItemType	TokenNameIdentifier	 f Item Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fMemberTypes	TokenNameIdentifier	 f Member Types
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fTypeName	TokenNameIdentifier	 f Type Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fFinalSet	TokenNameIdentifier	 f Final Set
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fBase	TokenNameIdentifier	 f Base
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fVariety	TokenNameIdentifier	 f Variety
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fValidationDV	TokenNameIdentifier	 f Validation DV
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//for constraining facets 	TokenNameCOMMENT_LINE	for constraining facets 
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fMinLength	TokenNameIdentifier	 f Min Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fMaxLength	TokenNameIdentifier	 f Max Length
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fTotalDigits	TokenNameIdentifier	 f Total Digits
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fPattern	TokenNameIdentifier	 f Pattern
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fPatternStr	TokenNameIdentifier	 f Pattern Str
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fEnumeration	TokenNameIdentifier	 f Enumeration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLexicalPattern	TokenNameIdentifier	 f Lexical Pattern
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLexicalEnumeration	TokenNameIdentifier	 f Lexical Enumeration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fActualEnumeration	TokenNameIdentifier	 f Actual Enumeration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fEnumerationTypeList	TokenNameIdentifier	 f Enumeration Type List
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fEnumerationItemTypeList	TokenNameIdentifier	 f Enumeration Item Type List
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
lengthAnnotation	TokenNameIdentifier	 length Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fPatternType	TokenNameIdentifier	 f Pattern Type
=	TokenNameEQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fFacets	TokenNameIdentifier	 f Facets
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// REVISIT: reset for fundamental facets 	TokenNameCOMMENT_LINE	REVISIT: reset for fundamental facets 
}	TokenNameRBRACE	
/** * @see org.apache.xerces.xs.XSObject#getNamespaceItem() */	TokenNameCOMMENT_JAVADOC	 @see org.apache.xerces.xs.XSObject#getNamespaceItem() 
public	TokenNamepublic	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
getNamespaceItem	TokenNameIdentifier	 get Namespace Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setNamespaceItem	TokenNameIdentifier	 set Namespace Item
(	TokenNameLPAREN	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
namespaceItem	TokenNameIdentifier	 namespace Item
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
=	TokenNameEQUAL	
namespaceItem	TokenNameIdentifier	 namespace Item
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see java.lang.Object#toString() */	TokenNameCOMMENT_JAVADOC	 @see java.lang.Object#toString() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
this	TokenNamethis	
.	TokenNameDOT	
fTypeName	TokenNameIdentifier	 f Type Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of constraining facets if it exists, otherwise an empty * <code>XSObjectList</code>. Note: This method must not be used to * retrieve values for <code>enumeration</code> and <code>pattern</code> * facets. */	TokenNameCOMMENT_JAVADOC	 A list of constraining facets if it exists, otherwise an empty <code>XSObjectList</code>. Note: This method must not be used to retrieve values for <code>enumeration</code> and <code>pattern</code> facets. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getFacets	TokenNameIdentifier	 get Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFacets	TokenNameIdentifier	 f Facets
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
facets	TokenNameIdentifier	 facets
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_ANYSIMPLETYPE	TokenNameIdentifier	 DV  ANYSIMPLETYPE
&&	TokenNameAND_AND	
fValidationDV	TokenNameIdentifier	 f Validation DV
!=	TokenNameNOT_EQUAL	
DV_ANYATOMICTYPE	TokenNameIdentifier	 DV  ANYATOMICTYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
,	TokenNameCOMMA	
WS_FACET_STRING	TokenNameIdentifier	 WS  FACET  STRING
[	TokenNameLBRACKET	
fWhiteSpace	TokenNameIdentifier	 f White Space
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
whiteSpaceAnnotation	TokenNameIdentifier	 white Space Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fLength	TokenNameIdentifier	 f Length
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_LENGTH	TokenNameIdentifier	 FACET  LENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
lengthAnnotation	TokenNameIdentifier	 length Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMinLength	TokenNameIdentifier	 f Min Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fMinLength	TokenNameIdentifier	 f Min Length
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MINLENGTH	TokenNameIdentifier	 FACET  MINLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
minLengthAnnotation	TokenNameIdentifier	 min Length Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fMaxLength	TokenNameIdentifier	 f Max Length
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fMaxLength	TokenNameIdentifier	 f Max Length
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXLENGTH	TokenNameIdentifier	 FACET  MAXLENGTH
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
maxLengthAnnotation	TokenNameIdentifier	 max Length Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fTotalDigits	TokenNameIdentifier	 f Total Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fTotalDigits	TokenNameIdentifier	 f Total Digits
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_TOTALDIGITS	TokenNameIdentifier	 FACET  TOTALDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
totalDigitsAnnotation	TokenNameIdentifier	 total Digits Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
,	TokenNameCOMMA	
"0"	TokenNameStringLiteral	0
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fFractionDigits	TokenNameIdentifier	 f Fraction Digits
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_FRACTIONDIGITS	TokenNameIdentifier	 FACET  FRACTIONDIGITS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fractionDigitsAnnotation	TokenNameIdentifier	 fraction Digits Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXINCLUSIVE	TokenNameIdentifier	 FACET  MAXINCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
maxInclusiveAnnotation	TokenNameIdentifier	 max Inclusive Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MAXEXCLUSIVE	TokenNameIdentifier	 FACET  MAXEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
maxExclusiveAnnotation	TokenNameIdentifier	 max Exclusive Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
,	TokenNameCOMMA	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MINEXCLUSIVE	TokenNameIdentifier	 FACET  MINEXCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
minExclusiveAnnotation	TokenNameIdentifier	 min Exclusive Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
,	TokenNameCOMMA	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
,	TokenNameCOMMA	
(	TokenNameLPAREN	
fFixedFacet	TokenNameIdentifier	 f Fixed Facet
&	TokenNameAND	
FACET_MININCLUSIVE	TokenNameIdentifier	 FACET  MININCLUSIVE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
minInclusiveAnnotation	TokenNameIdentifier	 min Inclusive Annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fFacets	TokenNameIdentifier	 f Facets
=	TokenNameEQUAL	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fFacets	TokenNameIdentifier	 f Facets
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fFacets	TokenNameIdentifier	 f Facets
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XSObject	TokenNameIdentifier	 XS Object
getFacet	TokenNameIdentifier	 get Facet
(	TokenNameLPAREN	
int	TokenNameint	
facetType	TokenNameIdentifier	 facet Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
facetType	TokenNameIdentifier	 facet Type
==	TokenNameEQUAL_EQUAL	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
||	TokenNameOR_OR	
facetType	TokenNameIdentifier	 facet Type
==	TokenNameEQUAL_EQUAL	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
getMultiValueFacets	TokenNameIdentifier	 get Multi Value Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSMultiValueFacet	TokenNameIdentifier	 XS Multi Value Facet
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSMultiValueFacet	TokenNameIdentifier	 XS Multi Value Facet
)	TokenNameRPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getFacetKind	TokenNameIdentifier	 get Facet Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
facetType	TokenNameIdentifier	 facet Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
getFacets	TokenNameIdentifier	 get Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSFacet	TokenNameIdentifier	 XS Facet
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSFacet	TokenNameIdentifier	 XS Facet
)	TokenNameRPAREN	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getFacetKind	TokenNameIdentifier	 get Facet Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
facetType	TokenNameIdentifier	 facet Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A list of enumeration and pattern constraining facets if it exists, * otherwise an empty <code>XSObjectList</code>. */	TokenNameCOMMENT_JAVADOC	 A list of enumeration and pattern constraining facets if it exists, otherwise an empty <code>XSObjectList</code>. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getMultiValueFacets	TokenNameIdentifier	 get Multi Value Facets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMultiValueFacets	TokenNameIdentifier	 f Multi Value Facets
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
facets	TokenNameIdentifier	 facets
=	TokenNameEQUAL	
new	TokenNamenew	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fFacetsDefined	TokenNameIdentifier	 f Facets Defined
&	TokenNameAND	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
fPatternType	TokenNameIdentifier	 f Pattern Type
!=	TokenNameNOT_EQUAL	
SPECIAL_PATTERN_NONE	TokenNameIdentifier	 SPECIAL  PATTERN  NONE
||	TokenNameOR_OR	
fValidationDV	TokenNameIdentifier	 f Validation DV
==	TokenNameEQUAL_EQUAL	
DV_INTEGER	TokenNameIdentifier	 DV  INTEGER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
(	TokenNameLPAREN	
FACET_PATTERN	TokenNameIdentifier	 FACET  PATTERN
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getLexicalPattern	TokenNameIdentifier	 get Lexical Pattern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
patternAnnotations	TokenNameIdentifier	 pattern Annotations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
facets	TokenNameIdentifier	 facets
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
(	TokenNameLPAREN	
FACET_ENUMERATION	TokenNameIdentifier	 FACET  ENUMERATION
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getLexicalEnumeration	TokenNameIdentifier	 get Lexical Enumeration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
ObjectListImpl	TokenNameIdentifier	 Object List Impl
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
,	TokenNameCOMMA	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
)	TokenNameRPAREN	
,	TokenNameCOMMA	
enumerationAnnotations	TokenNameIdentifier	 enumeration Annotations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMultiValueFacets	TokenNameIdentifier	 f Multi Value Facets
=	TokenNameEQUAL	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
facets	TokenNameIdentifier	 facets
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fMultiValueFacets	TokenNameIdentifier	 f Multi Value Facets
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fMultiValueFacets	TokenNameIdentifier	 f Multi Value Facets
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getMinInclusiveValue	TokenNameIdentifier	 get Min Inclusive Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMinInclusive	TokenNameIdentifier	 f Min Inclusive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getMinExclusiveValue	TokenNameIdentifier	 get Min Exclusive Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMinExclusive	TokenNameIdentifier	 f Min Exclusive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getMaxInclusiveValue	TokenNameIdentifier	 get Max Inclusive Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMaxInclusive	TokenNameIdentifier	 f Max Inclusive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getMaxExclusiveValue	TokenNameIdentifier	 get Max Exclusive Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMaxExclusive	TokenNameIdentifier	 f Max Exclusive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setAnonymous	TokenNameIdentifier	 set Anonymous
(	TokenNameLPAREN	
boolean	TokenNameboolean	
anon	TokenNameIdentifier	 anon
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnonymous	TokenNameIdentifier	 f Anonymous
=	TokenNameEQUAL	
anon	TokenNameIdentifier	 anon
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
implements	TokenNameimplements	
XSFacet	TokenNameIdentifier	 XS Facet
{	TokenNameLBRACE	
final	TokenNamefinal	
short	TokenNameshort	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
svalue	TokenNameIdentifier	 svalue
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
ivalue	TokenNameIdentifier	 ivalue
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
avalue	TokenNameIdentifier	 avalue
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
fixed	TokenNameIdentifier	 fixed
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSFacetImpl	TokenNameIdentifier	 XS Facet Impl
(	TokenNameLPAREN	
short	TokenNameshort	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
svalue	TokenNameIdentifier	 svalue
,	TokenNameCOMMA	
int	TokenNameint	
ivalue	TokenNameIdentifier	 ivalue
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
avalue	TokenNameIdentifier	 avalue
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fixed	TokenNameIdentifier	 fixed
,	TokenNameCOMMA	
XSAnnotation	TokenNameIdentifier	 XS Annotation
annotation	TokenNameIdentifier	 annotation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
svalue	TokenNameIdentifier	 svalue
=	TokenNameEQUAL	
svalue	TokenNameIdentifier	 svalue
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ivalue	TokenNameIdentifier	 ivalue
=	TokenNameEQUAL	
ivalue	TokenNameIdentifier	 ivalue
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
avalue	TokenNameIdentifier	 avalue
=	TokenNameEQUAL	
avalue	TokenNameIdentifier	 avalue
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fixed	TokenNameIdentifier	 fixed
=	TokenNameEQUAL	
fixed	TokenNameIdentifier	 fixed
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
.	TokenNameDOT	
addXSObject	TokenNameIdentifier	 add XS Object
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * (non-Javadoc) * * @see org.apache.xerces.xs.XSFacet#getAnnotation() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#getAnnotation() 
/** * Optional. Annotation. */	TokenNameCOMMENT_JAVADOC	 Optional. Annotation. 
public	TokenNamepublic	
XSAnnotation	TokenNameIdentifier	 XS Annotation
getAnnotation	TokenNameIdentifier	 get Annotation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSAnnotation	TokenNameIdentifier	 XS Annotation
)	TokenNameRPAREN	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * (non-Javadoc) * * @see org.apache.xerces.xs.XSFacet#getAnnotations() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#getAnnotations() 
/** * Optional. Annotations. */	TokenNameCOMMENT_JAVADOC	 Optional. Annotations. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getAnnotations	TokenNameIdentifier	 get Annotations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#getFacetKind() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSFacet#getFacetKind() 
public	TokenNamepublic	
short	TokenNameshort	
getFacetKind	TokenNameIdentifier	 get Facet Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#getLexicalFacetValue() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSFacet#getLexicalFacetValue() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLexicalFacetValue	TokenNameIdentifier	 get Lexical Facet Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
svalue	TokenNameIdentifier	 svalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getActualFacetValue	TokenNameIdentifier	 get Actual Facet Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
avalue	TokenNameIdentifier	 avalue
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
FACET_WHITESPACE	TokenNameIdentifier	 FACET  WHITESPACE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
avalue	TokenNameIdentifier	 avalue
=	TokenNameEQUAL	
svalue	TokenNameIdentifier	 svalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Must a facet with an integer value. Use BigInteger. 	TokenNameCOMMENT_LINE	Must a facet with an integer value. Use BigInteger. 
avalue	TokenNameIdentifier	 avalue
=	TokenNameEQUAL	
BigInteger	TokenNameIdentifier	 Big Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
ivalue	TokenNameIdentifier	 ivalue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
avalue	TokenNameIdentifier	 avalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getIntFacetValue	TokenNameIdentifier	 get Int Facet Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ivalue	TokenNameIdentifier	 ivalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#isFixed() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSFacet#isFixed() 
public	TokenNamepublic	
boolean	TokenNameboolean	
getFixed	TokenNameIdentifier	 get Fixed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fixed	TokenNameIdentifier	 fixed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getName() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getName() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getNamespace() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getNamespace() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getNamespaceItem() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getNamespaceItem() 
public	TokenNamepublic	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
getNamespaceItem	TokenNameIdentifier	 get Namespace Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: implement 	TokenNameCOMMENT_LINE	REVISIT: implement 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getType() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getType() 
public	TokenNamepublic	
short	TokenNameshort	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
FACET	TokenNameIdentifier	 FACET
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
implements	TokenNameimplements	
XSMultiValueFacet	TokenNameIdentifier	 XS Multi Value Facet
{	TokenNameLBRACE	
final	TokenNamefinal	
short	TokenNameshort	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
final	TokenNamefinal	
StringList	TokenNameIdentifier	 String List
svalues	TokenNameIdentifier	 svalues
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ObjectList	TokenNameIdentifier	 Object List
avalues	TokenNameIdentifier	 avalues
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSMVFacetImpl	TokenNameIdentifier	 XSMV Facet Impl
(	TokenNameLPAREN	
short	TokenNameshort	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
StringList	TokenNameIdentifier	 String List
svalues	TokenNameIdentifier	 svalues
,	TokenNameCOMMA	
ObjectList	TokenNameIdentifier	 Object List
avalues	TokenNameIdentifier	 avalues
,	TokenNameCOMMA	
XSObjectList	TokenNameIdentifier	 XS Object List
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
svalues	TokenNameIdentifier	 svalues
=	TokenNameEQUAL	
svalues	TokenNameIdentifier	 svalues
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
avalues	TokenNameIdentifier	 avalues
=	TokenNameEQUAL	
avalues	TokenNameIdentifier	 avalues
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
annotations	TokenNameIdentifier	 annotations
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSFacet#getFacetKind() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSFacet#getFacetKind() 
public	TokenNamepublic	
short	TokenNameshort	
getFacetKind	TokenNameIdentifier	 get Facet Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSMultiValueFacet#getAnnotations() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSMultiValueFacet#getAnnotations() 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getAnnotations	TokenNameIdentifier	 get Annotations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSMultiValueFacet#getLexicalFacetValues() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSMultiValueFacet#getLexicalFacetValues() 
public	TokenNamepublic	
StringList	TokenNameIdentifier	 String List
getLexicalFacetValues	TokenNameIdentifier	 get Lexical Facet Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
svalues	TokenNameIdentifier	 svalues
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ObjectList	TokenNameIdentifier	 Object List
getEnumerationValues	TokenNameIdentifier	 get Enumeration Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
avalues	TokenNameIdentifier	 avalues
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getName() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getName() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getNamespace() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getNamespace() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getNamespaceItem() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getNamespaceItem() 
public	TokenNamepublic	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
getNamespaceItem	TokenNameIdentifier	 get Namespace Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: implement 	TokenNameCOMMENT_LINE	REVISIT: implement 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSObject#getType() */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSObject#getType() 
public	TokenNamepublic	
short	TokenNameshort	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
MULTIVALUE_FACET	TokenNameIdentifier	 MULTIVALUE  FACET
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
AbstractObjectList	TokenNameIdentifier	 Abstract Object List
extends	TokenNameextends	
AbstractList	TokenNameIdentifier	 Abstract List
implements	TokenNameimplements	
ObjectList	TokenNameIdentifier	 Object List
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IndexOutOfBoundsException	TokenNameIdentifier	 Index Out Of Bounds Exception
(	TokenNameLPAREN	
"Index: "	TokenNameStringLiteral	Index: 
+	TokenNamePLUS	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTypeNamespace	TokenNameIdentifier	 get Type Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isDerivedFrom	TokenNameIdentifier	 is Derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
typeNamespaceArg	TokenNameIdentifier	 type Namespace Arg
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
typeNameArg	TokenNameIdentifier	 type Name Arg
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
typeNamespaceArg	TokenNameIdentifier	 type Namespace Arg
,	TokenNameCOMMA	
typeNameArg	TokenNameIdentifier	 type Name Arg
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
short	TokenNameshort	
convertToPrimitiveKind	TokenNameIdentifier	 convert To Primitive Kind
(	TokenNameLPAREN	
short	TokenNameshort	
valueType	TokenNameIdentifier	 value Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** Primitive datatypes. */	TokenNameCOMMENT_JAVADOC	 Primitive datatypes. 
if	TokenNameif	
(	TokenNameLPAREN	
valueType	TokenNameIdentifier	 value Type
<=	TokenNameLESS_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
NOTATION_DT	TokenNameIdentifier	 NOTATION  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
valueType	TokenNameIdentifier	 value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Types derived from string. */	TokenNameCOMMENT_JAVADOC	 Types derived from string. 
if	TokenNameif	
(	TokenNameLPAREN	
valueType	TokenNameIdentifier	 value Type
<=	TokenNameLESS_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
ENTITY_DT	TokenNameIdentifier	 ENTITY  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
STRING_DT	TokenNameIdentifier	 STRING  DT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Types derived from decimal. */	TokenNameCOMMENT_JAVADOC	 Types derived from decimal. 
if	TokenNameif	
(	TokenNameLPAREN	
valueType	TokenNameIdentifier	 value Type
<=	TokenNameLESS_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
POSITIVEINTEGER_DT	TokenNameIdentifier	 POSITIVEINTEGER  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DECIMAL_DT	TokenNameIdentifier	 DECIMAL  DT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Other types. */	TokenNameCOMMENT_JAVADOC	 Other types. 
return	TokenNamereturn	
valueType	TokenNameIdentifier	 value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
appendEnumString	TokenNameIdentifier	 append Enum String
(	TokenNameLPAREN	
StringBuffer	TokenNameIdentifier	 String Buffer
sb	TokenNameIdentifier	 sb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'['	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fEnumerationSize	TokenNameIdentifier	 f Enumeration Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fEnumeration	TokenNameIdentifier	 f Enumeration
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class XSSimpleTypeDecl 	TokenNameCOMMENT_LINE	class XSSimpleTypeDecl 
