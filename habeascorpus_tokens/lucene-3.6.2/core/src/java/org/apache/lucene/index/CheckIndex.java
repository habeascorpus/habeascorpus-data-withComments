package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
NumberFormat	TokenNameIdentifier	 Number Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Comparator	TokenNameIdentifier	 Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
AbstractField	TokenNameIdentifier	 Abstract Field
;	TokenNameSEMICOLON	
// for javadocs 	TokenNameCOMMENT_LINE	for javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
IndexSearcher	TokenNameIdentifier	 Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
FSDirectory	TokenNameIdentifier	 FS Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
IndexInput	TokenNameIdentifier	 Index Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CommandLineUtil	TokenNameIdentifier	 Command Line Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
StringHelper	TokenNameIdentifier	 String Helper
;	TokenNameSEMICOLON	
/** * Basic tool and API to check the health of an index and * write a new segments file that removes reference to * problematic segments. * * <p>As this tool checks every byte in the index, on a large * index it can take quite a long time to run. * * @lucene.experimental Please make a complete backup of your * index before using this to fix your index! */	TokenNameCOMMENT_JAVADOC	 Basic tool and API to check the health of an index and write a new segments file that removes reference to problematic segments. * <p>As this tool checks every byte in the index, on a large index it can take quite a long time to run. * @lucene.experimental Please make a complete backup of your index before using this to fix your index! 
public	TokenNamepublic	
class	TokenNameclass	
CheckIndex	TokenNameIdentifier	 Check Index
{	TokenNameLBRACE	
private	TokenNameprivate	
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
/** * Returned from {@link #checkIndex()} detailing the health and status of the index. * * @lucene.experimental **/	TokenNameCOMMENT_JAVADOC	 Returned from {@link #checkIndex()} detailing the health and status of the index. * @lucene.experimental *
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Status	TokenNameIdentifier	 Status
{	TokenNameLBRACE	
/** True if no problems were found with the index. */	TokenNameCOMMENT_JAVADOC	 True if no problems were found with the index. 
public	TokenNamepublic	
boolean	TokenNameboolean	
clean	TokenNameIdentifier	 clean
;	TokenNameSEMICOLON	
/** True if we were unable to locate and load the segments_N file. */	TokenNameCOMMENT_JAVADOC	 True if we were unable to locate and load the segments_N file. 
public	TokenNamepublic	
boolean	TokenNameboolean	
missingSegments	TokenNameIdentifier	 missing Segments
;	TokenNameSEMICOLON	
/** True if we were unable to open the segments_N file. */	TokenNameCOMMENT_JAVADOC	 True if we were unable to open the segments_N file. 
public	TokenNamepublic	
boolean	TokenNameboolean	
cantOpenSegments	TokenNameIdentifier	 cant Open Segments
;	TokenNameSEMICOLON	
/** True if we were unable to read the version number from segments_N file. */	TokenNameCOMMENT_JAVADOC	 True if we were unable to read the version number from segments_N file. 
public	TokenNamepublic	
boolean	TokenNameboolean	
missingSegmentVersion	TokenNameIdentifier	 missing Segment Version
;	TokenNameSEMICOLON	
/** Name of latest segments_N file in the index. */	TokenNameCOMMENT_JAVADOC	 Name of latest segments_N file in the index. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
segmentsFileName	TokenNameIdentifier	 segments File Name
;	TokenNameSEMICOLON	
/** Number of segments in the index. */	TokenNameCOMMENT_JAVADOC	 Number of segments in the index. 
public	TokenNamepublic	
int	TokenNameint	
numSegments	TokenNameIdentifier	 num Segments
;	TokenNameSEMICOLON	
/** String description of the version of the index. */	TokenNameCOMMENT_JAVADOC	 String description of the version of the index. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
segmentFormat	TokenNameIdentifier	 segment Format
;	TokenNameSEMICOLON	
/** Empty unless you passed specific segments list to check as optional 3rd argument. * @see CheckIndex#checkIndex(List) */	TokenNameCOMMENT_JAVADOC	 Empty unless you passed specific segments list to check as optional 3rd argument. @see CheckIndex#checkIndex(List) 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
segmentsChecked	TokenNameIdentifier	 segments Checked
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** True if the index was created with a newer version of Lucene than the CheckIndex tool. */	TokenNameCOMMENT_JAVADOC	 True if the index was created with a newer version of Lucene than the CheckIndex tool. 
public	TokenNamepublic	
boolean	TokenNameboolean	
toolOutOfDate	TokenNameIdentifier	 tool Out Of Date
;	TokenNameSEMICOLON	
/** List of {@link SegmentInfoStatus} instances, detailing status of each segment. */	TokenNameCOMMENT_JAVADOC	 List of {@link SegmentInfoStatus} instances, detailing status of each segment. 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SegmentInfoStatus	TokenNameIdentifier	 Segment Info Status
>	TokenNameGREATER	
segmentInfos	TokenNameIdentifier	 segment Infos
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SegmentInfoStatus	TokenNameIdentifier	 Segment Info Status
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Directory index is in. */	TokenNameCOMMENT_JAVADOC	 Directory index is in. 
public	TokenNamepublic	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
/** * SegmentInfos instance containing only segments that * had no problems (this is used with the {@link CheckIndex#fixIndex} * method to repair the index. */	TokenNameCOMMENT_JAVADOC	 SegmentInfos instance containing only segments that had no problems (this is used with the {@link CheckIndex#fixIndex} method to repair the index. 
SegmentInfos	TokenNameIdentifier	 Segment Infos
newSegments	TokenNameIdentifier	 new Segments
;	TokenNameSEMICOLON	
/** How many documents will be lost to bad segments. */	TokenNameCOMMENT_JAVADOC	 How many documents will be lost to bad segments. 
public	TokenNamepublic	
int	TokenNameint	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
;	TokenNameSEMICOLON	
/** How many bad segments were found. */	TokenNameCOMMENT_JAVADOC	 How many bad segments were found. 
public	TokenNamepublic	
int	TokenNameint	
numBadSegments	TokenNameIdentifier	 num Bad Segments
;	TokenNameSEMICOLON	
/** True if we checked only specific segments ({@link * #checkIndex(List)}) was called with non-null * argument). */	TokenNameCOMMENT_JAVADOC	 True if we checked only specific segments ({@link #checkIndex(List)}) was called with non-null argument). 
public	TokenNamepublic	
boolean	TokenNameboolean	
partial	TokenNameIdentifier	 partial
;	TokenNameSEMICOLON	
/** The greatest segment name. */	TokenNameCOMMENT_JAVADOC	 The greatest segment name. 
public	TokenNamepublic	
int	TokenNameint	
maxSegmentName	TokenNameIdentifier	 max Segment Name
;	TokenNameSEMICOLON	
/** Whether the SegmentInfos.counter is greater than any of the segments' names. */	TokenNameCOMMENT_JAVADOC	 Whether the SegmentInfos.counter is greater than any of the segments' names. 
public	TokenNamepublic	
boolean	TokenNameboolean	
validCounter	TokenNameIdentifier	 valid Counter
;	TokenNameSEMICOLON	
/** Holds the userData of the last commit in the index */	TokenNameCOMMENT_JAVADOC	 Holds the userData of the last commit in the index 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
userData	TokenNameIdentifier	 user Data
;	TokenNameSEMICOLON	
/** Holds the status of each segment in the index. * See {@link #segmentInfos}. * * <p><b>WARNING</b>: this API is new and experimental and is * subject to suddenly change in the next release. */	TokenNameCOMMENT_JAVADOC	 Holds the status of each segment in the index. See {@link #segmentInfos}. * <p><b>WARNING</b>: this API is new and experimental and is subject to suddenly change in the next release. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
SegmentInfoStatus	TokenNameIdentifier	 Segment Info Status
{	TokenNameLBRACE	
/** Name of the segment. */	TokenNameCOMMENT_JAVADOC	 Name of the segment. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
/** Document count (does not take deletions into account). */	TokenNameCOMMENT_JAVADOC	 Document count (does not take deletions into account). 
public	TokenNamepublic	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
/** True if segment is compound file format. */	TokenNameCOMMENT_JAVADOC	 True if segment is compound file format. 
public	TokenNamepublic	
boolean	TokenNameboolean	
compound	TokenNameIdentifier	 compound
;	TokenNameSEMICOLON	
/** Number of files referenced by this segment. */	TokenNameCOMMENT_JAVADOC	 Number of files referenced by this segment. 
public	TokenNamepublic	
int	TokenNameint	
numFiles	TokenNameIdentifier	 num Files
;	TokenNameSEMICOLON	
/** Net size (MB) of the files referenced by this * segment. */	TokenNameCOMMENT_JAVADOC	 Net size (MB) of the files referenced by this segment. 
public	TokenNamepublic	
double	TokenNamedouble	
sizeMB	TokenNameIdentifier	 size MB
;	TokenNameSEMICOLON	
/** Doc store offset, if this segment shares the doc * store files (stored fields and term vectors) with * other segments. This is -1 if it does not share. */	TokenNameCOMMENT_JAVADOC	 Doc store offset, if this segment shares the doc store files (stored fields and term vectors) with other segments. This is -1 if it does not share. 
public	TokenNamepublic	
int	TokenNameint	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** String of the shared doc store segment, or null if * this segment does not share the doc store files. */	TokenNameCOMMENT_JAVADOC	 String of the shared doc store segment, or null if this segment does not share the doc store files. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
docStoreSegment	TokenNameIdentifier	 doc Store Segment
;	TokenNameSEMICOLON	
/** True if the shared doc store files are compound file * format. */	TokenNameCOMMENT_JAVADOC	 True if the shared doc store files are compound file format. 
public	TokenNamepublic	
boolean	TokenNameboolean	
docStoreCompoundFile	TokenNameIdentifier	 doc Store Compound File
;	TokenNameSEMICOLON	
/** True if this segment has pending deletions. */	TokenNameCOMMENT_JAVADOC	 True if this segment has pending deletions. 
public	TokenNamepublic	
boolean	TokenNameboolean	
hasDeletions	TokenNameIdentifier	 has Deletions
;	TokenNameSEMICOLON	
/** Name of the current deletions file name. */	TokenNameCOMMENT_JAVADOC	 Name of the current deletions file name. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
deletionsFileName	TokenNameIdentifier	 deletions File Name
;	TokenNameSEMICOLON	
/** Number of deleted documents. */	TokenNameCOMMENT_JAVADOC	 Number of deleted documents. 
public	TokenNamepublic	
int	TokenNameint	
numDeleted	TokenNameIdentifier	 num Deleted
;	TokenNameSEMICOLON	
/** True if we were able to open a SegmentReader on this * segment. */	TokenNameCOMMENT_JAVADOC	 True if we were able to open a SegmentReader on this segment. 
public	TokenNamepublic	
boolean	TokenNameboolean	
openReaderPassed	TokenNameIdentifier	 open Reader Passed
;	TokenNameSEMICOLON	
/** Number of fields in this segment. */	TokenNameCOMMENT_JAVADOC	 Number of fields in this segment. 
int	TokenNameint	
numFields	TokenNameIdentifier	 num Fields
;	TokenNameSEMICOLON	
/** True if at least one of the fields in this segment * has position data * @see AbstractField#setIndexOptions(org.apache.lucene.index.FieldInfo.IndexOptions) */	TokenNameCOMMENT_JAVADOC	 True if at least one of the fields in this segment has position data @see AbstractField#setIndexOptions(org.apache.lucene.index.FieldInfo.IndexOptions) 
public	TokenNamepublic	
boolean	TokenNameboolean	
hasProx	TokenNameIdentifier	 has Prox
;	TokenNameSEMICOLON	
/** Map that includes certain * debugging details that IndexWriter records into * each segment it creates */	TokenNameCOMMENT_JAVADOC	 Map that includes certain debugging details that IndexWriter records into each segment it creates 
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
diagnostics	TokenNameIdentifier	 diagnostics
;	TokenNameSEMICOLON	
/** Status for testing of field norms (null if field norms could not be tested). */	TokenNameCOMMENT_JAVADOC	 Status for testing of field norms (null if field norms could not be tested). 
public	TokenNamepublic	
FieldNormStatus	TokenNameIdentifier	 Field Norm Status
fieldNormStatus	TokenNameIdentifier	 field Norm Status
;	TokenNameSEMICOLON	
/** Status for testing of indexed terms (null if indexed terms could not be tested). */	TokenNameCOMMENT_JAVADOC	 Status for testing of indexed terms (null if indexed terms could not be tested). 
public	TokenNamepublic	
TermIndexStatus	TokenNameIdentifier	 Term Index Status
termIndexStatus	TokenNameIdentifier	 term Index Status
;	TokenNameSEMICOLON	
/** Status for testing of stored fields (null if stored fields could not be tested). */	TokenNameCOMMENT_JAVADOC	 Status for testing of stored fields (null if stored fields could not be tested). 
public	TokenNamepublic	
StoredFieldStatus	TokenNameIdentifier	 Stored Field Status
storedFieldStatus	TokenNameIdentifier	 stored Field Status
;	TokenNameSEMICOLON	
/** Status for testing of term vectors (null if term vectors could not be tested). */	TokenNameCOMMENT_JAVADOC	 Status for testing of term vectors (null if term vectors could not be tested). 
public	TokenNamepublic	
TermVectorStatus	TokenNameIdentifier	 Term Vector Status
termVectorStatus	TokenNameIdentifier	 term Vector Status
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Status from testing field norms. */	TokenNameCOMMENT_JAVADOC	 Status from testing field norms. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
FieldNormStatus	TokenNameIdentifier	 Field Norm Status
{	TokenNameLBRACE	
/** Number of fields successfully tested */	TokenNameCOMMENT_JAVADOC	 Number of fields successfully tested 
public	TokenNamepublic	
long	TokenNamelong	
totFields	TokenNameIdentifier	 tot Fields
=	TokenNameEQUAL	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** Exception thrown during term index test (null on success) */	TokenNameCOMMENT_JAVADOC	 Exception thrown during term index test (null on success) 
public	TokenNamepublic	
Throwable	TokenNameIdentifier	 Throwable
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Status from testing term index. */	TokenNameCOMMENT_JAVADOC	 Status from testing term index. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
TermIndexStatus	TokenNameIdentifier	 Term Index Status
{	TokenNameLBRACE	
/** Total term count */	TokenNameCOMMENT_JAVADOC	 Total term count 
public	TokenNamepublic	
long	TokenNamelong	
termCount	TokenNameIdentifier	 term Count
=	TokenNameEQUAL	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** Total frequency across all terms. */	TokenNameCOMMENT_JAVADOC	 Total frequency across all terms. 
public	TokenNamepublic	
long	TokenNamelong	
totFreq	TokenNameIdentifier	 tot Freq
=	TokenNameEQUAL	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** Total number of positions. */	TokenNameCOMMENT_JAVADOC	 Total number of positions. 
public	TokenNamepublic	
long	TokenNamelong	
totPos	TokenNameIdentifier	 tot Pos
=	TokenNameEQUAL	
0L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** Exception thrown during term index test (null on success) */	TokenNameCOMMENT_JAVADOC	 Exception thrown during term index test (null on success) 
public	TokenNamepublic	
Throwable	TokenNameIdentifier	 Throwable
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Status from testing stored fields. */	TokenNameCOMMENT_JAVADOC	 Status from testing stored fields. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
StoredFieldStatus	TokenNameIdentifier	 Stored Field Status
{	TokenNameLBRACE	
/** Number of documents tested. */	TokenNameCOMMENT_JAVADOC	 Number of documents tested. 
public	TokenNamepublic	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Total number of stored fields tested. */	TokenNameCOMMENT_JAVADOC	 Total number of stored fields tested. 
public	TokenNamepublic	
long	TokenNamelong	
totFields	TokenNameIdentifier	 tot Fields
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Exception thrown during stored fields test (null on success) */	TokenNameCOMMENT_JAVADOC	 Exception thrown during stored fields test (null on success) 
public	TokenNamepublic	
Throwable	TokenNameIdentifier	 Throwable
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Status from testing stored fields. */	TokenNameCOMMENT_JAVADOC	 Status from testing stored fields. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
TermVectorStatus	TokenNameIdentifier	 Term Vector Status
{	TokenNameLBRACE	
/** Number of documents tested. */	TokenNameCOMMENT_JAVADOC	 Number of documents tested. 
public	TokenNamepublic	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Total number of term vectors tested. */	TokenNameCOMMENT_JAVADOC	 Total number of term vectors tested. 
public	TokenNamepublic	
long	TokenNamelong	
totVectors	TokenNameIdentifier	 tot Vectors
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Exception thrown during term vector test (null on success) */	TokenNameCOMMENT_JAVADOC	 Exception thrown during term vector test (null on success) 
public	TokenNamepublic	
Throwable	TokenNameIdentifier	 Throwable
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Create a new CheckIndex on the directory. */	TokenNameCOMMENT_JAVADOC	 Create a new CheckIndex on the directory. 
public	TokenNamepublic	
CheckIndex	TokenNameIdentifier	 Check Index
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Set infoStream where messages should go. If null, no * messages are printed */	TokenNameCOMMENT_JAVADOC	 Set infoStream where messages should go. If null, no messages are printed 
public	TokenNamepublic	
void	TokenNamevoid	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
MySegmentTermDocs	TokenNameIdentifier	 My Segment Term Docs
extends	TokenNameextends	
SegmentTermDocs	TokenNameIdentifier	 Segment Term Docs
{	TokenNameLBRACE	
int	TokenNameint	
delCount	TokenNameIdentifier	 del Count
;	TokenNameSEMICOLON	
MySegmentTermDocs	TokenNameIdentifier	 My Segment Term Docs
(	TokenNameLPAREN	
SegmentReader	TokenNameIdentifier	 Segment Reader
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
delCount	TokenNameIdentifier	 del Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
void	TokenNamevoid	
skippingDoc	TokenNameIdentifier	 skipping Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
delCount	TokenNameIdentifier	 del Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Returns a {@link Status} instance detailing * the state of the index. * * <p>As this method checks every byte in the index, on a large * index it can take quite a long time to run. * * <p><b>WARNING</b>: make sure * you only call this when the index is not opened by any * writer. */	TokenNameCOMMENT_JAVADOC	 Returns a {@link Status} instance detailing the state of the index. * <p>As this method checks every byte in the index, on a large index it can take quite a long time to run. * <p><b>WARNING</b>: make sure you only call this when the index is not opened by any writer. 
public	TokenNamepublic	
Status	TokenNameIdentifier	 Status
checkIndex	TokenNameIdentifier	 check Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
checkIndex	TokenNameIdentifier	 check Index
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a {@link Status} instance detailing * the state of the index. * * @param onlySegments list of specific segment names to check * * <p>As this method checks every byte in the specified * segments, on a large index it can take quite a long * time to run. * * <p><b>WARNING</b>: make sure * you only call this when the index is not opened by any * writer. */	TokenNameCOMMENT_JAVADOC	 Returns a {@link Status} instance detailing the state of the index. * @param onlySegments list of specific segment names to check * <p>As this method checks every byte in the specified segments, on a large index it can take quite a long time to run. * <p><b>WARNING</b>: make sure you only call this when the index is not opened by any writer. 
public	TokenNamepublic	
Status	TokenNameIdentifier	 Status
checkIndex	TokenNameIdentifier	 check Index
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
onlySegments	TokenNameIdentifier	 only Segments
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
NumberFormat	TokenNameIdentifier	 Number Format
nf	TokenNameIdentifier	 nf
=	TokenNameEQUAL	
NumberFormat	TokenNameIdentifier	 Number Format
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SegmentInfos	TokenNameIdentifier	 Segment Infos
sis	TokenNameIdentifier	 sis
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentInfos	TokenNameIdentifier	 Segment Infos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Status	TokenNameIdentifier	 Status
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR: could not read any segments file in directory"	TokenNameStringLiteral	ERROR: could not read any segments file in directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
missingSegments	TokenNameIdentifier	 missing Segments
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// find the oldest and newest segment versions 	TokenNameCOMMENT_LINE	find the oldest and newest segment versions 
String	TokenNameIdentifier	 String
oldest	TokenNameIdentifier	 oldest
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
,	TokenNameCOMMA	
newest	TokenNameIdentifier	 newest
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
oldSegs	TokenNameIdentifier	 old Segs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundNonNullVersion	TokenNameIdentifier	 found Non Null Version
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
versionComparator	TokenNameIdentifier	 version Comparator
=	TokenNameEQUAL	
StringHelper	TokenNameIdentifier	 String Helper
.	TokenNameDOT	
getVersionComparator	TokenNameIdentifier	 get Version Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
si	TokenNameIdentifier	 si
:	TokenNameCOLON	
sis	TokenNameIdentifier	 sis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
si	TokenNameIdentifier	 si
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pre-3.1 segment 	TokenNameCOMMENT_LINE	pre-3.1 segment 
oldSegs	TokenNameIdentifier	 old Segs
=	TokenNameEQUAL	
"pre-3.1"	TokenNameStringLiteral	pre-3.1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"2.x"	TokenNameStringLiteral	2.x
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// an old segment that was 'touched' by 3.1+ code 	TokenNameCOMMENT_LINE	an old segment that was 'touched' by 3.1+ code 
oldSegs	TokenNameIdentifier	 old Segs
=	TokenNameEQUAL	
"2.x"	TokenNameStringLiteral	2.x
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
foundNonNullVersion	TokenNameIdentifier	 found Non Null Version
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
versionComparator	TokenNameIdentifier	 version Comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
oldest	TokenNameIdentifier	 oldest
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oldest	TokenNameIdentifier	 oldest
=	TokenNameEQUAL	
version	TokenNameIdentifier	 version
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
versionComparator	TokenNameIdentifier	 version Comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
newest	TokenNameIdentifier	 newest
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newest	TokenNameIdentifier	 newest
=	TokenNameEQUAL	
version	TokenNameIdentifier	 version
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
numSegments	TokenNameIdentifier	 num Segments
=	TokenNameEQUAL	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
segmentsFileName	TokenNameIdentifier	 segments File Name
=	TokenNameEQUAL	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexInput	TokenNameIdentifier	 Index Input
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
openInput	TokenNameIdentifier	 open Input
(	TokenNameLPAREN	
segmentsFileName	TokenNameIdentifier	 segments File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR: could not open segments file in directory"	TokenNameStringLiteral	ERROR: could not open segments file in directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
cantOpenSegments	TokenNameIdentifier	 cant Open Segments
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR: could not read segment file version in directory"	TokenNameStringLiteral	ERROR: could not read segment file version in directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
missingSegmentVersion	TokenNameIdentifier	 missing Segment Version
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
skip	TokenNameIdentifier	 skip
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT	TokenNameIdentifier	 FORMAT
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT [Lucene Pre-2.1]"	TokenNameStringLiteral	FORMAT [Lucene Pre-2.1]
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_LOCKLESS	TokenNameIdentifier	 FORMAT  LOCKLESS
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_LOCKLESS [Lucene 2.1]"	TokenNameStringLiteral	FORMAT_LOCKLESS [Lucene 2.1]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_SINGLE_NORM_FILE	TokenNameIdentifier	 FORMAT  SINGLE  NORM  FILE
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]"	TokenNameStringLiteral	FORMAT_SINGLE_NORM_FILE [Lucene 2.2]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_SHARED_DOC_STORE	TokenNameIdentifier	 FORMAT  SHARED  DOC  STORE
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_SHARED_DOC_STORE [Lucene 2.3]"	TokenNameStringLiteral	FORMAT_SHARED_DOC_STORE [Lucene 2.3]
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_CHECKSUM	TokenNameIdentifier	 FORMAT  CHECKSUM
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_CHECKSUM [Lucene 2.4]"	TokenNameStringLiteral	FORMAT_CHECKSUM [Lucene 2.4]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_DEL_COUNT	TokenNameIdentifier	 FORMAT  DEL  COUNT
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_DEL_COUNT [Lucene 2.4]"	TokenNameStringLiteral	FORMAT_DEL_COUNT [Lucene 2.4]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_HAS_PROX	TokenNameIdentifier	 FORMAT  HAS  PROX
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_HAS_PROX [Lucene 2.4]"	TokenNameStringLiteral	FORMAT_HAS_PROX [Lucene 2.4]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_USER_DATA	TokenNameIdentifier	 FORMAT  USER  DATA
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_USER_DATA [Lucene 2.9]"	TokenNameStringLiteral	FORMAT_USER_DATA [Lucene 2.9]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_DIAGNOSTICS	TokenNameIdentifier	 FORMAT  DIAGNOSTICS
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_DIAGNOSTICS [Lucene 2.9]"	TokenNameStringLiteral	FORMAT_DIAGNOSTICS [Lucene 2.9]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_HAS_VECTORS	TokenNameIdentifier	 FORMAT  HAS  VECTORS
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_HAS_VECTORS [Lucene 3.1]"	TokenNameStringLiteral	FORMAT_HAS_VECTORS [Lucene 3.1]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
FORMAT_3_1	TokenNameIdentifier	 FORMAT 3 1
)	TokenNameRPAREN	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"FORMAT_3_1 [Lucene 3.1+]"	TokenNameStringLiteral	FORMAT_3_1 [Lucene 3.1+]
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
==	TokenNameEQUAL_EQUAL	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
CURRENT_FORMAT	TokenNameIdentifier	 CURRENT  FORMAT
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"BUG: You should update this tool!"	TokenNameStringLiteral	BUG: You should update this tool!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
<	TokenNameLESS	
SegmentInfos	TokenNameIdentifier	 Segment Infos
.	TokenNameDOT	
CURRENT_FORMAT	TokenNameIdentifier	 CURRENT  FORMAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
"int="	TokenNameStringLiteral	int=
+	TokenNamePLUS	
format	TokenNameIdentifier	 format
+	TokenNamePLUS	
" [newer version of Lucene than this tool]"	TokenNameStringLiteral	 [newer version of Lucene than this tool]
;	TokenNameSEMICOLON	
skip	TokenNameIdentifier	 skip
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sFormat	TokenNameIdentifier	 s Format
=	TokenNameEQUAL	
format	TokenNameIdentifier	 format
+	TokenNamePLUS	
" [Lucene 1.3 or prior]"	TokenNameStringLiteral	 [Lucene 1.3 or prior]
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
segmentsFileName	TokenNameIdentifier	 segments File Name
=	TokenNameEQUAL	
segmentsFileName	TokenNameIdentifier	 segments File Name
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
numSegments	TokenNameIdentifier	 num Segments
=	TokenNameEQUAL	
numSegments	TokenNameIdentifier	 num Segments
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
segmentFormat	TokenNameIdentifier	 segment Format
=	TokenNameEQUAL	
sFormat	TokenNameIdentifier	 s Format
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
userData	TokenNameIdentifier	 user Data
=	TokenNameEQUAL	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
userDataString	TokenNameIdentifier	 user Data String
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userDataString	TokenNameIdentifier	 user Data String
=	TokenNameEQUAL	
" userData="	TokenNameStringLiteral	 userData=
+	TokenNamePLUS	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
getUserData	TokenNameIdentifier	 get User Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
userDataString	TokenNameIdentifier	 user Data String
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
versionString	TokenNameIdentifier	 version String
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldSegs	TokenNameIdentifier	 old Segs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
foundNonNullVersion	TokenNameIdentifier	 found Non Null Version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
versionString	TokenNameIdentifier	 version String
=	TokenNameEQUAL	
"versions=["	TokenNameStringLiteral	versions=[
+	TokenNamePLUS	
oldSegs	TokenNameIdentifier	 old Segs
+	TokenNamePLUS	
" .. "	TokenNameStringLiteral	 .. 
+	TokenNamePLUS	
newest	TokenNameIdentifier	 newest
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
versionString	TokenNameIdentifier	 version String
=	TokenNameEQUAL	
"version="	TokenNameStringLiteral	version=
+	TokenNamePLUS	
oldSegs	TokenNameIdentifier	 old Segs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
versionString	TokenNameIdentifier	 version String
=	TokenNameEQUAL	
oldest	TokenNameIdentifier	 oldest
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
newest	TokenNameIdentifier	 newest
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
"version="	TokenNameStringLiteral	version=
+	TokenNamePLUS	
oldest	TokenNameIdentifier	 oldest
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
"versions=["	TokenNameStringLiteral	versions=[
+	TokenNamePLUS	
oldest	TokenNameIdentifier	 oldest
+	TokenNamePLUS	
" .. "	TokenNameStringLiteral	 .. 
+	TokenNamePLUS	
newest	TokenNameIdentifier	 newest
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"Segments file="	TokenNameStringLiteral	Segments file=
+	TokenNamePLUS	
segmentsFileName	TokenNameIdentifier	 segments File Name
+	TokenNamePLUS	
" numSegments="	TokenNameStringLiteral	 numSegments=
+	TokenNamePLUS	
numSegments	TokenNameIdentifier	 num Segments
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
versionString	TokenNameIdentifier	 version String
+	TokenNamePLUS	
" format="	TokenNameStringLiteral	 format=
+	TokenNamePLUS	
sFormat	TokenNameIdentifier	 s Format
+	TokenNamePLUS	
userDataString	TokenNameIdentifier	 user Data String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
onlySegments	TokenNameIdentifier	 only Segments
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
partial	TokenNameIdentifier	 partial
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" Checking only these segments:"	TokenNameStringLiteral	 Checking only these segments:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
:	TokenNameCOLON	
onlySegments	TokenNameIdentifier	 only Segments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
segmentsChecked	TokenNameIdentifier	 segments Checked
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
onlySegments	TokenNameIdentifier	 only Segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
skip	TokenNameIdentifier	 skip
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" ERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting"	TokenNameStringLiteral	 ERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
toolOutOfDate	TokenNameIdentifier	 tool Out Of Date
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SegmentInfos	TokenNameIdentifier	 Segment Infos
)	TokenNameRPAREN	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numSegments	TokenNameIdentifier	 num Segments
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
segmentName	TokenNameIdentifier	 segment Name
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
MAX_RADIX	TokenNameIdentifier	 MAX  RADIX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
segmentName	TokenNameIdentifier	 segment Name
>	TokenNameGREATER	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
=	TokenNameEQUAL	
segmentName	TokenNameIdentifier	 segment Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
onlySegments	TokenNameIdentifier	 only Segments
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
onlySegments	TokenNameIdentifier	 only Segments
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
SegmentInfoStatus	TokenNameIdentifier	 Segment Info Status
segInfoStat	TokenNameIdentifier	 seg Info Stat
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
SegmentInfoStatus	TokenNameIdentifier	 Segment Info Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
segmentInfos	TokenNameIdentifier	 segment Infos
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
+	TokenNamePLUS	
" of "	TokenNameStringLiteral	 of 
+	TokenNamePLUS	
numSegments	TokenNameIdentifier	 num Segments
+	TokenNamePLUS	
": name="	TokenNameStringLiteral	: name=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
" docCount="	TokenNameStringLiteral	 docCount=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
int	TokenNameint	
toLoseDocCount	TokenNameIdentifier	 to Lose Doc Count
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
SegmentReader	TokenNameIdentifier	 Segment Reader
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" compound="	TokenNameStringLiteral	 compound=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getUseCompoundFile	TokenNameIdentifier	 get Use Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
compound	TokenNameIdentifier	 compound
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getUseCompoundFile	TokenNameIdentifier	 get Use Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" hasProx="	TokenNameStringLiteral	 hasProx=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getHasProx	TokenNameIdentifier	 get Has Prox
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
hasProx	TokenNameIdentifier	 has Prox
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getHasProx	TokenNameIdentifier	 get Has Prox
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" numFiles="	TokenNameStringLiteral	 numFiles=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
numFiles	TokenNameIdentifier	 num Files
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
sizeMB	TokenNameIdentifier	 size MB
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
1024.	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
1024.	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" size (MB)="	TokenNameStringLiteral	 size (MB)=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
sizeMB	TokenNameIdentifier	 size MB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
diagnostics	TokenNameIdentifier	 diagnostics
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDiagnostics	TokenNameIdentifier	 get Diagnostics
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
diagnostics	TokenNameIdentifier	 diagnostics
=	TokenNameEQUAL	
diagnostics	TokenNameIdentifier	 diagnostics
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
diagnostics	TokenNameIdentifier	 diagnostics
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" diagnostics = "	TokenNameStringLiteral	 diagnostics = 
+	TokenNamePLUS	
diagnostics	TokenNameIdentifier	 diagnostics
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDocStoreOffset	TokenNameIdentifier	 get Doc Store Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" docStoreOffset="	TokenNameStringLiteral	 docStoreOffset=
+	TokenNamePLUS	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
=	TokenNameEQUAL	
docStoreOffset	TokenNameIdentifier	 doc Store Offset
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" docStoreSegment="	TokenNameStringLiteral	 docStoreSegment=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDocStoreSegment	TokenNameIdentifier	 get Doc Store Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
docStoreSegment	TokenNameIdentifier	 doc Store Segment
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDocStoreSegment	TokenNameIdentifier	 get Doc Store Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" docStoreIsCompoundFile="	TokenNameStringLiteral	 docStoreIsCompoundFile=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDocStoreIsCompoundFile	TokenNameIdentifier	 get Doc Store Is Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
docStoreCompoundFile	TokenNameIdentifier	 doc Store Compound File
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDocStoreIsCompoundFile	TokenNameIdentifier	 get Doc Store Is Compound File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
delFileName	TokenNameIdentifier	 del File Name
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelFileName	TokenNameIdentifier	 get Del File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
delFileName	TokenNameIdentifier	 del File Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" no deletions"	TokenNameStringLiteral	 no deletions
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
hasDeletions	TokenNameIdentifier	 has Deletions
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" has deletions [delFileName="	TokenNameStringLiteral	 has deletions [delFileName=
+	TokenNamePLUS	
delFileName	TokenNameIdentifier	 del File Name
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
hasDeletions	TokenNameIdentifier	 has Deletions
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
deletionsFileName	TokenNameIdentifier	 deletions File Name
=	TokenNameEQUAL	
delFileName	TokenNameIdentifier	 del File Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: open reader........."	TokenNameStringLiteral	 test: open reader.........
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
SegmentReader	TokenNameIdentifier	 Segment Reader
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
.	TokenNameDOT	
DEFAULT_TERMS_INDEX_DIVISOR	TokenNameIdentifier	 DEFAULT  TERMS  INDEX  DIVISOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
openReaderPassed	TokenNameIdentifier	 open Reader Passed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
numDocs	TokenNameIdentifier	 num Docs
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
numDocs	TokenNameIdentifier	 num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
toLoseDocCount	TokenNameIdentifier	 to Lose Doc Count
=	TokenNameEQUAL	
numDocs	TokenNameIdentifier	 num Docs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
hasDeletions	TokenNameIdentifier	 has Deletions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"delete count mismatch: info="	TokenNameStringLiteral	delete count mismatch: info=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs deletedDocs.count()="	TokenNameStringLiteral	 vs deletedDocs.count()=
+	TokenNamePLUS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"too many deleted docs: maxDoc()="	TokenNameStringLiteral	too many deleted docs: maxDoc()=
+	TokenNamePLUS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs deletedDocs.count()="	TokenNameStringLiteral	 vs deletedDocs.count()=
+	TokenNamePLUS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
-	TokenNameMINUS	
numDocs	TokenNameIdentifier	 num Docs
!=	TokenNameNOT_EQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"delete count mismatch: info="	TokenNameStringLiteral	delete count mismatch: info=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs reader="	TokenNameStringLiteral	 vs reader=
+	TokenNamePLUS	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
-	TokenNameMINUS	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
numLive	TokenNameIdentifier	 num Live
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numLive	TokenNameIdentifier	 num Live
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numLive	TokenNameIdentifier	 num Live
!=	TokenNameNOT_EQUAL	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"liveDocs count mismatch: info="	TokenNameStringLiteral	liveDocs count mismatch: info=
+	TokenNamePLUS	
numDocs	TokenNameIdentifier	 num Docs
+	TokenNamePLUS	
", vs bits="	TokenNameStringLiteral	, vs bits=
+	TokenNamePLUS	
numLive	TokenNameIdentifier	 num Live
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
numDeleted	TokenNameIdentifier	 num Deleted
=	TokenNameEQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
-	TokenNameMINUS	
numDocs	TokenNameIdentifier	 num Docs
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
numDeleted	TokenNameIdentifier	 num Deleted
)	TokenNameRPAREN	
+	TokenNamePLUS	
" deleted docs]"	TokenNameStringLiteral	 deleted docs]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"delete count mismatch: info="	TokenNameStringLiteral	delete count mismatch: info=
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getDelCount	TokenNameIdentifier	 get Del Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs reader="	TokenNameStringLiteral	 vs reader=
+	TokenNamePLUS	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
-	TokenNameMINUS	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"liveDocs mismatch: info says no deletions but doc "	TokenNameStringLiteral	liveDocs mismatch: info says no deletions but doc 
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
" is deleted."	TokenNameStringLiteral	 is deleted.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK"	TokenNameStringLiteral	OK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"SegmentReader.maxDoc() "	TokenNameStringLiteral	SegmentReader.maxDoc() 
+	TokenNamePLUS	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" != SegmentInfos.docCount "	TokenNameStringLiteral	 != SegmentInfos.docCount 
+	TokenNamePLUS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test getFieldInfos() 	TokenNameCOMMENT_LINE	Test getFieldInfos() 
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: fields.............."	TokenNameStringLiteral	 test: fields..............
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getFieldInfos	TokenNameIdentifier	 get Field Infos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
fieldInfos	TokenNameIdentifier	 field Infos
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" fields]"	TokenNameStringLiteral	 fields]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
numFields	TokenNameIdentifier	 num Fields
=	TokenNameEQUAL	
fieldInfos	TokenNameIdentifier	 field Infos
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test Field Norms 	TokenNameCOMMENT_LINE	Test Field Norms 
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
fieldNormStatus	TokenNameIdentifier	 field Norm Status
=	TokenNameEQUAL	
testFieldNorms	TokenNameIdentifier	 test Field Norms
(	TokenNameLPAREN	
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test the Term Index 	TokenNameCOMMENT_LINE	Test the Term Index 
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
termIndexStatus	TokenNameIdentifier	 term Index Status
=	TokenNameEQUAL	
testTermIndex	TokenNameIdentifier	 test Term Index
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test Stored Fields 	TokenNameCOMMENT_LINE	Test Stored Fields 
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
storedFieldStatus	TokenNameIdentifier	 stored Field Status
=	TokenNameEQUAL	
testStoredFields	TokenNameIdentifier	 test Stored Fields
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
nf	TokenNameIdentifier	 nf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Test Term Vectors 	TokenNameCOMMENT_LINE	Test Term Vectors 
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
termVectorStatus	TokenNameIdentifier	 term Vector Status
=	TokenNameEQUAL	
testTermVectors	TokenNameIdentifier	 test Term Vectors
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
nf	TokenNameIdentifier	 nf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Rethrow the first exception we encountered 	TokenNameCOMMENT_LINE	Rethrow the first exception we encountered 
// This will cause stats for failed segments to be incremented properly 	TokenNameCOMMENT_LINE	This will cause stats for failed segments to be incremented properly 
if	TokenNameif	
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
fieldNormStatus	TokenNameIdentifier	 field Norm Status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Field Norm test failed"	TokenNameStringLiteral	Field Norm test failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
termIndexStatus	TokenNameIdentifier	 term Index Status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Term Index test failed"	TokenNameStringLiteral	Term Index test failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
storedFieldStatus	TokenNameIdentifier	 stored Field Status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Stored Field test failed"	TokenNameStringLiteral	Stored Field test failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
segInfoStat	TokenNameIdentifier	 seg Info Stat
.	TokenNameDOT	
termVectorStatus	TokenNameIdentifier	 term Vector Status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Term Vector test failed"	TokenNameStringLiteral	Term Vector test failed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"FAILED"	TokenNameStringLiteral	FAILED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
comment	TokenNameIdentifier	 comment
;	TokenNameSEMICOLON	
comment	TokenNameIdentifier	 comment
=	TokenNameEQUAL	
"fixIndex() would remove reference to this segment"	TokenNameStringLiteral	fixIndex() would remove reference to this segment
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
" WARNING: "	TokenNameStringLiteral	 WARNING: 
+	TokenNamePLUS	
comment	TokenNameIdentifier	 comment
+	TokenNamePLUS	
"; full exception:"	TokenNameStringLiteral	; full exception:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
+=	TokenNamePLUS_EQUAL	
toLoseDocCount	TokenNameIdentifier	 to Lose Doc Count
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
numBadSegments	TokenNameIdentifier	 num Bad Segments
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Keeper 	TokenNameCOMMENT_LINE	Keeper 
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
)	TokenNameRPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
numBadSegments	TokenNameIdentifier	 num Bad Segments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clean	TokenNameIdentifier	 clean
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"WARNING: "	TokenNameStringLiteral	WARNING: 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
numBadSegments	TokenNameIdentifier	 num Bad Segments
+	TokenNamePLUS	
" broken segments (containing "	TokenNameStringLiteral	 broken segments (containing 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
+	TokenNamePLUS	
" documents) detected"	TokenNameStringLiteral	 documents) detected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
validCounter	TokenNameIdentifier	 valid Counter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
<	TokenNameLESS	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
counter	TokenNameIdentifier	 counter
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clean	TokenNameIdentifier	 clean
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR: Next segment name counter "	TokenNameStringLiteral	ERROR: Next segment name counter 
+	TokenNamePLUS	
sis	TokenNameIdentifier	 sis
.	TokenNameDOT	
counter	TokenNameIdentifier	 counter
+	TokenNamePLUS	
" is not greater than max segment name "	TokenNameStringLiteral	 is not greater than max segment name 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
maxSegmentName	TokenNameIdentifier	 max Segment Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clean	TokenNameIdentifier	 clean
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"No problems were detected with this index. "	TokenNameStringLiteral	No problems were detected with this index. 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test field norms. */	TokenNameCOMMENT_JAVADOC	 Test field norms. 
private	TokenNameprivate	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
FieldNormStatus	TokenNameIdentifier	 Field Norm Status
testFieldNorms	TokenNameIdentifier	 test Field Norms
(	TokenNameLPAREN	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
SegmentReader	TokenNameIdentifier	 Segment Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
FieldNormStatus	TokenNameIdentifier	 Field Norm Status
status	TokenNameIdentifier	 status
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
FieldNormStatus	TokenNameIdentifier	 Field Norm Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Test Field Norms 	TokenNameCOMMENT_LINE	Test Field Norms 
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: field norms........."	TokenNameStringLiteral	 test: field norms.........
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
FieldInfo	TokenNameIdentifier	 Field Info
fieldInfo	TokenNameIdentifier	 field Info
:	TokenNameCOLON	
fieldInfos	TokenNameIdentifier	 field Infos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
hasNorms	TokenNameIdentifier	 has Norms
(	TokenNameLPAREN	
fieldInfo	TokenNameIdentifier	 field Info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
norms	TokenNameIdentifier	 norms
(	TokenNameLPAREN	
fieldInfo	TokenNameIdentifier	 field Info
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFields	TokenNameIdentifier	 tot Fields
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFields	TokenNameIdentifier	 tot Fields
+	TokenNamePLUS	
" fields]"	TokenNameStringLiteral	 fields]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR ["	TokenNameStringLiteral	ERROR [
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
status	TokenNameIdentifier	 status
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test the term index. */	TokenNameCOMMENT_JAVADOC	 Test the term index. 
private	TokenNameprivate	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermIndexStatus	TokenNameIdentifier	 Term Index Status
testTermIndex	TokenNameIdentifier	 test Term Index
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
SegmentReader	TokenNameIdentifier	 Segment Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermIndexStatus	TokenNameIdentifier	 Term Index Status
status	TokenNameIdentifier	 status
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermIndexStatus	TokenNameIdentifier	 Term Index Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IndexSearcher	TokenNameIdentifier	 Index Searcher
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSearcher	TokenNameIdentifier	 Index Searcher
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: terms, freq, prox..."	TokenNameStringLiteral	 test: terms, freq, prox...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
TermEnum	TokenNameIdentifier	 Term Enum
termEnum	TokenNameIdentifier	 term Enum
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
terms	TokenNameIdentifier	 terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TermPositions	TokenNameIdentifier	 Term Positions
termPositions	TokenNameIdentifier	 term Positions
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
termPositions	TokenNameIdentifier	 term Positions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Used only to count up # deleted docs for this term 	TokenNameCOMMENT_LINE	Used only to count up # deleted docs for this term 
final	TokenNamefinal	
MySegmentTermDocs	TokenNameIdentifier	 My Segment Term Docs
myTermDocs	TokenNameIdentifier	 my Term Docs
=	TokenNameEQUAL	
new	TokenNamenew	
MySegmentTermDocs	TokenNameIdentifier	 My Segment Term Docs
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
maxDoc	TokenNameIdentifier	 max Doc
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
maxDoc	TokenNameIdentifier	 max Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
lastTerm	TokenNameIdentifier	 last Term
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
lastField	TokenNameIdentifier	 last Field
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
termCount	TokenNameIdentifier	 term Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
term	TokenNameIdentifier	 term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lastTerm	TokenNameIdentifier	 last Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
lastTerm	TokenNameIdentifier	 last Term
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"terms out of order: lastTerm="	TokenNameStringLiteral	terms out of order: lastTerm=
+	TokenNamePLUS	
lastTerm	TokenNameIdentifier	 last Term
+	TokenNamePLUS	
" term="	TokenNameStringLiteral	 term=
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastTerm	TokenNameIdentifier	 last Term
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
!=	TokenNameNOT_EQUAL	
lastField	TokenNameIdentifier	 last Field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// field change: verify its in fieldinfos, and that its indexed. 	TokenNameCOMMENT_LINE	field change: verify its in fieldinfos, and that its indexed. 
FieldInfo	TokenNameIdentifier	 Field Info
fi	TokenNameIdentifier	 fi
=	TokenNameEQUAL	
fieldInfos	TokenNameIdentifier	 field Infos
.	TokenNameDOT	
fieldInfo	TokenNameIdentifier	 field Info
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"terms inconsistent with fieldInfos, no fieldInfos for: "	TokenNameStringLiteral	terms inconsistent with fieldInfos, no fieldInfos for: 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"terms inconsistent with fieldInfos, isIndexed == false for: "	TokenNameStringLiteral	terms inconsistent with fieldInfos, isIndexed == false for: 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastField	TokenNameIdentifier	 last Field
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
docFreq	TokenNameIdentifier	 doc Freq
=	TokenNameEQUAL	
termEnum	TokenNameIdentifier	 term Enum
.	TokenNameDOT	
docFreq	TokenNameIdentifier	 doc Freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docFreq	TokenNameIdentifier	 doc Freq
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"docfreq: "	TokenNameStringLiteral	docfreq: 
+	TokenNamePLUS	
docFreq	TokenNameIdentifier	 doc Freq
+	TokenNamePLUS	
" is out of bounds"	TokenNameStringLiteral	 is out of bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastDoc	TokenNameIdentifier	 last Doc
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
freq0	TokenNameIdentifier	 freq0
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFreq	TokenNameIdentifier	 tot Freq
+=	TokenNamePLUS_EQUAL	
docFreq	TokenNameIdentifier	 doc Freq
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freq0	TokenNameIdentifier	 freq0
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
freq	TokenNameIdentifier	 freq
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
freq	TokenNameIdentifier	 freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
<=	TokenNameLESS_EQUAL	
lastDoc	TokenNameIdentifier	 last Doc
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": doc "	TokenNameStringLiteral	: doc 
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
" <= lastDoc "	TokenNameStringLiteral	 <= lastDoc 
+	TokenNamePLUS	
lastDoc	TokenNameIdentifier	 last Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
>=	TokenNameGREATER_EQUAL	
maxDoc	TokenNameIdentifier	 max Doc
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": doc "	TokenNameStringLiteral	: doc 
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
" >= maxDoc "	TokenNameStringLiteral	 >= maxDoc 
+	TokenNamePLUS	
maxDoc	TokenNameIdentifier	 max Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastDoc	TokenNameIdentifier	 last Doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
freq	TokenNameIdentifier	 freq
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": doc "	TokenNameStringLiteral	: doc 
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
": freq "	TokenNameStringLiteral	: freq 
+	TokenNamePLUS	
freq	TokenNameIdentifier	 freq
+	TokenNamePLUS	
" is out of bounds"	TokenNameStringLiteral	 is out of bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastPos	TokenNameIdentifier	 last Pos
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totPos	TokenNameIdentifier	 tot Pos
+=	TokenNamePLUS_EQUAL	
freq	TokenNameIdentifier	 freq
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
freq	TokenNameIdentifier	 freq
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
nextPosition	TokenNameIdentifier	 next Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: -1 is allowed because of ancient bug 	TokenNameCOMMENT_LINE	NOTE: -1 is allowed because of ancient bug 
// (LUCENE-1542) whereby IndexWriter could 	TokenNameCOMMENT_LINE	(LUCENE-1542) whereby IndexWriter could 
// write pos=-1 when first token's posInc is 0 	TokenNameCOMMENT_LINE	write pos=-1 when first token's posInc is 0 
// (separately: analyzers should not give 	TokenNameCOMMENT_LINE	(separately: analyzers should not give 
// posInc=0 to first token): 	TokenNameCOMMENT_LINE	posInc=0 to first token): 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": doc "	TokenNameStringLiteral	: doc 
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
": pos "	TokenNameStringLiteral	: pos 
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" is out of bounds"	TokenNameStringLiteral	 is out of bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
lastPos	TokenNameIdentifier	 last Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": doc "	TokenNameStringLiteral	: doc 
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
": pos "	TokenNameStringLiteral	: pos 
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" < lastPos "	TokenNameStringLiteral	 < lastPos 
+	TokenNamePLUS	
lastPos	TokenNameIdentifier	 last Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastPos	TokenNameIdentifier	 last Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Test skipping 	TokenNameCOMMENT_LINE	Test skipping 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
skipDocID	TokenNameIdentifier	 skip Doc ID
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
maxDoc	TokenNameIdentifier	 max Doc
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
skipTo	TokenNameIdentifier	 skip To
(	TokenNameLPAREN	
skipDocID	TokenNameIdentifier	 skip Doc ID
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
<	TokenNameLESS	
skipDocID	TokenNameIdentifier	 skip Doc ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": skipTo(docID="	TokenNameStringLiteral	: skipTo(docID=
+	TokenNamePLUS	
skipDocID	TokenNameIdentifier	 skip Doc ID
+	TokenNamePLUS	
") returned docID="	TokenNameStringLiteral	) returned docID=
+	TokenNamePLUS	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
freq	TokenNameIdentifier	 freq
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
freq	TokenNameIdentifier	 freq
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
freq	TokenNameIdentifier	 freq
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"termFreq "	TokenNameStringLiteral	termFreq 
+	TokenNamePLUS	
freq	TokenNameIdentifier	 freq
+	TokenNamePLUS	
" is out of bounds"	TokenNameStringLiteral	 is out of bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
lastPosition	TokenNameIdentifier	 last Position
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
posUpto	TokenNameIdentifier	 pos Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
posUpto	TokenNameIdentifier	 pos Upto
<	TokenNameLESS	
freq	TokenNameIdentifier	 freq
;	TokenNameSEMICOLON	
posUpto	TokenNameIdentifier	 pos Upto
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
nextPosition	TokenNameIdentifier	 next Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: -1 is allowed because of ancient bug 	TokenNameCOMMENT_LINE	NOTE: -1 is allowed because of ancient bug 
// (LUCENE-1542) whereby IndexWriter could 	TokenNameCOMMENT_LINE	(LUCENE-1542) whereby IndexWriter could 
// write pos=-1 when first token's posInc is 0 	TokenNameCOMMENT_LINE	write pos=-1 when first token's posInc is 0 
// (separately: analyzers should not give 	TokenNameCOMMENT_LINE	(separately: analyzers should not give 
// posInc=0 to first token): 	TokenNameCOMMENT_LINE	posInc=0 to first token): 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"position "	TokenNameStringLiteral	position 
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" is out of bounds"	TokenNameStringLiteral	 is out of bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO: we should assert when all pos == 0 that positions are actually omitted 	TokenNameCOMMENT_LINE	TODO: we should assert when all pos == 0 that positions are actually omitted 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
lastPosition	TokenNameIdentifier	 last Position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"position "	TokenNameStringLiteral	position 
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" is < lastPosition "	TokenNameStringLiteral	 is < lastPosition 
+	TokenNamePLUS	
lastPosition	TokenNameIdentifier	 last Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastPosition	TokenNameIdentifier	 last Position
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
nextDocID	TokenNameIdentifier	 next Doc ID
=	TokenNameEQUAL	
termPositions	TokenNameIdentifier	 term Positions
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextDocID	TokenNameIdentifier	 next Doc ID
<=	TokenNameLESS_EQUAL	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
": skipTo(docID="	TokenNameStringLiteral	: skipTo(docID=
+	TokenNamePLUS	
skipDocID	TokenNameIdentifier	 skip Doc ID
+	TokenNamePLUS	
"), then .next() returned docID="	TokenNameStringLiteral	), then .next() returned docID=
+	TokenNamePLUS	
nextDocID	TokenNameIdentifier	 next Doc ID
+	TokenNamePLUS	
" vs prev docID="	TokenNameStringLiteral	 vs prev docID=
+	TokenNamePLUS	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Now count how many deleted docs occurred in 	TokenNameCOMMENT_LINE	Now count how many deleted docs occurred in 
// this term: 	TokenNameCOMMENT_LINE	this term: 
final	TokenNamefinal	
int	TokenNameint	
delCount	TokenNameIdentifier	 del Count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
hasDeletions	TokenNameIdentifier	 has Deletions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
myTermDocs	TokenNameIdentifier	 my Term Docs
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
myTermDocs	TokenNameIdentifier	 my Term Docs
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
delCount	TokenNameIdentifier	 del Count
=	TokenNameEQUAL	
myTermDocs	TokenNameIdentifier	 my Term Docs
.	TokenNameDOT	
delCount	TokenNameIdentifier	 del Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
delCount	TokenNameIdentifier	 del Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
freq0	TokenNameIdentifier	 freq0
+	TokenNamePLUS	
delCount	TokenNameIdentifier	 del Count
!=	TokenNameNOT_EQUAL	
docFreq	TokenNameIdentifier	 doc Freq
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"term "	TokenNameStringLiteral	term 
+	TokenNamePLUS	
term	TokenNameIdentifier	 term
+	TokenNamePLUS	
" docFreq="	TokenNameStringLiteral	 docFreq=
+	TokenNamePLUS	
docFreq	TokenNameIdentifier	 doc Freq
+	TokenNamePLUS	
" != num docs seen "	TokenNameStringLiteral	 != num docs seen 
+	TokenNamePLUS	
freq0	TokenNameIdentifier	 freq0
+	TokenNamePLUS	
" + num docs deleted "	TokenNameStringLiteral	 + num docs deleted 
+	TokenNamePLUS	
delCount	TokenNameIdentifier	 del Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Test search on last term: 	TokenNameCOMMENT_LINE	Test search on last term: 
if	TokenNameif	
(	TokenNameLPAREN	
lastTerm	TokenNameIdentifier	 last Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
is	TokenNameIdentifier	 is
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
lastTerm	TokenNameIdentifier	 last Term
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
long	TokenNamelong	
uniqueTermCountAllFields	TokenNameIdentifier	 unique Term Count All Fields
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getUniqueTermCount	TokenNameIdentifier	 get Unique Term Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
termCount	TokenNameIdentifier	 term Count
!=	TokenNameNOT_EQUAL	
uniqueTermCountAllFields	TokenNameIdentifier	 unique Term Count All Fields
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"termCount mismatch "	TokenNameStringLiteral	termCount mismatch 
+	TokenNamePLUS	
uniqueTermCountAllFields	TokenNameIdentifier	 unique Term Count All Fields
+	TokenNamePLUS	
" vs "	TokenNameStringLiteral	 vs 
+	TokenNamePLUS	
(	TokenNameLPAREN	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
termCount	TokenNameIdentifier	 term Count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not supported 	TokenNameCOMMENT_LINE	not supported 
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
termCount	TokenNameIdentifier	 term Count
+	TokenNamePLUS	
" terms; "	TokenNameStringLiteral	 terms; 
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFreq	TokenNameIdentifier	 tot Freq
+	TokenNamePLUS	
" terms/docs pairs; "	TokenNameStringLiteral	 terms/docs pairs; 
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totPos	TokenNameIdentifier	 tot Pos
+	TokenNamePLUS	
" tokens]"	TokenNameStringLiteral	 tokens]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR ["	TokenNameStringLiteral	ERROR [
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
status	TokenNameIdentifier	 status
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test stored fields for a segment. */	TokenNameCOMMENT_JAVADOC	 Test stored fields for a segment. 
private	TokenNameprivate	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
StoredFieldStatus	TokenNameIdentifier	 Stored Field Status
testStoredFields	TokenNameIdentifier	 test Stored Fields
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
SegmentReader	TokenNameIdentifier	 Segment Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
NumberFormat	TokenNameIdentifier	 Number Format
format	TokenNameIdentifier	 format
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
StoredFieldStatus	TokenNameIdentifier	 Stored Field Status
status	TokenNameIdentifier	 status
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
StoredFieldStatus	TokenNameIdentifier	 Stored Field Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: stored fields......."	TokenNameStringLiteral	 test: stored fields.......
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Scan stored fields for all documents 	TokenNameCOMMENT_LINE	Scan stored fields for all documents 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
document	TokenNameIdentifier	 document
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFields	TokenNameIdentifier	 tot Fields
+=	TokenNamePLUS_EQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getFields	TokenNameIdentifier	 get Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Validate docCount 	TokenNameCOMMENT_LINE	Validate docCount 
if	TokenNameif	
(	TokenNameLPAREN	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
!=	TokenNameNOT_EQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
numDocs	TokenNameIdentifier	 num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"docCount="	TokenNameStringLiteral	docCount=
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
+	TokenNamePLUS	
" but saw "	TokenNameStringLiteral	 but saw 
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
+	TokenNamePLUS	
" undeleted docs"	TokenNameStringLiteral	 undeleted docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFields	TokenNameIdentifier	 tot Fields
+	TokenNamePLUS	
" total field count; avg "	TokenNameStringLiteral	 total field count; avg 
+	TokenNamePLUS	
format	TokenNameIdentifier	 format
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totFields	TokenNameIdentifier	 tot Fields
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" fields per doc]"	TokenNameStringLiteral	 fields per doc]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR ["	TokenNameStringLiteral	ERROR [
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
status	TokenNameIdentifier	 status
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test term vectors for a segment. */	TokenNameCOMMENT_JAVADOC	 Test term vectors for a segment. 
private	TokenNameprivate	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermVectorStatus	TokenNameIdentifier	 Term Vector Status
testTermVectors	TokenNameIdentifier	 test Term Vectors
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
info	TokenNameIdentifier	 info
,	TokenNameCOMMA	
SegmentReader	TokenNameIdentifier	 Segment Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
NumberFormat	TokenNameIdentifier	 Number Format
format	TokenNameIdentifier	 format
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermVectorStatus	TokenNameIdentifier	 Term Vector Status
status	TokenNameIdentifier	 status
=	TokenNameEQUAL	
new	TokenNamenew	
Status	TokenNameIdentifier	 Status
.	TokenNameDOT	
TermVectorStatus	TokenNameIdentifier	 Term Vector Status
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
infoStream	TokenNameIdentifier	 info Stream
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" test: term vectors........"	TokenNameStringLiteral	 test: term vectors........
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
isDeleted	TokenNameIdentifier	 is Deleted
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
TermFreqVector	TokenNameIdentifier	 Term Freq Vector
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tfv	TokenNameIdentifier	 tfv
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
getTermFreqVectors	TokenNameIdentifier	 get Term Freq Vectors
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tfv	TokenNameIdentifier	 tfv
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totVectors	TokenNameIdentifier	 tot Vectors
+=	TokenNamePLUS_EQUAL	
tfv	TokenNameIdentifier	 tfv
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"OK ["	TokenNameStringLiteral	OK [
+	TokenNamePLUS	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totVectors	TokenNameIdentifier	 tot Vectors
+	TokenNamePLUS	
" total vector count; avg "	TokenNameStringLiteral	 total vector count; avg 
+	TokenNamePLUS	
format	TokenNameIdentifier	 format
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
totVectors	TokenNameIdentifier	 tot Vectors
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" term/freq vector fields per doc]"	TokenNameStringLiteral	 term/freq vector fields per doc]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
(	TokenNameLPAREN	
"ERROR ["	TokenNameStringLiteral	ERROR [
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
status	TokenNameIdentifier	 status
.	TokenNameDOT	
error	TokenNameIdentifier	 error
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
status	TokenNameIdentifier	 status
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Repairs the index using previously returned result * from {@link #checkIndex}. Note that this does not * remove any of the unreferenced files after it's done; * you must separately open an {@link IndexWriter}, which * deletes unreferenced files when it's created. * * <p><b>WARNING</b>: this writes a * new segments file into the index, effectively removing * all documents in broken segments from the index. * BE CAREFUL. * * <p><b>WARNING</b>: Make sure you only call this when the * index is not opened by any writer. */	TokenNameCOMMENT_JAVADOC	 Repairs the index using previously returned result from {@link #checkIndex}. Note that this does not remove any of the unreferenced files after it's done; you must separately open an {@link IndexWriter}, which deletes unreferenced files when it's created. * <p><b>WARNING</b>: this writes a new segments file into the index, effectively removing all documents in broken segments from the index. BE CAREFUL. * <p><b>WARNING</b>: Make sure you only call this when the index is not opened by any writer. 
public	TokenNamepublic	
void	TokenNamevoid	
fixIndex	TokenNameIdentifier	 fix Index
(	TokenNameLPAREN	
Status	TokenNameIdentifier	 Status
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
partial	TokenNameIdentifier	 partial
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"can only fix an index that was fully checked (this status checked a subset of segments)"	TokenNameStringLiteral	can only fix an index that was fully checked (this status checked a subset of segments)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
changed	TokenNameIdentifier	 changed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
commit	TokenNameIdentifier	 commit
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
assertsOn	TokenNameIdentifier	 asserts On
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
testAsserts	TokenNameIdentifier	 test Asserts
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertsOn	TokenNameIdentifier	 asserts On
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
assertsOn	TokenNameIdentifier	 asserts On
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
testAsserts	TokenNameIdentifier	 test Asserts
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
assertsOn	TokenNameIdentifier	 asserts On
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Command-line interface to check and fix an index. <p> Run it like this: <pre> java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y] </pre> <ul> <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments <li><code>-segment X</code>: only check the specified segment(s). This can be specified multiple times, to check more than one segment, eg <code>-segment _2 -segment _a</code>. You can't use this with the -fix option. </ul> <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause documents (perhaps many) to be permanently removed from the index. Always make a backup copy of your index before running this! Do not run this tool on an index that is actively being written to. You have been warned! <p> Run without -fix, this tool will open the index, report version information and report any exceptions it hits and what action it would take if -fix were specified. With -fix, this tool will remove any segments that have issues and write a new segments_N file. This means all documents contained in the affected segments will be removed. <p> This tool exits with exit code 1 if the index cannot be opened or has any corruption, else 0. */	TokenNameCOMMENT_JAVADOC	 Command-line interface to check and fix an index. <p> Run it like this: <pre> java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y] </pre> <ul> <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments <li><code>-segment X</code>: only check the specified segment(s). This can be specified multiple times, to check more than one segment, eg <code>-segment _2 -segment _a</code>. You can't use this with the -fix option. </ul> <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause documents (perhaps many) to be permanently removed from the index. Always make a backup copy of your index before running this! Do not run this tool on an index that is actively being written to. You have been warned! <p> Run without -fix, this tool will open the index, report version information and report any exceptions it hits and what action it would take if -fix were specified. With -fix, this tool will remove any segments that have issues and write a new segments_N file. This means all documents contained in the affected segments will be removed. <p> This tool exits with exit code 1 if the index cannot be opened or has any corruption, else 0. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
main	TokenNameIdentifier	 main
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
doFix	TokenNameIdentifier	 do Fix
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
onlySegments	TokenNameIdentifier	 only Segments
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
indexPath	TokenNameIdentifier	 index Path
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dirImpl	TokenNameIdentifier	 dir Impl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
args	TokenNameIdentifier	 args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
arg	TokenNameIdentifier	 arg
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
"-fix"	TokenNameStringLiteral	-fix
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
arg	TokenNameIdentifier	 arg
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doFix	TokenNameIdentifier	 do Fix
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"-segment"	TokenNameStringLiteral	-segment
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
args	TokenNameIdentifier	 args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"ERROR: missing name for -segment option"	TokenNameStringLiteral	ERROR: missing name for -segment option
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
onlySegments	TokenNameIdentifier	 only Segments
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"-dir-impl"	TokenNameStringLiteral	-dir-impl
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
arg	TokenNameIdentifier	 arg
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
args	TokenNameIdentifier	 args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"ERROR: missing value for -dir-impl option"	TokenNameStringLiteral	ERROR: missing value for -dir-impl option
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
dirImpl	TokenNameIdentifier	 dir Impl
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexPath	TokenNameIdentifier	 index Path
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"ERROR: unexpected extra argument '"	TokenNameStringLiteral	ERROR: unexpected extra argument '
+	TokenNamePLUS	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
indexPath	TokenNameIdentifier	 index Path
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexPath	TokenNameIdentifier	 index Path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" ERROR: index path not specified"	TokenNameStringLiteral	 ERROR: index path not specified
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Usage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y] [-dir-impl X] "	TokenNameStringLiteral	 Usage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y] [-dir-impl X] 
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
" -fix: actually write a new segments_N file, removing any problematic segments "	TokenNameStringLiteral	 -fix: actually write a new segments_N file, removing any problematic segments 
+	TokenNamePLUS	
" -segment X: only check the specified segments. This can be specified multiple "	TokenNameStringLiteral	 -segment X: only check the specified segments. This can be specified multiple 
+	TokenNamePLUS	
" times, to check more than one segment, eg '-segment _2 -segment _a'. "	TokenNameStringLiteral	 times, to check more than one segment, eg '-segment _2 -segment _a'. 
+	TokenNamePLUS	
" You can't use this with the -fix option "	TokenNameStringLiteral	 You can't use this with the -fix option 
+	TokenNamePLUS	
" -dir-impl X: use a specific "	TokenNameStringLiteral	 -dir-impl X: use a specific 
+	TokenNamePLUS	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getSimpleName	TokenNameIdentifier	 get Simple Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" implementation. "	TokenNameStringLiteral	 implementation. 
+	TokenNamePLUS	
"If no package is specified the "	TokenNameStringLiteral	If no package is specified the 
+	TokenNamePLUS	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getPackage	TokenNameIdentifier	 get Package
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" package will be used. "	TokenNameStringLiteral	 package will be used. 
+	TokenNamePLUS	
"**WARNING**: -fix should only be used on an emergency basis as it will cause "	TokenNameStringLiteral	**WARNING**: -fix should only be used on an emergency basis as it will cause 
+	TokenNamePLUS	
"documents (perhaps many) to be permanently removed from the index. Always make "	TokenNameStringLiteral	documents (perhaps many) to be permanently removed from the index. Always make 
+	TokenNamePLUS	
"a backup copy of your index before running this! Do not run this tool on an index "	TokenNameStringLiteral	a backup copy of your index before running this! Do not run this tool on an index 
+	TokenNamePLUS	
"that is actively being written to. You have been warned! "	TokenNameStringLiteral	that is actively being written to. You have been warned! 
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"Run without -fix, this tool will open the index, report version information "	TokenNameStringLiteral	Run without -fix, this tool will open the index, report version information 
+	TokenNamePLUS	
"and report any exceptions it hits and what action it would take if -fix were "	TokenNameStringLiteral	and report any exceptions it hits and what action it would take if -fix were 
+	TokenNamePLUS	
"specified. With -fix, this tool will remove any segments that have issues and "	TokenNameStringLiteral	specified. With -fix, this tool will remove any segments that have issues and 
+	TokenNamePLUS	
"write a new segments_N file. This means all documents contained in the affected "	TokenNameStringLiteral	write a new segments_N file. This means all documents contained in the affected 
+	TokenNamePLUS	
"segments will be removed. "	TokenNameStringLiteral	segments will be removed. 
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
"This tool exits with exit code 1 if the index cannot be opened or has any "	TokenNameStringLiteral	This tool exits with exit code 1 if the index cannot be opened or has any 
+	TokenNamePLUS	
"corruption, else 0. "	TokenNameStringLiteral	corruption, else 0. 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
assertsOn	TokenNameIdentifier	 asserts On
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" NOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled"	TokenNameStringLiteral	 NOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
onlySegments	TokenNameIdentifier	 only Segments
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
onlySegments	TokenNameIdentifier	 only Segments
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
doFix	TokenNameIdentifier	 do Fix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"ERROR: cannot specify both -fix and -segment"	TokenNameStringLiteral	ERROR: cannot specify both -fix and -segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Opening index @ "	TokenNameStringLiteral	 Opening index @ 
+	TokenNamePLUS	
indexPath	TokenNameIdentifier	 index Path
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Directory	TokenNameIdentifier	 Directory
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dirImpl	TokenNameIdentifier	 dir Impl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
indexPath	TokenNameIdentifier	 index Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
CommandLineUtil	TokenNameIdentifier	 Command Line Util
.	TokenNameDOT	
newFSDirectory	TokenNameIdentifier	 new FS Directory
(	TokenNameLPAREN	
dirImpl	TokenNameIdentifier	 dir Impl
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
indexPath	TokenNameIdentifier	 index Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"ERROR: could not open directory ""	TokenNameStringLiteral	ERROR: could not open directory "
+	TokenNamePLUS	
indexPath	TokenNameIdentifier	 index Path
+	TokenNamePLUS	
""; exiting"	TokenNameStringLiteral	"; exiting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CheckIndex	TokenNameIdentifier	 Check Index
checker	TokenNameIdentifier	 checker
=	TokenNameEQUAL	
new	TokenNamenew	
CheckIndex	TokenNameIdentifier	 Check Index
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checker	TokenNameIdentifier	 checker
.	TokenNameDOT	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Status	TokenNameIdentifier	 Status
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
checker	TokenNameIdentifier	 checker
.	TokenNameDOT	
checkIndex	TokenNameIdentifier	 check Index
(	TokenNameLPAREN	
onlySegments	TokenNameIdentifier	 only Segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
missingSegments	TokenNameIdentifier	 missing Segments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clean	TokenNameIdentifier	 clean
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
doFix	TokenNameIdentifier	 do Fix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"WARNING: would write new segments file, and "	TokenNameStringLiteral	WARNING: would write new segments file, and 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
+	TokenNamePLUS	
" documents would be lost, if -fix were specified "	TokenNameStringLiteral	 documents would be lost, if -fix were specified 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"WARNING: "	TokenNameStringLiteral	WARNING: 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
+	TokenNamePLUS	
" documents will be lost "	TokenNameStringLiteral	 documents will be lost 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: will write new segments file in 5 seconds; this will remove "	TokenNameStringLiteral	NOTE: will write new segments file in 5 seconds; this will remove 
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
totLoseDocCount	TokenNameIdentifier	 tot Lose Doc Count
+	TokenNamePLUS	
" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!"	TokenNameStringLiteral	 docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
-	TokenNameMINUS	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
+	TokenNamePLUS	
"..."	TokenNameStringLiteral	...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Writing..."	TokenNameStringLiteral	Writing...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checker	TokenNameIdentifier	 checker
.	TokenNameDOT	
fixIndex	TokenNameIdentifier	 fix Index
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"OK"	TokenNameStringLiteral	OK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Wrote new segments file ""	TokenNameStringLiteral	Wrote new segments file "
+	TokenNamePLUS	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
newSegments	TokenNameIdentifier	 new Segments
.	TokenNameDOT	
getSegmentsFileName	TokenNameIdentifier	 get Segments File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
exitCode	TokenNameIdentifier	 exit Code
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
clean	TokenNameIdentifier	 clean
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
)	TokenNameRPAREN	
exitCode	TokenNameIdentifier	 exit Code
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
exitCode	TokenNameIdentifier	 exit Code
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
exitCode	TokenNameIdentifier	 exit Code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
