/* Generated By:JavaCC: Do not edit this line. HTMLParserTokenManager.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. HTMLParserTokenManager.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
benchmark	TokenNameIdentifier	 benchmark
.	TokenNameDOT	
byTask	TokenNameIdentifier	 by Task
.	TokenNameDOT	
feeds	TokenNameIdentifier	 feeds
.	TokenNameDOT	
demohtml	TokenNameIdentifier	 demohtml
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Properties	TokenNameIdentifier	 Properties
;	TokenNameSEMICOLON	
/** Token Manager. */	TokenNameCOMMENT_JAVADOC	 Token Manager. 
public	TokenNamepublic	
class	TokenNameclass	
HTMLParserTokenManager	TokenNameIdentifier	 HTML Parser Token Manager
implements	TokenNameimplements	
HTMLParserConstants	TokenNameIdentifier	 HTML Parser Constants
{	TokenNameLBRACE	
/** Debug output. */	TokenNameCOMMENT_JAVADOC	 Debug output. 
public	TokenNamepublic	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
/** Set debug output. */	TokenNameCOMMENT_JAVADOC	 Set debug output. 
public	TokenNamepublic	
void	TokenNamevoid	
setDebugStream	TokenNameIdentifier	 set Debug Stream
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
ds	TokenNameIdentifier	 ds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x32L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x30L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
60	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa1_0	TokenNameIdentifier	 jj Move String Literal Dfa1 0
(	TokenNameLPAREN	
0x32L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa1_0	TokenNameIdentifier	 jj Move String Literal Dfa1 0
(	TokenNameLPAREN	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
33	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x20L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveStringLiteralDfa2_0	TokenNameIdentifier	 jj Move String Literal Dfa2 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x10L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
115	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa2_0	TokenNameIdentifier	 jj Move String Literal Dfa2 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa2_0	TokenNameIdentifier	 jj Move String Literal Dfa2 0
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
45	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa3_0	TokenNameIdentifier	 jj Move String Literal Dfa3 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x10L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
99	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa3_0	TokenNameIdentifier	 jj Move String Literal Dfa3 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa3_0	TokenNameIdentifier	 jj Move String Literal Dfa3 0
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
45	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x10L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
114	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa4_0	TokenNameIdentifier	 jj Move String Literal Dfa4 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa4_0	TokenNameIdentifier	 jj Move String Literal Dfa4 0
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
105	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa5_0	TokenNameIdentifier	 jj Move String Literal Dfa5 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa5_0	TokenNameIdentifier	 jj Move String Literal Dfa5 0
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
112	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa6_0	TokenNameIdentifier	 jj Move String Literal Dfa6 0
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa6_0	TokenNameIdentifier	 jj Move String Literal Dfa6 0
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_0	TokenNameIdentifier	 jj Stop String Literal Dfa 0
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
116	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x2L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfaWithStates_0	TokenNameIdentifier	 jj Start Nfa With States 0
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_0	TokenNameIdentifier	 jj Start Nfa 0
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStartNfaWithStates_0	TokenNameIdentifier	 jj Start Nfa With States 0
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0xfffffffffffffffeL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec2	TokenNameIdentifier	 jjbit Vec2
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
28	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
20	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
47	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
11	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
60	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
38	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
36	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
36	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x500000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x880000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
14	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
7	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
!=	TokenNameNOT_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x208000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
10	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
13	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
59	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
14	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
35	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
15	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
15	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
35	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
17	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
18	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
19	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
60	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
22	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9fffff7affffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
23	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9ffffffeffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
24	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9fffff7affffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9ffffffeffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
20	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
21	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7fffffe07fffffeL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
11	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7fffffe07fffffeL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7fffffe07fffffeL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
12	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7fffffe07fffffeL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
17	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100000001000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
18	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7e0000007eL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
22	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
23	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
25	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7fffffe07fffffeL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
26	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
22	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
23	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
28	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_5	TokenNameIdentifier	 jj Move String Literal Dfa0 5
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_5	TokenNameIdentifier	 jj Move Nfa 5
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_5	TokenNameIdentifier	 jj Move Nfa 5
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
25	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
26	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
26	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
25	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
25	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_7	TokenNameIdentifier	 jj Stop String Literal Dfa 7
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_7	TokenNameIdentifier	 jj Start Nfa 7
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_7	TokenNameIdentifier	 jj Move Nfa 7
(	TokenNameLPAREN	
jjStopStringLiteralDfa_7	TokenNameIdentifier	 jj Stop String Literal Dfa 7
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_7	TokenNameIdentifier	 jj Move String Literal Dfa0 7
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
62	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_7	TokenNameIdentifier	 jj Move Nfa 7
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_7	TokenNameIdentifier	 jj Move Nfa 7
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xbfffffffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
29	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
29	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
29	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
29	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_4	TokenNameIdentifier	 jj Move String Literal Dfa0 4
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_4	TokenNameIdentifier	 jj Move Nfa 4
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_4	TokenNameIdentifier	 jj Move Nfa 4
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffff7fffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
39	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffff7fffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_3	TokenNameIdentifier	 jj Stop String Literal Dfa 3
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_3	TokenNameIdentifier	 jj Start Nfa 3
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
jjStopStringLiteralDfa_3	TokenNameIdentifier	 jj Stop String Literal Dfa 3
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_3	TokenNameIdentifier	 jj Move String Literal Dfa0 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
39	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9fffff7affffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xbffffffeffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_6	TokenNameIdentifier	 jj Stop String Literal Dfa 6
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x10000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x10000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_6	TokenNameIdentifier	 jj Start Nfa 6
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_6	TokenNameIdentifier	 jj Move Nfa 6
(	TokenNameLPAREN	
jjStopStringLiteralDfa_6	TokenNameIdentifier	 jj Stop String Literal Dfa 6
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_6	TokenNameIdentifier	 jj Move String Literal Dfa0 6
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
45	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa1_6	TokenNameIdentifier	 jj Move String Literal Dfa1 6
(	TokenNameLPAREN	
0x10000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_6	TokenNameIdentifier	 jj Move Nfa 6
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa1_6	TokenNameIdentifier	 jj Move String Literal Dfa1 6
(	TokenNameLPAREN	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_6	TokenNameIdentifier	 jj Stop String Literal Dfa 6
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
45	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa2_6	TokenNameIdentifier	 jj Move String Literal Dfa2 6
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
,	TokenNameCOMMA	
0x10000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_6	TokenNameIdentifier	 jj Start Nfa 6
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa2_6	TokenNameIdentifier	 jj Move String Literal Dfa2 6
(	TokenNameLPAREN	
long	TokenNamelong	
old0	TokenNameIdentifier	 old0
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&=	TokenNameAND_EQUAL	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfa_6	TokenNameIdentifier	 jj Start Nfa 6
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
old0	TokenNameIdentifier	 old0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_6	TokenNameIdentifier	 jj Stop String Literal Dfa 6
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
62	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x10000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_6	TokenNameIdentifier	 jj Start Nfa 6
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_6	TokenNameIdentifier	 jj Move Nfa 6
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffdfffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
45	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffdfffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
27	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
27	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xafffffffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x5000000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
60	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xafffffffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xafffffffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
62	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
10	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
47	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
11	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
60	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
116	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
112	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
105	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
7	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
114	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
99	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
115	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_2	TokenNameIdentifier	 jj Stop String Literal Dfa 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_2	TokenNameIdentifier	 jj Start Nfa 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
jjStopStringLiteralDfa_2	TokenNameIdentifier	 jj Stop String Literal Dfa 2
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_2	TokenNameIdentifier	 jj Move String Literal Dfa0 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
39	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
61	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStartNfaWithStates_2	TokenNameIdentifier	 jj Start Nfa With States 2
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStartNfaWithStates_2	TokenNameIdentifier	 jj Start Nfa With States 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9fffff7affffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
61	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
62	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
18	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x9ffffffeffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
62	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
18	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
61	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnextStates	TokenNameIdentifier	 jjnext States
=	TokenNameEQUAL	
{	TokenNameLBRACE	
20	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec2	TokenNameIdentifier	 jjbit Vec2
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
&	TokenNameAND	
l1	TokenNameIdentifier	 l1
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Token literal values. */	TokenNameCOMMENT_JAVADOC	 Token literal values. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
=	TokenNameEQUAL	
{	TokenNameLBRACE	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
"<script"	TokenNameStringLiteral	<script
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"<!--"	TokenNameStringLiteral	<!--
,	TokenNameCOMMA	
"<!"	TokenNameStringLiteral	<!
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"="	TokenNameStringLiteral	=
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
"""	TokenNameStringLiteral	"
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"-->"	TokenNameStringLiteral	-->
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
">"	TokenNameStringLiteral	>
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lexer state names. */	TokenNameCOMMENT_JAVADOC	 Lexer state names. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lexStateNames	TokenNameIdentifier	 lex State Names
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"DEFAULT"	TokenNameStringLiteral	DEFAULT
,	TokenNameCOMMA	
"WithinScript"	TokenNameStringLiteral	WithinScript
,	TokenNameCOMMA	
"WithinTag"	TokenNameStringLiteral	WithinTag
,	TokenNameCOMMA	
"AfterEquals"	TokenNameStringLiteral	AfterEquals
,	TokenNameCOMMA	
"WithinQuote1"	TokenNameStringLiteral	WithinQuote1
,	TokenNameCOMMA	
"WithinQuote2"	TokenNameStringLiteral	WithinQuote2
,	TokenNameCOMMA	
"WithinComment1"	TokenNameStringLiteral	WithinComment1
,	TokenNameCOMMA	
"WithinComment2"	TokenNameStringLiteral	WithinComment2
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lex State array. */	TokenNameCOMMENT_JAVADOC	 Lex State array. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
=	TokenNameEQUAL	
{	TokenNameLBRACE	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoToken	TokenNameIdentifier	 jjto Token
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x7fbfec7fL	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoSkip	TokenNameIdentifier	 jjto Skip
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x400000L	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
input_stream	TokenNameIdentifier	 input stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjrounds	TokenNameIdentifier	 jjrounds
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
28	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstateSet	TokenNameIdentifier	 jjstate Set
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
56	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
char	TokenNamechar	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
HTMLParserTokenManager	TokenNameIdentifier	 HTML Parser Token Manager
(	TokenNameLPAREN	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
.	TokenNameDOT	
staticFlag	TokenNameIdentifier	 static Flag
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."	TokenNameStringLiteral	ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
HTMLParserTokenManager	TokenNameIdentifier	 HTML Parser Token Manager
(	TokenNameLPAREN	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
defaultLexState	TokenNameIdentifier	 default Lex State
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jjround	TokenNameIdentifier	 jjround
=	TokenNameEQUAL	
0x80000001	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
28	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0x80000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
SimpleCharStream	TokenNameIdentifier	 Simple Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Switch to specified lex state. */	TokenNameCOMMENT_JAVADOC	 Switch to specified lex state. 
public	TokenNamepublic	
void	TokenNamevoid	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
>=	TokenNameGREATER_EQUAL	
8	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
lexState	TokenNameIdentifier	 lex State
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
"Error: Ignoring invalid lexical state : "	TokenNameStringLiteral	Error: Ignoring invalid lexical state : 
+	TokenNamePLUS	
lexState	TokenNameIdentifier	 lex State
+	TokenNamePLUS	
". State unchanged."	TokenNameStringLiteral	. State unchanged.
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
INVALID_LEXICAL_STATE	TokenNameIdentifier	 INVALID  LEXICAL  STATE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
lexState	TokenNameIdentifier	 lex State
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Token	TokenNameIdentifier	 Token
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
curTokenImage	TokenNameIdentifier	 cur Token Image
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
im	TokenNameIdentifier	 im
=	TokenNameEQUAL	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
curTokenImage	TokenNameIdentifier	 cur Token Image
=	TokenNameEQUAL	
(	TokenNameLPAREN	
im	TokenNameIdentifier	 im
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
im	TokenNameIdentifier	 im
;	TokenNameSEMICOLON	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginLine	TokenNameIdentifier	 get Begin Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginColumn	TokenNameIdentifier	 get Begin Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
Token	TokenNameIdentifier	 Token
.	TokenNameDOT	
newToken	TokenNameIdentifier	 new Token
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
,	TokenNameCOMMA	
curTokenImage	TokenNameIdentifier	 cur Token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
defaultLexState	TokenNameIdentifier	 default Lex State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
;	TokenNameSEMICOLON	
int	TokenNameint	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
;	TokenNameSEMICOLON	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
EOFLoop	TokenNameIdentifier	 EOF Loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
BeginToken	TokenNameIdentifier	 Begin Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
>	TokenNameGREATER	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
13	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_2	TokenNameIdentifier	 jj Move String Literal Dfa0 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_3	TokenNameIdentifier	 jj Move String Literal Dfa0 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_4	TokenNameIdentifier	 jj Move String Literal Dfa0 4
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_5	TokenNameIdentifier	 jj Move String Literal Dfa0 5
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_6	TokenNameIdentifier	 jj Move String Literal Dfa0 6
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
7	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_7	TokenNameIdentifier	 jj Move String Literal Dfa0 7
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
curPos	TokenNameIdentifier	 cur Pos
-	TokenNameMINUS	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjtoToken	TokenNameIdentifier	 jjto Token
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
EOFLoop	TokenNameIdentifier	 EOF Loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
error_line	TokenNameIdentifier	 error line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e1	TokenNameIdentifier	 e1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\n'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\r'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
error_line	TokenNameIdentifier	 error line
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
error_column	TokenNameIdentifier	 error column
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
EOFSeen	TokenNameIdentifier	 EOF Seen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
EOFSeen	TokenNameIdentifier	 EOF Seen
,	TokenNameCOMMA	
curLexState	TokenNameIdentifier	 cur Lex State
,	TokenNameCOMMA	
error_line	TokenNameIdentifier	 error line
,	TokenNameCOMMA	
error_column	TokenNameIdentifier	 error column
,	TokenNameCOMMA	
error_after	TokenNameIdentifier	 error after
,	TokenNameCOMMA	
curChar	TokenNameIdentifier	 cur Char
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
LEXICAL_ERROR	TokenNameIdentifier	 LEXICAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jjround	TokenNameIdentifier	 jjround
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
int	TokenNameint	
state1	TokenNameIdentifier	 state1
,	TokenNameCOMMA	
int	TokenNameint	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state1	TokenNameIdentifier	 state1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
