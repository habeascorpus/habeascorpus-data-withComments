/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ManagementFactory	TokenNameIdentifier	 Management Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
InetAddress	TokenNameIdentifier	 Inet Address
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicLong	TokenNameIdentifier	 Atomic Long
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
MBeanServer	TokenNameIdentifier	 M Bean Server
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ObjectName	TokenNameIdentifier	 Object Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Function	TokenNameIdentifier	 Function
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Stage	TokenNameIdentifier	 Stage
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
StageManager	TokenNameIdentifier	 Stage Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Schema	TokenNameIdentifier	 Schema
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Table	TokenNameIdentifier	 Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
ColumnSlice	TokenNameIdentifier	 Column Slice
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
QueryPath	TokenNameIdentifier	 Query Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
UUIDType	TokenNameIdentifier	 UUID Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Bounds	TokenNameIdentifier	 Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
RingPosition	TokenNameIdentifier	 Ring Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
gms	TokenNameIdentifier	 gms
.	TokenNameDOT	
FailureDetector	TokenNameIdentifier	 Failure Detector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
gms	TokenNameIdentifier	 gms
.	TokenNameDOT	
Gossiper	TokenNameIdentifier	 Gossiper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FastByteArrayOutputStream	TokenNameIdentifier	 Fast Byte Array Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
TokenMetadata	TokenNameIdentifier	 Token Metadata
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
Tracing	TokenNameIdentifier	 Tracing
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FBUtilities	TokenNameIdentifier	 FB Utilities
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
StorageProxy	TokenNameIdentifier	 Storage Proxy
implements	TokenNameimplements	
StorageProxyMBean	TokenNameIdentifier	 Storage Proxy M Bean
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
MBEAN_NAME	TokenNameIdentifier	 MBEAN  NAME
=	TokenNameEQUAL	
"org.apache.cassandra.db:type=StorageProxy"	TokenNameStringLiteral	org.apache.cassandra.db:type=StorageProxy
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
OPTIMIZE_LOCAL_REQUESTS	TokenNameIdentifier	 OPTIMIZE  LOCAL  REQUESTS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// set to false to test messagingservice path on single node 	TokenNameCOMMENT_LINE	set to false to test messagingservice path on single node 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
UNREACHABLE	TokenNameIdentifier	 UNREACHABLE
=	TokenNameEQUAL	
"UNREACHABLE"	TokenNameStringLiteral	UNREACHABLE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
WritePerformer	TokenNameIdentifier	 Write Performer
standardWritePerformer	TokenNameIdentifier	 standard Write Performer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
WritePerformer	TokenNameIdentifier	 Write Performer
counterWritePerformer	TokenNameIdentifier	 counter Write Performer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
WritePerformer	TokenNameIdentifier	 Write Performer
counterWriteOnCoordinatorPerformer	TokenNameIdentifier	 counter Write On Coordinator Performer
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
StorageProxy	TokenNameIdentifier	 Storage Proxy
instance	TokenNameIdentifier	 instance
=	TokenNameEQUAL	
new	TokenNamenew	
StorageProxy	TokenNameIdentifier	 Storage Proxy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
volatile	TokenNamevolatile	
int	TokenNameint	
maxHintsInProgress	TokenNameIdentifier	 max Hints In Progress
=	TokenNameEQUAL	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getAvailableProcessors	TokenNameIdentifier	 get Available Processors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
>	TokenNameGREATER	
hintsInProgress	TokenNameIdentifier	 hints In Progress
=	TokenNameEQUAL	
new	TokenNamenew	
MapMaker	TokenNameIdentifier	 Map Maker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
concurrencyLevel	TokenNameIdentifier	 concurrency Level
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
makeComputingMap	TokenNameIdentifier	 make Computing Map
(	TokenNameLPAREN	
new	TokenNamenew	
Function	TokenNameIdentifier	 Function
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
inetAddress	TokenNameIdentifier	 inet Address
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
totalHints	TokenNameIdentifier	 total Hints
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
readMetrics	TokenNameIdentifier	 read Metrics
=	TokenNameEQUAL	
new	TokenNamenew	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
(	TokenNameLPAREN	
"Read"	TokenNameStringLiteral	Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
rangeMetrics	TokenNameIdentifier	 range Metrics
=	TokenNameEQUAL	
new	TokenNamenew	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
(	TokenNameLPAREN	
"RangeSlice"	TokenNameStringLiteral	RangeSlice
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
writeMetrics	TokenNameIdentifier	 write Metrics
=	TokenNameEQUAL	
new	TokenNamenew	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
(	TokenNameLPAREN	
"Write"	TokenNameStringLiteral	Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
StorageProxy	TokenNameIdentifier	 Storage Proxy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
{	TokenNameLBRACE	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
registerMBean	TokenNameIdentifier	 register M Bean
(	TokenNameLPAREN	
new	TokenNamenew	
StorageProxy	TokenNameIdentifier	 Storage Proxy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
MBEAN_NAME	TokenNameIdentifier	 MBEAN  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
standardWritePerformer	TokenNameIdentifier	 standard Write Performer
=	TokenNameEQUAL	
new	TokenNamenew	
WritePerformer	TokenNameIdentifier	 Write Performer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
mutation	TokenNameIdentifier	 mutation
instanceof	TokenNameinstanceof	
RowMutation	TokenNameIdentifier	 Row Mutation
;	TokenNameSEMICOLON	
sendToHintedEndpoints	TokenNameIdentifier	 send To Hinted Endpoints
(	TokenNameLPAREN	
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
)	TokenNameRPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/* * We execute counter writes in 2 places: either directly in the coordinator node if it is a replica, or * in CounterMutationVerbHandler on a replica othewise. The write must be executed on the MUTATION stage * but on the latter case, the verb handler already run on the MUTATION stage, so we must not execute the * underlying on the stage otherwise we risk a deadlock. Hence two different performer. */	TokenNameCOMMENT_BLOCK	 We execute counter writes in 2 places: either directly in the coordinator node if it is a replica, or in CounterMutationVerbHandler on a replica othewise. The write must be executed on the MUTATION stage but on the latter case, the verb handler already run on the MUTATION stage, so we must not execute the underlying on the stage otherwise we risk a deadlock. Hence two different performer. 
counterWritePerformer	TokenNameIdentifier	 counter Write Performer
=	TokenNameEQUAL	
new	TokenNamenew	
WritePerformer	TokenNameIdentifier	 Write Performer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"insert writing local & replicate "	TokenNameStringLiteral	insert writing local & replicate 
+	TokenNamePLUS	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
counterWriteTask	TokenNameIdentifier	 counter Write Task
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runnable	TokenNameIdentifier	 runnable
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
counterWriteOnCoordinatorPerformer	TokenNameIdentifier	 counter Write On Coordinator Performer
=	TokenNameEQUAL	
new	TokenNamenew	
WritePerformer	TokenNameIdentifier	 Write Performer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"insert writing local & replicate "	TokenNameStringLiteral	insert writing local & replicate 
+	TokenNamePLUS	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
counterWriteTask	TokenNameIdentifier	 counter Write Task
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Use this method to have these Mutations applied * across all replicas. This method will take care * of the possibility of a replica being down and hint * the data across to some other replica. * * @param mutations the mutations to be applied across the replicas * @param consistency_level the consistency level for the operation */	TokenNameCOMMENT_JAVADOC	 Use this method to have these Mutations applied across all replicas. This method will take care of the possibility of a replica being down and hint the data across to some other replica. * @param mutations the mutations to be applied across the replicas @param consistency_level the consistency level for the operation 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
mutate	TokenNameIdentifier	 mutate
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
?	TokenNameQUESTION	
extends	TokenNameextends	
IMutation	TokenNameIdentifier	 I Mutation
>	TokenNameGREATER	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
,	TokenNameCOMMA	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Determining replicas for mutation"	TokenNameStringLiteral	Determining replicas for mutation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Mutations/ConsistencyLevel are {}/{}"	TokenNameStringLiteral	Mutations/ConsistencyLevel are {}/{}
,	TokenNameCOMMA	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
>	TokenNameGREATER	
responseHandlers	TokenNameIdentifier	 response Handlers
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
>	TokenNameGREATER	
(	TokenNameLPAREN	
mutations	TokenNameIdentifier	 mutations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IMutation	TokenNameIdentifier	 I Mutation
mostRecentMutation	TokenNameIdentifier	 most Recent Mutation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
:	TokenNameCOLON	
mutations	TokenNameIdentifier	 mutations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mostRecentMutation	TokenNameIdentifier	 most Recent Mutation
=	TokenNameEQUAL	
mutation	TokenNameIdentifier	 mutation
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
instanceof	TokenNameinstanceof	
CounterMutation	TokenNameIdentifier	 Counter Mutation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
responseHandlers	TokenNameIdentifier	 response Handlers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
mutateCounter	TokenNameIdentifier	 mutate Counter
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CounterMutation	TokenNameIdentifier	 Counter Mutation
)	TokenNameRPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
WriteType	TokenNameIdentifier	 Write Type
wt	TokenNameIdentifier	 wt
=	TokenNameEQUAL	
mutations	TokenNameIdentifier	 mutations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
SIMPLE	TokenNameIdentifier	 SIMPLE
:	TokenNameCOLON	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
UNLOGGED_BATCH	TokenNameIdentifier	 UNLOGGED  BATCH
;	TokenNameSEMICOLON	
responseHandlers	TokenNameIdentifier	 response Handlers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
performWrite	TokenNameIdentifier	 perform Write
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
standardWritePerformer	TokenNameIdentifier	 standard Write Performer
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
wt	TokenNameIdentifier	 wt
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// wait for writes. throws TimeoutException if necessary 	TokenNameCOMMENT_LINE	wait for writes. throws TimeoutException if necessary 
for	TokenNamefor	
(	TokenNameLPAREN	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
:	TokenNameCOLON	
responseHandlers	TokenNameIdentifier	 response Handlers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
timeouts	TokenNameIdentifier	 timeouts
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
writeTimeouts	TokenNameIdentifier	 write Timeouts
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
mstrings	TokenNameIdentifier	 mstrings
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
mutations	TokenNameIdentifier	 mutations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
:	TokenNameCOLON	
mutations	TokenNameIdentifier	 mutations
)	TokenNameRPAREN	
mstrings	TokenNameIdentifier	 mstrings
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Write timeout {} for one (or more) of: {}"	TokenNameStringLiteral	Write timeout {} for one (or more) of: {}
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
mstrings	TokenNameIdentifier	 mstrings
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Write timeout"	TokenNameStringLiteral	Write timeout
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
ex	TokenNameIdentifier	 ex
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
unavailables	TokenNameIdentifier	 unavailables
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
writeUnavailables	TokenNameIdentifier	 write Unavailables
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Unavailable"	TokenNameStringLiteral	Unavailable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
writeUnavailables	TokenNameIdentifier	 write Unavailables
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Overloaded"	TokenNameStringLiteral	Overloaded
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
mostRecentMutation	TokenNameIdentifier	 most Recent Mutation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"error writing key "	TokenNameStringLiteral	error writing key 
+	TokenNamePLUS	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytesToHex	TokenNameIdentifier	 bytes To Hex
(	TokenNameLPAREN	
mostRecentMutation	TokenNameIdentifier	 most Recent Mutation
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * See mutate. Adds additional steps before and after writing a batch. * Before writing the batch (but after doing availability check against the FD for the row replicas): * write the entire batch to a batchlog elsewhere in the cluster. * After: remove the batchlog entry (after writing hints for the batch rows, if necessary). * * @param mutations the RowMutations to be applied across the replicas * @param consistency_level the consistency level for the operation */	TokenNameCOMMENT_JAVADOC	 See mutate. Adds additional steps before and after writing a batch. Before writing the batch (but after doing availability check against the FD for the row replicas): write the entire batch to a batchlog elsewhere in the cluster. After: remove the batchlog entry (after writing hints for the batch rows, if necessary). * @param mutations the RowMutations to be applied across the replicas @param consistency_level the consistency level for the operation 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
mutateAtomically	TokenNameIdentifier	 mutate Atomically
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
RowMutation	TokenNameIdentifier	 Row Mutation
>	TokenNameGREATER	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
,	TokenNameCOMMA	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Determining replicas for atomic batch"	TokenNameStringLiteral	Determining replicas for atomic batch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Mutations/ConsistencyLevel are {}/{}"	TokenNameStringLiteral	Mutations/ConsistencyLevel are {}/{}
,	TokenNameCOMMA	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
>	TokenNameGREATER	
wrappers	TokenNameIdentifier	 wrappers
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
>	TokenNameGREATER	
(	TokenNameLPAREN	
mutations	TokenNameIdentifier	 mutations
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet 	TokenNameCOMMENT_LINE	add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet 
for	TokenNamefor	
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
:	TokenNameCOLON	
mutations	TokenNameIdentifier	 mutations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
wrapper	TokenNameIdentifier	 wrapper
=	TokenNameEQUAL	
wrapResponseHandler	TokenNameIdentifier	 wrap Response Handler
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
BATCH	TokenNameIdentifier	 BATCH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// exit early if we can't fulfill the CL at this time. 	TokenNameCOMMENT_LINE	exit early if we can't fulfill the CL at this time. 
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
assureSufficientLiveNodes	TokenNameIdentifier	 assure Sufficient Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wrappers	TokenNameIdentifier	 wrappers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
wrapper	TokenNameIdentifier	 wrapper
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// write to the batchlog 	TokenNameCOMMENT_LINE	write to the batchlog 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
batchlogEndpoints	TokenNameIdentifier	 batchlog Endpoints
=	TokenNameEQUAL	
getBatchlogEndpoints	TokenNameIdentifier	 get Batchlog Endpoints
(	TokenNameLPAREN	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
UUID	TokenNameIdentifier	 UUID
batchUUID	TokenNameIdentifier	 batch UUID
=	TokenNameEQUAL	
UUID	TokenNameIdentifier	 UUID
.	TokenNameDOT	
randomUUID	TokenNameIdentifier	 random UUID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
syncWriteToBatchlog	TokenNameIdentifier	 sync Write To Batchlog
(	TokenNameLPAREN	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
batchlogEndpoints	TokenNameIdentifier	 batchlog Endpoints
,	TokenNameCOMMA	
batchUUID	TokenNameIdentifier	 batch UUID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now actually perform the writes and wait for them to complete 	TokenNameCOMMENT_LINE	now actually perform the writes and wait for them to complete 
syncWriteBatchedMutations	TokenNameIdentifier	 sync Write Batched Mutations
(	TokenNameLPAREN	
wrappers	TokenNameIdentifier	 wrappers
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// remove the batchlog entries asynchronously 	TokenNameCOMMENT_LINE	remove the batchlog entries asynchronously 
asyncRemoveFromBatchlog	TokenNameIdentifier	 async Remove From Batchlog
(	TokenNameLPAREN	
batchlogEndpoints	TokenNameIdentifier	 batchlog Endpoints
,	TokenNameCOMMA	
batchUUID	TokenNameIdentifier	 batch UUID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
unavailables	TokenNameIdentifier	 unavailables
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
writeUnavailables	TokenNameIdentifier	 write Unavailables
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Unavailable"	TokenNameStringLiteral	Unavailable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
timeouts	TokenNameIdentifier	 timeouts
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
writeTimeouts	TokenNameIdentifier	 write Timeouts
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Write timeout"	TokenNameStringLiteral	Write timeout
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
syncWriteToBatchlog	TokenNameIdentifier	 sync Write To Batchlog
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
RowMutation	TokenNameIdentifier	 Row Mutation
>	TokenNameGREATER	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
uuid	TokenNameIdentifier	 uuid
)	TokenNameRPAREN	
throws	TokenNamethrows	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
{	TokenNameLBRACE	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
=	TokenNameEQUAL	
BatchlogManager	TokenNameIdentifier	 Batchlog Manager
.	TokenNameDOT	
getBatchlogMutationFor	TokenNameIdentifier	 get Batchlog Mutation For
(	TokenNameLPAREN	
mutations	TokenNameIdentifier	 mutations
,	TokenNameCOMMA	
uuid	TokenNameIdentifier	 uuid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
new	TokenNamenew	
WriteResponseHandler	TokenNameIdentifier	 Write Response Handler
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ONE	TokenNameIdentifier	 ONE
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
BATCH_LOG	TokenNameIdentifier	 BATCH  LOG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
sendMessagesToOneDC	TokenNameIdentifier	 send Messages To One DC
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error writing to batchlog"	TokenNameStringLiteral	Error writing to batchlog
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
asyncRemoveFromBatchlog	TokenNameIdentifier	 async Remove From Batchlog
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
uuid	TokenNameIdentifier	 uuid
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
=	TokenNameEQUAL	
new	TokenNamenew	
RowMutation	TokenNameIdentifier	 Row Mutation
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
,	TokenNameCOMMA	
UUIDType	TokenNameIdentifier	 UUID Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
decompose	TokenNameIdentifier	 decompose
(	TokenNameLPAREN	
uuid	TokenNameIdentifier	 uuid
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BATCHLOG_CF	TokenNameIdentifier	 BATCHLOG  CF
)	TokenNameRPAREN	
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
timestampMicros	TokenNameIdentifier	 timestamp Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
new	TokenNamenew	
WriteResponseHandler	TokenNameIdentifier	 Write Response Handler
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ANY	TokenNameIdentifier	 ANY
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
SIMPLE	TokenNameIdentifier	 SIMPLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
sendMessagesToOneDC	TokenNameIdentifier	 send Messages To One DC
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error deleting batch "	TokenNameStringLiteral	Error deleting batch 
+	TokenNamePLUS	
uuid	TokenNameIdentifier	 uuid
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
syncWriteBatchedMutations	TokenNameIdentifier	 sync Write Batched Mutations
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
>	TokenNameGREATER	
wrappers	TokenNameIdentifier	 wrappers
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
throws	TokenNamethrows	
WriteTimeoutException	TokenNameIdentifier	 Write Timeout Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
wrapper	TokenNameIdentifier	 wrapper
:	TokenNameCOLON	
wrappers	TokenNameIdentifier	 wrappers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sendToHintedEndpoints	TokenNameIdentifier	 send To Hinted Endpoints
(	TokenNameLPAREN	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
,	TokenNameCOMMA	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error writing key "	TokenNameStringLiteral	Error writing key 
+	TokenNamePLUS	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytesToHex	TokenNameIdentifier	 bytes To Hex
(	TokenNameLPAREN	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
wrapper	TokenNameIdentifier	 wrapper
:	TokenNameCOLON	
wrappers	TokenNameIdentifier	 wrappers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
wrapper	TokenNameIdentifier	 wrapper
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Perform the write of a mutation given a WritePerformer. * Gather the list of write endpoints, apply locally and/or forward the mutation to * said write endpoint (deletaged to the actual WritePerformer) and wait for the * responses based on consistency level. * * @param mutation the mutation to be applied * @param consistency_level the consistency level for the write operation * @param performer the WritePerformer in charge of appliying the mutation * given the list of write endpoints (either standardWritePerformer for * standard writes or counterWritePerformer for counter writes). * @param callback an optional callback to be run if and when the write is * successful. */	TokenNameCOMMENT_JAVADOC	 Perform the write of a mutation given a WritePerformer. Gather the list of write endpoints, apply locally and/or forward the mutation to said write endpoint (deletaged to the actual WritePerformer) and wait for the responses based on consistency level. * @param mutation the mutation to be applied @param consistency_level the consistency level for the write operation @param performer the WritePerformer in charge of appliying the mutation given the list of write endpoints (either standardWritePerformer for standard writes or counterWritePerformer for counter writes). @param callback an optional callback to be run if and when the write is successful. 
public	TokenNamepublic	
static	TokenNamestatic	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
performWrite	TokenNameIdentifier	 perform Write
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
WritePerformer	TokenNameIdentifier	 Write Performer
performer	TokenNameIdentifier	 performer
,	TokenNameCOMMA	
Runnable	TokenNameIdentifier	 Runnable
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
writeType	TokenNameIdentifier	 write Type
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
getTable	TokenNameIdentifier	 get Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tk	TokenNameIdentifier	 tk
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
tk	TokenNameIdentifier	 tk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
pendingEndpointsFor	TokenNameIdentifier	 pending Endpoints For
(	TokenNameLPAREN	
tk	TokenNameIdentifier	 tk
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
=	TokenNameEQUAL	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getWriteResponseHandler	TokenNameIdentifier	 get Write Response Handler
(	TokenNameLPAREN	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
writeType	TokenNameIdentifier	 write Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// exit early if we can't fulfill the CL at this time 	TokenNameCOMMENT_LINE	exit early if we can't fulfill the CL at this time 
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
assureSufficientLiveNodes	TokenNameIdentifier	 assure Sufficient Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
performer	TokenNameIdentifier	 performer
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
)	TokenNameRPAREN	
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
responseHandler	TokenNameIdentifier	 response Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// same as above except does not initiate writes (but does perfrom availability checks). 	TokenNameCOMMENT_LINE	same as above except does not initiate writes (but does perfrom availability checks). 
private	TokenNameprivate	
static	TokenNamestatic	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
wrapResponseHandler	TokenNameIdentifier	 wrap Response Handler
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
writeType	TokenNameIdentifier	 write Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
getTable	TokenNameIdentifier	 get Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
getTable	TokenNameIdentifier	 get Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tk	TokenNameIdentifier	 tk
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
tk	TokenNameIdentifier	 tk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
pendingEndpointsFor	TokenNameIdentifier	 pending Endpoints For
(	TokenNameLPAREN	
tk	TokenNameIdentifier	 tk
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
=	TokenNameEQUAL	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getWriteResponseHandler	TokenNameIdentifier	 get Write Response Handler
(	TokenNameLPAREN	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
writeType	TokenNameIdentifier	 write Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
(	TokenNameLPAREN	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
mutation	TokenNameIdentifier	 mutation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// used by atomic_batch_mutate to decouple availability check from the write itself, caches consistency level and endpoints. 	TokenNameCOMMENT_LINE	used by atomic_batch_mutate to decouple availability check from the write itself, caches consistency level and endpoints. 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
{	TokenNameLBRACE	
final	TokenNamefinal	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
final	TokenNamefinal	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
;	TokenNameSEMICOLON	
WriteResponseHandlerWrapper	TokenNameIdentifier	 Write Response Handler Wrapper
(	TokenNameLPAREN	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
mutation	TokenNameIdentifier	 mutation
=	TokenNameEQUAL	
mutation	TokenNameIdentifier	 mutation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * Replicas are picked manually: * - replicas should be alive according to the failure detector * - replicas should be in the local datacenter * - choose min(2, number of qualifying candiates above) * - allow the local node to be the only replica only if it's a single-node cluster */	TokenNameCOMMENT_BLOCK	 Replicas are picked manually: - replicas should be alive according to the failure detector - replicas should be in the local datacenter - choose min(2, number of qualifying candiates above) - allow the local node to be the only replica only if it's a single-node cluster 
private	TokenNameprivate	
static	TokenNamestatic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
getBatchlogEndpoints	TokenNameIdentifier	 get Batchlog Endpoints
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
{	TokenNameLBRACE	
// will include every known node in the DC, including localhost. 	TokenNameCOMMENT_LINE	will include every known node in the DC, including localhost. 
TokenMetadata	TokenNameIdentifier	 Token Metadata
.	TokenNameDOT	
Topology	TokenNameIdentifier	 Topology
topology	TokenNameIdentifier	 topology
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
cloneOnlyTokenMap	TokenNameIdentifier	 clone Only Token Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTopology	TokenNameIdentifier	 get Topology
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
localMembers	TokenNameIdentifier	 local Members
=	TokenNameEQUAL	
topology	TokenNameIdentifier	 topology
.	TokenNameDOT	
getDatacenterEndpoints	TokenNameIdentifier	 get Datacenter Endpoints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// special case for single-node datacenters 	TokenNameCOMMENT_LINE	special case for single-node datacenters 
if	TokenNameif	
(	TokenNameLPAREN	
localMembers	TokenNameIdentifier	 local Members
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
localMembers	TokenNameIdentifier	 local Members
;	TokenNameSEMICOLON	
// not a single-node cluster - don't count the local node. 	TokenNameCOMMENT_LINE	not a single-node cluster - don't count the local node. 
localMembers	TokenNameIdentifier	 local Members
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// include only alive nodes 	TokenNameCOMMENT_LINE	include only alive nodes 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
localMembers	TokenNameIdentifier	 local Members
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
member	TokenNameIdentifier	 member
:	TokenNameCOLON	
localMembers	TokenNameIdentifier	 local Members
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
member	TokenNameIdentifier	 member
)	TokenNameRPAREN	
)	TokenNameRPAREN	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
member	TokenNameIdentifier	 member
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
(	TokenNameLPAREN	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ONE	TokenNameIdentifier	 ONE
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
sortByProximity	TokenNameIdentifier	 sort By Proximity
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
candidates	TokenNameIdentifier	 candidates
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
candidates	TokenNameIdentifier	 candidates
=	TokenNameEQUAL	
candidates	TokenNameIdentifier	 candidates
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
candidates	TokenNameIdentifier	 candidates
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Send the mutations to the right targets, write it locally if it corresponds or writes a hint when the node * is not available. * * Note about hints: * * | Hinted Handoff | Consist. Level | * | on | >=1 | --> wait for hints. We DO NOT notify the handler with handler.response() for hints; * | on | ANY | --> wait for hints. Responses count towards consistency. * | off | >=1 | --> DO NOT fire hints. And DO NOT wait for them to complete. * | off | ANY | --> DO NOT fire hints. And DO NOT wait for them to complete. * * @throws TimeoutException if the hints cannot be written/enqueued */	TokenNameCOMMENT_JAVADOC	 Send the mutations to the right targets, write it locally if it corresponds or writes a hint when the node is not available. * Note about hints: * | Hinted Handoff | Consist. Level | | on | >=1 | --> wait for hints. We DO NOT notify the handler with handler.response() for hints; | on | ANY | --> wait for hints. Responses count towards consistency. | off | >=1 | --> DO NOT fire hints. And DO NOT wait for them to complete. | off | ANY | --> DO NOT fire hints. And DO NOT wait for them to complete. * @throws TimeoutException if the hints cannot be written/enqueued 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
sendToHintedEndpoints	TokenNameIdentifier	 send To Hinted Endpoints
(	TokenNameLPAREN	
final	TokenNamefinal	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
// Multimap that holds onto all the messages and addresses meant for a specific datacenter 	TokenNameCOMMENT_LINE	Multimap that holds onto all the messages and addresses meant for a specific datacenter 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
dcMessages	TokenNameIdentifier	 dc Messages
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
destination	TokenNameIdentifier	 destination
:	TokenNameCOLON	
targets	TokenNameIdentifier	 targets
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// avoid OOMing due to excess hints. we need to do this check even for "live" nodes, since we can 	TokenNameCOMMENT_LINE	avoid OOMing due to excess hints. we need to do this check even for "live" nodes, since we can 
// still generate hints for those if it's overloaded or simply dead but not yet known-to-be-dead. 	TokenNameCOMMENT_LINE	still generate hints for those if it's overloaded or simply dead but not yet known-to-be-dead. 
// The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to 	TokenNameCOMMENT_LINE	The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to 
// a small number of nodes causing problems, so we should avoid shutting down writes completely to 	TokenNameCOMMENT_LINE	a small number of nodes causing problems, so we should avoid shutting down writes completely to 
// healthy nodes. Any node with no hintsInProgress is considered healthy. 	TokenNameCOMMENT_LINE	healthy nodes. Any node with no hintsInProgress is considered healthy. 
if	TokenNameif	
(	TokenNameLPAREN	
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxHintsInProgress	TokenNameIdentifier	 max Hints In Progress
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
hintsInProgress	TokenNameIdentifier	 hints In Progress
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
shouldHint	TokenNameIdentifier	 should Hint
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
(	TokenNameLPAREN	
"Too many in flight hints: "	TokenNameStringLiteral	Too many in flight hints: 
+	TokenNamePLUS	
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FailureDetector	TokenNameIdentifier	 Failure Detector
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
OPTIMIZE_LOCAL_REQUESTS	TokenNameIdentifier	 OPTIMIZE  LOCAL  REQUESTS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
insertLocal	TokenNameIdentifier	 insert Local
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// belongs on a different server 	TokenNameCOMMENT_LINE	belongs on a different server 
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"insert writing key "	TokenNameStringLiteral	insert writing key 
+	TokenNamePLUS	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytesToHex	TokenNameIdentifier	 bytes To Hex
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dc	TokenNameIdentifier	 dc
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
messages	TokenNameIdentifier	 messages
=	TokenNameEQUAL	
dcMessages	TokenNameIdentifier	 dc Messages
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
messages	TokenNameIdentifier	 messages
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
messages	TokenNameIdentifier	 messages
=	TokenNameEQUAL	
HashMultimap	TokenNameIdentifier	 Hash Multimap
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dcMessages	TokenNameIdentifier	 dc Messages
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dc	TokenNameIdentifier	 dc
,	TokenNameCOMMA	
messages	TokenNameIdentifier	 messages
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
shouldHint	TokenNameIdentifier	 should Hint
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// Schedule a local hint 	TokenNameCOMMENT_LINE	Schedule a local hint 
scheduleLocalHint	TokenNameIdentifier	 schedule Local Hint
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
,	TokenNameCOMMA	
destination	TokenNameIdentifier	 destination
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sendMessages	TokenNameIdentifier	 send Messages
(	TokenNameLPAREN	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
dcMessages	TokenNameIdentifier	 dc Messages
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
Void	TokenNameIdentifier	 Void
>	TokenNameGREATER	
scheduleLocalHint	TokenNameIdentifier	 schedule Local Hint
(	TokenNameLPAREN	
final	TokenNamefinal	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
final	TokenNamefinal	
InetAddress	TokenNameIdentifier	 Inet Address
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
final	TokenNamefinal	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Hint of itself doesn't make sense. 	TokenNameCOMMENT_LINE	Hint of itself doesn't make sense. 
assert	TokenNameassert	
!	TokenNameNOT	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
targetHints	TokenNameIdentifier	 target Hints
=	TokenNameEQUAL	
hintsInProgress	TokenNameIdentifier	 hints In Progress
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
targetHints	TokenNameIdentifier	 target Hints
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Adding hint for {}"	TokenNameStringLiteral	Adding hint for {}
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
writeHintForMutation	TokenNameIdentifier	 write Hint For Mutation
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Notify the handler only for CL == ANY 	TokenNameCOMMENT_LINE	Notify the handler only for CL == ANY 
if	TokenNameif	
(	TokenNameLPAREN	
responseHandler	TokenNameIdentifier	 response Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
consistencyLevel	TokenNameIdentifier	 consistency Level
==	TokenNameEQUAL_EQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ANY	TokenNameIdentifier	 ANY
)	TokenNameRPAREN	
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
.	TokenNameDOT	
decrementAndGet	TokenNameIdentifier	 decrement And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
targetHints	TokenNameIdentifier	 target Hints
.	TokenNameDOT	
decrementAndGet	TokenNameIdentifier	 decrement And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
Void	TokenNameIdentifier	 Void
>	TokenNameGREATER	
)	TokenNameRPAREN	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
writeHintForMutation	TokenNameIdentifier	 write Hint For Mutation
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
UUID	TokenNameIdentifier	 UUID
hostId	TokenNameIdentifier	 host Id
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getHostId	TokenNameIdentifier	 get Host Id
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
hostId	TokenNameIdentifier	 host Id
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
<	TokenNameLESS	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
VERSION_12	TokenNameIdentifier	 VERSION 12
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Unable to store hint for host with missing ID, {} (old node?)"	TokenNameStringLiteral	Unable to store hint for host with missing ID, {} (old node?)
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
hostId	TokenNameIdentifier	 host Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
:	TokenNameCOLON	
"Missing host ID for "	TokenNameStringLiteral	Missing host ID for 
+	TokenNamePLUS	
target	TokenNameIdentifier	 target
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowMutation	TokenNameIdentifier	 Row Mutation
hintedMutation	TokenNameIdentifier	 hinted Mutation
=	TokenNameEQUAL	
RowMutation	TokenNameIdentifier	 Row Mutation
.	TokenNameDOT	
hintFor	TokenNameIdentifier	 hint For
(	TokenNameLPAREN	
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
hostId	TokenNameIdentifier	 host Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hintedMutation	TokenNameIdentifier	 hinted Mutation
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalHints	TokenNameIdentifier	 total Hints
.	TokenNameDOT	
incrementAndGet	TokenNameIdentifier	 increment And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * for each datacenter, send a message to one node to relay the write to other replicas */	TokenNameCOMMENT_JAVADOC	 for each datacenter, send a message to one node to relay the write to other replicas 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
sendMessages	TokenNameIdentifier	 send Messages
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
dcMessages	TokenNameIdentifier	 dc Messages
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Multimap	TokenNameIdentifier	 Multimap
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
dcMessages	TokenNameIdentifier	 dc Messages
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isLocalDC	TokenNameIdentifier	 is Local DC
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
MessageOut	TokenNameIdentifier	 Message Out
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>>	TokenNameRIGHT_SHIFT	
messages	TokenNameIdentifier	 messages
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asMap	TokenNameIdentifier	 as Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessageOut	TokenNameIdentifier	 Message Out
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
=	TokenNameEQUAL	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// a single message object is used for unhinted writes, so clean out any forwards 	TokenNameCOMMENT_LINE	a single message object is used for unhinted writes, so clean out any forwards 
// from previous loop iterations 	TokenNameCOMMENT_LINE	from previous loop iterations 
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
withHeaderRemoved	TokenNameIdentifier	 with Header Removed
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
.	TokenNameDOT	
FORWARD_TO	TokenNameIdentifier	 FORWARD  TO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sendMessagesToOneDC	TokenNameIdentifier	 send Messages To One DC
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
isLocalDC	TokenNameIdentifier	 is Local DC
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
sendMessagesToOneDC	TokenNameIdentifier	 send Messages To One DC
(	TokenNameLPAREN	
MessageOut	TokenNameIdentifier	 Message Out
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
boolean	TokenNameboolean	
localDC	TokenNameIdentifier	 local DC
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
targets	TokenNameIdentifier	 targets
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
InetAddress	TokenNameIdentifier	 Inet Address
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// direct writes to local DC or old Cassandra versions 	TokenNameCOMMENT_LINE	direct writes to local DC or old Cassandra versions 
if	TokenNameif	
(	TokenNameLPAREN	
localDC	TokenNameIdentifier	 local DC
||	TokenNameOR_OR	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
<	TokenNameLESS	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
VERSION_11	TokenNameIdentifier	 VERSION 11
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// yes, the loop and non-loop code here are the same; this is clunky but we want to avoid 	TokenNameCOMMENT_LINE	yes, the loop and non-loop code here are the same; this is clunky but we want to avoid 
// creating a second iterator since we already have a perfectly good one 	TokenNameCOMMENT_LINE	creating a second iterator since we already have a perfectly good one 
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Add all the other destinations of the same message as a FORWARD_HEADER entry 	TokenNameCOMMENT_LINE	Add all the other destinations of the same message as a FORWARD_HEADER entry 
FastByteArrayOutputStream	TokenNameIdentifier	 Fast Byte Array Output Stream
bos	TokenNameIdentifier	 bos
=	TokenNameEQUAL	
new	TokenNamenew	
FastByteArrayOutputStream	TokenNameIdentifier	 Fast Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
dos	TokenNameIdentifier	 dos
=	TokenNameEQUAL	
new	TokenNamenew	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
(	TokenNameLPAREN	
bos	TokenNameIdentifier	 bos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
targets	TokenNameIdentifier	 targets
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
destination	TokenNameIdentifier	 destination
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CompactEndpointSerializationHelper	TokenNameIdentifier	 Compact Endpoint Serialization Helper
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
destination	TokenNameIdentifier	 destination
,	TokenNameCOMMA	
dos	TokenNameIdentifier	 dos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
addCallback	TokenNameIdentifier	 add Callback
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
destination	TokenNameIdentifier	 destination
,	TokenNameCOMMA	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
getTimeout	TokenNameIdentifier	 get Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeUTF	TokenNameIdentifier	 write UTF
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Adding FWD message to {}@{}"	TokenNameStringLiteral	Adding FWD message to {}@{}
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
destination	TokenNameIdentifier	 destination
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
withParameter	TokenNameIdentifier	 with Parameter
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
.	TokenNameDOT	
FORWARD_TO	TokenNameIdentifier	 FORWARD  TO
,	TokenNameCOMMA	
bos	TokenNameIdentifier	 bos
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// send the combined message + forward headers 	TokenNameCOMMENT_LINE	send the combined message + forward headers 
String	TokenNameIdentifier	 String
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Sending message to {}@{}"	TokenNameStringLiteral	Sending message to {}@{}
,	TokenNameCOMMA	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
insertLocal	TokenNameIdentifier	 insert Local
(	TokenNameLPAREN	
final	TokenNamefinal	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"insert writing local "	TokenNameStringLiteral	insert writing local 
+	TokenNamePLUS	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
rm	TokenNameIdentifier	 rm
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle counter mutation on the coordinator host. * * A counter mutation needs to first be applied to a replica (that we'll call the leader for the mutation) before being * replicated to the other endpoint. To achieve so, there is two case: * 1) the coordinator host is a replica: we proceed to applying the update locally and replicate throug * applyCounterMutationOnCoordinator * 2) the coordinator is not a replica: we forward the (counter)mutation to a chosen replica (that will proceed through * applyCounterMutationOnLeader upon receive) and wait for its acknowledgment. * * Implementation note: We check if we can fulfill the CL on the coordinator host even if he is not a replica to allow * quicker response and because the WriteResponseHandlers don't make it easy to send back an error. We also always gather * the write latencies at the coordinator node to make gathering point similar to the case of standard writes. */	TokenNameCOMMENT_JAVADOC	 Handle counter mutation on the coordinator host. * A counter mutation needs to first be applied to a replica (that we'll call the leader for the mutation) before being replicated to the other endpoint. To achieve so, there is two case: 1) the coordinator host is a replica: we proceed to applying the update locally and replicate throug applyCounterMutationOnCoordinator 2) the coordinator is not a replica: we forward the (counter)mutation to a chosen replica (that will proceed through applyCounterMutationOnLeader upon receive) and wait for its acknowledgment. * Implementation note: We check if we can fulfill the CL on the coordinator host even if he is not a replica to allow quicker response and because the WriteResponseHandlers don't make it easy to send back an error. We also always gather the write latencies at the coordinator node to make gathering point similar to the case of standard writes. 
public	TokenNamepublic	
static	TokenNamestatic	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
mutateCounter	TokenNameIdentifier	 mutate Counter
(	TokenNameLPAREN	
CounterMutation	TokenNameIdentifier	 Counter Mutation
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
=	TokenNameEQUAL	
findSuitableEndpoint	TokenNameIdentifier	 find Suitable Endpoint
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
getTable	TokenNameIdentifier	 get Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
consistency	TokenNameIdentifier	 consistency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
applyCounterMutationOnCoordinator	TokenNameIdentifier	 apply Counter Mutation On Coordinator
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Exit now if we can't fulfill the CL here instead of forwarding to the leader replica 	TokenNameCOMMENT_LINE	Exit now if we can't fulfill the CL here instead of forwarding to the leader replica 
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
getTable	TokenNameIdentifier	 get Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractReplicationStrategy	TokenNameIdentifier	 Abstract Replication Strategy
rs	TokenNameIdentifier	 rs
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
.	TokenNameDOT	
getReplicationStrategy	TokenNameIdentifier	 get Replication Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tk	TokenNameIdentifier	 tk
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNaturalEndpoints	TokenNameIdentifier	 get Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
tk	TokenNameIdentifier	 tk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
pendingEndpointsFor	TokenNameIdentifier	 pending Endpoints For
(	TokenNameLPAREN	
tk	TokenNameIdentifier	 tk
,	TokenNameCOMMA	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rs	TokenNameIdentifier	 rs
.	TokenNameDOT	
getWriteResponseHandler	TokenNameIdentifier	 get Write Response Handler
(	TokenNameLPAREN	
naturalEndpoints	TokenNameIdentifier	 natural Endpoints
,	TokenNameCOMMA	
pendingEndpoints	TokenNameIdentifier	 pending Endpoints
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
consistency	TokenNameIdentifier	 consistency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
COUNTER	TokenNameIdentifier	 COUNTER
)	TokenNameRPAREN	
.	TokenNameDOT	
assureSufficientLiveNodes	TokenNameIdentifier	 assure Sufficient Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Forward the actual update to the chosen leader replica 	TokenNameCOMMENT_LINE	Forward the actual update to the chosen leader replica 
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
=	TokenNameEQUAL	
new	TokenNamenew	
WriteResponseHandler	TokenNameIdentifier	 Write Response Handler
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
COUNTER	TokenNameIdentifier	 COUNTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"forwarding counter update of key "	TokenNameStringLiteral	forwarding counter update of key 
+	TokenNamePLUS	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytesToHex	TokenNameIdentifier	 bytes To Hex
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
key	TokenNameIdentifier	 key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
makeMutationMessage	TokenNameIdentifier	 make Mutation Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
responseHandler	TokenNameIdentifier	 response Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Find a suitable replica as leader for counter update. * For now, we pick a random replica in the local DC (or ask the snitch if * there is no replica alive in the local DC). * TODO: if we track the latency of the counter writes (which makes sense * contrarily to standard writes since there is a read involved), we could * trust the dynamic snitch entirely, which may be a better solution. It * is unclear we want to mix those latencies with read latencies, so this * may be a bit involved. */	TokenNameCOMMENT_JAVADOC	 Find a suitable replica as leader for counter update. For now, we pick a random replica in the local DC (or ask the snitch if there is no replica alive in the local DC). TODO: if we track the latency of the counter writes (which makes sense contrarily to standard writes since there is a read involved), we could trust the dynamic snitch entirely, which may be a better solution. It is unclear we want to mix those latencies with read latencies, so this may be a bit involved. 
private	TokenNameprivate	
static	TokenNamestatic	
InetAddress	TokenNameIdentifier	 Inet Address
findSuitableEndpoint	TokenNameIdentifier	 find Suitable Endpoint
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
cl	TokenNameIdentifier	 cl
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
{	TokenNameLBRACE	
IEndpointSnitch	TokenNameIdentifier	 I Endpoint Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// TODO have a way to compute the consistency level 	TokenNameCOMMENT_LINE	TODO have a way to compute the consistency level 
throw	TokenNamethrow	
new	TokenNamenew	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
(	TokenNameLPAREN	
cl	TokenNameIdentifier	 cl
,	TokenNameCOMMA	
cl	TokenNameIdentifier	 cl
.	TokenNameDOT	
blockFor	TokenNameIdentifier	 block For
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
localEndpoints	TokenNameIdentifier	 local Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
)	TokenNameRPAREN	
localEndpoints	TokenNameIdentifier	 local Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
localEndpoints	TokenNameIdentifier	 local Endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No endpoint in local DC, pick the closest endpoint according to the snitch 	TokenNameCOMMENT_LINE	No endpoint in local DC, pick the closest endpoint according to the snitch 
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
sortByProximity	TokenNameIdentifier	 sort By Proximity
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
localEndpoints	TokenNameIdentifier	 local Endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
threadLocalRandom	TokenNameIdentifier	 thread Local Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
localEndpoints	TokenNameIdentifier	 local Endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Must be called on a replica of the mutation. This replica becomes the 	TokenNameCOMMENT_LINE	Must be called on a replica of the mutation. This replica becomes the 
// leader of this mutation. 	TokenNameCOMMENT_LINE	leader of this mutation. 
public	TokenNamepublic	
static	TokenNamestatic	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
applyCounterMutationOnLeader	TokenNameIdentifier	 apply Counter Mutation On Leader
(	TokenNameLPAREN	
CounterMutation	TokenNameIdentifier	 Counter Mutation
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
Runnable	TokenNameIdentifier	 Runnable
callback	TokenNameIdentifier	 callback
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
performWrite	TokenNameIdentifier	 perform Write
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
consistency	TokenNameIdentifier	 consistency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
counterWritePerformer	TokenNameIdentifier	 counter Write Performer
,	TokenNameCOMMA	
callback	TokenNameIdentifier	 callback
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
COUNTER	TokenNameIdentifier	 COUNTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Same as applyCounterMutationOnLeader but must with the difference that it use the MUTATION stage to execute the write (while 	TokenNameCOMMENT_LINE	Same as applyCounterMutationOnLeader but must with the difference that it use the MUTATION stage to execute the write (while 
// applyCounterMutationOnLeader assumes it is on the MUTATION stage already) 	TokenNameCOMMENT_LINE	applyCounterMutationOnLeader assumes it is on the MUTATION stage already) 
public	TokenNamepublic	
static	TokenNamestatic	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
applyCounterMutationOnCoordinator	TokenNameIdentifier	 apply Counter Mutation On Coordinator
(	TokenNameLPAREN	
CounterMutation	TokenNameIdentifier	 Counter Mutation
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
performWrite	TokenNameIdentifier	 perform Write
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
consistency	TokenNameIdentifier	 consistency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
counterWriteOnCoordinatorPerformer	TokenNameIdentifier	 counter Write On Coordinator Performer
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
WriteType	TokenNameIdentifier	 Write Type
.	TokenNameDOT	
COUNTER	TokenNameIdentifier	 COUNTER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Runnable	TokenNameIdentifier	 Runnable
counterWriteTask	TokenNameIdentifier	 counter Write Task
(	TokenNameLPAREN	
final	TokenNamefinal	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
final	TokenNamefinal	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
final	TokenNamefinal	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
final	TokenNamefinal	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
MUTATION	TokenNameIdentifier	 MUTATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
mutation	TokenNameIdentifier	 mutation
instanceof	TokenNameinstanceof	
CounterMutation	TokenNameIdentifier	 Counter Mutation
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CounterMutation	TokenNameIdentifier	 Counter Mutation
cm	TokenNameIdentifier	 cm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CounterMutation	TokenNameIdentifier	 Counter Mutation
)	TokenNameRPAREN	
mutation	TokenNameIdentifier	 mutation
;	TokenNameSEMICOLON	
// apply mutation 	TokenNameCOMMENT_LINE	apply mutation 
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// then send to replicas, if any 	TokenNameCOMMENT_LINE	then send to replicas, if any 
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
remotes	TokenNameIdentifier	 remotes
=	TokenNameEQUAL	
Sets	TokenNameIdentifier	 Sets
.	TokenNameDOT	
difference	TokenNameIdentifier	 difference
(	TokenNameLPAREN	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
targets	TokenNameIdentifier	 targets
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ImmutableSet	TokenNameIdentifier	 Immutable Set
.	TokenNameDOT	
of	TokenNameIdentifier	 of
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
shouldReplicateOnWrite	TokenNameIdentifier	 should Replicate On Write
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
remotes	TokenNameIdentifier	 remotes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We do the replication on another stage because it involves a read (see CM.makeReplicationMutation) 	TokenNameCOMMENT_LINE	We do the replication on another stage because it involves a read (see CM.makeReplicationMutation) 
// and we want to avoid blocking too much the MUTATION stage 	TokenNameCOMMENT_LINE	and we want to avoid blocking too much the MUTATION stage 
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
REPLICATE_ON_WRITE	TokenNameIdentifier	 REPLICATE  ON  WRITE
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
new	TokenNamenew	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
{	TokenNameLBRACE	
// send mutation to other replica 	TokenNameCOMMENT_LINE	send mutation to other replica 
sendToHintedEndpoints	TokenNameIdentifier	 send To Hinted Endpoints
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
makeReplicationMutation	TokenNameIdentifier	 make Replication Mutation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
remotes	TokenNameIdentifier	 remotes
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
systemTableQuery	TokenNameIdentifier	 system Table Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
cmds	TokenNameIdentifier	 cmds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ReadCommand	TokenNameIdentifier	 Read Command
cmd	TokenNameIdentifier	 cmd
:	TokenNameCOLON	
cmds	TokenNameIdentifier	 cmds
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cmd	TokenNameIdentifier	 cmd
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Performs the actual reading of a row out of the StorageService, fetching * a specific set of column names from a given column family. */	TokenNameCOMMENT_JAVADOC	 Performs the actual reading of a row out of the StorageService, fetching a specific set of column names from a given column family. 
public	TokenNamepublic	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
commands	TokenNameIdentifier	 commands
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
IsBootstrappingException	TokenNameIdentifier	 Is Bootstrapping Exception
,	TokenNameCOMMA	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isBootstrapMode	TokenNameIdentifier	 is Bootstrap Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
systemTableQuery	TokenNameIdentifier	 system Table Query
(	TokenNameLPAREN	
commands	TokenNameIdentifier	 commands
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
unavailables	TokenNameIdentifier	 unavailables
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
readUnavailables	TokenNameIdentifier	 read Unavailables
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IsBootstrappingException	TokenNameIdentifier	 Is Bootstrapping Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
fetchRows	TokenNameIdentifier	 fetch Rows
(	TokenNameLPAREN	
commands	TokenNameIdentifier	 commands
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
unavailables	TokenNameIdentifier	 unavailables
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
readUnavailables	TokenNameIdentifier	 read Unavailables
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
timeouts	TokenNameIdentifier	 timeouts
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ClientRequestMetrics	TokenNameIdentifier	 Client Request Metrics
.	TokenNameDOT	
readTimeouts	TokenNameIdentifier	 read Timeouts
.	TokenNameDOT	
inc	TokenNameIdentifier	 inc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This function executes local and remote reads, and blocks for the results: * * 1. Get the replica locations, sorted by response time according to the snitch * 2. Send a data request to the closest replica, and digest requests to either * a) all the replicas, if read repair is enabled * b) the closest R-1 replicas, where R is the number required to satisfy the ConsistencyLevel * 3. Wait for a response from R replicas * 4. If the digests (if any) match the data return the data * 5. else carry out read repair by getting data from all the nodes. */	TokenNameCOMMENT_JAVADOC	 This function executes local and remote reads, and blocks for the results: * 1. Get the replica locations, sorted by response time according to the snitch 2. Send a data request to the closest replica, and digest requests to either a) all the replicas, if read repair is enabled b) the closest R-1 replicas, where R is the number required to satisfy the ConsistencyLevel 3. Wait for a response from R replicas 4. If the digests (if any) match the data return the data 5. else carry out read repair by getting data from all the nodes. 
private	TokenNameprivate	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
fetchRows	TokenNameIdentifier	 fetch Rows
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
initialCommands	TokenNameIdentifier	 initial Commands
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
(	TokenNameLPAREN	
initialCommands	TokenNameIdentifier	 initial Commands
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
commandsToRetry	TokenNameIdentifier	 commands To Retry
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
commands	TokenNameIdentifier	 commands
=	TokenNameEQUAL	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
initialCommands	TokenNameIdentifier	 initial Commands
:	TokenNameCOLON	
commandsToRetry	TokenNameIdentifier	 commands To Retry
;	TokenNameSEMICOLON	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
ReadResponse	TokenNameIdentifier	 Read Response
,	TokenNameCOMMA	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
readCallbacks	TokenNameIdentifier	 read Callbacks
=	TokenNameEQUAL	
new	TokenNamenew	
ReadCallback	TokenNameIdentifier	 Read Callback
[	TokenNameLBRACKET	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Retrying {} commands"	TokenNameStringLiteral	Retrying {} commands
,	TokenNameCOMMA	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// send out read requests 	TokenNameCOMMENT_LINE	send out read requests 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReadCommand	TokenNameIdentifier	 Read Command
command	TokenNameIdentifier	 command
=	TokenNameEQUAL	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
!	TokenNameNOT	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
isDigestQuery	TokenNameIdentifier	 is Digest Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Command/ConsistencyLevel is {}/{}"	TokenNameStringLiteral	Command/ConsistencyLevel is {}/{}
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sortByProximity	TokenNameIdentifier	 sort By Proximity
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowDigestResolver	TokenNameIdentifier	 Row Digest Resolver
resolver	TokenNameIdentifier	 resolver
=	TokenNameEQUAL	
new	TokenNamenew	
RowDigestResolver	TokenNameIdentifier	 Row Digest Resolver
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
ReadResponse	TokenNameIdentifier	 Read Response
,	TokenNameCOMMA	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
getReadCallback	TokenNameIdentifier	 get Read Callback
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
assureSufficientLiveNodes	TokenNameIdentifier	 assure Sufficient Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
!	TokenNameNOT	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
readCallbacks	TokenNameIdentifier	 read Callbacks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
// The data-request message is sent to dataPoint, the node that will actually get the data for us 	TokenNameCOMMENT_LINE	The data-request message is sent to dataPoint, the node that will actually get the data for us 
InetAddress	TokenNameIdentifier	 Inet Address
dataPoint	TokenNameIdentifier	 data Point
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dataPoint	TokenNameIdentifier	 data Point
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
OPTIMIZE_LOCAL_REQUESTS	TokenNameIdentifier	 OPTIMIZE  LOCAL  REQUESTS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading data locally"	TokenNameStringLiteral	reading data locally
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
new	TokenNamenew	
LocalReadRunnable	TokenNameIdentifier	 Local Read Runnable
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading data from {}"	TokenNameStringLiteral	reading data from {}
,	TokenNameCOMMA	
dataPoint	TokenNameIdentifier	 data Point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dataPoint	TokenNameIdentifier	 data Point
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// send the other endpoints a digest request 	TokenNameCOMMENT_LINE	send the other endpoints a digest request 
ReadCommand	TokenNameIdentifier	 Read Command
digestCommand	TokenNameIdentifier	 digest Command
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
digestCommand	TokenNameIdentifier	 digest Command
.	TokenNameDOT	
setDigestQuery	TokenNameIdentifier	 set Digest Query
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessageOut	TokenNameIdentifier	 Message Out
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
digestPoint	TokenNameIdentifier	 digest Point
:	TokenNameCOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
digestPoint	TokenNameIdentifier	 digest Point
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
OPTIMIZE_LOCAL_REQUESTS	TokenNameIdentifier	 OPTIMIZE  LOCAL  REQUESTS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading digest locally"	TokenNameStringLiteral	reading digest locally
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
new	TokenNamenew	
LocalReadRunnable	TokenNameIdentifier	 Local Read Runnable
(	TokenNameLPAREN	
digestCommand	TokenNameIdentifier	 digest Command
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading digest from {}"	TokenNameStringLiteral	reading digest from {}
,	TokenNameCOMMA	
digestPoint	TokenNameIdentifier	 digest Point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// (We lazy-construct the digest Message object since it may not be necessary if we 	TokenNameCOMMENT_LINE	(We lazy-construct the digest Message object since it may not be necessary if we 
// are doing a local digest read, or no digest reads at all.) 	TokenNameCOMMENT_LINE	are doing a local digest read, or no digest reads at all.) 
if	TokenNameif	
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
digestCommand	TokenNameIdentifier	 digest Command
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
digestPoint	TokenNameIdentifier	 digest Point
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// read results and make a second pass for any digest mismatches 	TokenNameCOMMENT_LINE	read results and make a second pass for any digest mismatches 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
repairCommands	TokenNameIdentifier	 repair Commands
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
RepairCallback	TokenNameIdentifier	 Repair Callback
>	TokenNameGREATER	
repairResponseHandlers	TokenNameIdentifier	 repair Response Handlers
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
ReadResponse	TokenNameIdentifier	 Read Response
,	TokenNameCOMMA	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
readCallbacks	TokenNameIdentifier	 read Callbacks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ReadCommand	TokenNameIdentifier	 Read Command
command	TokenNameIdentifier	 command
=	TokenNameEQUAL	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
long	TokenNamelong	
startTime2	TokenNameIdentifier	 start Time2
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maybeTrim	TokenNameIdentifier	 maybe Trim
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Read timeout: {}"	TokenNameStringLiteral	Read timeout: {}
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
ex	TokenNameIdentifier	 ex
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DigestMismatchException	TokenNameIdentifier	 Digest Mismatch Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Digest mismatch: {}"	TokenNameStringLiteral	Digest mismatch: {}
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowRepairResolver	TokenNameIdentifier	 Row Repair Resolver
resolver	TokenNameIdentifier	 resolver
=	TokenNameEQUAL	
new	TokenNamenew	
RowRepairResolver	TokenNameIdentifier	 Row Repair Resolver
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
table	TokenNameIdentifier	 table
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RepairCallback	TokenNameIdentifier	 Repair Callback
repairHandler	TokenNameIdentifier	 repair Handler
=	TokenNameEQUAL	
new	TokenNamenew	
RepairCallback	TokenNameIdentifier	 Repair Callback
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
repairCommands	TokenNameIdentifier	 repair Commands
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
repairCommands	TokenNameIdentifier	 repair Commands
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
repairResponseHandlers	TokenNameIdentifier	 repair Response Handlers
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
RepairCallback	TokenNameIdentifier	 Repair Callback
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
repairCommands	TokenNameIdentifier	 repair Commands
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
repairResponseHandlers	TokenNameIdentifier	 repair Response Handlers
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
repairHandler	TokenNameIdentifier	 repair Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessageOut	TokenNameIdentifier	 Message Out
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
repairHandler	TokenNameIdentifier	 repair Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
commandsToRetry	TokenNameIdentifier	 commands To Retry
!=	TokenNameNOT_EQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
)	TokenNameRPAREN	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// read the results for the digest mismatch retries 	TokenNameCOMMENT_LINE	read the results for the digest mismatch retries 
if	TokenNameif	
(	TokenNameLPAREN	
repairResponseHandlers	TokenNameIdentifier	 repair Response Handlers
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
repairCommands	TokenNameIdentifier	 repair Commands
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReadCommand	TokenNameIdentifier	 Read Command
command	TokenNameIdentifier	 command
=	TokenNameEQUAL	
repairCommands	TokenNameIdentifier	 repair Commands
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RepairCallback	TokenNameIdentifier	 Repair Callback
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
repairResponseHandlers	TokenNameIdentifier	 repair Response Handlers
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DigestMismatchException	TokenNameIdentifier	 Digest Mismatch Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// full data requested from each node here, no digests should be sent 	TokenNameCOMMENT_LINE	full data requested from each node here, no digests should be sent 
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// wait for the repair writes to be acknowledged, to minimize impact on any replica that's 	TokenNameCOMMENT_LINE	wait for the repair writes to be acknowledged, to minimize impact on any replica that's 
// behind on writes in case the out-of-sync row is read multiple times in quick succession 	TokenNameCOMMENT_LINE	behind on writes in case the out-of-sync row is read multiple times in quick succession 
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
waitOnFutures	TokenNameIdentifier	 wait On Futures
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
resolver	TokenNameIdentifier	 resolver
.	TokenNameDOT	
repairResults	TokenNameIdentifier	 repair Results
,	TokenNameCOMMA	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getWriteRpcTimeout	TokenNameIdentifier	 get Write Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TimeoutException	TokenNameIdentifier	 Timeout Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
blockFor	TokenNameIdentifier	 block For
=	TokenNameEQUAL	
consistency_level	TokenNameIdentifier	 consistency level
.	TokenNameDOT	
blockFor	TokenNameIdentifier	 block For
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
getKeyspace	TokenNameIdentifier	 get Keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
(	TokenNameLPAREN	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
blockFor	TokenNameIdentifier	 block For
,	TokenNameCOMMA	
blockFor	TokenNameIdentifier	 block For
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// retry any potential short reads 	TokenNameCOMMENT_LINE	retry any potential short reads 
ReadCommand	TokenNameIdentifier	 Read Command
retryCommand	TokenNameIdentifier	 retry Command
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maybeGenerateRetryCommand	TokenNameIdentifier	 maybe Generate Retry Command
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
retryCommand	TokenNameIdentifier	 retry Command
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Issuing retry for read command"	TokenNameStringLiteral	Issuing retry for read command
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
commandsToRetry	TokenNameIdentifier	 commands To Retry
==	TokenNameEQUAL_EQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
)	TokenNameRPAREN	
commandsToRetry	TokenNameIdentifier	 commands To Retry
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
retryCommand	TokenNameIdentifier	 retry Command
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maybeTrim	TokenNameIdentifier	 maybe Trim
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
commandsToRetry	TokenNameIdentifier	 commands To Retry
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
class	TokenNameclass	
LocalReadRunnable	TokenNameIdentifier	 Local Read Runnable
extends	TokenNameextends	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
ReadCommand	TokenNameIdentifier	 Read Command
command	TokenNameIdentifier	 command
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
ReadResponse	TokenNameIdentifier	 Read Response
,	TokenNameCOMMA	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LocalReadRunnable	TokenNameIdentifier	 Local Read Runnable
(	TokenNameLPAREN	
ReadCommand	TokenNameIdentifier	 Read Command
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
ReadResponse	TokenNameIdentifier	 Read Response
,	TokenNameCOMMA	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
command	TokenNameIdentifier	 command
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"LocalReadRunnable reading {}"	TokenNameStringLiteral	LocalReadRunnable reading {}
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Row	TokenNameIdentifier	 Row
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
getRow	TokenNameIdentifier	 get Row
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ReadResponse	TokenNameIdentifier	 Read Response
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
ReadVerbHandler	TokenNameIdentifier	 Read Verb Handler
.	TokenNameDOT	
getResponse	TokenNameIdentifier	 get Response
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
addLatency	TokenNameIdentifier	 add Latency
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
class	TokenNameclass	
LocalRangeSliceRunnable	TokenNameIdentifier	 Local Range Slice Runnable
extends	TokenNameextends	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
command	TokenNameIdentifier	 command
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
RangeSliceReply	TokenNameIdentifier	 Range Slice Reply
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>>	TokenNameRIGHT_SHIFT	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LocalRangeSliceRunnable	TokenNameIdentifier	 Local Range Slice Runnable
(	TokenNameLPAREN	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
RangeSliceReply	TokenNameIdentifier	 Range Slice Reply
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>>	TokenNameRIGHT_SHIFT	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
command	TokenNameIdentifier	 command
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"LocalReadRunnable reading {}"	TokenNameStringLiteral	LocalReadRunnable reading {}
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RangeSliceReply	TokenNameIdentifier	 Range Slice Reply
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
new	TokenNamenew	
RangeSliceReply	TokenNameIdentifier	 Range Slice Reply
(	TokenNameLPAREN	
RangeSliceVerbHandler	TokenNameIdentifier	 Range Slice Verb Handler
.	TokenNameDOT	
executeLocally	TokenNameIdentifier	 execute Locally
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
addLatency	TokenNameIdentifier	 add Latency
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
<	TokenNameLESS	
TMessage	TokenNameIdentifier	 T Message
,	TokenNameCOMMA	
TResolved	TokenNameIdentifier	 T Resolved
>	TokenNameGREATER	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
TMessage	TokenNameIdentifier	 T Message
,	TokenNameCOMMA	
TResolved	TokenNameIdentifier	 T Resolved
>	TokenNameGREATER	
getReadCallback	TokenNameIdentifier	 get Read Callback
(	TokenNameLPAREN	
IResponseResolver	TokenNameIdentifier	 I Response Resolver
<	TokenNameLESS	
TMessage	TokenNameIdentifier	 T Message
,	TokenNameCOMMA	
TResolved	TokenNameIdentifier	 T Resolved
>	TokenNameGREATER	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
IReadCommand	TokenNameIdentifier	 I Read Command
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistencyLevel	TokenNameIdentifier	 consistency Level
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
consistencyLevel	TokenNameIdentifier	 consistency Level
==	TokenNameEQUAL_EQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
LOCAL_QUORUM	TokenNameIdentifier	 LOCAL  QUORUM
||	TokenNameOR_OR	
consistencyLevel	TokenNameIdentifier	 consistency Level
==	TokenNameEQUAL_EQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
EACH_QUORUM	TokenNameIdentifier	 EACH  QUORUM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
DatacenterReadCallback	TokenNameIdentifier	 Datacenter Read Callback
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ReadCallback	TokenNameIdentifier	 Read Callback
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
getRangeSlice	TokenNameIdentifier	 get Range Slice
(	TokenNameLPAREN	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Determining replicas to query"	TokenNameStringLiteral	Determining replicas to query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Command/ConsistencyLevel is {}/{}"	TokenNameStringLiteral	Command/ConsistencyLevel is {}/{}
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
// now scan until we have enough results 	TokenNameCOMMENT_LINE	now scan until we have enough results 
try	TokenNametry	
{	TokenNameLBRACE	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
commandPredicate	TokenNameIdentifier	 command Predicate
=	TokenNameEQUAL	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
predicate	TokenNameIdentifier	 predicate
;	TokenNameSEMICOLON	
int	TokenNameint	
cql3RowCount	TokenNameIdentifier	 cql3 Row Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
getRestrictedRanges	TokenNameIdentifier	 get Restricted Ranges
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
nodeCmd	TokenNameIdentifier	 node Cmd
=	TokenNameEQUAL	
new	TokenNamenew	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
column_family	TokenNameIdentifier	 column family
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
,	TokenNameCOMMA	
commandPredicate	TokenNameIdentifier	 command Predicate
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
row_filter	TokenNameIdentifier	 row filter
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
isPaging	TokenNameIdentifier	 is Paging
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
liveEndpoints	TokenNameIdentifier	 live Endpoints
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveNaturalEndpoints	TokenNameIdentifier	 get Live Natural Endpoints
(	TokenNameLPAREN	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getEndpointSnitch	TokenNameIdentifier	 get Endpoint Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sortByProximity	TokenNameIdentifier	 sort By Proximity
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
liveEndpoints	TokenNameIdentifier	 live Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// collect replies and resolve according to consistency level 	TokenNameCOMMENT_LINE	collect replies and resolve according to consistency level 
RangeSliceResponseResolver	TokenNameIdentifier	 Range Slice Response Resolver
resolver	TokenNameIdentifier	 resolver
=	TokenNameEQUAL	
new	TokenNamenew	
RangeSliceResponseResolver	TokenNameIdentifier	 Range Slice Response Resolver
(	TokenNameLPAREN	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ReadCallback	TokenNameIdentifier	 Read Callback
<	TokenNameLESS	
RangeSliceReply	TokenNameIdentifier	 Range Slice Reply
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>>	TokenNameRIGHT_SHIFT	
handler	TokenNameIdentifier	 handler
=	TokenNameEQUAL	
getReadCallback	TokenNameIdentifier	 get Read Callback
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
nodeCmd	TokenNameIdentifier	 node Cmd
,	TokenNameCOMMA	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
liveEndpoints	TokenNameIdentifier	 live Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
assureSufficientLiveNodes	TokenNameIdentifier	 assure Sufficient Live Nodes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resolver	TokenNameIdentifier	 resolver
.	TokenNameDOT	
setSources	TokenNameIdentifier	 set Sources
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getBroadcastAddress	TokenNameIdentifier	 get Broadcast Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
OPTIMIZE_LOCAL_REQUESTS	TokenNameIdentifier	 OPTIMIZE  LOCAL  REQUESTS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading data locally"	TokenNameStringLiteral	reading data locally
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StageManager	TokenNameIdentifier	 Stage Manager
.	TokenNameDOT	
getStage	TokenNameIdentifier	 get Stage
(	TokenNameLPAREN	
Stage	TokenNameIdentifier	 Stage
.	TokenNameDOT	
READ	TokenNameIdentifier	 READ
)	TokenNameRPAREN	
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
new	TokenNamenew	
LocalRangeSliceRunnable	TokenNameIdentifier	 Local Range Slice Runnable
(	TokenNameLPAREN	
nodeCmd	TokenNameIdentifier	 node Cmd
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
MessageOut	TokenNameIdentifier	 Message Out
<	TokenNameLESS	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
>	TokenNameGREATER	
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
endpoints	TokenNameIdentifier	 endpoints
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"reading {} from {}"	TokenNameStringLiteral	reading {} from {}
,	TokenNameCOMMA	
nodeCmd	TokenNameIdentifier	 node Cmd
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
)	TokenNameRPAREN	
cql3RowCount	TokenNameIdentifier	 cql3 Row Count
+=	TokenNamePLUS_EQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getLiveCount	TokenNameIdentifier	 get Live Count
(	TokenNameLPAREN	
commandPredicate	TokenNameIdentifier	 command Predicate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"range slices read {}"	TokenNameStringLiteral	range slices read {}
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
waitOnFutures	TokenNameIdentifier	 wait On Futures
(	TokenNameLPAREN	
resolver	TokenNameIdentifier	 resolver
.	TokenNameDOT	
repairResults	TokenNameIdentifier	 repair Results
,	TokenNameCOMMA	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getWriteRpcTimeout	TokenNameIdentifier	 get Write Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TimeoutException	TokenNameIdentifier	 Timeout Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Range slice timeout: {}"	TokenNameStringLiteral	Range slice timeout: {}
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We actually got all response at that point 	TokenNameCOMMENT_LINE	We actually got all response at that point 
int	TokenNameint	
blockFor	TokenNameIdentifier	 block For
=	TokenNameEQUAL	
consistency_level	TokenNameIdentifier	 consistency level
.	TokenNameDOT	
blockFor	TokenNameIdentifier	 block For
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ReadTimeoutException	TokenNameIdentifier	 Read Timeout Exception
(	TokenNameLPAREN	
consistency_level	TokenNameIdentifier	 consistency level
,	TokenNameCOMMA	
blockFor	TokenNameIdentifier	 block For
,	TokenNameCOMMA	
blockFor	TokenNameIdentifier	 block For
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DigestMismatchException	TokenNameIdentifier	 Digest Mismatch Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// no digests in range slices yet 	TokenNameCOMMENT_LINE	no digests in range slices yet 
}	TokenNameRBRACE	
// if we're done, great, otherwise, move to the next range 	TokenNameCOMMENT_LINE	if we're done, great, otherwise, move to the next range 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
?	TokenNameQUESTION	
cql3RowCount	TokenNameIdentifier	 cql3 Row Count
:	TokenNameCOLON	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
nodeCmd	TokenNameIdentifier	 node Cmd
.	TokenNameDOT	
maxResults	TokenNameIdentifier	 max Results
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// if we are paging and already got some rows, reset the column filter predicate, 	TokenNameCOMMENT_LINE	if we are paging and already got some rows, reset the column filter predicate, 
// so we start iterating the next row from the first column 	TokenNameCOMMENT_LINE	so we start iterating the next row from the first column 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
isPaging	TokenNameIdentifier	 is Paging
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We only allow paging with a slice filter (doesn't make sense otherwise anyway) 	TokenNameCOMMENT_LINE	We only allow paging with a slice filter (doesn't make sense otherwise anyway) 
assert	TokenNameassert	
commandPredicate	TokenNameIdentifier	 command Predicate
instanceof	TokenNameinstanceof	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
;	TokenNameSEMICOLON	
commandPredicate	TokenNameIdentifier	 command Predicate
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
commandPredicate	TokenNameIdentifier	 command Predicate
)	TokenNameRPAREN	
.	TokenNameDOT	
withUpdatedSlices	TokenNameIdentifier	 with Updated Slices
(	TokenNameLPAREN	
ColumnSlice	TokenNameIdentifier	 Column Slice
.	TokenNameDOT	
ALL_COLUMNS_ARRAY	TokenNameIdentifier	 ALL  COLUMNS  ARRAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
addNano	TokenNameIdentifier	 add Nano
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
getEmptySlicePredicate	TokenNameIdentifier	 get Empty Slice Predicate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
command	TokenNameIdentifier	 command
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// When countCQL3Rows, we let the caller trim the result. 	TokenNameCOMMENT_LINE	When countCQL3Rows, we let the caller trim the result. 
if	TokenNameif	
(	TokenNameLPAREN	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
)	TokenNameRPAREN	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maxResults	TokenNameIdentifier	 max Results
?	TokenNameQUESTION	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
command	TokenNameIdentifier	 command
.	TokenNameDOT	
maxResults	TokenNameIdentifier	 max Results
)	TokenNameRPAREN	
:	TokenNameCOLON	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * initiate a request/response session with each live node to check whether or not everybody is using the same * migration id. This is useful for determining if a schema change has propagated through the cluster. Disagreement * is assumed if any node fails to respond. */	TokenNameCOMMENT_JAVADOC	 initiate a request/response session with each live node to check whether or not everybody is using the same migration id. This is useful for determining if a schema change has propagated through the cluster. Disagreement is assumed if any node fails to respond. 
public	TokenNamepublic	
static	TokenNamestatic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
describeSchemaVersions	TokenNameIdentifier	 describe Schema Versions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
myVersion	TokenNameIdentifier	 my Version
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getVersion	TokenNameIdentifier	 get Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
versions	TokenNameIdentifier	 versions
=	TokenNameEQUAL	
new	TokenNamenew	
ConcurrentHashMap	TokenNameIdentifier	 Concurrent Hash Map
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
,	TokenNameCOMMA	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
liveHosts	TokenNameIdentifier	 live Hosts
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
new	TokenNamenew	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
(	TokenNameLPAREN	
liveHosts	TokenNameIdentifier	 live Hosts
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IAsyncCallback	TokenNameIdentifier	 I Async Callback
<	TokenNameLESS	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
cb	TokenNameIdentifier	 cb
=	TokenNameEQUAL	
new	TokenNamenew	
IAsyncCallback	TokenNameIdentifier	 I Async Callback
<	TokenNameLESS	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
response	TokenNameIdentifier	 response
(	TokenNameLPAREN	
MessageIn	TokenNameIdentifier	 Message In
<	TokenNameLESS	
UUID	TokenNameIdentifier	 UUID
>	TokenNameGREATER	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// record the response from the remote node. 	TokenNameCOMMENT_LINE	record the response from the remote node. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Received schema check response from {}"	TokenNameStringLiteral	Received schema check response from {}
,	TokenNameCOMMA	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
from	TokenNameIdentifier	 from
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
versions	TokenNameIdentifier	 versions
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
payload	TokenNameIdentifier	 payload
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isLatencyForSnitch	TokenNameIdentifier	 is Latency For Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// an empty message acts as a request to the SchemaCheckVerbHandler. 	TokenNameCOMMENT_LINE	an empty message acts as a request to the SchemaCheckVerbHandler. 
MessageOut	TokenNameIdentifier	 Message Out
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
new	TokenNamenew	
MessageOut	TokenNameIdentifier	 Message Out
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
.	TokenNameDOT	
SCHEMA_CHECK	TokenNameIdentifier	 SCHEMA  CHECK
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
liveHosts	TokenNameIdentifier	 live Hosts
)	TokenNameRPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
cb	TokenNameIdentifier	 cb
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// wait for as long as possible. timeout-1s if possible. 	TokenNameCOMMENT_LINE	wait for as long as possible. timeout-1s if possible. 
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
await	TokenNameIdentifier	 await
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRpcTimeout	TokenNameIdentifier	 get Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
"This latch shouldn't have been interrupted."	TokenNameStringLiteral	This latch shouldn't have been interrupted.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"My version is {}"	TokenNameStringLiteral	My version is {}
,	TokenNameCOMMA	
myVersion	TokenNameIdentifier	 my Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// maps versions to hosts that are on that version. 	TokenNameCOMMENT_LINE	maps versions to hosts that are on that version. 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
allHosts	TokenNameIdentifier	 all Hosts
=	TokenNameEQUAL	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getUnreachableMembers	TokenNameIdentifier	 get Unreachable Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
host	TokenNameIdentifier	 host
:	TokenNameCOLON	
allHosts	TokenNameIdentifier	 all Hosts
)	TokenNameRPAREN	
{	TokenNameLBRACE	
UUID	TokenNameIdentifier	 UUID
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
versions	TokenNameIdentifier	 versions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
host	TokenNameIdentifier	 host
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
stringVersion	TokenNameIdentifier	 string Version
=	TokenNameEQUAL	
version	TokenNameIdentifier	 version
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
UNREACHABLE	TokenNameIdentifier	 UNREACHABLE
:	TokenNameCOLON	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
hosts	TokenNameIdentifier	 hosts
=	TokenNameEQUAL	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
stringVersion	TokenNameIdentifier	 string Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hosts	TokenNameIdentifier	 hosts
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hosts	TokenNameIdentifier	 hosts
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
stringVersion	TokenNameIdentifier	 string Version
,	TokenNameCOMMA	
hosts	TokenNameIdentifier	 hosts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hosts	TokenNameIdentifier	 hosts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
host	TokenNameIdentifier	 host
.	TokenNameDOT	
getHostAddress	TokenNameIdentifier	 get Host Address
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we're done: the results map is ready to return to the client. the rest is just debug logging: 	TokenNameCOMMENT_LINE	we're done: the results map is ready to return to the client. the rest is just debug logging: 
if	TokenNameif	
(	TokenNameLPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
UNREACHABLE	TokenNameIdentifier	 UNREACHABLE
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Hosts not in agreement. Didn't get a response from everybody: {}"	TokenNameStringLiteral	Hosts not in agreement. Didn't get a response from everybody: {}
,	TokenNameCOMMA	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
UNREACHABLE	TokenNameIdentifier	 UNREACHABLE
)	TokenNameRPAREN	
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check for version disagreement. log the hosts that don't agree. 	TokenNameCOMMENT_LINE	check for version disagreement. log the hosts that don't agree. 
if	TokenNameif	
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
UNREACHABLE	TokenNameIdentifier	 UNREACHABLE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
myVersion	TokenNameIdentifier	 my Version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
host	TokenNameIdentifier	 host
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"{} disagrees ({})"	TokenNameStringLiteral	{} disagrees ({})
,	TokenNameCOMMA	
host	TokenNameIdentifier	 host
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Schemas are in agreement."	TokenNameStringLiteral	Schemas are in agreement.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
results	TokenNameIdentifier	 results
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Compute all ranges we're going to query, in sorted order. Nodes can be replica destinations for many ranges, * so we need to restrict each scan to the specific range we want, or else we'd get duplicate results. */	TokenNameCOMMENT_JAVADOC	 Compute all ranges we're going to query, in sorted order. Nodes can be replica destinations for many ranges, so we need to restrict each scan to the specific range we want, or else we'd get duplicate results. 
static	TokenNamestatic	
<	TokenNameLESS	
T	TokenNameIdentifier	 T
extends	TokenNameextends	
RingPosition	TokenNameIdentifier	 Ring Position
>	TokenNameGREATER	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
getRestrictedRanges	TokenNameIdentifier	 get Restricted Ranges
(	TokenNameLPAREN	
final	TokenNamefinal	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
queryRange	TokenNameIdentifier	 query Range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// special case for bounds containing exactly 1 (non-minimum) token 	TokenNameCOMMENT_LINE	special case for bounds containing exactly 1 (non-minimum) token 
if	TokenNameif	
(	TokenNameLPAREN	
queryRange	TokenNameIdentifier	 query Range
instanceof	TokenNameinstanceof	
Bounds	TokenNameIdentifier	 Bounds
&&	TokenNameAND_AND	
queryRange	TokenNameIdentifier	 query Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
queryRange	TokenNameIdentifier	 query Range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
queryRange	TokenNameIdentifier	 query Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"restricted single token match for query {}"	TokenNameStringLiteral	restricted single token match for query {}
,	TokenNameCOMMA	
queryRange	TokenNameIdentifier	 query Range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
queryRange	TokenNameIdentifier	 query Range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
TokenMetadata	TokenNameIdentifier	 Token Metadata
tokenMetadata	TokenNameIdentifier	 token Metadata
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTokenMetadata	TokenNameIdentifier	 get Token Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// divide the queryRange into pieces delimited by the ring and minimum tokens 	TokenNameCOMMENT_LINE	divide the queryRange into pieces delimited by the ring and minimum tokens 
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
ringIter	TokenNameIdentifier	 ring Iter
=	TokenNameEQUAL	
TokenMetadata	TokenNameIdentifier	 Token Metadata
.	TokenNameDOT	
ringIterator	TokenNameIdentifier	 ring Iterator
(	TokenNameLPAREN	
tokenMetadata	TokenNameIdentifier	 token Metadata
.	TokenNameDOT	
sortedTokens	TokenNameIdentifier	 sorted Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
queryRange	TokenNameIdentifier	 query Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
remainder	TokenNameIdentifier	 remainder
=	TokenNameEQUAL	
queryRange	TokenNameIdentifier	 query Range
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ringIter	TokenNameIdentifier	 ring Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * remainder can be a range/bounds of token _or_ keys and we want to split it with a token: * - if remainder is tokens, then we'll just split using the provided token. * - if remainder is keys, we want to split using token.upperBoundKey. For instance, if remainder * is [DK(10, 'foo'), DK(20, 'bar')], and we have 3 nodes with tokens 0, 15, 30. We want to * split remainder to A=[DK(10, 'foo'), 15] and B=(15, DK(20, 'bar')]. But since we can't mix * tokens and keys at the same time in a range, we uses 15.upperBoundKey() to have A include all * keys having 15 as token and B include none of those (since that is what our node owns). * asSplitValue() abstracts that choice. */	TokenNameCOMMENT_BLOCK	 remainder can be a range/bounds of token _or_ keys and we want to split it with a token: - if remainder is tokens, then we'll just split using the provided token. - if remainder is keys, we want to split using token.upperBoundKey. For instance, if remainder is [DK(10, 'foo'), DK(20, 'bar')], and we have 3 nodes with tokens 0, 15, 30. We want to split remainder to A=[DK(10, 'foo'), 15] and B=(15, DK(20, 'bar')]. But since we can't mix tokens and keys at the same time in a range, we uses 15.upperBoundKey() to have A include all keys having 15 as token and B include none of those (since that is what our node owns). asSplitValue() abstracts that choice. 
Token	TokenNameIdentifier	 Token
upperBoundToken	TokenNameIdentifier	 upper Bound Token
=	TokenNameEQUAL	
ringIter	TokenNameIdentifier	 ring Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
T	TokenNameIdentifier	 T
upperBound	TokenNameIdentifier	 upper Bound
=	TokenNameEQUAL	
(	TokenNameLPAREN	
T	TokenNameIdentifier	 T
)	TokenNameRPAREN	
upperBoundToken	TokenNameIdentifier	 upper Bound Token
.	TokenNameDOT	
upperBound	TokenNameIdentifier	 upper Bound
(	TokenNameLPAREN	
queryRange	TokenNameIdentifier	 query Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
remainder	TokenNameIdentifier	 remainder
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
upperBound	TokenNameIdentifier	 upper Bound
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
remainder	TokenNameIdentifier	 remainder
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
upperBound	TokenNameIdentifier	 upper Bound
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// no more splits 	TokenNameCOMMENT_LINE	no more splits 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>	TokenNameGREATER	
,	TokenNameCOMMA	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
T	TokenNameIdentifier	 T
>>	TokenNameRIGHT_SHIFT	
splits	TokenNameIdentifier	 splits
=	TokenNameEQUAL	
remainder	TokenNameIdentifier	 remainder
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
upperBound	TokenNameIdentifier	 upper Bound
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
splits	TokenNameIdentifier	 splits
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
splits	TokenNameIdentifier	 splits
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
remainder	TokenNameIdentifier	 remainder
=	TokenNameEQUAL	
splits	TokenNameIdentifier	 splits
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
remainder	TokenNameIdentifier	 remainder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"restricted ranges for query {} are {}"	TokenNameStringLiteral	restricted ranges for query {} are {}
,	TokenNameCOMMA	
queryRange	TokenNameIdentifier	 query Range
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getReadOperations	TokenNameIdentifier	 get Read Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalReadLatencyMicros	TokenNameIdentifier	 get Total Read Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
totalLatency	TokenNameIdentifier	 total Latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentReadLatencyMicros	TokenNameIdentifier	 get Recent Read Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
getRecentLatency	TokenNameIdentifier	 get Recent Latency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getTotalReadLatencyHistogramMicros	TokenNameIdentifier	 get Total Read Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
totalLatencyHistogram	TokenNameIdentifier	 total Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentReadLatencyHistogramMicros	TokenNameIdentifier	 get Recent Read Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
readMetrics	TokenNameIdentifier	 read Metrics
.	TokenNameDOT	
recentLatencyHistogram	TokenNameIdentifier	 recent Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getRangeOperations	TokenNameIdentifier	 get Range Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalRangeLatencyMicros	TokenNameIdentifier	 get Total Range Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
totalLatency	TokenNameIdentifier	 total Latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentRangeLatencyMicros	TokenNameIdentifier	 get Recent Range Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
getRecentLatency	TokenNameIdentifier	 get Recent Latency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getTotalRangeLatencyHistogramMicros	TokenNameIdentifier	 get Total Range Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
totalLatencyHistogram	TokenNameIdentifier	 total Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentRangeLatencyHistogramMicros	TokenNameIdentifier	 get Recent Range Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeMetrics	TokenNameIdentifier	 range Metrics
.	TokenNameDOT	
recentLatencyHistogram	TokenNameIdentifier	 recent Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getWriteOperations	TokenNameIdentifier	 get Write Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
latency	TokenNameIdentifier	 latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalWriteLatencyMicros	TokenNameIdentifier	 get Total Write Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
totalLatency	TokenNameIdentifier	 total Latency
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getRecentWriteLatencyMicros	TokenNameIdentifier	 get Recent Write Latency Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
getRecentLatency	TokenNameIdentifier	 get Recent Latency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getTotalWriteLatencyHistogramMicros	TokenNameIdentifier	 get Total Write Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
totalLatencyHistogram	TokenNameIdentifier	 total Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecentWriteLatencyHistogramMicros	TokenNameIdentifier	 get Recent Write Latency Histogram Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
writeMetrics	TokenNameIdentifier	 write Metrics
.	TokenNameDOT	
recentLatencyHistogram	TokenNameIdentifier	 recent Latency Histogram
.	TokenNameDOT	
getBuckets	TokenNameIdentifier	 get Buckets
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
getHintedHandoffEnabled	TokenNameIdentifier	 get Hinted Handoff Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
hintedHandoffEnabled	TokenNameIdentifier	 hinted Handoff Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setHintedHandoffEnabled	TokenNameIdentifier	 set Hinted Handoff Enabled
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setHintedHandoffEnabled	TokenNameIdentifier	 set Hinted Handoff Enabled
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMaxHintWindow	TokenNameIdentifier	 get Max Hint Window
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getMaxHintWindow	TokenNameIdentifier	 get Max Hint Window
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMaxHintWindow	TokenNameIdentifier	 set Max Hint Window
(	TokenNameLPAREN	
int	TokenNameint	
ms	TokenNameIdentifier	 ms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setMaxHintWindow	TokenNameIdentifier	 set Max Hint Window
(	TokenNameLPAREN	
ms	TokenNameIdentifier	 ms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
shouldHint	TokenNameIdentifier	 should Hint
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
hintedHandoffEnabled	TokenNameIdentifier	 hinted Handoff Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hintWindowExpired	TokenNameIdentifier	 hint Window Expired
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointDowntime	TokenNameIdentifier	 get Endpoint Downtime
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
>	TokenNameGREATER	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getMaxHintWindow	TokenNameIdentifier	 get Max Hint Window
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hintWindowExpired	TokenNameIdentifier	 hint Window Expired
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"not hinting {} which has been down {}ms"	TokenNameStringLiteral	not hinting {} which has been down {}ms
,	TokenNameCOMMA	
ep	TokenNameIdentifier	 ep
,	TokenNameCOMMA	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getEndpointDowntime	TokenNameIdentifier	 get Endpoint Downtime
(	TokenNameLPAREN	
ep	TokenNameIdentifier	 ep
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
!	TokenNameNOT	
hintWindowExpired	TokenNameIdentifier	 hint Window Expired
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Performs the truncate operatoin, which effectively deletes all data from * the column family cfname * @param keyspace * @param cfname * @throws UnavailableException If some of the hosts in the ring are down. * @throws TimeoutException * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Performs the truncate operatoin, which effectively deletes all data from the column family cfname @param keyspace @param cfname @throws UnavailableException If some of the hosts in the ring are down. @throws TimeoutException @throws IOException 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
truncateBlocking	TokenNameIdentifier	 truncate Blocking
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
throws	TokenNamethrows	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimeoutException	TokenNameIdentifier	 Timeout Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Starting a blocking truncate operation on keyspace {}, CF "	TokenNameStringLiteral	Starting a blocking truncate operation on keyspace {}, CF 
,	TokenNameCOMMA	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isAnyHostDown	TokenNameIdentifier	 is Any Host Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Cannot perform truncate, some hosts are down"	TokenNameStringLiteral	Cannot perform truncate, some hosts are down
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Since the truncate operation is so aggressive and is typically only 	TokenNameCOMMENT_LINE	Since the truncate operation is so aggressive and is typically only 
// invoked by an admin, for simplicity we require that all nodes are up 	TokenNameCOMMENT_LINE	invoked by an admin, for simplicity we require that all nodes are up 
// to perform the operation. 	TokenNameCOMMENT_LINE	to perform the operation. 
int	TokenNameint	
liveMembers	TokenNameIdentifier	 live Members
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
(	TokenNameLPAREN	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ALL	TokenNameIdentifier	 ALL
,	TokenNameCOMMA	
liveMembers	TokenNameIdentifier	 live Members
+	TokenNamePLUS	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getUnreachableMembers	TokenNameIdentifier	 get Unreachable Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
liveMembers	TokenNameIdentifier	 live Members
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
allEndpoints	TokenNameIdentifier	 all Endpoints
=	TokenNameEQUAL	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLiveMembers	TokenNameIdentifier	 get Live Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
blockFor	TokenNameIdentifier	 block For
=	TokenNameEQUAL	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TruncateResponseHandler	TokenNameIdentifier	 Truncate Response Handler
responseHandler	TokenNameIdentifier	 response Handler
=	TokenNameEQUAL	
new	TokenNamenew	
TruncateResponseHandler	TokenNameIdentifier	 Truncate Response Handler
(	TokenNameLPAREN	
blockFor	TokenNameIdentifier	 block For
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Send out the truncate calls and track the responses with the callbacks. 	TokenNameCOMMENT_LINE	Send out the truncate calls and track the responses with the callbacks. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Starting to send truncate messages to hosts {}"	TokenNameStringLiteral	Starting to send truncate messages to hosts {}
,	TokenNameCOMMA	
allEndpoints	TokenNameIdentifier	 all Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Truncation	TokenNameIdentifier	 Truncation
truncation	TokenNameIdentifier	 truncation
=	TokenNameEQUAL	
new	TokenNamenew	
Truncation	TokenNameIdentifier	 Truncation
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MessageOut	TokenNameIdentifier	 Message Out
<	TokenNameLESS	
Truncation	TokenNameIdentifier	 Truncation
>	TokenNameGREATER	
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
truncation	TokenNameIdentifier	 truncation
.	TokenNameDOT	
createMessage	TokenNameIdentifier	 create Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
endpoint	TokenNameIdentifier	 endpoint
:	TokenNameCOLON	
allEndpoints	TokenNameIdentifier	 all Endpoints
)	TokenNameRPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sendRR	TokenNameIdentifier	 send RR
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
endpoint	TokenNameIdentifier	 endpoint
,	TokenNameCOMMA	
responseHandler	TokenNameIdentifier	 response Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Wait for all 	TokenNameCOMMENT_LINE	Wait for all 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Sent all truncate messages, now waiting for {} responses"	TokenNameStringLiteral	Sent all truncate messages, now waiting for {} responses
,	TokenNameCOMMA	
blockFor	TokenNameIdentifier	 block For
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
responseHandler	TokenNameIdentifier	 response Handler
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Asks the gossiper if there are any nodes that are currently down. * @return true if the gossiper thinks all nodes are up. */	TokenNameCOMMENT_JAVADOC	 Asks the gossiper if there are any nodes that are currently down. @return true if the gossiper thinks all nodes are up. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isAnyHostDown	TokenNameIdentifier	 is Any Host Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
Gossiper	TokenNameIdentifier	 Gossiper
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getUnreachableMembers	TokenNameIdentifier	 get Unreachable Members
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
interface	TokenNameinterface	
WritePerformer	TokenNameIdentifier	 Write Performer
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
IMutation	TokenNameIdentifier	 I Mutation
mutation	TokenNameIdentifier	 mutation
,	TokenNameCOMMA	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
targets	TokenNameIdentifier	 targets
,	TokenNameCOMMA	
AbstractWriteResponseHandler	TokenNameIdentifier	 Abstract Write Response Handler
responseHandler	TokenNameIdentifier	 response Handler
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localDataCenter	TokenNameIdentifier	 local Data Center
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistency_level	TokenNameIdentifier	 consistency level
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
,	TokenNameCOMMA	
OverloadedException	TokenNameIdentifier	 Overloaded Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
implements	TokenNameimplements	
Runnable	TokenNameIdentifier	 Runnable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
constructionTime	TokenNameIdentifier	 construction Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
verb	TokenNameIdentifier	 verb
;	TokenNameSEMICOLON	
public	TokenNamepublic	
DroppableRunnable	TokenNameIdentifier	 Droppable Runnable
(	TokenNameLPAREN	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
Verb	TokenNameIdentifier	 Verb
verb	TokenNameIdentifier	 verb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
verb	TokenNameIdentifier	 verb
=	TokenNameEQUAL	
verb	TokenNameIdentifier	 verb
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
constructionTime	TokenNameIdentifier	 construction Time
+	TokenNamePLUS	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getTimeout	TokenNameIdentifier	 get Timeout
(	TokenNameLPAREN	
verb	TokenNameIdentifier	 verb
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
incrementDroppedMessages	TokenNameIdentifier	 increment Dropped Messages
(	TokenNameLPAREN	
verb	TokenNameIdentifier	 verb
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
abstract	TokenNameabstract	
protected	TokenNameprotected	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalHints	TokenNameIdentifier	 get Total Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
totalHints	TokenNameIdentifier	 total Hints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getMaxHintsInProgress	TokenNameIdentifier	 get Max Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxHintsInProgress	TokenNameIdentifier	 max Hints In Progress
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMaxHintsInProgress	TokenNameIdentifier	 set Max Hints In Progress
(	TokenNameLPAREN	
int	TokenNameint	
qs	TokenNameIdentifier	 qs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxHintsInProgress	TokenNameIdentifier	 max Hints In Progress
=	TokenNameEQUAL	
qs	TokenNameIdentifier	 qs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getHintsInProgress	TokenNameIdentifier	 get Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
totalHintsInProgress	TokenNameIdentifier	 total Hints In Progress
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
verifyNoHintsInProgress	TokenNameIdentifier	 verify No Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getHintsInProgress	TokenNameIdentifier	 get Hints In Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Some hints were not written before shutdown. This is not supposed to happen. You should (a) run repair, and (b) file a bug report"	TokenNameStringLiteral	Some hints were not written before shutdown. This is not supposed to happen. You should (a) run repair, and (b) file a bug report
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getRpcTimeout	TokenNameIdentifier	 get Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRpcTimeout	TokenNameIdentifier	 get Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setRpcTimeout	TokenNameIdentifier	 set Rpc Timeout
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setRpcTimeout	TokenNameIdentifier	 set Rpc Timeout
(	TokenNameLPAREN	
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getReadRpcTimeout	TokenNameIdentifier	 get Read Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getReadRpcTimeout	TokenNameIdentifier	 get Read Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setReadRpcTimeout	TokenNameIdentifier	 set Read Rpc Timeout
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setReadRpcTimeout	TokenNameIdentifier	 set Read Rpc Timeout
(	TokenNameLPAREN	
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getWriteRpcTimeout	TokenNameIdentifier	 get Write Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getWriteRpcTimeout	TokenNameIdentifier	 get Write Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setWriteRpcTimeout	TokenNameIdentifier	 set Write Rpc Timeout
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setWriteRpcTimeout	TokenNameIdentifier	 set Write Rpc Timeout
(	TokenNameLPAREN	
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getRangeRpcTimeout	TokenNameIdentifier	 get Range Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getRangeRpcTimeout	TokenNameIdentifier	 get Range Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setRangeRpcTimeout	TokenNameIdentifier	 set Range Rpc Timeout
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setRangeRpcTimeout	TokenNameIdentifier	 set Range Rpc Timeout
(	TokenNameLPAREN	
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Long	TokenNameIdentifier	 Long
getTruncateRpcTimeout	TokenNameIdentifier	 get Truncate Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getTruncateRpcTimeout	TokenNameIdentifier	 get Truncate Rpc Timeout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setTruncateRpcTimeout	TokenNameIdentifier	 set Truncate Rpc Timeout
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
setTruncateRpcTimeout	TokenNameIdentifier	 set Truncate Rpc Timeout
(	TokenNameLPAREN	
timeoutInMillis	TokenNameIdentifier	 timeout In Millis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
