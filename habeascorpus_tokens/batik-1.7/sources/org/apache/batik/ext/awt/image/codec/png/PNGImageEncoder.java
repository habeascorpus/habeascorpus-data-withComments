/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
png	TokenNameIdentifier	 png
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ImageEncoderImpl	TokenNameIdentifier	 Image Encoder Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ColorModel	TokenNameIdentifier	 Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
IndexColorModel	TokenNameIdentifier	 Index Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
Raster	TokenNameIdentifier	 Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
RenderedImage	TokenNameIdentifier	 Rendered Image
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SampleModel	TokenNameIdentifier	 Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataOutput	TokenNameIdentifier	 Data Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FilterOutputStream	TokenNameIdentifier	 Filter Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Calendar	TokenNameIdentifier	 Calendar
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Date	TokenNameIdentifier	 Date
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
GregorianCalendar	TokenNameIdentifier	 Gregorian Calendar
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
TimeZone	TokenNameIdentifier	 Time Zone
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
Deflater	TokenNameIdentifier	 Deflater
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
DeflaterOutputStream	TokenNameIdentifier	 Deflater Output Stream
;	TokenNameSEMICOLON	
class	TokenNameclass	
CRC	TokenNameIdentifier	 CRC
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
crcTable	TokenNameIdentifier	 crc Table
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
256	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
// Initialize CRC table 	TokenNameCOMMENT_LINE	Initialize CRC table 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
256	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
&	TokenNameAND	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
0xedb88320	TokenNameIntegerLiteral	
^	TokenNameXOR	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
>>>=	TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
crcTable	TokenNameIdentifier	 crc Table
[	TokenNameLBRACKET	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
updateCRC	TokenNameIdentifier	 update CRC
(	TokenNameLPAREN	
int	TokenNameint	
crc	TokenNameIdentifier	 crc
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
int	TokenNameint	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
crc	TokenNameIdentifier	 crc
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
crcTable	TokenNameIdentifier	 crc Table
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
^	TokenNameXOR	
data	TokenNameIdentifier	 data
[	TokenNameLBRACKET	
off	TokenNameIdentifier	 off
+	TokenNamePLUS	
n	TokenNameIdentifier	 n
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
^	TokenNameXOR	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
class	TokenNameclass	
ChunkStream	TokenNameIdentifier	 Chunk Stream
extends	TokenNameextends	
OutputStream	TokenNameIdentifier	 Output Stream
implements	TokenNameimplements	
DataOutput	TokenNameIdentifier	 Data Output
{	TokenNameLBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
baos	TokenNameIdentifier	 baos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
dos	TokenNameIdentifier	 dos
;	TokenNameSEMICOLON	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
baos	TokenNameIdentifier	 baos
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
dos	TokenNameIdentifier	 dos
=	TokenNameEQUAL	
new	TokenNamenew	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
int	TokenNameint	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
int	TokenNameint	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeBoolean	TokenNameIdentifier	 write Boolean
(	TokenNameLPAREN	
boolean	TokenNameboolean	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeBoolean	TokenNameIdentifier	 write Boolean
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeBytes	TokenNameIdentifier	 write Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeBytes	TokenNameIdentifier	 write Bytes
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeChar	TokenNameIdentifier	 write Char
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeChar	TokenNameIdentifier	 write Char
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeChars	TokenNameIdentifier	 write Chars
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeChars	TokenNameIdentifier	 write Chars
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeDouble	TokenNameIdentifier	 write Double
(	TokenNameLPAREN	
double	TokenNamedouble	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeDouble	TokenNameIdentifier	 write Double
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeFloat	TokenNameIdentifier	 write Float
(	TokenNameLPAREN	
float	TokenNamefloat	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeFloat	TokenNameIdentifier	 write Float
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
long	TokenNamelong	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeUTF	TokenNameIdentifier	 write UTF
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeUTF	TokenNameIdentifier	 write UTF
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
typeSignature	TokenNameIdentifier	 type Signature
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
typeSignature	TokenNameIdentifier	 type Signature
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeSignature	TokenNameIdentifier	 type Signature
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeSignature	TokenNameIdentifier	 type Signature
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
typeSignature	TokenNameIdentifier	 type Signature
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baos	TokenNameIdentifier	 baos
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
baos	TokenNameIdentifier	 baos
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
typeSignature	TokenNameIdentifier	 type Signature
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
0xffffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
CRC	TokenNameIdentifier	 CRC
.	TokenNameDOT	
updateCRC	TokenNameIdentifier	 update CRC
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
,	TokenNameCOMMA	
typeSignature	TokenNameIdentifier	 type Signature
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
CRC	TokenNameIdentifier	 CRC
.	TokenNameDOT	
updateCRC	TokenNameIdentifier	 update CRC
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
^	TokenNameXOR	
0xffffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * this doesnt do much, its main purpose is to stop complaints * about 'outputStream not closed...'. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 this doesnt do much, its main purpose is to stop complaints about 'outputStream not closed...'. * @throws IOException 
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baos	TokenNameIdentifier	 baos
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baos	TokenNameIdentifier	 baos
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baos	TokenNameIdentifier	 baos
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
class	TokenNameclass	
IDATOutputStream	TokenNameIdentifier	 IDAT Output Stream
extends	TokenNameextends	
FilterOutputStream	TokenNameIdentifier	 Filter Output Stream
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
typeSignature	TokenNameIdentifier	 type Signature
=	TokenNameEQUAL	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
'I'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
'D'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
'A'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
'T'	TokenNameCharacterLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
bytesWritten	TokenNameIdentifier	 bytes Written
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
segmentLength	TokenNameIdentifier	 segment Length
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
;	TokenNameSEMICOLON	
public	TokenNamepublic	
IDATOutputStream	TokenNameIdentifier	 IDAT Output Stream
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
int	TokenNameint	
segmentLength	TokenNameIdentifier	 segment Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
segmentLength	TokenNameIdentifier	 segment Length
=	TokenNameEQUAL	
segmentLength	TokenNameIdentifier	 segment Length
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
segmentLength	TokenNameIdentifier	 segment Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
int	TokenNameint	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Length 	TokenNameCOMMENT_LINE	Length 
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
bytesWritten	TokenNameIdentifier	 bytes Written
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 'IDAT' signature 	TokenNameCOMMENT_LINE	'IDAT' signature 
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
typeSignature	TokenNameIdentifier	 type Signature
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Data 	TokenNameCOMMENT_LINE	Data 
out	TokenNameIdentifier	 out
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bytesWritten	TokenNameIdentifier	 bytes Written
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
0xffffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
CRC	TokenNameIdentifier	 CRC
.	TokenNameDOT	
updateCRC	TokenNameIdentifier	 update CRC
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
,	TokenNameCOMMA	
typeSignature	TokenNameIdentifier	 type Signature
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
crc	TokenNameIdentifier	 crc
=	TokenNameEQUAL	
CRC	TokenNameIdentifier	 CRC
.	TokenNameDOT	
updateCRC	TokenNameIdentifier	 update CRC
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bytesWritten	TokenNameIdentifier	 bytes Written
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CRC 	TokenNameCOMMENT_LINE	CRC 
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
crc	TokenNameIdentifier	 crc
^	TokenNameXOR	
0xffffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reset buffer 	TokenNameCOMMENT_LINE	Reset buffer 
bytesWritten	TokenNameIdentifier	 bytes Written
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
int	TokenNameint	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
int	TokenNameint	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
len	TokenNameIdentifier	 len
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
segmentLength	TokenNameIdentifier	 segment Length
-	TokenNameMINUS	
bytesWritten	TokenNameIdentifier	 bytes Written
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
bytesWritten	TokenNameIdentifier	 bytes Written
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
off	TokenNameIdentifier	 off
+=	TokenNamePLUS_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
-=	TokenNameMINUS_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
bytesWritten	TokenNameIdentifier	 bytes Written
+=	TokenNamePLUS_EQUAL	
bytes	TokenNameIdentifier	 bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytesWritten	TokenNameIdentifier	 bytes Written
==	TokenNameEQUAL_EQUAL	
segmentLength	TokenNameIdentifier	 segment Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
int	TokenNameint	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
[	TokenNameLBRACKET	
bytesWritten	TokenNameIdentifier	 bytes Written
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytesWritten	TokenNameIdentifier	 bytes Written
==	TokenNameEQUAL_EQUAL	
segmentLength	TokenNameIdentifier	 segment Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * An ImageEncoder for the PNG file format. * * @since EA4 * @version $Id: PNGImageEncoder.java 501844 2007-01-31 13:54:05Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 An ImageEncoder for the PNG file format. * @since EA4 @version $Id: PNGImageEncoder.java 501844 2007-01-31 13:54:05Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
PNGImageEncoder	TokenNameIdentifier	 PNG Image Encoder
extends	TokenNameextends	
ImageEncoderImpl	TokenNameIdentifier	 Image Encoder Impl
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
PNG_COLOR_GRAY	TokenNameIdentifier	 PNG  COLOR  GRAY
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
PNG_COLOR_RGB	TokenNameIdentifier	 PNG  COLOR  RGB
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
PNG_COLOR_PALETTE	TokenNameIdentifier	 PNG  COLOR  PALETTE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
PNG_COLOR_GRAY_ALPHA	TokenNameIdentifier	 PNG  COLOR  GRAY  ALPHA
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
PNG_COLOR_RGB_ALPHA	TokenNameIdentifier	 PNG  COLOR  RGB  ALPHA
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
magic	TokenNameIdentifier	 magic
=	TokenNameEQUAL	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
137	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
80	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
78	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
71	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
13	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
26	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
10	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
private	TokenNameprivate	
RenderedImage	TokenNameIdentifier	 Rendered Image
image	TokenNameIdentifier	 image
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
width	TokenNameIdentifier	 width
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
bitDepth	TokenNameIdentifier	 bit Depth
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
bitShift	TokenNameIdentifier	 bit Shift
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
colorType	TokenNameIdentifier	 color Type
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
bpp	TokenNameIdentifier	 bpp
;	TokenNameSEMICOLON	
// bytes per pixel, rounded up 	TokenNameCOMMENT_LINE	bytes per pixel, rounded up 
private	TokenNameprivate	
boolean	TokenNameboolean	
skipAlpha	TokenNameIdentifier	 skip Alpha
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
compressGray	TokenNameIdentifier	 compress Gray
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
interlace	TokenNameIdentifier	 interlace
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
redPalette	TokenNameIdentifier	 red Palette
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
greenPalette	TokenNameIdentifier	 green Palette
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bluePalette	TokenNameIdentifier	 blue Palette
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
alphaPalette	TokenNameIdentifier	 alpha Palette
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
dataOutput	TokenNameIdentifier	 data Output
;	TokenNameSEMICOLON	
public	TokenNamepublic	
PNGImageEncoder	TokenNameIdentifier	 PNG Image Encoder
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dataOutput	TokenNameIdentifier	 data Output
=	TokenNameEQUAL	
new	TokenNamenew	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeMagic	TokenNameIdentifier	 write Magic
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dataOutput	TokenNameIdentifier	 data Output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
magic	TokenNameIdentifier	 magic
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeIHDR	TokenNameIdentifier	 write IHDR
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"IHDR"	TokenNameStringLiteral	IHDR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
width	TokenNameIdentifier	 width
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
colorType	TokenNameIdentifier	 color Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
interlace	TokenNameIdentifier	 interlace
?	TokenNameQUESTION	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
prevRow	TokenNameIdentifier	 prev Row
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
currRow	TokenNameIdentifier	 curr Row
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
filteredRows	TokenNameIdentifier	 filtered Rows
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
clamp	TokenNameIdentifier	 clamp
(	TokenNameLPAREN	
int	TokenNameint	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
int	TokenNameint	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>	TokenNameGREATER	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
?	TokenNameQUESTION	
maxValue	TokenNameIdentifier	 max Value
:	TokenNameCOLON	
val	TokenNameIdentifier	 val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
os	TokenNameIdentifier	 os
,	TokenNameCOMMA	
Raster	TokenNameIdentifier	 Raster
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
int	TokenNameint	
xOffset	TokenNameIdentifier	 x Offset
,	TokenNameCOMMA	
int	TokenNameint	
yOffset	TokenNameIdentifier	 y Offset
,	TokenNameCOMMA	
int	TokenNameint	
xSkip	TokenNameIdentifier	 x Skip
,	TokenNameCOMMA	
int	TokenNameint	
ySkip	TokenNameIdentifier	 y Skip
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
minX	TokenNameIdentifier	 min X
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
minY	TokenNameIdentifier	 min Y
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
width	TokenNameIdentifier	 width
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
height	TokenNameIdentifier	 height
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
xOffset	TokenNameIdentifier	 x Offset
*=	TokenNameMULTIPLY_EQUAL	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
xSkip	TokenNameIdentifier	 x Skip
*=	TokenNameMULTIPLY_EQUAL	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
int	TokenNameint	
samplesPerByte	TokenNameIdentifier	 samples Per Byte
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
bitDepth	TokenNameIdentifier	 bit Depth
;	TokenNameSEMICOLON	
int	TokenNameint	
numSamples	TokenNameIdentifier	 num Samples
=	TokenNameEQUAL	
width	TokenNameIdentifier	 width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
samples	TokenNameIdentifier	 samples
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numSamples	TokenNameIdentifier	 num Samples
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
pixels	TokenNameIdentifier	 pixels
=	TokenNameEQUAL	
(	TokenNameLPAREN	
numSamples	TokenNameIdentifier	 num Samples
-	TokenNameMINUS	
xOffset	TokenNameIdentifier	 x Offset
+	TokenNamePLUS	
xSkip	TokenNameIdentifier	 x Skip
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
xSkip	TokenNameIdentifier	 x Skip
;	TokenNameSEMICOLON	
int	TokenNameint	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
=	TokenNameEQUAL	
pixels	TokenNameIdentifier	 pixels
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
+	TokenNamePLUS	
samplesPerByte	TokenNameIdentifier	 samples Per Byte
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
samplesPerByte	TokenNameIdentifier	 samples Per Byte
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
*=	TokenNameMULTIPLY_EQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
currRow	TokenNameIdentifier	 curr Row
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
+	TokenNamePLUS	
bpp	TokenNameIdentifier	 bpp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
prevRow	TokenNameIdentifier	 prev Row
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
+	TokenNamePLUS	
bpp	TokenNameIdentifier	 bpp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
filteredRows	TokenNameIdentifier	 filtered Rows
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
+	TokenNamePLUS	
bpp	TokenNameIdentifier	 bpp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
maxValue	TokenNameIdentifier	 max Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
minY	TokenNameIdentifier	 min Y
+	TokenNamePLUS	
yOffset	TokenNameIdentifier	 y Offset
;	TokenNameSEMICOLON	
row	TokenNameIdentifier	 row
<	TokenNameLESS	
minY	TokenNameIdentifier	 min Y
+	TokenNamePLUS	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
row	TokenNameIdentifier	 row
+=	TokenNamePLUS_EQUAL	
ySkip	TokenNameIdentifier	 y Skip
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getPixels	TokenNameIdentifier	 get Pixels
(	TokenNameLPAREN	
minX	TokenNameIdentifier	 min X
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
,	TokenNameCOMMA	
width	TokenNameIdentifier	 width
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
samples	TokenNameIdentifier	 samples
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compressGray	TokenNameIdentifier	 compress Gray
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
shift	TokenNameIdentifier	 shift
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
-	TokenNameMINUS	
bitDepth	TokenNameIdentifier	 bit Depth
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
width	TokenNameIdentifier	 width
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
samples	TokenNameIdentifier	 samples
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
>>=	TokenNameRIGHT_SHIFT_EQUAL	
shift	TokenNameIdentifier	 shift
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
bpp	TokenNameIdentifier	 bpp
;	TokenNameSEMICOLON	
// leave first 'bpp' bytes zero 	TokenNameCOMMENT_LINE	leave first 'bpp' bytes zero 
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
// Image can only have a single band 	TokenNameCOMMENT_LINE	Image can only have a single band 
int	TokenNameint	
mask	TokenNameIdentifier	 mask
=	TokenNameEQUAL	
samplesPerByte	TokenNameIdentifier	 samples Per Byte
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
xOffset	TokenNameIdentifier	 x Offset
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
numSamples	TokenNameIdentifier	 num Samples
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
+=	TokenNamePLUS_EQUAL	
xSkip	TokenNameIdentifier	 x Skip
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
clamp	TokenNameIdentifier	 clamp
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
]	TokenNameRBRACKET	
>>	TokenNameRIGHT_SHIFT	
bitShift	TokenNameIdentifier	 bit Shift
,	TokenNameCOMMA	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
<<	TokenNameLEFT_SHIFT	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
|	TokenNameOR	
val	TokenNameIdentifier	 val
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
==	TokenNameEQUAL_EQUAL	
mask	TokenNameIdentifier	 mask
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currRow	TokenNameIdentifier	 curr Row
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Left shift the last byte 	TokenNameCOMMENT_LINE	Left shift the last byte 
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmp	TokenNameIdentifier	 tmp
<<=	TokenNameLEFT_SHIFT_EQUAL	
(	TokenNameLPAREN	
samplesPerByte	TokenNameIdentifier	 samples Per Byte
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
bitDepth	TokenNameIdentifier	 bit Depth
;	TokenNameSEMICOLON	
currRow	TokenNameIdentifier	 curr Row
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
xOffset	TokenNameIdentifier	 x Offset
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
numSamples	TokenNameIdentifier	 num Samples
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
+=	TokenNamePLUS_EQUAL	
xSkip	TokenNameIdentifier	 x Skip
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currRow	TokenNameIdentifier	 curr Row
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
clamp	TokenNameIdentifier	 clamp
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
+	TokenNamePLUS	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
>>	TokenNameRIGHT_SHIFT	
bitShift	TokenNameIdentifier	 bit Shift
,	TokenNameCOMMA	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
xOffset	TokenNameIdentifier	 x Offset
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
numSamples	TokenNameIdentifier	 num Samples
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
+=	TokenNamePLUS_EQUAL	
xSkip	TokenNameIdentifier	 x Skip
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
clamp	TokenNameIdentifier	 clamp
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
+	TokenNamePLUS	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
>>	TokenNameRIGHT_SHIFT	
bitShift	TokenNameIdentifier	 bit Shift
,	TokenNameCOMMA	
maxValue	TokenNameIdentifier	 max Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currRow	TokenNameIdentifier	 curr Row
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currRow	TokenNameIdentifier	 curr Row
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Perform filtering 	TokenNameCOMMENT_LINE	Perform filtering 
int	TokenNameint	
filterType	TokenNameIdentifier	 filter Type
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
filterRow	TokenNameIdentifier	 filter Row
(	TokenNameLPAREN	
currRow	TokenNameIdentifier	 curr Row
,	TokenNameCOMMA	
prevRow	TokenNameIdentifier	 prev Row
,	TokenNameCOMMA	
filteredRows	TokenNameIdentifier	 filtered Rows
,	TokenNameCOMMA	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
bpp	TokenNameIdentifier	 bpp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
os	TokenNameIdentifier	 os
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
filterType	TokenNameIdentifier	 filter Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
os	TokenNameIdentifier	 os
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
filteredRows	TokenNameIdentifier	 filtered Rows
[	TokenNameLBRACKET	
filterType	TokenNameIdentifier	 filter Type
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
bpp	TokenNameIdentifier	 bpp
,	TokenNameCOMMA	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Swap current and previous rows 	TokenNameCOMMENT_LINE	Swap current and previous rows 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
swap	TokenNameIdentifier	 swap
=	TokenNameEQUAL	
currRow	TokenNameIdentifier	 curr Row
;	TokenNameSEMICOLON	
currRow	TokenNameIdentifier	 curr Row
=	TokenNameEQUAL	
prevRow	TokenNameIdentifier	 prev Row
;	TokenNameSEMICOLON	
prevRow	TokenNameIdentifier	 prev Row
=	TokenNameEQUAL	
swap	TokenNameIdentifier	 swap
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeIDAT	TokenNameIdentifier	 write IDAT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
IDATOutputStream	TokenNameIdentifier	 IDAT Output Stream
ios	TokenNameIdentifier	 ios
=	TokenNameEQUAL	
new	TokenNamenew	
IDATOutputStream	TokenNameIdentifier	 IDAT Output Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
,	TokenNameCOMMA	
8192	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DeflaterOutputStream	TokenNameIdentifier	 Deflater Output Stream
dos	TokenNameIdentifier	 dos
=	TokenNameEQUAL	
new	TokenNamenew	
DeflaterOutputStream	TokenNameIdentifier	 Deflater Output Stream
(	TokenNameLPAREN	
ios	TokenNameIdentifier	 ios
,	TokenNameCOMMA	
new	TokenNamenew	
Deflater	TokenNameIdentifier	 Deflater
(	TokenNameLPAREN	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Future work - don't convert entire image to a Raster It 	TokenNameCOMMENT_LINE	Future work - don't convert entire image to a Raster It 
// might seem that you could just call image.getData() but 	TokenNameCOMMENT_LINE	might seem that you could just call image.getData() but 
// 'BufferedImage.subImage' doesn't appear to set the Width 	TokenNameCOMMENT_LINE	'BufferedImage.subImage' doesn't appear to set the Width 
// and height properly of the Child Raster, so the Raster 	TokenNameCOMMENT_LINE	and height properly of the Child Raster, so the Raster 
// you get back here appears larger than it should. 	TokenNameCOMMENT_LINE	you get back here appears larger than it should. 
// This solves that problem by bounding the raster to the 	TokenNameCOMMENT_LINE	This solves that problem by bounding the raster to the 
// image's bounds... 	TokenNameCOMMENT_LINE	image's bounds... 
Raster	TokenNameIdentifier	 Raster
ras	TokenNameIdentifier	 ras
=	TokenNameEQUAL	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println("Image: [" + 	TokenNameCOMMENT_LINE	System.out.println("Image: [" + 
// image.getMinY() + ", " + 	TokenNameCOMMENT_LINE	image.getMinY() + ", " + 
// image.getMinX() + ", " + 	TokenNameCOMMENT_LINE	image.getMinX() + ", " + 
// image.getWidth() + ", " + 	TokenNameCOMMENT_LINE	image.getWidth() + ", " + 
// image.getHeight() + "]"); 	TokenNameCOMMENT_LINE	image.getHeight() + "]"); 
// System.out.println("Ras: [" + 	TokenNameCOMMENT_LINE	System.out.println("Ras: [" + 
// ras.getMinX() + ", " + 	TokenNameCOMMENT_LINE	ras.getMinX() + ", " + 
// ras.getMinY() + ", " + 	TokenNameCOMMENT_LINE	ras.getMinY() + ", " + 
// ras.getWidth() + ", " + 	TokenNameCOMMENT_LINE	ras.getWidth() + ", " + 
// ras.getHeight() + "]"); 	TokenNameCOMMENT_LINE	ras.getHeight() + "]"); 
if	TokenNameif	
(	TokenNameLPAREN	
skipAlpha	TokenNameIdentifier	 skip Alpha
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bandList	TokenNameIdentifier	 band List
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bandList	TokenNameIdentifier	 band List
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ras	TokenNameIdentifier	 ras
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
createChild	TokenNameIdentifier	 create Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bandList	TokenNameIdentifier	 band List
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
interlace	TokenNameIdentifier	 interlace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Interlacing pass 1 	TokenNameCOMMENT_LINE	Interlacing pass 1 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 2 	TokenNameCOMMENT_LINE	Interlacing pass 2 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 3 	TokenNameCOMMENT_LINE	Interlacing pass 3 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 4 	TokenNameCOMMENT_LINE	Interlacing pass 4 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 5 	TokenNameCOMMENT_LINE	Interlacing pass 5 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 6 	TokenNameCOMMENT_LINE	Interlacing pass 6 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Interlacing pass 7 	TokenNameCOMMENT_LINE	Interlacing pass 7 
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
encodePass	TokenNameIdentifier	 encode Pass
(	TokenNameLPAREN	
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
ras	TokenNameIdentifier	 ras
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ios	TokenNameIdentifier	 ios
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeIEND	TokenNameIdentifier	 write IEND
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"IEND"	TokenNameStringLiteral	IEND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srgbChroma	TokenNameIdentifier	 srgb Chroma
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0.31270F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.329F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.64F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.33F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.3F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.6F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.15F	TokenNameFloatingPointLiteral	
,	TokenNameCOMMA	
0.06F	TokenNameFloatingPointLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
writeCHRM	TokenNameIdentifier	 write CHRM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isChromaticitySet	TokenNameIdentifier	 is Chromaticity Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSRGBIntentSet	TokenNameIdentifier	 is SRGB Intent Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"cHRM"	TokenNameStringLiteral	cHRM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chroma	TokenNameIdentifier	 chroma
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSRGBIntentSet	TokenNameIdentifier	 is SRGB Intent Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
chroma	TokenNameIdentifier	 chroma
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getChromaticity	TokenNameIdentifier	 get Chromaticity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
chroma	TokenNameIdentifier	 chroma
=	TokenNameEQUAL	
srgbChroma	TokenNameIdentifier	 srgb Chroma
;	TokenNameSEMICOLON	
// SRGB chromaticities 	TokenNameCOMMENT_LINE	SRGB chromaticities 
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
chroma	TokenNameIdentifier	 chroma
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
100000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeGAMA	TokenNameIdentifier	 write GAMA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isGammaSet	TokenNameIdentifier	 is Gamma Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSRGBIntentSet	TokenNameIdentifier	 is SRGB Intent Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"gAMA"	TokenNameStringLiteral	gAMA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
gamma	TokenNameIdentifier	 gamma
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSRGBIntentSet	TokenNameIdentifier	 is SRGB Intent Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gamma	TokenNameIdentifier	 gamma
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getGamma	TokenNameIdentifier	 get Gamma
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
gamma	TokenNameIdentifier	 gamma
=	TokenNameEQUAL	
1.0F	TokenNameFloatingPointLiteral	
/	TokenNameDIVIDE	
2.2F	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
// SRGB gamma 	TokenNameCOMMENT_LINE	SRGB gamma 
}	TokenNameRBRACE	
// TD should include the .5 but causes regard to say 	TokenNameCOMMENT_LINE	TD should include the .5 but causes regard to say 
// everything is different. 	TokenNameCOMMENT_LINE	everything is different. 
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
gamma	TokenNameIdentifier	 gamma
*	TokenNameMULTIPLY	
100000	TokenNameIntegerLiteral	
/*+0.5*/	TokenNameCOMMENT_BLOCK	+0.5
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeICCP	TokenNameIdentifier	 write ICCP
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isICCProfileDataSet	TokenNameIdentifier	 is ICC Profile Data Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"iCCP"	TokenNameStringLiteral	iCCP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ICCProfileData	TokenNameIdentifier	 ICC Profile Data
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getICCProfileData	TokenNameIdentifier	 get ICC Profile Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
ICCProfileData	TokenNameIdentifier	 ICC Profile Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeSBIT	TokenNameIdentifier	 write SBIT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSignificantBitsSet	TokenNameIdentifier	 is Significant Bits Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"sBIT"	TokenNameStringLiteral	sBIT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
significantBits	TokenNameIdentifier	 significant Bits
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getSignificantBits	TokenNameIdentifier	 get Significant Bits
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
significantBits	TokenNameIdentifier	 significant Bits
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
significantBits	TokenNameIdentifier	 significant Bits
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeSRGB	TokenNameIdentifier	 write SRGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSRGBIntentSet	TokenNameIdentifier	 is SRGB Intent Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"sRGB"	TokenNameStringLiteral	sRGB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
intent	TokenNameIdentifier	 intent
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getSRGBIntent	TokenNameIdentifier	 get SRGB Intent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
intent	TokenNameIdentifier	 intent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writePLTE	TokenNameIdentifier	 write PLTE
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
redPalette	TokenNameIdentifier	 red Palette
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"PLTE"	TokenNameStringLiteral	PLTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
redPalette	TokenNameIdentifier	 red Palette
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
redPalette	TokenNameIdentifier	 red Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
greenPalette	TokenNameIdentifier	 green Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
bluePalette	TokenNameIdentifier	 blue Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeBKGD	TokenNameIdentifier	 write BKGD
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isBackgroundSet	TokenNameIdentifier	 is Background Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"bKGD"	TokenNameStringLiteral	bKGD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
colorType	TokenNameIdentifier	 color Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
PNG_COLOR_GRAY	TokenNameIdentifier	 PNG  COLOR  GRAY
:	TokenNameCOLON	
case	TokenNamecase	
PNG_COLOR_GRAY_ALPHA	TokenNameIdentifier	 PNG  COLOR  GRAY  ALPHA
:	TokenNameCOLON	
int	TokenNameint	
gray	TokenNameIdentifier	 gray
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getBackgroundGray	TokenNameIdentifier	 get Background Gray
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
gray	TokenNameIdentifier	 gray
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
PNG_COLOR_PALETTE	TokenNameIdentifier	 PNG  COLOR  PALETTE
:	TokenNameCOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getBackgroundPaletteIndex	TokenNameIdentifier	 get Background Palette Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
PNG_COLOR_RGB	TokenNameIdentifier	 PNG  COLOR  RGB
:	TokenNameCOLON	
case	TokenNamecase	
PNG_COLOR_RGB_ALPHA	TokenNameIdentifier	 PNG  COLOR  RGB  ALPHA
:	TokenNameCOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rgb	TokenNameIdentifier	 rgb
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
RGB	TokenNameIdentifier	 RGB
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getBackgroundRGB	TokenNameIdentifier	 get Background RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeHIST	TokenNameIdentifier	 write HIST
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isPaletteHistogramSet	TokenNameIdentifier	 is Palette Histogram Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"hIST"	TokenNameStringLiteral	hIST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hist	TokenNameIdentifier	 hist
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getPaletteHistogram	TokenNameIdentifier	 get Palette Histogram
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
hist	TokenNameIdentifier	 hist
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
hist	TokenNameIdentifier	 hist
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeTRNS	TokenNameIdentifier	 write TRNS
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isTransparencySet	TokenNameIdentifier	 is Transparency Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
colorType	TokenNameIdentifier	 color Type
!=	TokenNameNOT_EQUAL	
PNG_COLOR_GRAY_ALPHA	TokenNameIdentifier	 PNG  COLOR  GRAY  ALPHA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
colorType	TokenNameIdentifier	 color Type
!=	TokenNameNOT_EQUAL	
PNG_COLOR_RGB_ALPHA	TokenNameIdentifier	 PNG  COLOR  RGB  ALPHA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"tRNS"	TokenNameStringLiteral	tRNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getPaletteTransparency	TokenNameIdentifier	 get Palette Transparency
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getTransparentGray	TokenNameIdentifier	 get Transparent Gray
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
RGB	TokenNameIdentifier	 RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
RGB	TokenNameIdentifier	 RGB
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
.	TokenNameDOT	
getTransparentRGB	TokenNameIdentifier	 get Transparent RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
colorType	TokenNameIdentifier	 color Type
==	TokenNameEQUAL_EQUAL	
PNG_COLOR_PALETTE	TokenNameIdentifier	 PNG  COLOR  PALETTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
lastEntry	TokenNameIdentifier	 last Entry
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
255	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
alphaPalette	TokenNameIdentifier	 alpha Palette
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nonOpaque	TokenNameIdentifier	 non Opaque
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
nonOpaque	TokenNameIdentifier	 non Opaque
=	TokenNameEQUAL	
lastEntry	TokenNameIdentifier	 last Entry
;	TokenNameSEMICOLON	
nonOpaque	TokenNameIdentifier	 non Opaque
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nonOpaque	TokenNameIdentifier	 non Opaque
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
alphaPalette	TokenNameIdentifier	 alpha Palette
[	TokenNameLBRACKET	
nonOpaque	TokenNameIdentifier	 non Opaque
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nonOpaque	TokenNameIdentifier	 non Opaque
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"tRNS"	TokenNameStringLiteral	tRNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
nonOpaque	TokenNameIdentifier	 non Opaque
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
alphaPalette	TokenNameIdentifier	 alpha Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writePHYS	TokenNameIdentifier	 write PHYS
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isPhysicalDimensionSet	TokenNameIdentifier	 is Physical Dimension Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"pHYs"	TokenNameStringLiteral	pHYs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dims	TokenNameIdentifier	 dims
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getPhysicalDimension	TokenNameIdentifier	 get Physical Dimension
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
dims	TokenNameIdentifier	 dims
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
dims	TokenNameIdentifier	 dims
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
dims	TokenNameIdentifier	 dims
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeSPLT	TokenNameIdentifier	 write SPLT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isSuggestedPaletteSet	TokenNameIdentifier	 is Suggested Palette Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"sPLT"	TokenNameStringLiteral	sPLT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"sPLT not supported yet."	TokenNameStringLiteral	sPLT not supported yet.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeTIME	TokenNameIdentifier	 write TIME
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isModificationTimeSet	TokenNameIdentifier	 is Modification Time Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"tIME"	TokenNameStringLiteral	tIME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Date	TokenNameIdentifier	 Date
date	TokenNameIdentifier	 date
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getModificationTime	TokenNameIdentifier	 get Modification Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TimeZone	TokenNameIdentifier	 Time Zone
gmt	TokenNameIdentifier	 gmt
=	TokenNameEQUAL	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
getTimeZone	TokenNameIdentifier	 get Time Zone
(	TokenNameLPAREN	
"GMT"	TokenNameStringLiteral	GMT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GregorianCalendar	TokenNameIdentifier	 Gregorian Calendar
cal	TokenNameIdentifier	 cal
=	TokenNameEQUAL	
new	TokenNamenew	
GregorianCalendar	TokenNameIdentifier	 Gregorian Calendar
(	TokenNameLPAREN	
gmt	TokenNameIdentifier	 gmt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
setTime	TokenNameIdentifier	 set Time
(	TokenNameLPAREN	
date	TokenNameIdentifier	 date
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
year	TokenNameIdentifier	 year
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
YEAR	TokenNameIdentifier	 YEAR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
month	TokenNameIdentifier	 month
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
MONTH	TokenNameIdentifier	 MONTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
day	TokenNameIdentifier	 day
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
DAY_OF_MONTH	TokenNameIdentifier	 DAY  OF  MONTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
hour	TokenNameIdentifier	 hour
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
HOUR_OF_DAY	TokenNameIdentifier	 HOUR  OF  DAY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
minute	TokenNameIdentifier	 minute
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
MINUTE	TokenNameIdentifier	 MINUTE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
second	TokenNameIdentifier	 second
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
SECOND	TokenNameIdentifier	 SECOND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeShort	TokenNameIdentifier	 write Short
(	TokenNameLPAREN	
year	TokenNameIdentifier	 year
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
month	TokenNameIdentifier	 month
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
day	TokenNameIdentifier	 day
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
hour	TokenNameIdentifier	 hour
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
minute	TokenNameIdentifier	 minute
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeByte	TokenNameIdentifier	 write Byte
(	TokenNameLPAREN	
second	TokenNameIdentifier	 second
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeTEXT	TokenNameIdentifier	 write TEXT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isTextSet	TokenNameIdentifier	 is Text Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyword	TokenNameIdentifier	 keyword
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"tEXt"	TokenNameStringLiteral	tEXt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
keyword	TokenNameIdentifier	 keyword
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
keyword	TokenNameIdentifier	 keyword
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeZTXT	TokenNameIdentifier	 write ZTXT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isCompressedTextSet	TokenNameIdentifier	 is Compressed Text Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getCompressedText	TokenNameIdentifier	 get Compressed Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyword	TokenNameIdentifier	 keyword
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
"zTXt"	TokenNameStringLiteral	zTXt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
keyword	TokenNameIdentifier	 keyword
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
keyword	TokenNameIdentifier	 keyword
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DeflaterOutputStream	TokenNameIdentifier	 Deflater Output Stream
dos	TokenNameIdentifier	 dos
=	TokenNameEQUAL	
new	TokenNamenew	
DeflaterOutputStream	TokenNameIdentifier	 Deflater Output Stream
(	TokenNameLPAREN	
cs	TokenNameIdentifier	 cs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writePrivateChunks	TokenNameIdentifier	 write Private Chunks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
numChunks	TokenNameIdentifier	 num Chunks
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getNumPrivateChunks	TokenNameIdentifier	 get Num Private Chunks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numChunks	TokenNameIdentifier	 num Chunks
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getPrivateChunkType	TokenNameIdentifier	 get Private Chunk Type
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getPrivateChunkData	TokenNameIdentifier	 get Private Chunk Data
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ChunkStream	TokenNameIdentifier	 Chunk Stream
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
new	TokenNamenew	
ChunkStream	TokenNameIdentifier	 Chunk Stream
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
writeToStream	TokenNameIdentifier	 write To Stream
(	TokenNameLPAREN	
dataOutput	TokenNameIdentifier	 data Output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Analyzes a set of palettes and determines if it can be expressed * as a standard set of gray values, with zero or one values being * fully transparent and the rest being fully opaque. If it * is possible to express the data thusly, the method returns * a suitable instance of PNGEncodeParam.Gray; otherwise it * returns null. */	TokenNameCOMMENT_JAVADOC	 Analyzes a set of palettes and determines if it can be expressed as a standard set of gray values, with zero or one values being fully transparent and the rest being fully opaque. If it is possible to express the data thusly, the method returns a suitable instance of PNGEncodeParam.Gray; otherwise it returns null. 
private	TokenNameprivate	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
createGrayParam	TokenNameIdentifier	 create Gray Param
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
redPalette	TokenNameIdentifier	 red Palette
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
greenPalette	TokenNameIdentifier	 green Palette
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bluePalette	TokenNameIdentifier	 blue Palette
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
alphaPalette	TokenNameIdentifier	 alpha Palette
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numTransparent	TokenNameIdentifier	 num Transparent
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
grayFactor	TokenNameIdentifier	 gray Factor
=	TokenNameEQUAL	
255	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
bitDepth	TokenNameIdentifier	 bit Depth
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
entries	TokenNameIdentifier	 entries
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
red	TokenNameIdentifier	 red
=	TokenNameEQUAL	
redPalette	TokenNameIdentifier	 red Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
red	TokenNameIdentifier	 red
!=	TokenNameNOT_EQUAL	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
grayFactor	TokenNameIdentifier	 gray Factor
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
red	TokenNameIdentifier	 red
!=	TokenNameNOT_EQUAL	
greenPalette	TokenNameIdentifier	 green Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
red	TokenNameIdentifier	 red
!=	TokenNameNOT_EQUAL	
bluePalette	TokenNameIdentifier	 blue Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// All alphas must be 255 except at most 1 can be 0 	TokenNameCOMMENT_LINE	All alphas must be 255 except at most 1 can be 0 
byte	TokenNamebyte	
alpha	TokenNameIdentifier	 alpha
=	TokenNameEQUAL	
alphaPalette	TokenNameIdentifier	 alpha Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
alpha	TokenNameIdentifier	 alpha
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
setTransparentGray	TokenNameIdentifier	 set Transparent Gray
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
numTransparent	TokenNameIdentifier	 num Transparent
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numTransparent	TokenNameIdentifier	 num Transparent
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
alpha	TokenNameIdentifier	 alpha
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method encodes a <code>RenderedImage</code> into PNG. * The stream into which the PNG is dumped is not closed at * the end of the operation, this should be done if needed * by the caller of this method. */	TokenNameCOMMENT_JAVADOC	 This method encodes a <code>RenderedImage</code> into PNG. The stream into which the PNG is dumped is not closed at the end of the operation, this should be done if needed by the caller of this method. 
public	TokenNamepublic	
void	TokenNamevoid	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
RenderedImage	TokenNameIdentifier	 Rendered Image
im	TokenNameIdentifier	 im
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
width	TokenNameIdentifier	 width
=	TokenNameEQUAL	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
height	TokenNameIdentifier	 height
=	TokenNameEQUAL	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sampleSize	TokenNameIdentifier	 sample Size
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getSampleSize	TokenNameIdentifier	 get Sample Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set bitDepth to a sentinel value 	TokenNameCOMMENT_LINE	Set bitDepth to a sentinel value 
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bitShift	TokenNameIdentifier	 bit Shift
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Allow user to override the bit depth of gray images 	TokenNameCOMMENT_LINE	Allow user to override the bit depth of gray images 
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
paramg	TokenNameIdentifier	 paramg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
paramg	TokenNameIdentifier	 paramg
.	TokenNameDOT	
isBitDepthSet	TokenNameIdentifier	 is Bit Depth Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
paramg	TokenNameIdentifier	 paramg
.	TokenNameDOT	
getBitDepth	TokenNameIdentifier	 get Bit Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
paramg	TokenNameIdentifier	 paramg
.	TokenNameDOT	
isBitShiftSet	TokenNameIdentifier	 is Bit Shift Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
bitShift	TokenNameIdentifier	 bit Shift
=	TokenNameEQUAL	
paramg	TokenNameIdentifier	 paramg
.	TokenNameDOT	
getBitShift	TokenNameIdentifier	 get Bit Shift
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Get bit depth from image if not set in param 	TokenNameCOMMENT_LINE	Get bit depth from image if not set in param 
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get bit depth from channel 0 of the image 	TokenNameCOMMENT_LINE	Get bit depth from channel 0 of the image 
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Ensure all channels have the same bit depth 	TokenNameCOMMENT_LINE	Ensure all channels have the same bit depth 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
sampleSize	TokenNameIdentifier	 sample Size
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
bitDepth	TokenNameIdentifier	 bit Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Round bit depth up to a power of 2 	TokenNameCOMMENT_LINE	Round bit depth up to a power of 2 
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
>	TokenNameGREATER	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bpp	TokenNameIdentifier	 bpp
=	TokenNameEQUAL	
numBands	TokenNameIdentifier	 num Bands
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColorModel	TokenNameIdentifier	 Color Model
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
instanceof	TokenNameinstanceof	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
bitDepth	TokenNameIdentifier	 bit Depth
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexColorModel	TokenNameIdentifier	 Index Color Model
icm	TokenNameIdentifier	 icm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
colorModel	TokenNameIdentifier	 color Model
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getMapSize	TokenNameIdentifier	 get Map Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
redPalette	TokenNameIdentifier	 red Palette
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
greenPalette	TokenNameIdentifier	 green Palette
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bluePalette	TokenNameIdentifier	 blue Palette
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
alphaPalette	TokenNameIdentifier	 alpha Palette
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getReds	TokenNameIdentifier	 get Reds
(	TokenNameLPAREN	
redPalette	TokenNameIdentifier	 red Palette
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getGreens	TokenNameIdentifier	 get Greens
(	TokenNameLPAREN	
greenPalette	TokenNameIdentifier	 green Palette
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getBlues	TokenNameIdentifier	 get Blues
(	TokenNameLPAREN	
bluePalette	TokenNameIdentifier	 blue Palette
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getAlphas	TokenNameIdentifier	 get Alphas
(	TokenNameLPAREN	
alphaPalette	TokenNameIdentifier	 alpha Palette
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bpp	TokenNameIdentifier	 bpp
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
createGrayParam	TokenNameIdentifier	 create Gray Param
(	TokenNameLPAREN	
redPalette	TokenNameIdentifier	 red Palette
,	TokenNameCOMMA	
greenPalette	TokenNameIdentifier	 green Palette
,	TokenNameCOMMA	
bluePalette	TokenNameIdentifier	 blue Palette
,	TokenNameCOMMA	
alphaPalette	TokenNameIdentifier	 alpha Palette
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If param is still null, it can't be expressed as gray 	TokenNameCOMMENT_LINE	If param is still null, it can't be expressed as gray 
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If palette not set in param, create one from the ColorModel. 	TokenNameCOMMENT_LINE	If palette not set in param, create one from the ColorModel. 
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
parami	TokenNameIdentifier	 parami
=	TokenNameEQUAL	
(	TokenNameLPAREN	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Palette	TokenNameIdentifier	 Palette
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parami	TokenNameIdentifier	 parami
.	TokenNameDOT	
isPaletteSet	TokenNameIdentifier	 is Palette Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
palette	TokenNameIdentifier	 palette
=	TokenNameEQUAL	
parami	TokenNameIdentifier	 parami
.	TokenNameDOT	
getPalette	TokenNameIdentifier	 get Palette
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
palette	TokenNameIdentifier	 palette
.	TokenNameDOT	
length	TokenNameIdentifier	 length
/	TokenNameDIVIDE	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
redPalette	TokenNameIdentifier	 red Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
palette	TokenNameIdentifier	 palette
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
greenPalette	TokenNameIdentifier	 green Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
palette	TokenNameIdentifier	 palette
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bluePalette	TokenNameIdentifier	 blue Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
palette	TokenNameIdentifier	 palette
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
alphaPalette	TokenNameIdentifier	 alpha Palette
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
255	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_PALETTE	TokenNameIdentifier	 PNG  COLOR  PALETTE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
instanceof	TokenNameinstanceof	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
)	TokenNameRPAREN	
{	TokenNameLBRACE	
redPalette	TokenNameIdentifier	 red Palette
=	TokenNameEQUAL	
greenPalette	TokenNameIdentifier	 green Palette
=	TokenNameEQUAL	
bluePalette	TokenNameIdentifier	 blue Palette
=	TokenNameEQUAL	
alphaPalette	TokenNameIdentifier	 alpha Palette
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_GRAY	TokenNameIdentifier	 PNG  COLOR  GRAY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_GRAY	TokenNameIdentifier	 PNG  COLOR  GRAY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
Gray	TokenNameIdentifier	 Gray
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isTransparencySet	TokenNameIdentifier	 is Transparency Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipAlpha	TokenNameIdentifier	 skip Alpha
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compressGray	TokenNameIdentifier	 compress Gray
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bpp	TokenNameIdentifier	 bpp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_GRAY	TokenNameIdentifier	 PNG  COLOR  GRAY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
<	TokenNameLESS	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
bitDepth	TokenNameIdentifier	 bit Depth
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_GRAY_ALPHA	TokenNameIdentifier	 PNG  COLOR  GRAY  ALPHA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
RGB	TokenNameIdentifier	 RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_RGB	TokenNameIdentifier	 PNG  COLOR  RGB
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
PNGEncodeParam	TokenNameIdentifier	 PNG Encode Param
.	TokenNameDOT	
RGB	TokenNameIdentifier	 RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
isTransparencySet	TokenNameIdentifier	 is Transparency Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipAlpha	TokenNameIdentifier	 skip Alpha
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bpp	TokenNameIdentifier	 bpp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bitDepth	TokenNameIdentifier	 bit Depth
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_RGB	TokenNameIdentifier	 PNG  COLOR  RGB
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
colorType	TokenNameIdentifier	 color Type
=	TokenNameEQUAL	
PNG_COLOR_RGB_ALPHA	TokenNameIdentifier	 PNG  COLOR  RGB  ALPHA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
interlace	TokenNameIdentifier	 interlace
=	TokenNameEQUAL	
param	TokenNameIdentifier	 param
.	TokenNameDOT	
getInterlacing	TokenNameIdentifier	 get Interlacing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeMagic	TokenNameIdentifier	 write Magic
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeIHDR	TokenNameIdentifier	 write IHDR
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeCHRM	TokenNameIdentifier	 write CHRM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeGAMA	TokenNameIdentifier	 write GAMA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeICCP	TokenNameIdentifier	 write ICCP
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeSBIT	TokenNameIdentifier	 write SBIT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeSRGB	TokenNameIdentifier	 write SRGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writePLTE	TokenNameIdentifier	 write PLTE
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeHIST	TokenNameIdentifier	 write HIST
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeTRNS	TokenNameIdentifier	 write TRNS
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeBKGD	TokenNameIdentifier	 write BKGD
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writePHYS	TokenNameIdentifier	 write PHYS
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeSPLT	TokenNameIdentifier	 write SPLT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeTIME	TokenNameIdentifier	 write TIME
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeTEXT	TokenNameIdentifier	 write TEXT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeZTXT	TokenNameIdentifier	 write ZTXT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writePrivateChunks	TokenNameIdentifier	 write Private Chunks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeIDAT	TokenNameIdentifier	 write IDAT
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeIEND	TokenNameIdentifier	 write IEND
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dataOutput	TokenNameIdentifier	 data Output
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
