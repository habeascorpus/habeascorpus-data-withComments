/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: SimpleResultTreeImpl.java 468651 2006-10-28 07:04:25Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: SimpleResultTreeImpl.java 468651 2006-10-28 07:04:25Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
xsltc	TokenNameIdentifier	 xsltc
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
xsltc	TokenNameIdentifier	 xsltc
.	TokenNameDOT	
DOM	TokenNameIdentifier	 DOM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
xsltc	TokenNameIdentifier	 xsltc
.	TokenNameDOT	
TransletException	TokenNameIdentifier	 Translet Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
xsltc	TokenNameIdentifier	 xsltc
.	TokenNameDOT	
StripFilter	TokenNameIdentifier	 Strip Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
xsltc	TokenNameIdentifier	 xsltc
.	TokenNameDOT	
runtime	TokenNameIdentifier	 runtime
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTM	TokenNameIdentifier	 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
Axis	TokenNameIdentifier	 Axis
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMAxisTraverser	TokenNameIdentifier	 DTM Axis Traverser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTMManager	TokenNameIdentifier	 DTM Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMAxisIteratorBase	TokenNameIdentifier	 DTM Axis Iterator Base
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
EmptySerializer	TokenNameIdentifier	 Empty Serializer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
XMLStringDefault	TokenNameIdentifier	 XML String Default
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
NodeList	TokenNameIdentifier	 Node List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
SourceLocator	TokenNameIdentifier	 Source Locator
;	TokenNameSEMICOLON	
/** * This class represents a light-weight DOM model for simple result tree fragment(RTF). * A simple RTF is an RTF that has only one Text node. The Text node can be produced by a * combination of Text, xsl:value-of and xsl:number instructions. It can also be produced * by a control structure (xsl:if or xsl:choose) whose body is pure Text. * <p> * A SimpleResultTreeImpl has only two nodes, i.e. the ROOT node and its Text child. All DOM * interfaces are overridden with this in mind. For example, the getStringValue() interface * returns the value of the Text node. This class receives the character data from the * characters() interface. * <p> * This class implements DOM and SerializationHandler. It also implements the DTM interface * for support in MultiDOM. The nested iterators (SimpleIterator and SingletonIterator) are * used to support the nodeset() extension function. */	TokenNameCOMMENT_JAVADOC	 This class represents a light-weight DOM model for simple result tree fragment(RTF). A simple RTF is an RTF that has only one Text node. The Text node can be produced by a combination of Text, xsl:value-of and xsl:number instructions. It can also be produced by a control structure (xsl:if or xsl:choose) whose body is pure Text. <p> A SimpleResultTreeImpl has only two nodes, i.e. the ROOT node and its Text child. All DOM interfaces are overridden with this in mind. For example, the getStringValue() interface returns the value of the Text node. This class receives the character data from the characters() interface. <p> This class implements DOM and SerializationHandler. It also implements the DTM interface for support in MultiDOM. The nested iterators (SimpleIterator and SingletonIterator) are used to support the nodeset() extension function. 
public	TokenNamepublic	
class	TokenNameclass	
SimpleResultTreeImpl	TokenNameIdentifier	 Simple Result Tree Impl
extends	TokenNameextends	
EmptySerializer	TokenNameIdentifier	 Empty Serializer
implements	TokenNameimplements	
DOM	TokenNameIdentifier	 DOM
,	TokenNameCOMMA	
DTM	TokenNameIdentifier	 DTM
{	TokenNameLBRACE	
/** * The SimpleIterator is designed to support the nodeset() extension function. It has * a traversal direction parameter. The DOWN direction is used for child and descendant * axes, while the UP direction is used for parent and ancestor axes. * * This iterator only handles two nodes (RTF_ROOT and RTF_TEXT). If the type is set, * it will also match the node type with the given type. */	TokenNameCOMMENT_JAVADOC	 The SimpleIterator is designed to support the nodeset() extension function. It has a traversal direction parameter. The DOWN direction is used for child and descendant axes, while the UP direction is used for parent and ancestor axes. * This iterator only handles two nodes (RTF_ROOT and RTF_TEXT). If the type is set, it will also match the node type with the given type. 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
extends	TokenNameextends	
DTMAxisIteratorBase	TokenNameIdentifier	 DTM Axis Iterator Base
{	TokenNameLBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// The direction of traversal (default to DOWN). 	TokenNameCOMMENT_LINE	The direction of traversal (default to DOWN). 
// DOWN is for child and descendant. UP is for parent and ancestor. 	TokenNameCOMMENT_LINE	DOWN is for child and descendant. UP is for parent and ancestor. 
int	TokenNameint	
_direction	TokenNameIdentifier	 direction
=	TokenNameEQUAL	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
;	TokenNameSEMICOLON	
int	TokenNameint	
_type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
;	TokenNameSEMICOLON	
int	TokenNameint	
_currentNode	TokenNameIdentifier	 current Node
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
int	TokenNameint	
direction	TokenNameIdentifier	 direction
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_direction	TokenNameIdentifier	 direction
=	TokenNameEQUAL	
direction	TokenNameIdentifier	 direction
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
int	TokenNameint	
direction	TokenNameIdentifier	 direction
,	TokenNameCOMMA	
int	TokenNameint	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_direction	TokenNameIdentifier	 direction
=	TokenNameEQUAL	
direction	TokenNameIdentifier	 direction
;	TokenNameSEMICOLON	
_type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Increase the node ID for down traversal. Also match the node type 	TokenNameCOMMENT_LINE	Increase the node ID for down traversal. Also match the node type 
// if the type is given. 	TokenNameCOMMENT_LINE	if the type is given. 
if	TokenNameif	
(	TokenNameLPAREN	
_direction	TokenNameIdentifier	 direction
==	TokenNameEQUAL_EQUAL	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
<	TokenNameLESS	
NUMBER_OF_NODES	TokenNameIdentifier	 NUMBER  OF  NODES
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ROOT_NODE	TokenNameIdentifier	 ROOT  NODE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
returnNode	TokenNameIdentifier	 return Node
(	TokenNameLPAREN	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
_currentNode	TokenNameIdentifier	 current Node
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
returnNode	TokenNameIdentifier	 return Node
(	TokenNameLPAREN	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Decrease the node ID for up traversal. 	TokenNameCOMMENT_LINE	Decrease the node ID for up traversal. 
else	TokenNameelse	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ROOT_NODE	TokenNameIdentifier	 ROOT  NODE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
returnNode	TokenNameIdentifier	 return Node
(	TokenNameLPAREN	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
_currentNode	TokenNameIdentifier	 current Node
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
returnNode	TokenNameIdentifier	 return Node
(	TokenNameLPAREN	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
setStartNode	TokenNameIdentifier	 set Start Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
nodeID	TokenNameIdentifier	 node ID
;	TokenNameSEMICOLON	
// Increase the node ID by 1 if self is not included. 	TokenNameCOMMENT_LINE	Increase the node ID by 1 if self is not included. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
_includeSelf	TokenNameIdentifier	 include Self
&&	TokenNameAND_AND	
nodeID	TokenNameIdentifier	 node ID
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_direction	TokenNameIdentifier	 direction
==	TokenNameEQUAL_EQUAL	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
)	TokenNameRPAREN	
nodeID	TokenNameIdentifier	 node ID
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
_direction	TokenNameIdentifier	 direction
==	TokenNameEQUAL_EQUAL	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
)	TokenNameRPAREN	
nodeID	TokenNameIdentifier	 node ID
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
_currentNode	TokenNameIdentifier	 current Node
=	TokenNameEQUAL	
nodeID	TokenNameIdentifier	 node ID
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMark	TokenNameIdentifier	 set Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_markedNode	TokenNameIdentifier	 marked Node
=	TokenNameEQUAL	
_currentNode	TokenNameIdentifier	 current Node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
gotoMark	TokenNameIdentifier	 goto Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_currentNode	TokenNameIdentifier	 current Node
=	TokenNameEQUAL	
_markedNode	TokenNameIdentifier	 marked Node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// END of SimpleIterator 	TokenNameCOMMENT_LINE	END of SimpleIterator 
/** * The SingletonIterator is used for the self axis. */	TokenNameCOMMENT_JAVADOC	 The SingletonIterator is used for the self axis. 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
extends	TokenNameextends	
DTMAxisIteratorBase	TokenNameIdentifier	 DTM Axis Iterator Base
{	TokenNameLBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
_type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
;	TokenNameSEMICOLON	
int	TokenNameint	
_currentNode	TokenNameIdentifier	 current Node
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
(	TokenNameLPAREN	
int	TokenNameint	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMark	TokenNameIdentifier	 set Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_markedNode	TokenNameIdentifier	 marked Node
=	TokenNameEQUAL	
_currentNode	TokenNameIdentifier	 current Node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
gotoMark	TokenNameIdentifier	 goto Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_currentNode	TokenNameIdentifier	 current Node
=	TokenNameEQUAL	
_markedNode	TokenNameIdentifier	 marked Node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
setStartNode	TokenNameIdentifier	 set Start Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_currentNode	TokenNameIdentifier	 current Node
=	TokenNameEQUAL	
_startNode	TokenNameIdentifier	 start Node
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
return	TokenNamereturn	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
_currentNode	TokenNameIdentifier	 current Node
=	TokenNameEQUAL	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
_type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
NO_TYPE	TokenNameIdentifier	 NO  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ROOT_NODE	TokenNameIdentifier	 ROOT  NODE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
&&	TokenNameAND_AND	
_type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
_currentNode	TokenNameIdentifier	 current Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// END of SingletonIterator 	TokenNameCOMMENT_LINE	END of SingletonIterator 
// empty iterator to be returned when there are no children 	TokenNameCOMMENT_LINE	empty iterator to be returned when there are no children 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
EMPTY_ITERATOR	TokenNameIdentifier	 EMPTY  ITERATOR
=	TokenNameEQUAL	
new	TokenNamenew	
DTMAxisIteratorBase	TokenNameIdentifier	 DTM Axis Iterator Base
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
setStartNode	TokenNameIdentifier	 set Start Node
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setMark	TokenNameIdentifier	 set Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
gotoMark	TokenNameIdentifier	 goto Mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLast	TokenNameIdentifier	 get Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
cloneIterator	TokenNameIdentifier	 clone Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setRestartable	TokenNameIdentifier	 set Restartable
(	TokenNameLPAREN	
boolean	TokenNameboolean	
isRestartable	TokenNameIdentifier	 is Restartable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// The root node id of the simple RTF 	TokenNameCOMMENT_LINE	The root node id of the simple RTF 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// The Text node id of the simple RTF (simple RTF has only one Text node). 	TokenNameCOMMENT_LINE	The Text node id of the simple RTF (simple RTF has only one Text node). 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// The number of nodes. 	TokenNameCOMMENT_LINE	The number of nodes. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
NUMBER_OF_NODES	TokenNameIdentifier	 NUMBER  OF  NODES
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Document URI index, which increases by 1 at each getDocumentURI() call. 	TokenNameCOMMENT_LINE	Document URI index, which increases by 1 at each getDocumentURI() call. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
_documentURIIndex	TokenNameIdentifier	 document URI Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Constant for empty String 	TokenNameCOMMENT_LINE	Constant for empty String 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
// The String value of the Text node. 	TokenNameCOMMENT_LINE	The String value of the Text node. 
// This is set at the endDocument() call. 	TokenNameCOMMENT_LINE	This is set at the endDocument() call. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
_text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
// The array of Text items, which is built by the characters() call. 	TokenNameCOMMENT_LINE	The array of Text items, which is built by the characters() call. 
// The characters() interface can be called multiple times. Each character item 	TokenNameCOMMENT_LINE	The characters() interface can be called multiple times. Each character item 
// can have different escape settings. 	TokenNameCOMMENT_LINE	can have different escape settings. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
_textArray	TokenNameIdentifier	 text Array
;	TokenNameSEMICOLON	
// The DTMManager 	TokenNameCOMMENT_LINE	The DTMManager 
protected	TokenNameprotected	
XSLTCDTMManager	TokenNameIdentifier	 XSLTCDTM Manager
_dtmManager	TokenNameIdentifier	 dtm Manager
;	TokenNameSEMICOLON	
// Number of character items 	TokenNameCOMMENT_LINE	Number of character items 
protected	TokenNameprotected	
int	TokenNameint	
_size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// The document ID 	TokenNameCOMMENT_LINE	The document ID 
private	TokenNameprivate	
int	TokenNameint	
_documentID	TokenNameIdentifier	 document ID
;	TokenNameSEMICOLON	
// A BitArray, each bit holding the escape setting for a character item. 	TokenNameCOMMENT_LINE	A BitArray, each bit holding the escape setting for a character item. 
private	TokenNameprivate	
BitArray	TokenNameIdentifier	 Bit Array
_dontEscape	TokenNameIdentifier	 dont Escape
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// The current escape setting 	TokenNameCOMMENT_LINE	The current escape setting 
private	TokenNameprivate	
boolean	TokenNameboolean	
_escaping	TokenNameIdentifier	 escaping
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Create a SimpleResultTreeImpl from a DTMManager and a document ID. 	TokenNameCOMMENT_LINE	Create a SimpleResultTreeImpl from a DTMManager and a document ID. 
public	TokenNamepublic	
SimpleResultTreeImpl	TokenNameIdentifier	 Simple Result Tree Impl
(	TokenNameLPAREN	
XSLTCDTMManager	TokenNameIdentifier	 XSLTCDTM Manager
dtmManager	TokenNameIdentifier	 dtm Manager
,	TokenNameCOMMA	
int	TokenNameint	
documentID	TokenNameIdentifier	 document ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_dtmManager	TokenNameIdentifier	 dtm Manager
=	TokenNameEQUAL	
dtmManager	TokenNameIdentifier	 dtm Manager
;	TokenNameSEMICOLON	
_documentID	TokenNameIdentifier	 document ID
=	TokenNameEQUAL	
documentID	TokenNameIdentifier	 document ID
;	TokenNameSEMICOLON	
_textArray	TokenNameIdentifier	 text Array
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMManagerDefault	TokenNameIdentifier	 DTM Manager Default
getDTMManager	TokenNameIdentifier	 get DTM Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_dtmManager	TokenNameIdentifier	 dtm Manager
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Return the document ID 	TokenNameCOMMENT_LINE	Return the document ID 
public	TokenNamepublic	
int	TokenNameint	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_documentID	TokenNameIdentifier	 document ID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Return the String value of the RTF 	TokenNameCOMMENT_LINE	Return the String value of the RTF 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getStringValue	TokenNameIdentifier	 get String Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getIterator	TokenNameIdentifier	 get Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
(	TokenNameLPAREN	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getChildren	TokenNameIdentifier	 get Children
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setStartNode	TokenNameIdentifier	 set Start Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getTypedChildren	TokenNameIdentifier	 get Typed Children
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Return the axis iterator for a given axis. 	TokenNameCOMMENT_LINE	Return the axis iterator for a given axis. 
// The SimpleIterator is used for the child, descendant, parent and ancestor axes. 	TokenNameCOMMENT_LINE	The SimpleIterator is used for the child, descendant, parent and ancestor axes. 
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getAxisIterator	TokenNameIdentifier	 get Axis Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
includeSelf	TokenNameIdentifier	 include Self
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
includeSelf	TokenNameIdentifier	 include Self
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
EMPTY_ITERATOR	TokenNameIdentifier	 EMPTY  ITERATOR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getTypedAxisIterator	TokenNameIdentifier	 get Typed Axis Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
CHILD	TokenNameIdentifier	 CHILD
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANT	TokenNameIdentifier	 DESCENDANT
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
PARENT	TokenNameIdentifier	 PARENT
:	TokenNameCOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTOR	TokenNameIdentifier	 ANCESTOR
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
ANCESTORORSELF	TokenNameIdentifier	 ANCESTORORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_UP	TokenNameIdentifier	 DIRECTION  UP
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
includeSelf	TokenNameIdentifier	 include Self
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
DESCENDANTORSELF	TokenNameIdentifier	 DESCENDANTORSELF
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
(	TokenNameLPAREN	
SimpleIterator	TokenNameIdentifier	 Simple Iterator
.	TokenNameDOT	
DIRECTION_DOWN	TokenNameIdentifier	 DIRECTION  DOWN
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
includeSelf	TokenNameIdentifier	 include Self
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Axis	TokenNameIdentifier	 Axis
.	TokenNameDOT	
SELF	TokenNameIdentifier	 SELF
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
SingletonIterator	TokenNameIdentifier	 Singleton Iterator
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
EMPTY_ITERATOR	TokenNameIdentifier	 EMPTY  ITERATOR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// %REVISIT% Can this one ever get used? 	TokenNameCOMMENT_LINE	%REVISIT% Can this one ever get used? 
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getNthDescendant	TokenNameIdentifier	 get Nth Descendant
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
boolean	TokenNameboolean	
includeself	TokenNameIdentifier	 includeself
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getNamespaceAxisIterator	TokenNameIdentifier	 get Namespace Axis Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
ns	TokenNameIdentifier	 ns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// %REVISIT% Can this one ever get used? 	TokenNameCOMMENT_LINE	%REVISIT% Can this one ever get used? 
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
getNodeValueIterator	TokenNameIdentifier	 get Node Value Iterator
(	TokenNameLPAREN	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
iter	TokenNameIdentifier	 iter
,	TokenNameCOMMA	
int	TokenNameint	
returnType	TokenNameIdentifier	 return Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
op	TokenNameIdentifier	 op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
orderNodes	TokenNameIdentifier	 order Nodes
(	TokenNameLPAREN	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
source	TokenNameIdentifier	 source
,	TokenNameCOMMA	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
return	TokenNamereturn	
"#text"	TokenNameStringLiteral	#text
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeNameX	TokenNameIdentifier	 get Node Name X
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceName	TokenNameIdentifier	 get Namespace Name
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Return the expanded type id of a given node 	TokenNameCOMMENT_LINE	Return the expanded type id of a given node 
public	TokenNamepublic	
int	TokenNameint	
getExpandedTypeID	TokenNameIdentifier	 get Expanded Type ID
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ROOT_NODE	TokenNameIdentifier	 ROOT  NODE
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNamespaceType	TokenNameIdentifier	 get Namespace Type
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
?	TokenNameQUESTION	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
:	TokenNameCOLON	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
gType	TokenNameIdentifier	 g Type
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getStringValueX	TokenNameIdentifier	 get String Value X
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
||	TokenNameOR_OR	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
return	TokenNamereturn	
_text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransletException	TokenNameIdentifier	 Translet Exception
{	TokenNameLBRACE	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
nodes	TokenNameIdentifier	 nodes
,	TokenNameCOMMA	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransletException	TokenNameIdentifier	 Translet Exception
{	TokenNameLBRACE	
int	TokenNameint	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
shallowCopy	TokenNameIdentifier	 shallow Copy
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransletException	TokenNameIdentifier	 Translet Exception
{	TokenNameLBRACE	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
node2	TokenNameIdentifier	 node2
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
<	TokenNameLESS	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Dispatch the character content of a node to an output handler. * * The escape setting should be taken care of when outputting to * a handler. */	TokenNameCOMMENT_JAVADOC	 Dispatch the character content of a node to an output handler. * The escape setting should be taken care of when outputting to a handler. 
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransletException	TokenNameIdentifier	 Translet Exception
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
||	TokenNameOR_OR	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
escapeBit	TokenNameIdentifier	 escape Bit
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
oldEscapeSetting	TokenNameIdentifier	 old Escape Setting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
_size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
escapeBit	TokenNameIdentifier	 escape Bit
=	TokenNameEQUAL	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
getBit	TokenNameIdentifier	 get Bit
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
escapeBit	TokenNameIdentifier	 escape Bit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oldEscapeSetting	TokenNameIdentifier	 old Escape Setting
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
setEscaping	TokenNameIdentifier	 set Escaping
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
_textArray	TokenNameIdentifier	 text Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
escapeBit	TokenNameIdentifier	 escape Bit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
handler	TokenNameIdentifier	 handler
.	TokenNameDOT	
setEscaping	TokenNameIdentifier	 set Escaping
(	TokenNameLPAREN	
oldEscapeSetting	TokenNameIdentifier	 old Escape Setting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TransletException	TokenNameIdentifier	 Translet Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// %REVISIT% Can the makeNode() and makeNodeList() interfaces ever get used? 	TokenNameCOMMENT_LINE	%REVISIT% Can the makeNode() and makeNodeList() interfaces ever get used? 
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
makeNode	TokenNameIdentifier	 make Node
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
makeNode	TokenNameIdentifier	 make Node
(	TokenNameLPAREN	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
NodeList	TokenNameIdentifier	 Node List
makeNodeList	TokenNameIdentifier	 make Node List
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
NodeList	TokenNameIdentifier	 Node List
makeNodeList	TokenNameIdentifier	 make Node List
(	TokenNameLPAREN	
DTMAxisIterator	TokenNameIdentifier	 DTM Axis Iterator
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLanguage	TokenNameIdentifier	 get Language
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentURI	TokenNameIdentifier	 get Document URI
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"simple_rtf"	TokenNameStringLiteral	simple_rtf
+	TokenNamePLUS	
_documentURIIndex	TokenNameIdentifier	 document URI Index
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setFilter	TokenNameIdentifier	 set Filter
(	TokenNameLPAREN	
StripFilter	TokenNameIdentifier	 Strip Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setupMapping	TokenNameIdentifier	 setup Mapping
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
names	TokenNameIdentifier	 names
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
uris	TokenNameIdentifier	 uris
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
types	TokenNameIdentifier	 types
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
namespaces	TokenNameIdentifier	 namespaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isElement	TokenNameIdentifier	 is Element
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isAttribute	TokenNameIdentifier	 is Attribute
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
lookupNamespace	TokenNameIdentifier	 lookup Namespace
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransletException	TokenNameIdentifier	 Translet Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the node identity from a node handle. */	TokenNameCOMMENT_JAVADOC	 Return the node identity from a node handle. 
public	TokenNamepublic	
int	TokenNameint	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
nodehandle	TokenNameIdentifier	 nodehandle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
nodehandle	TokenNameIdentifier	 nodehandle
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
nodehandle	TokenNameIdentifier	 nodehandle
-	TokenNameMINUS	
_documentID	TokenNameIdentifier	 document ID
)	TokenNameRPAREN	
:	TokenNameCOLON	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the node handle from a node identity. */	TokenNameCOMMENT_JAVADOC	 Return the node handle from a node identity. 
public	TokenNamepublic	
int	TokenNameint	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
nodeId	TokenNameIdentifier	 node Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
nodeId	TokenNameIdentifier	 node Id
!=	TokenNameNOT_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
nodeId	TokenNameIdentifier	 node Id
+	TokenNamePLUS	
_documentID	TokenNameIdentifier	 document ID
)	TokenNameRPAREN	
:	TokenNameCOLON	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DOM	TokenNameIdentifier	 DOM
getResultTreeFrag	TokenNameIdentifier	 get Result Tree Frag
(	TokenNameLPAREN	
int	TokenNameint	
initialSize	TokenNameIdentifier	 initial Size
,	TokenNameCOMMA	
int	TokenNameint	
rtfType	TokenNameIdentifier	 rtf Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DOM	TokenNameIdentifier	 DOM
getResultTreeFrag	TokenNameIdentifier	 get Result Tree Frag
(	TokenNameLPAREN	
int	TokenNameint	
initialSize	TokenNameIdentifier	 initial Size
,	TokenNameCOMMA	
int	TokenNameint	
rtfType	TokenNameIdentifier	 rtf Type
,	TokenNameCOMMA	
boolean	TokenNameboolean	
addToManager	TokenNameIdentifier	 add To Manager
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SerializationHandler	TokenNameIdentifier	 Serialization Handler
getOutputDomBuilder	TokenNameIdentifier	 get Output Dom Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNSType	TokenNameIdentifier	 get NS Type
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getUnparsedEntityURI	TokenNameIdentifier	 get Unparsed Entity URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Hashtable	TokenNameIdentifier	 Hashtable
getElementsWithIDs	TokenNameIdentifier	 get Elements With I Ds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Implementation of the SerializationHandler interfaces **/	TokenNameCOMMENT_JAVADOC	 Implementation of the SerializationHandler interfaces *
/** * We only need to override the endDocument, characters, and * setEscaping interfaces. A simple RTF does not have element * nodes. We do not need to touch startElement and endElement. */	TokenNameCOMMENT_JAVADOC	 We only need to override the endDocument, characters, and setEscaping interfaces. A simple RTF does not have element nodes. We do not need to touch startElement and endElement. 
public	TokenNamepublic	
void	TokenNamevoid	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
// Set the String value when the document is built. 	TokenNameCOMMENT_LINE	Set the String value when the document is built. 
if	TokenNameif	
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
_text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
_textArray	TokenNameIdentifier	 text Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
_size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
_textArray	TokenNameIdentifier	 text Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
_text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
// Resize the text array if necessary 	TokenNameCOMMENT_LINE	Resize the text array if necessary 
if	TokenNameif	
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
>=	TokenNameGREATER_EQUAL	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newTextArray	TokenNameIdentifier	 new Text Array
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
_textArray	TokenNameIdentifier	 text Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newTextArray	TokenNameIdentifier	 new Text Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_textArray	TokenNameIdentifier	 text Array
=	TokenNameEQUAL	
newTextArray	TokenNameIdentifier	 new Text Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the escape setting is false, set the corresponding bit in 	TokenNameCOMMENT_LINE	If the escape setting is false, set the corresponding bit in 
// the _dontEscape BitArray. 	TokenNameCOMMENT_LINE	the _dontEscape BitArray. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
_escaping	TokenNameIdentifier	 escaping
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The _dontEscape array is only created when needed. 	TokenNameCOMMENT_LINE	The _dontEscape array is only created when needed. 
if	TokenNameif	
(	TokenNameLPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_dontEscape	TokenNameIdentifier	 dont Escape
=	TokenNameEQUAL	
new	TokenNamenew	
BitArray	TokenNameIdentifier	 Bit Array
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Resize the _dontEscape array if necessary 	TokenNameCOMMENT_LINE	Resize the _dontEscape array if necessary 
if	TokenNameif	
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
>=	TokenNameGREATER_EQUAL	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
setBit	TokenNameIdentifier	 set Bit
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
_textArray	TokenNameIdentifier	 text Array
[	TokenNameLBRACKET	
_size	TokenNameIdentifier	 size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
str	TokenNameIdentifier	 str
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
>=	TokenNameGREATER_EQUAL	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newTextArray	TokenNameIdentifier	 new Text Array
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
_textArray	TokenNameIdentifier	 text Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newTextArray	TokenNameIdentifier	 new Text Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
_textArray	TokenNameIdentifier	 text Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_textArray	TokenNameIdentifier	 text Array
=	TokenNameEQUAL	
newTextArray	TokenNameIdentifier	 new Text Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
_escaping	TokenNameIdentifier	 escaping
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_dontEscape	TokenNameIdentifier	 dont Escape
=	TokenNameEQUAL	
new	TokenNamenew	
BitArray	TokenNameIdentifier	 Bit Array
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
>=	TokenNameGREATER_EQUAL	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
resize	TokenNameIdentifier	 resize
(	TokenNameLPAREN	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_dontEscape	TokenNameIdentifier	 dont Escape
.	TokenNameDOT	
setBit	TokenNameIdentifier	 set Bit
(	TokenNameLPAREN	
_size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
_textArray	TokenNameIdentifier	 text Array
[	TokenNameLBRACKET	
_size	TokenNameIdentifier	 size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
setEscaping	TokenNameIdentifier	 set Escaping
(	TokenNameLPAREN	
boolean	TokenNameboolean	
escape	TokenNameIdentifier	 escape
)	TokenNameRPAREN	
throws	TokenNamethrows	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
_escaping	TokenNameIdentifier	 escaping
;	TokenNameSEMICOLON	
_escaping	TokenNameIdentifier	 escaping
=	TokenNameEQUAL	
escape	TokenNameIdentifier	 escape
;	TokenNameSEMICOLON	
return	TokenNamereturn	
temp	TokenNameIdentifier	 temp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Implementation of the DTM interfaces **/	TokenNameCOMMENT_JAVADOC	 Implementation of the DTM interfaces *
/** * The DTM interfaces are not used in this class. Implementing the DTM * interface is a requirement from MultiDOM. If we have a better way * of handling multiple documents, we can get rid of the DTM dependency. * * The following interfaces are just placeholders. The implementation * does not have an impact because they will not be used. */	TokenNameCOMMENT_JAVADOC	 The DTM interfaces are not used in this class. Implementing the DTM interface is a requirement from MultiDOM. If we have a better way of handling multiple documents, we can get rid of the DTM dependency. * The following interfaces are just placeholders. The implementation does not have an impact because they will not be used. 
public	TokenNamepublic	
void	TokenNamevoid	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
property	TokenNameIdentifier	 property
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
DTMAxisTraverser	TokenNameIdentifier	 DTM Axis Traverser
getAxisTraverser	TokenNameIdentifier	 get Axis Traverser
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
axis	TokenNameIdentifier	 axis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasChildNodes	TokenNameIdentifier	 has Child Nodes
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
return	TokenNamereturn	
getNodeHandle	TokenNameIdentifier	 get Node Handle
(	TokenNameLPAREN	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLastChild	TokenNameIdentifier	 get Last Child
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
int	TokenNameint	
elementHandle	TokenNameIdentifier	 element Handle
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespaceURI	TokenNameIdentifier	 namespace URI
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getFirstAttribute	TokenNameIdentifier	 get First Attribute
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getFirstNamespaceNode	TokenNameIdentifier	 get First Namespace Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inScope	TokenNameIdentifier	 in Scope
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getPreviousSibling	TokenNameIdentifier	 get Previous Sibling
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNextAttribute	TokenNameIdentifier	 get Next Attribute
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNextNamespaceNode	TokenNameIdentifier	 get Next Namespace Node
(	TokenNameLPAREN	
int	TokenNameint	
baseHandle	TokenNameIdentifier	 base Handle
,	TokenNameCOMMA	
int	TokenNameint	
namespaceHandle	TokenNameIdentifier	 namespace Handle
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inScope	TokenNameIdentifier	 in Scope
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getDocumentRoot	TokenNameIdentifier	 get Document Root
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XMLString	TokenNameIdentifier	 XML String
getStringValue	TokenNameIdentifier	 get String Value
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
XMLStringDefault	TokenNameIdentifier	 XML String Default
(	TokenNameLPAREN	
getStringValueX	TokenNameIdentifier	 get String Value X
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getStringValueChunkCount	TokenNameIdentifier	 get String Value Chunk Count
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getStringValueChunk	TokenNameIdentifier	 get String Value Chunk
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
int	TokenNameint	
chunkIndex	TokenNameIdentifier	 chunk Index
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
startAndLen	TokenNameIdentifier	 start And Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getExpandedTypeID	TokenNameIdentifier	 get Expanded Type ID
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
,	TokenNameCOMMA	
int	TokenNameint	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLocalNameFromExpandedNameID	TokenNameIdentifier	 get Local Name From Expanded Name ID
(	TokenNameLPAREN	
int	TokenNameint	
ExpandedNameID	TokenNameIdentifier	 Expanded Name ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceFromExpandedNameID	TokenNameIdentifier	 get Namespace From Expanded Name ID
(	TokenNameLPAREN	
int	TokenNameint	
ExpandedNameID	TokenNameIdentifier	 Expanded Name ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
?	TokenNameQUESTION	
_text	TokenNameIdentifier	 text
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ROOT_NODE	TokenNameIdentifier	 ROOT  NODE
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getLevel	TokenNameIdentifier	 get Level
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nodeID	TokenNameIdentifier	 node ID
=	TokenNameEQUAL	
getNodeIdent	TokenNameIdentifier	 get Node Ident
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_TEXT	TokenNameIdentifier	 RTF  TEXT
)	TokenNameRPAREN	
return	TokenNamereturn	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeID	TokenNameIdentifier	 node ID
==	TokenNameEQUAL_EQUAL	
RTF_ROOT	TokenNameIdentifier	 RTF  ROOT
)	TokenNameRPAREN	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isSupported	TokenNameIdentifier	 is Supported
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
feature	TokenNameIdentifier	 feature
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentBaseURI	TokenNameIdentifier	 get Document Base URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
EMPTY_STR	TokenNameIdentifier	 EMPTY  STR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentBaseURI	TokenNameIdentifier	 set Document Base URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
baseURI	TokenNameIdentifier	 base URI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentSystemIdentifier	TokenNameIdentifier	 get Document System Identifier
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentEncoding	TokenNameIdentifier	 get Document Encoding
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentStandalone	TokenNameIdentifier	 get Document Standalone
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentVersion	TokenNameIdentifier	 get Document Version
(	TokenNameLPAREN	
int	TokenNameint	
documentHandle	TokenNameIdentifier	 document Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
getDocumentAllDeclarationsProcessed	TokenNameIdentifier	 get Document All Declarations Processed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentTypeDeclarationSystemIdentifier	TokenNameIdentifier	 get Document Type Declaration System Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getDocumentTypeDeclarationPublicIdentifier	TokenNameIdentifier	 get Document Type Declaration Public Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getElementById	TokenNameIdentifier	 get Element By Id
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
elementId	TokenNameIdentifier	 element Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
supportsPreStripping	TokenNameIdentifier	 supports Pre Stripping
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isNodeAfter	TokenNameIdentifier	 is Node After
(	TokenNameLPAREN	
int	TokenNameint	
firstNodeHandle	TokenNameIdentifier	 first Node Handle
,	TokenNameCOMMA	
int	TokenNameint	
secondNodeHandle	TokenNameIdentifier	 second Node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
firstNodeHandle	TokenNameIdentifier	 first Node Handle
,	TokenNameCOMMA	
secondNodeHandle	TokenNameIdentifier	 second Node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isCharacterElementContentWhitespace	TokenNameIdentifier	 is Character Element Content Whitespace
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isDocumentAllDeclarationsProcessed	TokenNameIdentifier	 is Document All Declarations Processed
(	TokenNameLPAREN	
int	TokenNameint	
documentHandle	TokenNameIdentifier	 document Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isAttributeSpecified	TokenNameIdentifier	 is Attribute Specified
(	TokenNameLPAREN	
int	TokenNameint	
attributeHandle	TokenNameIdentifier	 attribute Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
dispatchCharactersEvents	TokenNameIdentifier	 dispatch Characters Events
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
boolean	TokenNameboolean	
normalize	TokenNameIdentifier	 normalize
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
dispatchToEvents	TokenNameIdentifier	 dispatch To Events
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
,	TokenNameCOMMA	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
throws	TokenNamethrows	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
int	TokenNameint	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
makeNode	TokenNameIdentifier	 make Node
(	TokenNameLPAREN	
nodeHandle	TokenNameIdentifier	 node Handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
needsTwoThreads	TokenNameIdentifier	 needs Two Threads
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ContentHandler	TokenNameIdentifier	 Content Handler
getContentHandler	TokenNameIdentifier	 get Content Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
LexicalHandler	TokenNameIdentifier	 Lexical Handler
getLexicalHandler	TokenNameIdentifier	 get Lexical Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
EntityResolver	TokenNameIdentifier	 Entity Resolver
getEntityResolver	TokenNameIdentifier	 get Entity Resolver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
DTDHandler	TokenNameIdentifier	 DTD Handler
getDTDHandler	TokenNameIdentifier	 get DTD Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ErrorHandler	TokenNameIdentifier	 Error Handler
getErrorHandler	TokenNameIdentifier	 get Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
DeclHandler	TokenNameIdentifier	 Decl Handler
getDeclHandler	TokenNameIdentifier	 get Decl Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
appendChild	TokenNameIdentifier	 append Child
(	TokenNameLPAREN	
int	TokenNameint	
newChild	TokenNameIdentifier	 new Child
,	TokenNameCOMMA	
boolean	TokenNameboolean	
clone	TokenNameIdentifier	 clone
,	TokenNameCOMMA	
boolean	TokenNameboolean	
cloneDepth	TokenNameIdentifier	 clone Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
appendTextChild	TokenNameIdentifier	 append Text Child
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
SourceLocator	TokenNameIdentifier	 Source Locator
getSourceLocatorFor	TokenNameIdentifier	 get Source Locator For
(	TokenNameLPAREN	
int	TokenNameint	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
documentRegistration	TokenNameIdentifier	 document Registration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
documentRelease	TokenNameIdentifier	 document Release
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
migrateTo	TokenNameIdentifier	 migrate To
(	TokenNameLPAREN	
DTMManager	TokenNameIdentifier	 DTM Manager
manager	TokenNameIdentifier	 manager
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
