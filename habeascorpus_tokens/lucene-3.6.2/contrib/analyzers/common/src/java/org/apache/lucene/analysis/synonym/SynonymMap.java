package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
synonym	TokenNameIdentifier	 synonym
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
ByteArrayDataOutput	TokenNameIdentifier	 Byte Array Data Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRef	TokenNameIdentifier	 Bytes Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BytesRefHash	TokenNameIdentifier	 Bytes Ref Hash
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CharsRef	TokenNameIdentifier	 Chars Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntsRef	TokenNameIdentifier	 Ints Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
UnicodeUtil	TokenNameIdentifier	 Unicode Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Util	TokenNameIdentifier	 Util
;	TokenNameSEMICOLON	
/** * A map of synonyms, keys and values are phrases. * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 A map of synonyms, keys and values are phrases. @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
SynonymMap	TokenNameIdentifier	 Synonym Map
{	TokenNameLBRACE	
/** for multiword support, you must separate words with this separator */	TokenNameCOMMENT_JAVADOC	 for multiword support, you must separate words with this separator 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
char	TokenNamechar	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** map<input word, list<ord>> */	TokenNameCOMMENT_JAVADOC	 map<input word, list<ord>> 
public	TokenNamepublic	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
/** map<ord, outputword> */	TokenNameCOMMENT_JAVADOC	 map<ord, outputword> 
public	TokenNamepublic	
final	TokenNamefinal	
BytesRefHash	TokenNameIdentifier	 Bytes Ref Hash
words	TokenNameIdentifier	 words
;	TokenNameSEMICOLON	
/** maxHorizontalContext: maximum context we need on the tokenstream */	TokenNameCOMMENT_JAVADOC	 maxHorizontalContext: maximum context we need on the tokenstream 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SynonymMap	TokenNameIdentifier	 Synonym Map
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
BytesRefHash	TokenNameIdentifier	 Bytes Ref Hash
words	TokenNameIdentifier	 words
,	TokenNameCOMMA	
int	TokenNameint	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
words	TokenNameIdentifier	 words
=	TokenNameEQUAL	
words	TokenNameIdentifier	 words
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
=	TokenNameEQUAL	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds an FSTSynonymMap. * <p> * Call add() until you have added all the mappings, then call build() to get an FSTSynonymMap * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Builds an FSTSynonymMap. <p> Call add() until you have added all the mappings, then call build() to get an FSTSynonymMap @lucene.experimental 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Builder	TokenNameIdentifier	 Builder
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
CharsRef	TokenNameIdentifier	 Chars Ref
,	TokenNameCOMMA	
MapEntry	TokenNameIdentifier	 Map Entry
>	TokenNameGREATER	
workingSet	TokenNameIdentifier	 working Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
CharsRef	TokenNameIdentifier	 Chars Ref
,	TokenNameCOMMA	
MapEntry	TokenNameIdentifier	 Map Entry
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BytesRefHash	TokenNameIdentifier	 Bytes Ref Hash
words	TokenNameIdentifier	 words
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRefHash	TokenNameIdentifier	 Bytes Ref Hash
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BytesRef	TokenNameIdentifier	 Bytes Ref
utf8Scratch	TokenNameIdentifier	 utf8 Scratch
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
dedup	TokenNameIdentifier	 dedup
;	TokenNameSEMICOLON	
/** If dedup is true then identical rules (same input, * same output) will be added only once. */	TokenNameCOMMENT_JAVADOC	 If dedup is true then identical rules (same input, same output) will be added only once. 
public	TokenNamepublic	
Builder	TokenNameIdentifier	 Builder
(	TokenNameLPAREN	
boolean	TokenNameboolean	
dedup	TokenNameIdentifier	 dedup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dedup	TokenNameIdentifier	 dedup
=	TokenNameEQUAL	
dedup	TokenNameIdentifier	 dedup
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
MapEntry	TokenNameIdentifier	 Map Entry
{	TokenNameLBRACE	
boolean	TokenNameboolean	
includeOrig	TokenNameIdentifier	 include Orig
;	TokenNameSEMICOLON	
// we could sort for better sharing ultimately, but it could confuse people 	TokenNameCOMMENT_LINE	we could sort for better sharing ultimately, but it could confuse people 
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
ords	TokenNameIdentifier	 ords
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Sugar: just joins the provided terms with {@link * SynonymMap#WORD_SEPARATOR}. reuse and its chars * must not be null. */	TokenNameCOMMENT_JAVADOC	 Sugar: just joins the provided terms with {@link SynonymMap#WORD_SEPARATOR}. reuse and its chars must not be null. 
public	TokenNamepublic	
static	TokenNamestatic	
CharsRef	TokenNameIdentifier	 Chars Ref
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
words	TokenNameIdentifier	 words
,	TokenNameCOMMA	
CharsRef	TokenNameIdentifier	 Chars Ref
reuse	TokenNameIdentifier	 reuse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
word	TokenNameIdentifier	 word
:	TokenNameCOLON	
words	TokenNameIdentifier	 words
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
>=	TokenNameGREATER_EQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
buffer	TokenNameIdentifier	 buffer
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
wordLen	TokenNameIdentifier	 word Len
=	TokenNameEQUAL	
word	TokenNameIdentifier	 word
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
needed	TokenNameIdentifier	 needed
=	TokenNameEQUAL	
upto	TokenNameIdentifier	 upto
+	TokenNamePLUS	
wordLen	TokenNameIdentifier	 word Len
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
needed	TokenNameIdentifier	 needed
>	TokenNameGREATER	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
needed	TokenNameIdentifier	 needed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
word	TokenNameIdentifier	 word
.	TokenNameDOT	
getChars	TokenNameIdentifier	 get Chars
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
wordLen	TokenNameIdentifier	 word Len
,	TokenNameCOMMA	
buffer	TokenNameIdentifier	 buffer
,	TokenNameCOMMA	
upto	TokenNameIdentifier	 upto
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
upto	TokenNameIdentifier	 upto
+=	TokenNamePLUS_EQUAL	
wordLen	TokenNameIdentifier	 word Len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
reuse	TokenNameIdentifier	 reuse
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Sugar: analyzes the text with the analyzer and * separates by {@link SynonymMap#WORD_SEPARATOR}. * reuse and its chars must not be null. */	TokenNameCOMMENT_JAVADOC	 Sugar: analyzes the text with the analyzer and separates by {@link SynonymMap#WORD_SEPARATOR}. reuse and its chars must not be null. 
public	TokenNamepublic	
static	TokenNamestatic	
CharsRef	TokenNameIdentifier	 Chars Ref
analyze	TokenNameIdentifier	 analyze
(	TokenNameLPAREN	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
CharsRef	TokenNameIdentifier	 Chars Ref
reuse	TokenNameIdentifier	 reuse
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
TokenStream	TokenNameIdentifier	 Token Stream
ts	TokenNameIdentifier	 ts
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
.	TokenNameDOT	
reusableTokenStream	TokenNameIdentifier	 reusable Token Stream
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
posIncAtt	TokenNameIdentifier	 pos Inc Att
=	TokenNameEQUAL	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"term: "	TokenNameStringLiteral	term: 
+	TokenNamePLUS	
text	TokenNameIdentifier	 text
+	TokenNamePLUS	
" analyzed to a zero-length token"	TokenNameStringLiteral	 analyzed to a zero-length token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
posIncAtt	TokenNameIdentifier	 pos Inc Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"term: "	TokenNameStringLiteral	term: 
+	TokenNamePLUS	
text	TokenNameIdentifier	 text
+	TokenNamePLUS	
" analyzed to a token with posinc != 1"	TokenNameStringLiteral	 analyzed to a token with posinc != 1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* current + word + separator */	TokenNameCOMMENT_BLOCK	 current + word + separator 
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
end	TokenNameIdentifier	 end
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
;	TokenNameSEMICOLON	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
buffer	TokenNameIdentifier	 buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+=	TokenNamePLUS_EQUAL	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
end	TokenNameIdentifier	 end
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reuse	TokenNameIdentifier	 reuse
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"term: "	TokenNameStringLiteral	term: 
+	TokenNamePLUS	
text	TokenNameIdentifier	 text
+	TokenNamePLUS	
" was completely eliminated by analyzer"	TokenNameStringLiteral	 was completely eliminated by analyzer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
reuse	TokenNameIdentifier	 reuse
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** only used for asserting! */	TokenNameCOMMENT_JAVADOC	 only used for asserting! 
private	TokenNameprivate	
boolean	TokenNameboolean	
hasHoles	TokenNameIdentifier	 has Holes
(	TokenNameLPAREN	
CharsRef	TokenNameIdentifier	 Chars Ref
chars	TokenNameIdentifier	 chars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
&&	TokenNameAND_AND	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// NOTE: while it's tempting to make this public, since 	TokenNameCOMMENT_LINE	NOTE: while it's tempting to make this public, since 
// caller's parser likely knows the 	TokenNameCOMMENT_LINE	caller's parser likely knows the 
// numInput/numOutputWords, sneaky exceptions, much later 	TokenNameCOMMENT_LINE	numInput/numOutputWords, sneaky exceptions, much later 
// on, will result if these values are wrong; so we always 	TokenNameCOMMENT_LINE	on, will result if these values are wrong; so we always 
// recompute ourselves to be safe: 	TokenNameCOMMENT_LINE	recompute ourselves to be safe: 
private	TokenNameprivate	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
CharsRef	TokenNameIdentifier	 Chars Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
numInputWords	TokenNameIdentifier	 num Input Words
,	TokenNameCOMMA	
CharsRef	TokenNameIdentifier	 Chars Ref
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
int	TokenNameint	
numOutputWords	TokenNameIdentifier	 num Output Words
,	TokenNameCOMMA	
boolean	TokenNameboolean	
includeOrig	TokenNameIdentifier	 include Orig
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first convert to UTF-8 	TokenNameCOMMENT_LINE	first convert to UTF-8 
if	TokenNameif	
(	TokenNameLPAREN	
numInputWords	TokenNameIdentifier	 num Input Words
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"numInputWords must be > 0 (got "	TokenNameStringLiteral	numInputWords must be > 0 (got 
+	TokenNamePLUS	
numInputWords	TokenNameIdentifier	 num Input Words
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"input.length must be > 0 (got "	TokenNameStringLiteral	input.length must be > 0 (got 
+	TokenNamePLUS	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numOutputWords	TokenNameIdentifier	 num Output Words
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"numOutputWords must be > 0 (got "	TokenNameStringLiteral	numOutputWords must be > 0 (got 
+	TokenNamePLUS	
numOutputWords	TokenNameIdentifier	 num Output Words
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"output.length must be > 0 (got "	TokenNameStringLiteral	output.length must be > 0 (got 
+	TokenNamePLUS	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
hasHoles	TokenNameIdentifier	 has Holes
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
:	TokenNameCOLON	
"input has holes: "	TokenNameStringLiteral	input has holes: 
+	TokenNamePLUS	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
assert	TokenNameassert	
!	TokenNameNOT	
hasHoles	TokenNameIdentifier	 has Holes
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
:	TokenNameCOLON	
"output has holes: "	TokenNameStringLiteral	output has holes: 
+	TokenNamePLUS	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
//System.out.println("fmap.add input=" + input + " numInputWords=" + numInputWords + " output=" + output + " numOutputWords=" + numOutputWords); 	TokenNameCOMMENT_LINE	System.out.println("fmap.add input=" + input + " numInputWords=" + numInputWords + " output=" + output + " numOutputWords=" + numOutputWords); 
final	TokenNamefinal	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
=	TokenNameEQUAL	
UnicodeUtil	TokenNameIdentifier	 Unicode Util
.	TokenNameDOT	
UTF16toUTF8WithHash	TokenNameIdentifier	 UT F16to UT F8 With Hash
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
utf8Scratch	TokenNameIdentifier	 utf8 Scratch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// lookup in hash 	TokenNameCOMMENT_LINE	lookup in hash 
int	TokenNameint	
ord	TokenNameIdentifier	 ord
=	TokenNameEQUAL	
words	TokenNameIdentifier	 words
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
utf8Scratch	TokenNameIdentifier	 utf8 Scratch
,	TokenNameCOMMA	
hashCode	TokenNameIdentifier	 hash Code
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// already exists in our hash 	TokenNameCOMMENT_LINE	already exists in our hash 
ord	TokenNameIdentifier	 ord
=	TokenNameEQUAL	
(	TokenNameLPAREN	
-	TokenNameMINUS	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" output=" + output + " old ord=" + ord); 	TokenNameCOMMENT_LINE	System.out.println(" output=" + output + " old ord=" + ord); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//System.out.println(" output=" + output + " new ord=" + ord); 	TokenNameCOMMENT_LINE	System.out.println(" output=" + output + " new ord=" + ord); 
}	TokenNameRBRACE	
MapEntry	TokenNameIdentifier	 Map Entry
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
workingSet	TokenNameIdentifier	 working Set
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
MapEntry	TokenNameIdentifier	 Map Entry
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
workingSet	TokenNameIdentifier	 working Set
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
CharsRef	TokenNameIdentifier	 Chars Ref
.	TokenNameDOT	
deepCopyOf	TokenNameIdentifier	 deep Copy Of
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// make a copy, since we will keep around in our map 	TokenNameCOMMENT_LINE	make a copy, since we will keep around in our map 
}	TokenNameRBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ord	TokenNameIdentifier	 ord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
includeOrig	TokenNameIdentifier	 include Orig
|=	TokenNameOR_EQUAL	
includeOrig	TokenNameIdentifier	 include Orig
;	TokenNameSEMICOLON	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
,	TokenNameCOMMA	
numInputWords	TokenNameIdentifier	 num Input Words
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
,	TokenNameCOMMA	
numOutputWords	TokenNameIdentifier	 num Output Words
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
countWords	TokenNameIdentifier	 count Words
(	TokenNameLPAREN	
CharsRef	TokenNameIdentifier	 Chars Ref
chars	TokenNameIdentifier	 chars
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
wordCount	TokenNameIdentifier	 word Count
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
upto	TokenNameIdentifier	 upto
=	TokenNameEQUAL	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
upto	TokenNameIdentifier	 upto
<	TokenNameLESS	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
.	TokenNameDOT	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
upto	TokenNameIdentifier	 upto
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
SynonymMap	TokenNameIdentifier	 Synonym Map
.	TokenNameDOT	
WORD_SEPARATOR	TokenNameIdentifier	 WORD  SEPARATOR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
wordCount	TokenNameIdentifier	 word Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
wordCount	TokenNameIdentifier	 word Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a phrase->phrase synonym mapping. * Phrases are character sequences where words are * separated with character zero (  	TokenNameCOMMENT_JAVADOC	 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
CharsRef	TokenNameIdentifier	 Chars Ref
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
CharsRef	TokenNameIdentifier	 Chars Ref
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
boolean	TokenNameboolean	
includeOrig	TokenNameIdentifier	 include Orig
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
countWords	TokenNameIdentifier	 count Words
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
countWords	TokenNameIdentifier	 count Words
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
,	TokenNameCOMMA	
includeOrig	TokenNameIdentifier	 include Orig
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds an {@link SynonymMap} and returns it. */	TokenNameCOMMENT_JAVADOC	 Builds an {@link SynonymMap} and returns it. 
public	TokenNamepublic	
SynonymMap	TokenNameIdentifier	 Synonym Map
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
outputs	TokenNameIdentifier	 outputs
=	TokenNameEQUAL	
ByteSequenceOutputs	TokenNameIdentifier	 Byte Sequence Outputs
.	TokenNameDOT	
getSingleton	TokenNameIdentifier	 get Singleton
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: are we using the best sharing options? 	TokenNameCOMMENT_LINE	TODO: are we using the best sharing options? 
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
(	TokenNameLPAREN	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
INPUT_TYPE	TokenNameIdentifier	 INPUT  TYPE
.	TokenNameDOT	
BYTE4	TokenNameIdentifier	 BYT E4
,	TokenNameCOMMA	
outputs	TokenNameIdentifier	 outputs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BytesRef	TokenNameIdentifier	 Bytes Ref
scratch	TokenNameIdentifier	 scratch
=	TokenNameEQUAL	
new	TokenNamenew	
BytesRef	TokenNameIdentifier	 Bytes Ref
(	TokenNameLPAREN	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteArrayDataOutput	TokenNameIdentifier	 Byte Array Data Output
scratchOutput	TokenNameIdentifier	 scratch Output
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayDataOutput	TokenNameIdentifier	 Byte Array Data Output
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
dedupSet	TokenNameIdentifier	 dedup Set
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dedup	TokenNameIdentifier	 dedup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dedupSet	TokenNameIdentifier	 dedup Set
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dedupSet	TokenNameIdentifier	 dedup Set
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
spare	TokenNameIdentifier	 spare
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
CharsRef	TokenNameIdentifier	 Chars Ref
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
workingSet	TokenNameIdentifier	 working Set
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CharsRef	TokenNameIdentifier	 Chars Ref
sortedKeys	TokenNameIdentifier	 sorted Keys
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
CharsRef	TokenNameIdentifier	 Chars Ref
[	TokenNameLBRACKET	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
sortedKeys	TokenNameIdentifier	 sorted Keys
,	TokenNameCOMMA	
CharsRef	TokenNameIdentifier	 Chars Ref
.	TokenNameDOT	
getUTF16SortedAsUTF8Comparator	TokenNameIdentifier	 get UT F16 Sorted As UT F8 Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("fmap.build"); 	TokenNameCOMMENT_LINE	System.out.println("fmap.build"); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
keyIdx	TokenNameIdentifier	 key Idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
keyIdx	TokenNameIdentifier	 key Idx
<	TokenNameLESS	
sortedKeys	TokenNameIdentifier	 sorted Keys
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
keyIdx	TokenNameIdentifier	 key Idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CharsRef	TokenNameIdentifier	 Chars Ref
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
sortedKeys	TokenNameIdentifier	 sorted Keys
[	TokenNameLBRACKET	
keyIdx	TokenNameIdentifier	 key Idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
MapEntry	TokenNameIdentifier	 Map Entry
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
workingSet	TokenNameIdentifier	 working Set
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numEntries	TokenNameIdentifier	 num Entries
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// output size, assume the worst case 	TokenNameCOMMENT_LINE	output size, assume the worst case 
int	TokenNameint	
estimatedSize	TokenNameIdentifier	 estimated Size
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
+	TokenNamePLUS	
numEntries	TokenNameIdentifier	 num Entries
*	TokenNameMULTIPLY	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// numEntries + one ord for each entry 	TokenNameCOMMENT_LINE	numEntries + one ord for each entry 
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// now write our output data: 	TokenNameCOMMENT_LINE	now write our output data: 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numEntries	TokenNameIdentifier	 num Entries
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dedupSet	TokenNameIdentifier	 dedup Set
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// box once 	TokenNameCOMMENT_LINE	box once 
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
ent	TokenNameIdentifier	 ent
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dedupSet	TokenNameIdentifier	 dedup Set
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dedupSet	TokenNameIdentifier	 dedup Set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ent	TokenNameIdentifier	 ent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
writeVInt	TokenNameIdentifier	 write V Int
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
|	TokenNameOR	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
includeOrig	TokenNameIdentifier	 include Orig
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
pos2	TokenNameIdentifier	 pos2
=	TokenNameEQUAL	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
vIntLen	TokenNameIdentifier	 v Int Len
=	TokenNameEQUAL	
pos2	TokenNameIdentifier	 pos2
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
// Move the count + includeOrig to the front of the byte[]: 	TokenNameCOMMENT_LINE	Move the count + includeOrig to the front of the byte[]: 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
spare	TokenNameIdentifier	 spare
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
vIntLen	TokenNameIdentifier	 v Int Len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
vIntLen	TokenNameIdentifier	 v Int Len
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
spare	TokenNameIdentifier	 spare
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
vIntLen	TokenNameIdentifier	 v Int Len
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dedupSet	TokenNameIdentifier	 dedup Set
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dedupSet	TokenNameIdentifier	 dedup Set
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
scratchOutput	TokenNameIdentifier	 scratch Output
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
scratch	TokenNameIdentifier	 scratch
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
//System.out.println(" add input=" + input + " output=" + scratch + " offset=" + scratch.offset + " length=" + scratch.length + " count=" + count); 	TokenNameCOMMENT_LINE	System.out.println(" add input=" + input + " output=" + scratch + " offset=" + scratch.offset + " length=" + scratch.length + " count=" + count); 
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Util	TokenNameIdentifier	 Util
.	TokenNameDOT	
toUTF32	TokenNameIdentifier	 to UT F32
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
scratchIntsRef	TokenNameIdentifier	 scratch Ints Ref
)	TokenNameRPAREN	
,	TokenNameCOMMA	
BytesRef	TokenNameIdentifier	 Bytes Ref
.	TokenNameDOT	
deepCopyOf	TokenNameIdentifier	 deep Copy Of
(	TokenNameLPAREN	
scratch	TokenNameIdentifier	 scratch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FST	TokenNameIdentifier	 FST
<	TokenNameLESS	
BytesRef	TokenNameIdentifier	 Bytes Ref
>	TokenNameGREATER	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SynonymMap	TokenNameIdentifier	 Synonym Map
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
,	TokenNameCOMMA	
words	TokenNameIdentifier	 words
,	TokenNameCOMMA	
maxHorizontalContext	TokenNameIdentifier	 max Horizontal Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
