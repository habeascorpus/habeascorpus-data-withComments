package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
complexPhrase	TokenNameIdentifier	 complex Phrase
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
ParseException	TokenNameIdentifier	 Parse Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
QueryParser	TokenNameIdentifier	 Query Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spans	TokenNameIdentifier	 spans
.	TokenNameDOT	
SpanNearQuery	TokenNameIdentifier	 Span Near Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spans	TokenNameIdentifier	 spans
.	TokenNameDOT	
SpanNotQuery	TokenNameIdentifier	 Span Not Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spans	TokenNameIdentifier	 spans
.	TokenNameDOT	
SpanOrQuery	TokenNameIdentifier	 Span Or Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spans	TokenNameIdentifier	 spans
.	TokenNameDOT	
SpanQuery	TokenNameIdentifier	 Span Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
spans	TokenNameIdentifier	 spans
.	TokenNameDOT	
SpanTermQuery	TokenNameIdentifier	 Span Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
;	TokenNameSEMICOLON	
/** * QueryParser which permits complex phrase query syntax eg "(john jon * jonathan~) peters*". * <p> * Performs potentially multiple passes over Query text to parse any nested * logic in PhraseQueries. - First pass takes any PhraseQuery content between * quotes and stores for subsequent pass. All other query content is parsed as * normal - Second pass parses any stored PhraseQuery content, checking all * embedded clauses are referring to the same field and therefore can be * rewritten as Span queries. All PhraseQuery clauses are expressed as * ComplexPhraseQuery objects * </p> * <p> * This could arguably be done in one pass using a new QueryParser but here I am * working within the constraints of the existing parser as a base class. This * currently simply feeds all phrase content through an analyzer to select * phrase terms - any "special" syntax such as * ~ * etc are not given special * status * </p> * */	TokenNameCOMMENT_JAVADOC	 QueryParser which permits complex phrase query syntax eg "(john jon jonathan~) peters*". <p> Performs potentially multiple passes over Query text to parse any nested logic in PhraseQueries. - First pass takes any PhraseQuery content between quotes and stores for subsequent pass. All other query content is parsed as normal - Second pass parses any stored PhraseQuery content, checking all embedded clauses are referring to the same field and therefore can be rewritten as Span queries. All PhraseQuery clauses are expressed as ComplexPhraseQuery objects </p> <p> This could arguably be done in one pass using a new QueryParser but here I am working within the constraints of the existing parser as a base class. This currently simply feeds all phrase content through an analyzer to select phrase terms - any "special" syntax such as ~ etc are not given special status </p> 
public	TokenNamepublic	
class	TokenNameclass	
ComplexPhraseQueryParser	TokenNameIdentifier	 Complex Phrase Query Parser
extends	TokenNameextends	
QueryParser	TokenNameIdentifier	 Query Parser
{	TokenNameLBRACE	
private	TokenNameprivate	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
>	TokenNameGREATER	
complexPhrases	TokenNameIdentifier	 complex Phrases
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
currentPhraseQuery	TokenNameIdentifier	 current Phrase Query
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ComplexPhraseQueryParser	TokenNameIdentifier	 Complex Phrase Query Parser
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
matchVersion	TokenNameIdentifier	 match Version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
matchVersion	TokenNameIdentifier	 match Version
,	TokenNameCOMMA	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
int	TokenNameint	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
cpq	TokenNameIdentifier	 cpq
=	TokenNameEQUAL	
new	TokenNamenew	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
complexPhrases	TokenNameIdentifier	 complex Phrases
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cpq	TokenNameIdentifier	 cpq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// add to list of phrases to be parsed once 	TokenNameCOMMENT_LINE	add to list of phrases to be parsed once 
// we 	TokenNameCOMMENT_LINE	we 
// are through with this pass 	TokenNameCOMMENT_LINE	are through with this pass 
return	TokenNamereturn	
cpq	TokenNameIdentifier	 cpq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
RewriteMethod	TokenNameIdentifier	 Rewrite Method
oldMethod	TokenNameIdentifier	 old Method
=	TokenNameEQUAL	
getMultiTermRewriteMethod	TokenNameIdentifier	 get Multi Term Rewrite Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Temporarily force BooleanQuery rewrite so that Parser will 	TokenNameCOMMENT_LINE	Temporarily force BooleanQuery rewrite so that Parser will 
// generate visible 	TokenNameCOMMENT_LINE	generate visible 
// collection of terms which we can convert into SpanQueries. 	TokenNameCOMMENT_LINE	collection of terms which we can convert into SpanQueries. 
// ConstantScoreRewrite mode produces an 	TokenNameCOMMENT_LINE	ConstantScoreRewrite mode produces an 
// opaque ConstantScoreQuery object which cannot be interrogated for 	TokenNameCOMMENT_LINE	opaque ConstantScoreQuery object which cannot be interrogated for 
// terms in the same way a BooleanQuery can. 	TokenNameCOMMENT_LINE	terms in the same way a BooleanQuery can. 
// QueryParser is not guaranteed threadsafe anyway so this temporary 	TokenNameCOMMENT_LINE	QueryParser is not guaranteed threadsafe anyway so this temporary 
// state change should not 	TokenNameCOMMENT_LINE	state change should not 
// present an issue 	TokenNameCOMMENT_LINE	present an issue 
setMultiTermRewriteMethod	TokenNameIdentifier	 set Multi Term Rewrite Method
(	TokenNameLPAREN	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
SCORING_BOOLEAN_QUERY_REWRITE	TokenNameIdentifier	 SCORING  BOOLEAN  QUERY  REWRITE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
setMultiTermRewriteMethod	TokenNameIdentifier	 set Multi Term Rewrite Method
(	TokenNameLPAREN	
oldMethod	TokenNameIdentifier	 old Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// First pass - parse the top-level query recording any PhraseQuerys 	TokenNameCOMMENT_LINE	First pass - parse the top-level query recording any PhraseQuerys 
// which will need to be resolved 	TokenNameCOMMENT_LINE	which will need to be resolved 
complexPhrases	TokenNameIdentifier	 complex Phrases
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
super	TokenNamesuper	
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Perform second pass, using this QueryParser to parse any nested 	TokenNameCOMMENT_LINE	Perform second pass, using this QueryParser to parse any nested 
// PhraseQueries with different 	TokenNameCOMMENT_LINE	PhraseQueries with different 
// set of syntax restrictions (i.e. all fields must be same) 	TokenNameCOMMENT_LINE	set of syntax restrictions (i.e. all fields must be same) 
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
complexPhrases	TokenNameIdentifier	 complex Phrases
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPhraseQuery	TokenNameIdentifier	 current Phrase Query
=	TokenNameEQUAL	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// in each phrase, now parse the contents between quotes as a 	TokenNameCOMMENT_LINE	in each phrase, now parse the contents between quotes as a 
// separate parse operation 	TokenNameCOMMENT_LINE	separate parse operation 
currentPhraseQuery	TokenNameIdentifier	 current Phrase Query
.	TokenNameDOT	
parsePhraseElements	TokenNameIdentifier	 parse Phrase Elements
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// There is No "getTermQuery throws ParseException" method to override so 	TokenNameCOMMENT_LINE	There is No "getTermQuery throws ParseException" method to override so 
// unfortunately need 	TokenNameCOMMENT_LINE	unfortunately need 
// to throw a runtime exception here if a term for another field is embedded 	TokenNameCOMMENT_LINE	to throw a runtime exception here if a term for another field is embedded 
// in phrase query 	TokenNameCOMMENT_LINE	in phrase query 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newTermQuery	TokenNameIdentifier	 new Term Query
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
checkPhraseClauseIsForSameField	TokenNameIdentifier	 check Phrase Clause Is For Same Field
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
field	TokenNameIdentifier	 field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParseException	TokenNameIdentifier	 Parse Exception
pe	TokenNameIdentifier	 pe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error parsing complex phrase"	TokenNameStringLiteral	Error parsing complex phrase
,	TokenNameCOMMA	
pe	TokenNameIdentifier	 pe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
newTermQuery	TokenNameIdentifier	 new Term Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Helper method used to report on any clauses that appear in query syntax 	TokenNameCOMMENT_LINE	Helper method used to report on any clauses that appear in query syntax 
private	TokenNameprivate	
void	TokenNamevoid	
checkPhraseClauseIsForSameField	TokenNameIdentifier	 check Phrase Clause Is For Same Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currentPhraseQuery	TokenNameIdentifier	 current Phrase Query
.	TokenNameDOT	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Cannot have clause for field ""	TokenNameStringLiteral	Cannot have clause for field "
+	TokenNamePLUS	
field	TokenNameIdentifier	 field
+	TokenNamePLUS	
"" nested in phrase "	TokenNameStringLiteral	" nested in phrase 
+	TokenNamePLUS	
" for field ""	TokenNameStringLiteral	 for field "
+	TokenNamePLUS	
currentPhraseQuery	TokenNameIdentifier	 current Phrase Query
.	TokenNameDOT	
field	TokenNameIdentifier	 field
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getWildcardQuery	TokenNameIdentifier	 get Wildcard Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkPhraseClauseIsForSameField	TokenNameIdentifier	 check Phrase Clause Is For Same Field
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
getWildcardQuery	TokenNameIdentifier	 get Wildcard Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getRangeQuery	TokenNameIdentifier	 get Range Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkPhraseClauseIsForSameField	TokenNameIdentifier	 check Phrase Clause Is For Same Field
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
getRangeQuery	TokenNameIdentifier	 get Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newRangeQuery	TokenNameIdentifier	 new Range Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Must use old-style RangeQuery in order to produce a BooleanQuery 	TokenNameCOMMENT_LINE	Must use old-style RangeQuery in order to produce a BooleanQuery 
// that can be turned into SpanOr clause 	TokenNameCOMMENT_LINE	that can be turned into SpanOr clause 
TermRangeQuery	TokenNameIdentifier	 Term Range Query
rangeQuery	TokenNameIdentifier	 range Query
=	TokenNameEQUAL	
new	TokenNamenew	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
,	TokenNameCOMMA	
getRangeCollator	TokenNameIdentifier	 get Range Collator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangeQuery	TokenNameIdentifier	 range Query
.	TokenNameDOT	
setRewriteMethod	TokenNameIdentifier	 set Rewrite Method
(	TokenNameLPAREN	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
SCORING_BOOLEAN_QUERY_REWRITE	TokenNameIdentifier	 SCORING  BOOLEAN  QUERY  REWRITE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rangeQuery	TokenNameIdentifier	 range Query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
newRangeQuery	TokenNameIdentifier	 new Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFuzzyQuery	TokenNameIdentifier	 get Fuzzy Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
termStr	TokenNameIdentifier	 term Str
,	TokenNameCOMMA	
float	TokenNamefloat	
minSimilarity	TokenNameIdentifier	 min Similarity
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isPass2ResolvingPhrases	TokenNameIdentifier	 is Pass2 Resolving Phrases
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkPhraseClauseIsForSameField	TokenNameIdentifier	 check Phrase Clause Is For Same Field
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
getFuzzyQuery	TokenNameIdentifier	 get Fuzzy Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termStr	TokenNameIdentifier	 term Str
,	TokenNameCOMMA	
minSimilarity	TokenNameIdentifier	 min Similarity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Used to handle the query content in between quotes and produced Span-based * interpretations of the clauses. */	TokenNameCOMMENT_BLOCK	 Used to handle the query content in between quotes and produced Span-based interpretations of the clauses. 
static	TokenNamestatic	
class	TokenNameclass	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
extends	TokenNameextends	
Query	TokenNameIdentifier	 Query
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
;	TokenNameSEMICOLON	
int	TokenNameint	
slopFactor	TokenNameIdentifier	 slop Factor
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Query	TokenNameIdentifier	 Query
contents	TokenNameIdentifier	 contents
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
,	TokenNameCOMMA	
int	TokenNameint	
slopFactor	TokenNameIdentifier	 slop Factor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
=	TokenNameEQUAL	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
slopFactor	TokenNameIdentifier	 slop Factor
=	TokenNameEQUAL	
slopFactor	TokenNameIdentifier	 slop Factor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Called by ComplexPhraseQueryParser for each phrase after the main 	TokenNameCOMMENT_LINE	Called by ComplexPhraseQueryParser for each phrase after the main 
// parse 	TokenNameCOMMENT_LINE	parse 
// thread is through 	TokenNameCOMMENT_LINE	thread is through 
protected	TokenNameprotected	
void	TokenNamevoid	
parsePhraseElements	TokenNameIdentifier	 parse Phrase Elements
(	TokenNameLPAREN	
QueryParser	TokenNameIdentifier	 Query Parser
qp	TokenNameIdentifier	 qp
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
// TODO ensure that field-sensitivity is preserved ie the query 	TokenNameCOMMENT_LINE	TODO ensure that field-sensitivity is preserved ie the query 
// string below is parsed as 	TokenNameCOMMENT_LINE	string below is parsed as 
// field+":("+phrasedQueryStringContents+")" 	TokenNameCOMMENT_LINE	field+":("+phrasedQueryStringContents+")" 
// but this will need code in rewrite to unwrap the first layer of 	TokenNameCOMMENT_LINE	but this will need code in rewrite to unwrap the first layer of 
// boolean query 	TokenNameCOMMENT_LINE	boolean query 
contents	TokenNameIdentifier	 contents
=	TokenNameEQUAL	
qp	TokenNameIdentifier	 qp
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// ArrayList spanClauses = new ArrayList(); 	TokenNameCOMMENT_LINE	ArrayList spanClauses = new ArrayList(); 
if	TokenNameif	
(	TokenNameLPAREN	
contents	TokenNameIdentifier	 contents
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
contents	TokenNameIdentifier	 contents
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Build a sequence of Span clauses arranged in a SpanNear - child 	TokenNameCOMMENT_LINE	Build a sequence of Span clauses arranged in a SpanNear - child 
// clauses can be complex 	TokenNameCOMMENT_LINE	clauses can be complex 
// Booleans e.g. nots and ors etc 	TokenNameCOMMENT_LINE	Booleans e.g. nots and ors etc 
int	TokenNameint	
numNegatives	TokenNameIdentifier	 num Negatives
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
contents	TokenNameIdentifier	 contents
instanceof	TokenNameinstanceof	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Unknown query type ""	TokenNameStringLiteral	Unknown query type "
+	TokenNamePLUS	
contents	TokenNameIdentifier	 contents
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"" found in phrase query string ""	TokenNameStringLiteral	" found in phrase query string "
+	TokenNamePLUS	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
bq	TokenNameIdentifier	 bq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
contents	TokenNameIdentifier	 contents
;	TokenNameSEMICOLON	
BooleanClause	TokenNameIdentifier	 Boolean Clause
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bclauses	TokenNameIdentifier	 bclauses
=	TokenNameEQUAL	
bq	TokenNameIdentifier	 bq
.	TokenNameDOT	
getClauses	TokenNameIdentifier	 get Clauses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
=	TokenNameEQUAL	
new	TokenNamenew	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
bclauses	TokenNameIdentifier	 bclauses
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// For all clauses e.g. one* two~ 	TokenNameCOMMENT_LINE	For all clauses e.g. one* two~ 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bclauses	TokenNameIdentifier	 bclauses
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// HashSet bclauseterms=new HashSet(); 	TokenNameCOMMENT_LINE	HashSet bclauseterms=new HashSet(); 
Query	TokenNameIdentifier	 Query
qc	TokenNameIdentifier	 qc
=	TokenNameEQUAL	
bclauses	TokenNameIdentifier	 bclauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getQuery	TokenNameIdentifier	 get Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Rewrite this clause e.g one* becomes (one OR onerous) 	TokenNameCOMMENT_LINE	Rewrite this clause e.g one* becomes (one OR onerous) 
qc	TokenNameIdentifier	 qc
=	TokenNameEQUAL	
qc	TokenNameIdentifier	 qc
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bclauses	TokenNameIdentifier	 bclauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getOccur	TokenNameIdentifier	 get Occur
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST_NOT	TokenNameIdentifier	 MUST  NOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numNegatives	TokenNameIdentifier	 num Negatives
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
qc	TokenNameIdentifier	 qc
instanceof	TokenNameinstanceof	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
sc	TokenNameIdentifier	 sc
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addComplexPhraseClause	TokenNameIdentifier	 add Complex Phrase Clause
(	TokenNameLPAREN	
sc	TokenNameIdentifier	 sc
,	TokenNameCOMMA	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
qc	TokenNameIdentifier	 qc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sc	TokenNameIdentifier	 sc
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sc	TokenNameIdentifier	 sc
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Insert fake term e.g. phrase query was for "Fred Smithe*" and 	TokenNameCOMMENT_LINE	Insert fake term e.g. phrase query was for "Fred Smithe*" and 
// there were no "Smithe*" terms - need to 	TokenNameCOMMENT_LINE	there were no "Smithe*" terms - need to 
// prevent match on just "Fred". 	TokenNameCOMMENT_LINE	prevent match on just "Fred". 
allSpanClauses	TokenNameIdentifier	 all Span Clauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
SpanTermQuery	TokenNameIdentifier	 Span Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
"Dummy clause because no terms found - must match nothing"	TokenNameStringLiteral	Dummy clause because no terms found - must match nothing
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
qc	TokenNameIdentifier	 qc
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TermQuery	TokenNameIdentifier	 Term Query
tq	TokenNameIdentifier	 tq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
qc	TokenNameIdentifier	 qc
;	TokenNameSEMICOLON	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
SpanTermQuery	TokenNameIdentifier	 Span Term Query
(	TokenNameLPAREN	
tq	TokenNameIdentifier	 tq
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Unknown query type ""	TokenNameStringLiteral	Unknown query type "
+	TokenNamePLUS	
qc	TokenNameIdentifier	 qc
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"" found in phrase query string ""	TokenNameStringLiteral	" found in phrase query string "
+	TokenNamePLUS	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numNegatives	TokenNameIdentifier	 num Negatives
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The simple case - no negative elements in phrase 	TokenNameCOMMENT_LINE	The simple case - no negative elements in phrase 
return	TokenNamereturn	
new	TokenNamenew	
SpanNearQuery	TokenNameIdentifier	 Span Near Query
(	TokenNameLPAREN	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
,	TokenNameCOMMA	
slopFactor	TokenNameIdentifier	 slop Factor
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Complex case - we have mixed positives and negatives in the 	TokenNameCOMMENT_LINE	Complex case - we have mixed positives and negatives in the 
// sequence. 	TokenNameCOMMENT_LINE	sequence. 
// Need to return a SpanNotQuery 	TokenNameCOMMENT_LINE	Need to return a SpanNotQuery 
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
positiveClauses	TokenNameIdentifier	 positive Clauses
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
bclauses	TokenNameIdentifier	 bclauses
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
getOccur	TokenNameIdentifier	 get Occur
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST_NOT	TokenNameIdentifier	 MUST  NOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positiveClauses	TokenNameIdentifier	 positive Clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
includeClauses	TokenNameIdentifier	 include Clauses
=	TokenNameEQUAL	
positiveClauses	TokenNameIdentifier	 positive Clauses
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
positiveClauses	TokenNameIdentifier	 positive Clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SpanQuery	TokenNameIdentifier	 Span Query
include	TokenNameIdentifier	 include
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeClauses	TokenNameIdentifier	 include Clauses
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
include	TokenNameIdentifier	 include
=	TokenNameEQUAL	
includeClauses	TokenNameIdentifier	 include Clauses
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// only one positive clause 	TokenNameCOMMENT_LINE	only one positive clause 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// need to increase slop factor based on gaps introduced by 	TokenNameCOMMENT_LINE	need to increase slop factor based on gaps introduced by 
// negatives 	TokenNameCOMMENT_LINE	negatives 
include	TokenNameIdentifier	 include
=	TokenNameEQUAL	
new	TokenNamenew	
SpanNearQuery	TokenNameIdentifier	 Span Near Query
(	TokenNameLPAREN	
includeClauses	TokenNameIdentifier	 include Clauses
,	TokenNameCOMMA	
slopFactor	TokenNameIdentifier	 slop Factor
+	TokenNamePLUS	
numNegatives	TokenNameIdentifier	 num Negatives
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Use sequence of positive and negative values as the exclude. 	TokenNameCOMMENT_LINE	Use sequence of positive and negative values as the exclude. 
SpanNearQuery	TokenNameIdentifier	 Span Near Query
exclude	TokenNameIdentifier	 exclude
=	TokenNameEQUAL	
new	TokenNamenew	
SpanNearQuery	TokenNameIdentifier	 Span Near Query
(	TokenNameLPAREN	
allSpanClauses	TokenNameIdentifier	 all Span Clauses
,	TokenNameCOMMA	
slopFactor	TokenNameIdentifier	 slop Factor
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SpanNotQuery	TokenNameIdentifier	 Span Not Query
snot	TokenNameIdentifier	 snot
=	TokenNameEQUAL	
new	TokenNamenew	
SpanNotQuery	TokenNameIdentifier	 Span Not Query
(	TokenNameLPAREN	
include	TokenNameIdentifier	 include
,	TokenNameCOMMA	
exclude	TokenNameIdentifier	 exclude
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
snot	TokenNameIdentifier	 snot
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addComplexPhraseClause	TokenNameIdentifier	 add Complex Phrase Clause
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
spanClauses	TokenNameIdentifier	 span Clauses
,	TokenNameCOMMA	
BooleanQuery	TokenNameIdentifier	 Boolean Query
qc	TokenNameIdentifier	 qc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
ors	TokenNameIdentifier	 ors
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
nots	TokenNameIdentifier	 nots
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BooleanClause	TokenNameIdentifier	 Boolean Clause
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bclauses	TokenNameIdentifier	 bclauses
=	TokenNameEQUAL	
qc	TokenNameIdentifier	 qc
.	TokenNameDOT	
getClauses	TokenNameIdentifier	 get Clauses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// For all clauses e.g. one* two~ 	TokenNameCOMMENT_LINE	For all clauses e.g. one* two~ 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bclauses	TokenNameIdentifier	 bclauses
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
childQuery	TokenNameIdentifier	 child Query
=	TokenNameEQUAL	
bclauses	TokenNameIdentifier	 bclauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getQuery	TokenNameIdentifier	 get Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// select the list to which we will add these options 	TokenNameCOMMENT_LINE	select the list to which we will add these options 
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SpanQuery	TokenNameIdentifier	 Span Query
>	TokenNameGREATER	
chosenList	TokenNameIdentifier	 chosen List
=	TokenNameEQUAL	
ors	TokenNameIdentifier	 ors
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bclauses	TokenNameIdentifier	 bclauses
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getOccur	TokenNameIdentifier	 get Occur
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST_NOT	TokenNameIdentifier	 MUST  NOT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
chosenList	TokenNameIdentifier	 chosen List
=	TokenNameEQUAL	
nots	TokenNameIdentifier	 nots
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
childQuery	TokenNameIdentifier	 child Query
instanceof	TokenNameinstanceof	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TermQuery	TokenNameIdentifier	 Term Query
tq	TokenNameIdentifier	 tq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TermQuery	TokenNameIdentifier	 Term Query
)	TokenNameRPAREN	
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
SpanTermQuery	TokenNameIdentifier	 Span Term Query
stq	TokenNameIdentifier	 stq
=	TokenNameEQUAL	
new	TokenNamenew	
SpanTermQuery	TokenNameIdentifier	 Span Term Query
(	TokenNameLPAREN	
tq	TokenNameIdentifier	 tq
.	TokenNameDOT	
getTerm	TokenNameIdentifier	 get Term
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stq	TokenNameIdentifier	 stq
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
tq	TokenNameIdentifier	 tq
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
chosenList	TokenNameIdentifier	 chosen List
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
stq	TokenNameIdentifier	 stq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childQuery	TokenNameIdentifier	 child Query
instanceof	TokenNameinstanceof	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
cbq	TokenNameIdentifier	 cbq
=	TokenNameEQUAL	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
)	TokenNameRPAREN	
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
addComplexPhraseClause	TokenNameIdentifier	 add Complex Phrase Clause
(	TokenNameLPAREN	
chosenList	TokenNameIdentifier	 chosen List
,	TokenNameCOMMA	
cbq	TokenNameIdentifier	 cbq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// TODO alternatively could call extract terms here? 	TokenNameCOMMENT_LINE	TODO alternatively could call extract terms here? 
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Unknown query type:"	TokenNameStringLiteral	Unknown query type:
+	TokenNamePLUS	
childQuery	TokenNameIdentifier	 child Query
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ors	TokenNameIdentifier	 ors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SpanOrQuery	TokenNameIdentifier	 Span Or Query
soq	TokenNameIdentifier	 soq
=	TokenNameEQUAL	
new	TokenNamenew	
SpanOrQuery	TokenNameIdentifier	 Span Or Query
(	TokenNameLPAREN	
ors	TokenNameIdentifier	 ors
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
ors	TokenNameIdentifier	 ors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nots	TokenNameIdentifier	 nots
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
spanClauses	TokenNameIdentifier	 span Clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
soq	TokenNameIdentifier	 soq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
SpanOrQuery	TokenNameIdentifier	 Span Or Query
snqs	TokenNameIdentifier	 snqs
=	TokenNameEQUAL	
new	TokenNamenew	
SpanOrQuery	TokenNameIdentifier	 Span Or Query
(	TokenNameLPAREN	
nots	TokenNameIdentifier	 nots
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
SpanQuery	TokenNameIdentifier	 Span Query
[	TokenNameLBRACKET	
nots	TokenNameIdentifier	 nots
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SpanNotQuery	TokenNameIdentifier	 Span Not Query
snq	TokenNameIdentifier	 snq
=	TokenNameEQUAL	
new	TokenNamenew	
SpanNotQuery	TokenNameIdentifier	 Span Not Query
(	TokenNameLPAREN	
soq	TokenNameIdentifier	 soq
,	TokenNameCOMMA	
snqs	TokenNameIdentifier	 snqs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
spanClauses	TokenNameIdentifier	 span Clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
snq	TokenNameIdentifier	 snq
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"""	TokenNameStringLiteral	"
+	TokenNamePLUS	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
prime	TokenNameIdentifier	 prime
=	TokenNameEQUAL	
31	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
result	TokenNameIdentifier	 result
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
result	TokenNameIdentifier	 result
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
result	TokenNameIdentifier	 result
+	TokenNamePLUS	
slopFactor	TokenNameIdentifier	 slop Factor
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
==	TokenNameEQUAL_EQUAL	
obj	TokenNameIdentifier	 obj
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
obj	TokenNameIdentifier	 obj
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ComplexPhraseQuery	TokenNameIdentifier	 Complex Phrase Query
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
field	TokenNameIdentifier	 field
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
phrasedQueryStringContents	TokenNameIdentifier	 phrased Query String Contents
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
slopFactor	TokenNameIdentifier	 slop Factor
!=	TokenNameNOT_EQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
slopFactor	TokenNameIdentifier	 slop Factor
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
