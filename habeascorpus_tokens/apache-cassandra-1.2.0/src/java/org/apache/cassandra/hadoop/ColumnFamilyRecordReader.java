/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
InetAddress	TokenNameIdentifier	 Inet Address
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
transport	TokenNameIdentifier	 transport
.	TokenNameDOT	
TTransport	TokenNameIdentifier	 T Transport
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
auth	TokenNameIdentifier	 auth
.	TokenNameDOT	
IAuthenticator	TokenNameIdentifier	 I Authenticator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
IColumn	TokenNameIdentifier	 I Column
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
AbstractType	TokenNameIdentifier	 Abstract Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
TypeParser	TokenNameIdentifier	 Type Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
IPartitioner	TokenNameIdentifier	 I Partitioner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FBUtilities	TokenNameIdentifier	 FB Utilities
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
.	TokenNameDOT	
conf	TokenNameIdentifier	 conf
.	TokenNameDOT	
Configuration	TokenNameIdentifier	 Configuration
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
.	TokenNameDOT	
mapreduce	TokenNameIdentifier	 mapreduce
.	TokenNameDOT	
InputSplit	TokenNameIdentifier	 Input Split
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
.	TokenNameDOT	
mapreduce	TokenNameIdentifier	 mapreduce
.	TokenNameDOT	
RecordReader	TokenNameIdentifier	 Record Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
.	TokenNameDOT	
mapreduce	TokenNameIdentifier	 mapreduce
.	TokenNameDOT	
TaskAttemptContext	TokenNameIdentifier	 Task Attempt Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
TException	TokenNameIdentifier	 T Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
transport	TokenNameIdentifier	 transport
.	TokenNameDOT	
TSocket	TokenNameIdentifier	 T Socket
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
ColumnFamilyRecordReader	TokenNameIdentifier	 Column Family Record Reader
extends	TokenNameextends	
RecordReader	TokenNameIdentifier	 Record Reader
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
implements	TokenNameimplements	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
hadoop	TokenNameIdentifier	 hadoop
.	TokenNameDOT	
mapred	TokenNameIdentifier	 mapred
.	TokenNameDOT	
RecordReader	TokenNameIdentifier	 Record Reader
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
ColumnFamilyRecordReader	TokenNameIdentifier	 Column Family Record Reader
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CASSANDRA_HADOOP_MAX_KEY_SIZE_DEFAULT	TokenNameIdentifier	 CASSANDRA  HADOOP  MAX  KEY  SIZE  DEFAULT
=	TokenNameEQUAL	
8192	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ColumnFamilySplit	TokenNameIdentifier	 Column Family Split
split	TokenNameIdentifier	 split
;	TokenNameSEMICOLON	
private	TokenNameprivate	
RowIterator	TokenNameIdentifier	 Row Iterator
iter	TokenNameIdentifier	 iter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
currentRow	TokenNameIdentifier	 current Row
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isEmptyPredicate	TokenNameIdentifier	 is Empty Predicate
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
totalRowCount	TokenNameIdentifier	 total Row Count
;	TokenNameSEMICOLON	
// total number of rows to fetch 	TokenNameCOMMENT_LINE	total number of rows to fetch 
private	TokenNameprivate	
int	TokenNameint	
batchSize	TokenNameIdentifier	 batch Size
;	TokenNameSEMICOLON	
// fetch this many per batch 	TokenNameCOMMENT_LINE	fetch this many per batch 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TSocket	TokenNameIdentifier	 T Socket
socket	TokenNameIdentifier	 socket
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
client	TokenNameIdentifier	 client
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistencyLevel	TokenNameIdentifier	 consistency Level
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
keyBufferSize	TokenNameIdentifier	 key Buffer Size
=	TokenNameEQUAL	
8192	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ColumnFamilyRecordReader	TokenNameIdentifier	 Column Family Record Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
ColumnFamilyRecordReader	TokenNameIdentifier	 Column Family Record Reader
.	TokenNameDOT	
CASSANDRA_HADOOP_MAX_KEY_SIZE_DEFAULT	TokenNameIdentifier	 CASSANDRA  HADOOP  MAX  KEY  SIZE  DEFAULT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamilyRecordReader	TokenNameIdentifier	 Column Family Record Reader
(	TokenNameLPAREN	
int	TokenNameint	
keyBufferSize	TokenNameIdentifier	 key Buffer Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
keyBufferSize	TokenNameIdentifier	 key Buffer Size
=	TokenNameEQUAL	
keyBufferSize	TokenNameIdentifier	 key Buffer Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
socket	TokenNameIdentifier	 socket
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
socket	TokenNameIdentifier	 socket
.	TokenNameDOT	
isOpen	TokenNameIdentifier	 is Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
socket	TokenNameIdentifier	 socket
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
socket	TokenNameIdentifier	 socket
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
client	TokenNameIdentifier	 client
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getCurrentKey	TokenNameIdentifier	 get Current Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentRow	TokenNameIdentifier	 current Row
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
getCurrentValue	TokenNameIdentifier	 get Current Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentRow	TokenNameIdentifier	 current Row
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
float	TokenNamefloat	
getProgress	TokenNameIdentifier	 get Progress
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
1.0F	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
// the progress is likely to be reported slightly off the actual but close enough 	TokenNameCOMMENT_LINE	the progress is likely to be reported slightly off the actual but close enough 
float	TokenNamefloat	
progress	TokenNameIdentifier	 progress
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
rowsRead	TokenNameIdentifier	 rows Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
totalRowCount	TokenNameIdentifier	 total Row Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
progress	TokenNameIdentifier	 progress
>	TokenNameGREATER	
1.0F	TokenNameFloatingPointLiteral	
?	TokenNameQUESTION	
1.0F	TokenNameFloatingPointLiteral	
:	TokenNameCOLON	
progress	TokenNameIdentifier	 progress
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
boolean	TokenNameboolean	
isEmptyPredicate	TokenNameIdentifier	 is Empty Predicate
(	TokenNameLPAREN	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
predicate	TokenNameIdentifier	 predicate
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
isSetColumn_names	TokenNameIdentifier	 is Set Column names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
getSlice_range	TokenNameIdentifier	 get Slice range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
getSlice_range	TokenNameIdentifier	 get Slice range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
getSlice_range	TokenNameIdentifier	 get Slice range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
finish	TokenNameIdentifier	 finish
=	TokenNameEQUAL	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
getSlice_range	TokenNameIdentifier	 get Slice range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getFinish	TokenNameIdentifier	 get Finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
finish	TokenNameIdentifier	 finish
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
finish	TokenNameIdentifier	 finish
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
InputSplit	TokenNameIdentifier	 Input Split
split	TokenNameIdentifier	 split
,	TokenNameCOMMA	
TaskAttemptContext	TokenNameIdentifier	 Task Attempt Context
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
split	TokenNameIdentifier	 split
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ColumnFamilySplit	TokenNameIdentifier	 Column Family Split
)	TokenNameRPAREN	
split	TokenNameIdentifier	 split
;	TokenNameSEMICOLON	
Configuration	TokenNameIdentifier	 Configuration
conf	TokenNameIdentifier	 conf
=	TokenNameEQUAL	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
getConfiguration	TokenNameIdentifier	 get Configuration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KeyRange	TokenNameIdentifier	 Key Range
jobRange	TokenNameIdentifier	 job Range
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputKeyRange	TokenNameIdentifier	 get Input Key Range
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
jobRange	TokenNameIdentifier	 job Range
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
jobRange	TokenNameIdentifier	 job Range
.	TokenNameDOT	
row_filter	TokenNameIdentifier	 row filter
;	TokenNameSEMICOLON	
predicate	TokenNameIdentifier	 predicate
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputSlicePredicate	TokenNameIdentifier	 get Input Slice Predicate
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
widerows	TokenNameIdentifier	 widerows
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputIsWide	TokenNameIdentifier	 get Input Is Wide
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isEmptyPredicate	TokenNameIdentifier	 is Empty Predicate
=	TokenNameEQUAL	
isEmptyPredicate	TokenNameIdentifier	 is Empty Predicate
(	TokenNameLPAREN	
predicate	TokenNameIdentifier	 predicate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalRowCount	TokenNameIdentifier	 total Row Count
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
this	TokenNamethis	
.	TokenNameDOT	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
batchSize	TokenNameIdentifier	 batch Size
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getRangeBatchSize	TokenNameIdentifier	 get Range Batch Size
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfName	TokenNameIdentifier	 cf Name
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputColumnFamily	TokenNameIdentifier	 get Input Column Family
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
consistencyLevel	TokenNameIdentifier	 consistency Level
=	TokenNameEQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getReadConsistencyLevel	TokenNameIdentifier	 get Read Consistency Level
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspace	TokenNameIdentifier	 keyspace
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputKeyspace	TokenNameIdentifier	 get Input Keyspace
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// only need to connect once 	TokenNameCOMMENT_LINE	only need to connect once 
if	TokenNameif	
(	TokenNameLPAREN	
socket	TokenNameIdentifier	 socket
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
socket	TokenNameIdentifier	 socket
.	TokenNameDOT	
isOpen	TokenNameIdentifier	 is Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// create connection using thrift 	TokenNameCOMMENT_LINE	create connection using thrift 
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
socket	TokenNameIdentifier	 socket
=	TokenNameEQUAL	
new	TokenNamenew	
TSocket	TokenNameIdentifier	 T Socket
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputRpcPort	TokenNameIdentifier	 get Input Rpc Port
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TTransport	TokenNameIdentifier	 T Transport
transport	TokenNameIdentifier	 transport
=	TokenNameEQUAL	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputTransportFactory	TokenNameIdentifier	 get Input Transport Factory
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
.	TokenNameDOT	
openTransport	TokenNameIdentifier	 open Transport
(	TokenNameLPAREN	
socket	TokenNameIdentifier	 socket
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TBinaryProtocol	TokenNameIdentifier	 T Binary Protocol
binaryProtocol	TokenNameIdentifier	 binary Protocol
=	TokenNameEQUAL	
new	TokenNamenew	
TBinaryProtocol	TokenNameIdentifier	 T Binary Protocol
(	TokenNameLPAREN	
transport	TokenNameIdentifier	 transport
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
client	TokenNameIdentifier	 client
=	TokenNameEQUAL	
new	TokenNamenew	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
(	TokenNameLPAREN	
binaryProtocol	TokenNameIdentifier	 binary Protocol
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// log in 	TokenNameCOMMENT_LINE	log in 
client	TokenNameIdentifier	 client
.	TokenNameDOT	
set_keyspace	TokenNameIdentifier	 set keyspace
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputKeyspaceUserName	TokenNameIdentifier	 get Input Keyspace User Name
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
creds	TokenNameIdentifier	 creds
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
creds	TokenNameIdentifier	 creds
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
IAuthenticator	TokenNameIdentifier	 I Authenticator
.	TokenNameDOT	
USERNAME_KEY	TokenNameIdentifier	 USERNAME  KEY
,	TokenNameCOMMA	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputKeyspaceUserName	TokenNameIdentifier	 get Input Keyspace User Name
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
creds	TokenNameIdentifier	 creds
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
IAuthenticator	TokenNameIdentifier	 I Authenticator
.	TokenNameDOT	
PASSWORD_KEY	TokenNameIdentifier	 PASSWORD  KEY
,	TokenNameCOMMA	
ConfigHelper	TokenNameIdentifier	 Config Helper
.	TokenNameDOT	
getInputKeyspacePassword	TokenNameIdentifier	 get Input Keyspace Password
(	TokenNameLPAREN	
conf	TokenNameIdentifier	 conf
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AuthenticationRequest	TokenNameIdentifier	 Authentication Request
authRequest	TokenNameIdentifier	 auth Request
=	TokenNameEQUAL	
new	TokenNamenew	
AuthenticationRequest	TokenNameIdentifier	 Authentication Request
(	TokenNameLPAREN	
creds	TokenNameIdentifier	 creds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
client	TokenNameIdentifier	 client
.	TokenNameDOT	
login	TokenNameIdentifier	 login
(	TokenNameLPAREN	
authRequest	TokenNameIdentifier	 auth Request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
widerows	TokenNameIdentifier	 widerows
?	TokenNameQUESTION	
new	TokenNamenew	
WideRowIterator	TokenNameIdentifier	 Wide Row Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
StaticRowIterator	TokenNameIdentifier	 Static Row Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"created {}"	TokenNameStringLiteral	created {}
,	TokenNameCOMMA	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
nextKeyValue	TokenNameIdentifier	 next Key Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Finished scanning "	TokenNameStringLiteral	Finished scanning 
+	TokenNamePLUS	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
rowsRead	TokenNameIdentifier	 rows Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" rows (estimate was: "	TokenNameStringLiteral	 rows (estimate was: 
+	TokenNamePLUS	
totalRowCount	TokenNameIdentifier	 total Row Count
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
currentRow	TokenNameIdentifier	 current Row
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we don't use endpointsnitch since we are trying to support hadoop nodes that are 	TokenNameCOMMENT_LINE	we don't use endpointsnitch since we are trying to support hadoop nodes that are 
// not necessarily on Cassandra machines, too. This should be adequate for single-DC clusters, at least. 	TokenNameCOMMENT_LINE	not necessarily on Cassandra machines, too. This should be adequate for single-DC clusters, at least. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
InetAddress	TokenNameIdentifier	 Inet Address
>	TokenNameGREATER	
localAddresses	TokenNameIdentifier	 local Addresses
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getAllLocalAddresses	TokenNameIdentifier	 get All Local Addresses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
address	TokenNameIdentifier	 address
:	TokenNameCOLON	
localAddresses	TokenNameIdentifier	 local Addresses
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
location	TokenNameIdentifier	 location
:	TokenNameCOLON	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getLocations	TokenNameIdentifier	 get Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
InetAddress	TokenNameIdentifier	 Inet Address
locationAddress	TokenNameIdentifier	 location Address
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
locationAddress	TokenNameIdentifier	 location Address
=	TokenNameEQUAL	
InetAddress	TokenNameIdentifier	 Inet Address
.	TokenNameDOT	
getByName	TokenNameIdentifier	 get By Name
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
address	TokenNameIdentifier	 address
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
locationAddress	TokenNameIdentifier	 location Address
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
location	TokenNameIdentifier	 location
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getLocations	TokenNameIdentifier	 get Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
abstract	TokenNameabstract	
class	TokenNameclass	
RowIterator	TokenNameIdentifier	 Row Iterator
extends	TokenNameextends	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
{	TokenNameLBRACE	
protected	TokenNameprotected	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
int	TokenNameint	
totalRead	TokenNameIdentifier	 total Read
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
subComparator	TokenNameIdentifier	 sub Comparator
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
;	TokenNameSEMICOLON	
private	TokenNameprivate	
RowIterator	TokenNameIdentifier	 Row Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
partitioner	TokenNameIdentifier	 partitioner
=	TokenNameEQUAL	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
newPartitioner	TokenNameIdentifier	 new Partitioner
(	TokenNameLPAREN	
client	TokenNameIdentifier	 client
.	TokenNameDOT	
describe_partitioner	TokenNameIdentifier	 describe partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the Keyspace metadata, then get the specific CF metadata 	TokenNameCOMMENT_LINE	Get the Keyspace metadata, then get the specific CF metadata 
// in order to populate the sub/comparator. 	TokenNameCOMMENT_LINE	in order to populate the sub/comparator. 
KsDef	TokenNameIdentifier	 Ks Def
ks_def	TokenNameIdentifier	 ks def
=	TokenNameEQUAL	
client	TokenNameIdentifier	 client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
cfnames	TokenNameIdentifier	 cfnames
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfd	TokenNameIdentifier	 cfd
:	TokenNameCOLON	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
)	TokenNameRPAREN	
cfnames	TokenNameIdentifier	 cfnames
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfd	TokenNameIdentifier	 cfd
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
cfnames	TokenNameIdentifier	 cfnames
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cf_def	TokenNameIdentifier	 cf def
=	TokenNameEQUAL	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
TypeParser	TokenNameIdentifier	 Type Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
subComparator	TokenNameIdentifier	 sub Comparator
=	TokenNameEQUAL	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
TypeParser	TokenNameIdentifier	 Type Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"unable to load sub/comparator"	TokenNameStringLiteral	unable to load sub/comparator
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TException	TokenNameIdentifier	 T Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"error communicating via Thrift"	TokenNameStringLiteral	error communicating via Thrift
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"unable to load keyspace "	TokenNameStringLiteral	unable to load keyspace 
+	TokenNamePLUS	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return total number of rows read by this record reader */	TokenNameCOMMENT_JAVADOC	 @return total number of rows read by this record reader 
public	TokenNamepublic	
int	TokenNameint	
rowsRead	TokenNameIdentifier	 rows Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
totalRead	TokenNameIdentifier	 total Read
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
IColumn	TokenNameIdentifier	 I Column
unthriftify	TokenNameIdentifier	 unthriftify
(	TokenNameLPAREN	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
cosc	TokenNameIdentifier	 cosc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
unthriftifyCounter	TokenNameIdentifier	 unthriftify Counter
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_super_column	TokenNameIdentifier	 counter super column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
unthriftifySuperCounter	TokenNameIdentifier	 unthriftify Super Counter
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_super_column	TokenNameIdentifier	 counter super column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
unthriftifySuper	TokenNameIdentifier	 unthriftify Super
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
column	TokenNameIdentifier	 column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
unthriftifySimple	TokenNameIdentifier	 unthriftify Simple
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IColumn	TokenNameIdentifier	 I Column
unthriftifySuper	TokenNameIdentifier	 unthriftify Super
(	TokenNameLPAREN	
SuperColumn	TokenNameIdentifier	 Super Column
super_column	TokenNameIdentifier	 super column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
SuperColumn	TokenNameIdentifier	 Super Column
sc	TokenNameIdentifier	 sc
=	TokenNameEQUAL	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
SuperColumn	TokenNameIdentifier	 Super Column
(	TokenNameLPAREN	
super_column	TokenNameIdentifier	 super column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
subComparator	TokenNameIdentifier	 sub Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Column	TokenNameIdentifier	 Column
column	TokenNameIdentifier	 column
:	TokenNameCOLON	
super_column	TokenNameIdentifier	 super column
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sc	TokenNameIdentifier	 sc
.	TokenNameDOT	
addColumn	TokenNameIdentifier	 add Column
(	TokenNameLPAREN	
unthriftifySimple	TokenNameIdentifier	 unthriftify Simple
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sc	TokenNameIdentifier	 sc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
IColumn	TokenNameIdentifier	 I Column
unthriftifySimple	TokenNameIdentifier	 unthriftify Simple
(	TokenNameLPAREN	
Column	TokenNameIdentifier	 Column
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IColumn	TokenNameIdentifier	 I Column
unthriftifyCounter	TokenNameIdentifier	 unthriftify Counter
(	TokenNameLPAREN	
CounterColumn	TokenNameIdentifier	 Counter Column
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//CounterColumns read the counterID from the System table, so need the StorageService running and access 	TokenNameCOMMENT_LINE	CounterColumns read the counterID from the System table, so need the StorageService running and access 
//to cassandra.yaml. To avoid a Hadoop needing access to yaml return a regular Column. 	TokenNameCOMMENT_LINE	to cassandra.yaml. To avoid a Hadoop needing access to yaml return a regular Column. 
return	TokenNamereturn	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IColumn	TokenNameIdentifier	 I Column
unthriftifySuperCounter	TokenNameIdentifier	 unthriftify Super Counter
(	TokenNameLPAREN	
CounterSuperColumn	TokenNameIdentifier	 Counter Super Column
superColumn	TokenNameIdentifier	 super Column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
SuperColumn	TokenNameIdentifier	 Super Column
sc	TokenNameIdentifier	 sc
=	TokenNameEQUAL	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
SuperColumn	TokenNameIdentifier	 Super Column
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
subComparator	TokenNameIdentifier	 sub Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CounterColumn	TokenNameIdentifier	 Counter Column
column	TokenNameIdentifier	 column
:	TokenNameCOLON	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
sc	TokenNameIdentifier	 sc
.	TokenNameDOT	
addColumn	TokenNameIdentifier	 add Column
(	TokenNameLPAREN	
unthriftifyCounter	TokenNameIdentifier	 unthriftify Counter
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sc	TokenNameIdentifier	 sc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
StaticRowIterator	TokenNameIdentifier	 Static Row Iterator
extends	TokenNameextends	
RowIterator	TokenNameIdentifier	 Row Iterator
{	TokenNameLBRACE	
protected	TokenNameprotected	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
maybeInit	TokenNameIdentifier	 maybe Init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// check if we need another batch 	TokenNameCOMMENT_LINE	check if we need another batch 
if	TokenNameif	
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
startToken	TokenNameIdentifier	 start Token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalRead	TokenNameIdentifier	 total Read
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first request 	TokenNameCOMMENT_LINE	first request 
startToken	TokenNameIdentifier	 start Token
=	TokenNameEQUAL	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getStartToken	TokenNameIdentifier	 get Start Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
startToken	TokenNameIdentifier	 start Token
=	TokenNameEQUAL	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
getLast	TokenNameIdentifier	 get Last
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
startToken	TokenNameIdentifier	 start Token
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getEndToken	TokenNameIdentifier	 get End Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reached end of the split 	TokenNameCOMMENT_LINE	reached end of the split 
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
KeyRange	TokenNameIdentifier	 Key Range
keyRange	TokenNameIdentifier	 key Range
=	TokenNameEQUAL	
new	TokenNamenew	
KeyRange	TokenNameIdentifier	 Key Range
(	TokenNameLPAREN	
batchSize	TokenNameIdentifier	 batch Size
)	TokenNameRPAREN	
.	TokenNameDOT	
setStart_token	TokenNameIdentifier	 set Start token
(	TokenNameLPAREN	
startToken	TokenNameIdentifier	 start Token
)	TokenNameRPAREN	
.	TokenNameDOT	
setEnd_token	TokenNameIdentifier	 set End token
(	TokenNameLPAREN	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getEndToken	TokenNameIdentifier	 get End Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRow_filter	TokenNameIdentifier	 set Row filter
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
client	TokenNameIdentifier	 client
.	TokenNameDOT	
get_range_slices	TokenNameIdentifier	 get range slices
(	TokenNameLPAREN	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
predicate	TokenNameIdentifier	 predicate
,	TokenNameCOMMA	
keyRange	TokenNameIdentifier	 key Range
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// nothing new? reached the end 	TokenNameCOMMENT_LINE	nothing new? reached the end 
if	TokenNameif	
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// remove ghosts when fetching all columns 	TokenNameCOMMENT_LINE	remove ghosts when fetching all columns 
if	TokenNameif	
(	TokenNameLPAREN	
isEmptyPredicate	TokenNameIdentifier	 is Empty Predicate
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KeySlice	TokenNameIdentifier	 Key Slice
ks	TokenNameIdentifier	 ks
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
ks	TokenNameIdentifier	 ks
=	TokenNameEQUAL	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
getColumnsSize	TokenNameIdentifier	 get Columns Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// all ghosts, spooky 	TokenNameCOMMENT_LINE	all ghosts, spooky 
if	TokenNameif	
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// maybeInit assumes it can get the start-with key from the rows collection, so add back the last 	TokenNameCOMMENT_LINE	maybeInit assumes it can get the start-with key from the rows collection, so add back the last 
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maybeInit	TokenNameIdentifier	 maybe Init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reset to iterate through this new batch 	TokenNameCOMMENT_LINE	reset to iterate through this new batch 
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maybeInit	TokenNameIdentifier	 maybe Init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalRead	TokenNameIdentifier	 total Read
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
KeySlice	TokenNameIdentifier	 Key Slice
ks	TokenNameIdentifier	 ks
=	TokenNameEQUAL	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
cosc	TokenNameIdentifier	 cosc
:	TokenNameCOLON	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IColumn	TokenNameIdentifier	 I Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
unthriftify	TokenNameIdentifier	 unthriftify
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
WideRowIterator	TokenNameIdentifier	 Wide Row Iterator
extends	TokenNameextends	
RowIterator	TokenNameIdentifier	 Row Iterator
{	TokenNameLBRACE	
private	TokenNameprivate	
PeekingIterator	TokenNameIdentifier	 Peeking Iterator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
wideColumns	TokenNameIdentifier	 wide Columns
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
lastColumn	TokenNameIdentifier	 last Column
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
lastCountedKey	TokenNameIdentifier	 last Counted Key
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
maybeInit	TokenNameIdentifier	 maybe Init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wideColumns	TokenNameIdentifier	 wide Columns
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
KeyRange	TokenNameIdentifier	 Key Range
keyRange	TokenNameIdentifier	 key Range
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalRead	TokenNameIdentifier	 total Read
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
startToken	TokenNameIdentifier	 start Token
=	TokenNameEQUAL	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getStartToken	TokenNameIdentifier	 get Start Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyRange	TokenNameIdentifier	 key Range
=	TokenNameEQUAL	
new	TokenNamenew	
KeyRange	TokenNameIdentifier	 Key Range
(	TokenNameLPAREN	
batchSize	TokenNameIdentifier	 batch Size
)	TokenNameRPAREN	
.	TokenNameDOT	
setStart_token	TokenNameIdentifier	 set Start token
(	TokenNameLPAREN	
startToken	TokenNameIdentifier	 start Token
)	TokenNameRPAREN	
.	TokenNameDOT	
setEnd_token	TokenNameIdentifier	 set End token
(	TokenNameLPAREN	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getEndToken	TokenNameIdentifier	 get End Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRow_filter	TokenNameIdentifier	 set Row filter
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
KeySlice	TokenNameIdentifier	 Key Slice
lastRow	TokenNameIdentifier	 last Row
=	TokenNameEQUAL	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
getLast	TokenNameIdentifier	 get Last
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Starting with last-seen row {}"	TokenNameStringLiteral	Starting with last-seen row {}
,	TokenNameCOMMA	
lastRow	TokenNameIdentifier	 last Row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyRange	TokenNameIdentifier	 key Range
=	TokenNameEQUAL	
new	TokenNamenew	
KeyRange	TokenNameIdentifier	 Key Range
(	TokenNameLPAREN	
batchSize	TokenNameIdentifier	 batch Size
)	TokenNameRPAREN	
.	TokenNameDOT	
setStart_key	TokenNameIdentifier	 set Start key
(	TokenNameLPAREN	
lastRow	TokenNameIdentifier	 last Row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
setEnd_token	TokenNameIdentifier	 set End token
(	TokenNameLPAREN	
split	TokenNameIdentifier	 split
.	TokenNameDOT	
getEndToken	TokenNameIdentifier	 get End Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setRow_filter	TokenNameIdentifier	 set Row filter
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
client	TokenNameIdentifier	 client
.	TokenNameDOT	
get_paged_slice	TokenNameIdentifier	 get paged slice
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
keyRange	TokenNameIdentifier	 key Range
,	TokenNameCOMMA	
lastColumn	TokenNameIdentifier	 last Column
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
KeySlice	TokenNameIdentifier	 Key Slice
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
+=	TokenNamePLUS_EQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"read {} columns in {} rows for {} starting with {}"	TokenNameStringLiteral	read {} columns in {} rows for {} starting with {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
keyRange	TokenNameIdentifier	 key Range
,	TokenNameCOMMA	
lastColumn	TokenNameIdentifier	 last Column
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wideColumns	TokenNameIdentifier	 wide Columns
=	TokenNameEQUAL	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
peekingIterator	TokenNameIdentifier	 peeking Iterator
(	TokenNameLPAREN	
new	TokenNamenew	
WideColumnIterator	TokenNameIdentifier	 Wide Column Iterator
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
lastColumn	TokenNameIdentifier	 last Column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maybeInit	TokenNameIdentifier	 maybe Init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
wideColumns	TokenNameIdentifier	 wide Columns
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastColumn	TokenNameIdentifier	 last Column
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maybeIncreaseRowCounter	TokenNameIdentifier	 maybe Increase Row Counter
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Increases the row counter only if we really moved to the next row. * @param next just fetched row slice */	TokenNameCOMMENT_JAVADOC	 Increases the row counter only if we really moved to the next row. @param next just fetched row slice 
private	TokenNameprivate	
void	TokenNamevoid	
maybeIncreaseRowCounter	TokenNameIdentifier	 maybe Increase Row Counter
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
currentKey	TokenNameIdentifier	 current Key
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currentKey	TokenNameIdentifier	 current Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
lastCountedKey	TokenNameIdentifier	 last Counted Key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
totalRead	TokenNameIdentifier	 total Read
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
lastCountedKey	TokenNameIdentifier	 last Counted Key
=	TokenNameEQUAL	
currentKey	TokenNameIdentifier	 current Key
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
WideColumnIterator	TokenNameIdentifier	 Wide Column Iterator
extends	TokenNameextends	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
public	TokenNamepublic	
KeySlice	TokenNameIdentifier	 Key Slice
currentRow	TokenNameIdentifier	 current Row
;	TokenNameSEMICOLON	
public	TokenNamepublic	
WideColumnIterator	TokenNameIdentifier	 Wide Column Iterator
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
nextRow	TokenNameIdentifier	 next Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
emptyIterator	TokenNameIdentifier	 empty Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
nextRow	TokenNameIdentifier	 next Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentRow	TokenNameIdentifier	 current Row
=	TokenNameEQUAL	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
currentRow	TokenNameIdentifier	 current Row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
cosc	TokenNameIdentifier	 cosc
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IColumn	TokenNameIdentifier	 I Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
unthriftify	TokenNameIdentifier	 unthriftify
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ImmutableSortedMap	TokenNameIdentifier	 Immutable Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
ImmutableSortedMap	TokenNameIdentifier	 Immutable Sorted Map
.	TokenNameDOT	
of	TokenNameIdentifier	 of
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
currentRow	TokenNameIdentifier	 current Row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextRow	TokenNameIdentifier	 next Row
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Because the old Hadoop API wants us to write to the key and value 	TokenNameCOMMENT_LINE	Because the old Hadoop API wants us to write to the key and value 
// and the new asks for them, we need to copy the output of the new API 	TokenNameCOMMENT_LINE	and the new asks for them, we need to copy the output of the new API 
// to the old. Thus, expect a small performance hit. 	TokenNameCOMMENT_LINE	to the old. Thus, expect a small performance hit. 
// And obviously this wouldn't work for wide rows. But since ColumnFamilyInputFormat 	TokenNameCOMMENT_LINE	And obviously this wouldn't work for wide rows. But since ColumnFamilyInputFormat 
// and ColumnFamilyRecordReader don't support them, it should be fine for now. 	TokenNameCOMMENT_LINE	and ColumnFamilyRecordReader don't support them, it should be fine for now. 
public	TokenNamepublic	
boolean	TokenNameboolean	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
nextKeyValue	TokenNameIdentifier	 next Key Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
getCurrentKey	TokenNameIdentifier	 get Current Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
flip	TokenNameIdentifier	 flip
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
putAll	TokenNameIdentifier	 put All
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
getCurrentValue	TokenNameIdentifier	 get Current Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
createKey	TokenNameIdentifier	 create Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
this	TokenNamethis	
.	TokenNameDOT	
keyBufferSize	TokenNameIdentifier	 key Buffer Size
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SortedMap	TokenNameIdentifier	 Sorted Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
createValue	TokenNameIdentifier	 create Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TreeMap	TokenNameIdentifier	 Tree Map
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getPos	TokenNameIdentifier	 get Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
rowsRead	TokenNameIdentifier	 rows Read
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
