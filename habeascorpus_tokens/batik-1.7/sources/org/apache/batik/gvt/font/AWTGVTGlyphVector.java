/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Color	TokenNameIdentifier	 Color
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Graphics2D	TokenNameIdentifier	 Graphics2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Paint	TokenNameIdentifier	 Paint
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
RenderingHints	TokenNameIdentifier	 Rendering Hints
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Shape	TokenNameIdentifier	 Shape
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Stroke	TokenNameIdentifier	 Stroke
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
FontRenderContext	TokenNameIdentifier	 Font Render Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GlyphJustificationInfo	TokenNameIdentifier	 Glyph Justification Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GlyphMetrics	TokenNameIdentifier	 Glyph Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GlyphVector	TokenNameIdentifier	 Glyph Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
AffineTransform	TokenNameIdentifier	 Affine Transform
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
GeneralPath	TokenNameIdentifier	 General Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Point2D	TokenNameIdentifier	 Point2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
CharacterIterator	TokenNameIdentifier	 Character Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
ArabicTextHandler	TokenNameIdentifier	 Arabic Text Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
;	TokenNameSEMICOLON	
/** * This is a wrapper class for a java.awt.font.GlyphVector instance. * * @author <a href="mailto:bella.robinson@cmis.csiro.au">Bella Robinson</a> * @version $Id: AWTGVTGlyphVector.java 479559 2006-11-27 09:46:16Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 This is a wrapper class for a java.awt.font.GlyphVector instance. * @author <a href="mailto:bella.robinson@cmis.csiro.au">Bella Robinson</a> @version $Id: AWTGVTGlyphVector.java 479559 2006-11-27 09:46:16Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
AWTGVTGlyphVector	TokenNameIdentifier	 AWTGVT Glyph Vector
implements	TokenNameimplements	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
.	TokenNameDOT	
Attribute	TokenNameIdentifier	 Attribute
PAINT_INFO	TokenNameIdentifier	 PAINT  INFO
=	TokenNameEQUAL	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
PAINT_INFO	TokenNameIdentifier	 PAINT  INFO
;	TokenNameSEMICOLON	
private	TokenNameprivate	
GlyphVector	TokenNameIdentifier	 Glyph Vector
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
;	TokenNameSEMICOLON	
private	TokenNameprivate	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
gvtFont	TokenNameIdentifier	 gvt Font
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CharacterIterator	TokenNameIdentifier	 Character Iterator
ci	TokenNameIdentifier	 ci
;	TokenNameSEMICOLON	
// This contains the glyphPostions after doing a performDefaultLayout 	TokenNameCOMMENT_LINE	This contains the glyphPostions after doing a performDefaultLayout 
private	TokenNameprivate	
Point2D	TokenNameIdentifier	 Point2 D
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphPositions	TokenNameIdentifier	 glyph Positions
;	TokenNameSEMICOLON	
// need to keep track of the glyphTransforms since GlyphVector doesn't 	TokenNameCOMMENT_LINE	need to keep track of the glyphTransforms since GlyphVector doesn't 
// seem to 	TokenNameCOMMENT_LINE	seem to 
private	TokenNameprivate	
AffineTransform	TokenNameIdentifier	 Affine Transform
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
;	TokenNameSEMICOLON	
// these are for caching the glyph outlines 	TokenNameCOMMENT_LINE	these are for caching the glyph outlines 
private	TokenNameprivate	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphVisible	TokenNameIdentifier	 glyph Visible
;	TokenNameSEMICOLON	
private	TokenNameprivate	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
;	TokenNameSEMICOLON	
private	TokenNameprivate	
GeneralPath	TokenNameIdentifier	 General Path
outline	TokenNameIdentifier	 outline
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
visualBounds	TokenNameIdentifier	 visual Bounds
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
logicalBounds	TokenNameIdentifier	 logical Bounds
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
bounds2D	TokenNameIdentifier	 bounds2 D
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
scaleFactor	TokenNameIdentifier	 scale Factor
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
ascent	TokenNameIdentifier	 ascent
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
descent	TokenNameIdentifier	 descent
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
cacheTPI	TokenNameIdentifier	 cache TPI
;	TokenNameSEMICOLON	
/** * Creates and new AWTGVTGlyphVector from the specified GlyphVector and * AWTGVTFont objects. * * @param glyphVector The glyph vector that this one will be based upon. * @param font The font that is creating this glyph vector. * @param scaleFactor The scale factor to apply to the glyph vector. * IMPORTANT: This is only required because the GlyphVector class doesn't * handle font sizes less than 1 correctly. By using the scale factor we * can use a GlyphVector created by a larger font and then scale it down to * the correct size. * @param ci The character string that this glyph vector represents. */	TokenNameCOMMENT_JAVADOC	 Creates and new AWTGVTGlyphVector from the specified GlyphVector and AWTGVTFont objects. * @param glyphVector The glyph vector that this one will be based upon. @param font The font that is creating this glyph vector. @param scaleFactor The scale factor to apply to the glyph vector. IMPORTANT: This is only required because the GlyphVector class doesn't handle font sizes less than 1 correctly. By using the scale factor we can use a GlyphVector created by a larger font and then scale it down to the correct size. @param ci The character string that this glyph vector represents. 
public	TokenNamepublic	
AWTGVTGlyphVector	TokenNameIdentifier	 AWTGVT Glyph Vector
(	TokenNameLPAREN	
GlyphVector	TokenNameIdentifier	 Glyph Vector
glyphVector	TokenNameIdentifier	 glyph Vector
,	TokenNameCOMMA	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
font	TokenNameIdentifier	 font
,	TokenNameCOMMA	
float	TokenNamefloat	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
CharacterIterator	TokenNameIdentifier	 Character Iterator
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
=	TokenNameEQUAL	
glyphVector	TokenNameIdentifier	 glyph Vector
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
gvtFont	TokenNameIdentifier	 gvt Font
=	TokenNameEQUAL	
font	TokenNameIdentifier	 font
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scaleFactor	TokenNameIdentifier	 scale Factor
=	TokenNameEQUAL	
scaleFactor	TokenNameIdentifier	 scale Factor
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ci	TokenNameIdentifier	 ci
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
;	TokenNameSEMICOLON	
GVTLineMetrics	TokenNameIdentifier	 GVT Line Metrics
lineMetrics	TokenNameIdentifier	 line Metrics
=	TokenNameEQUAL	
gvtFont	TokenNameIdentifier	 gvt Font
.	TokenNameDOT	
getLineMetrics	TokenNameIdentifier	 get Line Metrics
(	TokenNameLPAREN	
"By"	TokenNameStringLiteral	By
,	TokenNameCOMMA	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getFontRenderContext	TokenNameIdentifier	 get Font Render Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ascent	TokenNameIdentifier	 ascent
=	TokenNameEQUAL	
lineMetrics	TokenNameIdentifier	 line Metrics
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
descent	TokenNameIdentifier	 descent
=	TokenNameEQUAL	
lineMetrics	TokenNameIdentifier	 line Metrics
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
glyphVector	TokenNameIdentifier	 glyph Vector
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphPositions	TokenNameIdentifier	 glyph Positions
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
=	TokenNameEQUAL	
new	TokenNamenew	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphVisible	TokenNameIdentifier	 glyph Visible
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
=	TokenNameEQUAL	
new	TokenNamenew	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
[	TokenNameLBRACKET	
numGlyphs	TokenNameIdentifier	 num Glyphs
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the GVTFont associated with this GVTGlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the GVTFont associated with this GVTGlyphVector. 
public	TokenNamepublic	
GVTFont	TokenNameIdentifier	 GVT Font
getFont	TokenNameIdentifier	 get Font
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
gvtFont	TokenNameIdentifier	 gvt Font
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the FontRenderContext associated with this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the FontRenderContext associated with this GlyphVector. 
public	TokenNamepublic	
FontRenderContext	TokenNameIdentifier	 Font Render Context
getFontRenderContext	TokenNameIdentifier	 get Font Render Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getFontRenderContext	TokenNameIdentifier	 get Font Render Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the glyphcode of the specified glyph. */	TokenNameCOMMENT_JAVADOC	 Returns the glyphcode of the specified glyph. 
public	TokenNamepublic	
int	TokenNameint	
getGlyphCode	TokenNameIdentifier	 get Glyph Code
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getGlyphCode	TokenNameIdentifier	 get Glyph Code
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns an array of glyphcodes for the specified glyphs. */	TokenNameCOMMENT_JAVADOC	 Returns an array of glyphcodes for the specified glyphs. 
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getGlyphCodes	TokenNameIdentifier	 get Glyph Codes
(	TokenNameLPAREN	
int	TokenNameint	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
,	TokenNameCOMMA	
int	TokenNameint	
numEntries	TokenNameIdentifier	 num Entries
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
codeReturn	TokenNameIdentifier	 code Return
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getGlyphCodes	TokenNameIdentifier	 get Glyph Codes
(	TokenNameLPAREN	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
,	TokenNameCOMMA	
numEntries	TokenNameIdentifier	 num Entries
,	TokenNameCOMMA	
codeReturn	TokenNameIdentifier	 code Return
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the justification information for the glyph at the specified * index into this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the justification information for the glyph at the specified index into this GlyphVector. 
public	TokenNamepublic	
GlyphJustificationInfo	TokenNameIdentifier	 Glyph Justification Info
getGlyphJustificationInfo	TokenNameIdentifier	 get Glyph Justification Info
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getGlyphJustificationInfo	TokenNameIdentifier	 get Glyph Justification Info
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a tight bounds on the GylphVector including stroking. */	TokenNameCOMMENT_JAVADOC	 Returns a tight bounds on the GylphVector including stroking. 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
{	TokenNameLBRACE	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
tpi	TokenNameIdentifier	 tpi
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
PAINT_INFO	TokenNameIdentifier	 PAINT  INFO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
.	TokenNameDOT	
equivilent	TokenNameIdentifier	 equivilent
(	TokenNameLPAREN	
tpi	TokenNameIdentifier	 tpi
,	TokenNameCOMMA	
cacheTPI	TokenNameIdentifier	 cache TPI
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
bounds2D	TokenNameIdentifier	 bounds2 D
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tpi	TokenNameIdentifier	 tpi
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
visible	TokenNameIdentifier	 visible
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
cacheTPI	TokenNameIdentifier	 cache TPI
=	TokenNameEQUAL	
new	TokenNamenew	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
(	TokenNameLPAREN	
tpi	TokenNameIdentifier	 tpi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Shape	TokenNameIdentifier	 Shape
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
fillPaint	TokenNameIdentifier	 fill Paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
outline	TokenNameIdentifier	 outline
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check if we need to include the 	TokenNameCOMMENT_LINE	check if we need to include the 
// outline of this glyph 	TokenNameCOMMENT_LINE	outline of this glyph 
Stroke	TokenNameIdentifier	 Stroke
stroke	TokenNameIdentifier	 stroke
=	TokenNameEQUAL	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
strokeStroke	TokenNameIdentifier	 stroke Stroke
;	TokenNameSEMICOLON	
Paint	TokenNameIdentifier	 Paint
paint	TokenNameIdentifier	 paint
=	TokenNameEQUAL	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
strokePaint	TokenNameIdentifier	 stroke Paint
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
stroke	TokenNameIdentifier	 stroke
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
paint	TokenNameIdentifier	 paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
strokeBounds	TokenNameIdentifier	 stroke Bounds
=	TokenNameEQUAL	
stroke	TokenNameIdentifier	 stroke
.	TokenNameDOT	
createStrokedShape	TokenNameIdentifier	 create Stroked Shape
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
strokeBounds	TokenNameIdentifier	 stroke Bounds
;	TokenNameSEMICOLON	
else	TokenNameelse	
// bounds2D = bounds2D.createUnion(strokeBounds); 	TokenNameCOMMENT_LINE	bounds2D = bounds2D.createUnion(strokeBounds); 
bounds2D	TokenNameIdentifier	 bounds2 D
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
strokeBounds	TokenNameIdentifier	 stroke Bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
bounds2D	TokenNameIdentifier	 bounds2 D
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the logical bounds of this GlyphVector. * This is a bound useful for hit detection and highlighting. */	TokenNameCOMMENT_JAVADOC	 Returns the logical bounds of this GlyphVector. This is a bound useful for hit detection and highlighting. 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getLogicalBounds	TokenNameIdentifier	 get Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This fills in logicalBounds... 	TokenNameCOMMENT_LINE	This fills in logicalBounds... 
computeGlyphLogicalBounds	TokenNameIdentifier	 compute Glyph Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
logicalBounds	TokenNameIdentifier	 logical Bounds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the logical bounds of the specified glyph within this * GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the logical bounds of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getGlyphLogicalBounds	TokenNameIdentifier	 get Glyph Logical Bounds
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
computeGlyphLogicalBounds	TokenNameIdentifier	 compute Glyph Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates the logical bounds for each glyph. The logical * bounds are what is used for highlighting the glyphs when * selected. */	TokenNameCOMMENT_JAVADOC	 Calculates the logical bounds for each glyph. The logical bounds are what is used for highlighting the glyphs when selected. 
private	TokenNameprivate	
void	TokenNamevoid	
computeGlyphLogicalBounds	TokenNameIdentifier	 compute Glyph Logical Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Shape	TokenNameIdentifier	 Shape
[	TokenNameLBRACKET	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rotated	TokenNameIdentifier	 rotated
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
maxWidth	TokenNameIdentifier	 max Width
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
maxHeight	TokenNameIdentifier	 max Height
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the glyph is not drawn 	TokenNameCOMMENT_LINE	the glyph is not drawn 
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
glyphMetrics	TokenNameIdentifier	 glyph Metrics
=	TokenNameEQUAL	
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphX	TokenNameIdentifier	 glyph X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphY	TokenNameIdentifier	 glyph Y
=	TokenNameEQUAL	
-	TokenNameMINUS	
ascent	TokenNameIdentifier	 ascent
/	TokenNameDIVIDE	
scaleFactor	TokenNameIdentifier	 scale Factor
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphWidth	TokenNameIdentifier	 glyph Width
=	TokenNameEQUAL	
(	TokenNameLPAREN	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
.	TokenNameDOT	
getHorizontalAdvance	TokenNameIdentifier	 get Horizontal Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
glyphHeight	TokenNameIdentifier	 glyph Height
=	TokenNameEQUAL	
(	TokenNameLPAREN	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
.	TokenNameDOT	
getVerticalAdvance	TokenNameIdentifier	 get Vertical Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
glyphX	TokenNameIdentifier	 glyph X
,	TokenNameCOMMA	
glyphY	TokenNameIdentifier	 glyph Y
,	TokenNameCOMMA	
glyphWidth	TokenNameIdentifier	 glyph Width
,	TokenNameCOMMA	
glyphHeight	TokenNameIdentifier	 glyph Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// can't tell if rotated or not, make it the same as 	TokenNameCOMMENT_LINE	can't tell if rotated or not, make it the same as 
// the previous glyph 	TokenNameCOMMENT_LINE	the previous glyph 
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// get three corner points so we can determine 	TokenNameCOMMENT_LINE	get three corner points so we can determine 
// whether the glyph is rotated 	TokenNameCOMMENT_LINE	whether the glyph is rotated 
Point2D	TokenNameIdentifier	 Point2 D
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMaxX	TokenNameIdentifier	 get Max X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
p3	TokenNameIdentifier	 p3
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMaxY	TokenNameIdentifier	 get Max Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
gpos	TokenNameIdentifier	 gpos
=	TokenNameEQUAL	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
gpos	TokenNameIdentifier	 gpos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
scale	TokenNameIdentifier	 scale
(	TokenNameLPAREN	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
tp1	TokenNameIdentifier	 tp1
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
tp2	TokenNameIdentifier	 tp2
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
tp3	TokenNameIdentifier	 tp3
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
tp1	TokenNameIdentifier	 tp1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
tp2	TokenNameIdentifier	 tp2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
(	TokenNameLPAREN	
p3	TokenNameIdentifier	 p3
,	TokenNameCOMMA	
tp3	TokenNameIdentifier	 tp3
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tdx12	TokenNameIdentifier	 tdx12
=	TokenNameEQUAL	
tp1	TokenNameIdentifier	 tp1
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tp2	TokenNameIdentifier	 tp2
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tdx13	TokenNameIdentifier	 tdx13
=	TokenNameEQUAL	
tp1	TokenNameIdentifier	 tp1
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tp3	TokenNameIdentifier	 tp3
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tdy12	TokenNameIdentifier	 tdy12
=	TokenNameEQUAL	
tp1	TokenNameIdentifier	 tp1
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tp2	TokenNameIdentifier	 tp2
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
tdy13	TokenNameIdentifier	 tdy13
=	TokenNameEQUAL	
tp1	TokenNameIdentifier	 tp1
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
tp3	TokenNameIdentifier	 tp3
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
tdx12	TokenNameIdentifier	 tdx12
)	TokenNameRPAREN	
<	TokenNameLESS	
0.001	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
tdy13	TokenNameIdentifier	 tdy13
)	TokenNameRPAREN	
<	TokenNameLESS	
0.001	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
tdx13	TokenNameIdentifier	 tdx13
)	TokenNameRPAREN	
<	TokenNameLESS	
0.001	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
tdy12	TokenNameIdentifier	 tdy12
)	TokenNameRPAREN	
<	TokenNameLESS	
0.001	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If either of these are zero then it is axially aligned 	TokenNameCOMMENT_LINE	If either of these are zero then it is axially aligned 
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
rectBounds	TokenNameIdentifier	 rect Bounds
;	TokenNameSEMICOLON	
rectBounds	TokenNameIdentifier	 rect Bounds
=	TokenNameEQUAL	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rectBounds	TokenNameIdentifier	 rect Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxWidth	TokenNameIdentifier	 max Width
)	TokenNameRPAREN	
maxWidth	TokenNameIdentifier	 max Width
=	TokenNameEQUAL	
rectBounds	TokenNameIdentifier	 rect Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rectBounds	TokenNameIdentifier	 rect Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxHeight	TokenNameIdentifier	 max Height
)	TokenNameRPAREN	
maxHeight	TokenNameIdentifier	 max Height
=	TokenNameEQUAL	
rectBounds	TokenNameIdentifier	 rect Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if appropriate, join adjacent glyph logical bounds 	TokenNameCOMMENT_LINE	if appropriate, join adjacent glyph logical bounds 
GeneralPath	TokenNameIdentifier	 General Path
logicalBoundsPath	TokenNameIdentifier	 logical Bounds Path
=	TokenNameEQUAL	
new	TokenNamenew	
GeneralPath	TokenNameIdentifier	 General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logicalBoundsPath	TokenNameIdentifier	 logical Bounds Path
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
logicalBoundsPath	TokenNameIdentifier	 logical Bounds Path
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
maxHeight	TokenNameIdentifier	 max Height
*	TokenNameMULTIPLY	
1.5	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make all glyphs tops and bottoms the same as the full bounds 	TokenNameCOMMENT_LINE	make all glyphs tops and bottoms the same as the full bounds 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first make sure that the glyph logical bounds are 	TokenNameCOMMENT_LINE	first make sure that the glyph logical bounds are 
// not rotated 	TokenNameCOMMENT_LINE	not rotated 
if	TokenNameif	
(	TokenNameLPAREN	
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
width	TokenNameIdentifier	 width
=	TokenNameEQUAL	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make this glyph extend to the start of the next one 	TokenNameCOMMENT_LINE	make this glyph extend to the start of the next one 
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
ngb	TokenNameIdentifier	 ngb
=	TokenNameEQUAL	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
nw	TokenNameIdentifier	 nw
=	TokenNameEQUAL	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nw	TokenNameIdentifier	 nw
<	TokenNameLESS	
width	TokenNameIdentifier	 width
*	TokenNameMULTIPLY	
1.15	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
nw	TokenNameIdentifier	 nw
>	TokenNameGREATER	
width	TokenNameIdentifier	 width
*	TokenNameMULTIPLY	
.85	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nw	TokenNameIdentifier	 nw
-	TokenNameMINUS	
width	TokenNameIdentifier	 width
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
.5	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
width	TokenNameIdentifier	 width
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
setRect	TokenNameIdentifier	 set Rect
(	TokenNameLPAREN	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
delta	TokenNameIdentifier	 delta
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
delta	TokenNameIdentifier	 delta
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
width	TokenNameIdentifier	 width
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
maxWidth	TokenNameIdentifier	 max Width
*	TokenNameMULTIPLY	
1.5	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make all glyphs left and right edges the same as the full bounds 	TokenNameCOMMENT_LINE	make all glyphs left and right edges the same as the full bounds 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first make sure that the glyph logical bounds are 	TokenNameCOMMENT_LINE	first make sure that the glyph logical bounds are 
// not rotated 	TokenNameCOMMENT_LINE	not rotated 
if	TokenNameif	
(	TokenNameLPAREN	
rotated	TokenNameIdentifier	 rotated
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
height	TokenNameIdentifier	 height
=	TokenNameEQUAL	
glyphBounds	TokenNameIdentifier	 glyph Bounds
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make this glyph extend to the start of the next one 	TokenNameCOMMENT_LINE	make this glyph extend to the start of the next one 
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
ngb	TokenNameIdentifier	 ngb
=	TokenNameEQUAL	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// going top to bottom 	TokenNameCOMMENT_LINE	going top to bottom 
double	TokenNamedouble	
nh	TokenNameIdentifier	 nh
=	TokenNameEQUAL	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nh	TokenNameIdentifier	 nh
<	TokenNameLESS	
height	TokenNameIdentifier	 height
*	TokenNameMULTIPLY	
1.15	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
nh	TokenNameIdentifier	 nh
>	TokenNameGREATER	
height	TokenNameIdentifier	 height
*	TokenNameMULTIPLY	
.85	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nh	TokenNameIdentifier	 nh
-	TokenNameMINUS	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
.5	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
height	TokenNameIdentifier	 height
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
setRect	TokenNameIdentifier	 set Rect
(	TokenNameLPAREN	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
delta	TokenNameIdentifier	 delta
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ngb	TokenNameIdentifier	 ngb
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
delta	TokenNameIdentifier	 delta
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
logicalBounds	TokenNameIdentifier	 logical Bounds
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
height	TokenNameIdentifier	 height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
tempLogicalBounds	TokenNameIdentifier	 temp Logical Bounds
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the metrics of the glyph at the specified index into this * GVTGlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the metrics of the glyph at the specified index into this GVTGlyphVector. 
public	TokenNamepublic	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
getGlyphMetrics	TokenNameIdentifier	 get Glyph Metrics
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// -- start glyph cache code -- 	TokenNameCOMMENT_LINE	-- start glyph cache code -- 
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AWTGlyphGeometryCache	TokenNameIdentifier	 AWT Glyph Geometry Cache
.	TokenNameDOT	
Value	TokenNameIdentifier	 Value
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
.	TokenNameDOT	
getGlyphGeometry	TokenNameIdentifier	 get Glyph Geometry
(	TokenNameLPAREN	
gvtFont	TokenNameIdentifier	 gvt Font
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
,	TokenNameCOMMA	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
glyphPos	TokenNameIdentifier	 glyph Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
gmB	TokenNameIdentifier	 gm B
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// -- end glyph cache code -- 	TokenNameCOMMENT_LINE	-- end glyph cache code -- 
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
gmB	TokenNameIdentifier	 gm B
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
gmB	TokenNameIdentifier	 gm B
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
gmB	TokenNameIdentifier	 gm B
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
gmB	TokenNameIdentifier	 gm B
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// defaultGlyphPositions has one more entry than glyphs 	TokenNameCOMMENT_LINE	defaultGlyphPositions has one more entry than glyphs 
// the last entry stores the total advance for the 	TokenNameCOMMENT_LINE	the last entry stores the total advance for the 
// glyphVector. 	TokenNameCOMMENT_LINE	glyphVector. 
float	TokenNamefloat	
adv	TokenNameIdentifier	 adv
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
GVTGlyphMetrics	TokenNameIdentifier	 GVT Glyph Metrics
(	TokenNameLPAREN	
adv	TokenNameIdentifier	 adv
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
(	TokenNameLPAREN	
ascent	TokenNameIdentifier	 ascent
+	TokenNamePLUS	
descent	TokenNameIdentifier	 descent
)	TokenNameRPAREN	
,	TokenNameCOMMA	
bounds	TokenNameIdentifier	 bounds
,	TokenNameCOMMA	
GlyphMetrics	TokenNameIdentifier	 Glyph Metrics
.	TokenNameDOT	
STANDARD	TokenNameIdentifier	 STANDARD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a Shape whose interior corresponds to the visual representation * of the specified glyph within this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns a Shape whose interior corresponds to the visual representation of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getGlyphOutline	TokenNameIdentifier	 get Glyph Outline
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Shape glyphOutline = awtGlyphVector.getGlyphOutline(glyphIndex); */	TokenNameCOMMENT_BLOCK	 Shape glyphOutline = awtGlyphVector.getGlyphOutline(glyphIndex); 
// -- start glyph cache code -- 	TokenNameCOMMENT_LINE	-- start glyph cache code -- 
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AWTGlyphGeometryCache	TokenNameIdentifier	 AWT Glyph Geometry Cache
.	TokenNameDOT	
Value	TokenNameIdentifier	 Value
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
.	TokenNameDOT	
getGlyphGeometry	TokenNameIdentifier	 get Glyph Geometry
(	TokenNameLPAREN	
gvtFont	TokenNameIdentifier	 gvt Font
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
,	TokenNameCOMMA	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
glyphPos	TokenNameIdentifier	 glyph Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Shape	TokenNameIdentifier	 Shape
glyphOutline	TokenNameIdentifier	 glyph Outline
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// -- end glyph cache code -- 	TokenNameCOMMENT_LINE	-- end glyph cache code -- 
AffineTransform	TokenNameIdentifier	 Affine Transform
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// <!> HACK 	TokenNameCOMMENT_LINE	<!> HACK 
// 	TokenNameCOMMENT_LINE	 
// GlyphVector.getGlyphOutline behavior changes between 1.3 and 1.4 	TokenNameCOMMENT_LINE	GlyphVector.getGlyphOutline behavior changes between 1.3 and 1.4 
// 	TokenNameCOMMENT_LINE	 
// I've looked at this problem a bit more and the incorrect glyph 	TokenNameCOMMENT_LINE	I've looked at this problem a bit more and the incorrect glyph 
// positioning in Batik is definitely due to the change in 	TokenNameCOMMENT_LINE	positioning in Batik is definitely due to the change in 
// behavior of GlyphVector.getGlyphOutline(glyphIndex). It used to 	TokenNameCOMMENT_LINE	behavior of GlyphVector.getGlyphOutline(glyphIndex). It used to 
// return the outline of the glyph at position 0,0 which meant 	TokenNameCOMMENT_LINE	return the outline of the glyph at position 0,0 which meant 
// that we had to translate it to the actual glyph position before 	TokenNameCOMMENT_LINE	that we had to translate it to the actual glyph position before 
// drawing it. Now, it returns the outline which has already been 	TokenNameCOMMENT_LINE	drawing it. Now, it returns the outline which has already been 
// positioned. 	TokenNameCOMMENT_LINE	positioned. 
// 	TokenNameCOMMENT_LINE	 
// -- Bella 	TokenNameCOMMENT_LINE	-- Bella 
// 	TokenNameCOMMENT_LINE	 
/* if (outlinesPositioned()) { Point2D glyphPos = defaultGlyphPositions[glyphIndex]; tr.translate(-glyphPos.getX(), -glyphPos.getY()); } */	TokenNameCOMMENT_BLOCK	 if (outlinesPositioned()) { Point2D glyphPos = defaultGlyphPositions[glyphIndex]; tr.translate(-glyphPos.getX(), -glyphPos.getY()); } 
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
scale	TokenNameIdentifier	 scale
(	TokenNameLPAREN	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
glyphOutline	TokenNameIdentifier	 glyph Outline
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This is true if GlyphVector.getGlyphOutline returns glyph outlines 	TokenNameCOMMENT_LINE	This is true if GlyphVector.getGlyphOutline returns glyph outlines 
// that are positioned (if it is false the outlines are always at 0,0). 	TokenNameCOMMENT_LINE	that are positioned (if it is false the outlines are always at 0,0). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
;	TokenNameSEMICOLON	
// This is true if Graphics2D.drawGlyphVector works for the 	TokenNameCOMMENT_LINE	This is true if Graphics2D.drawGlyphVector works for the 
// current JDK/OS combination. 	TokenNameCOMMENT_LINE	current JDK/OS combination. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
drawGlyphVectorWorks	TokenNameIdentifier	 draw Glyph Vector Works
;	TokenNameSEMICOLON	
// This is true if Graphics2D.drawGlyphVector will correctly 	TokenNameCOMMENT_LINE	This is true if Graphics2D.drawGlyphVector will correctly 
// render Glyph Vectors with per glyph transforms. 	TokenNameCOMMENT_LINE	render Glyph Vectors with per glyph transforms. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
glyphVectorTransformWorks	TokenNameIdentifier	 glyph Vector Transform Works
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"java.specification.version"	TokenNameStringLiteral	java.specification.version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
"1.4"	TokenNameStringLiteral	1.4
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
drawGlyphVectorWorks	TokenNameIdentifier	 draw Glyph Vector Works
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
glyphVectorTransformWorks	TokenNameIdentifier	 glyph Vector Transform Works
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"Mac OS X"	TokenNameStringLiteral	Mac OS X
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"os.name"	TokenNameStringLiteral	os.name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
drawGlyphVectorWorks	TokenNameIdentifier	 draw Glyph Vector Works
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
glyphVectorTransformWorks	TokenNameIdentifier	 glyph Vector Transform Works
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
drawGlyphVectorWorks	TokenNameIdentifier	 draw Glyph Vector Works
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
glyphVectorTransformWorks	TokenNameIdentifier	 glyph Vector Transform Works
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Returns true if GlyphVector.getGlyphOutlines returns glyph outlines 	TokenNameCOMMENT_LINE	Returns true if GlyphVector.getGlyphOutlines returns glyph outlines 
// that are positioned (otherwise they are always at 0,0). 	TokenNameCOMMENT_LINE	that are positioned (otherwise they are always at 0,0). 
static	TokenNamestatic	
boolean	TokenNameboolean	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
outlinesPositioned	TokenNameIdentifier	 outlines Positioned
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the bounding box of the specified glyph, considering only the * glyph's metrics (ascent, descent, advance) rather than the actual glyph * shape. */	TokenNameCOMMENT_JAVADOC	 Returns the bounding box of the specified glyph, considering only the glyph's metrics (ascent, descent, advance) rather than the actual glyph shape. 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getGlyphCellBounds	TokenNameIdentifier	 get Glyph Cell Bounds
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getGlyphLogicalBounds	TokenNameIdentifier	 get Glyph Logical Bounds
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the position of the specified glyph within this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the position of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
Point2D	TokenNameIdentifier	 Point2 D
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns an array of glyph positions for the specified glyphs */	TokenNameCOMMENT_JAVADOC	 Returns an array of glyph positions for the specified glyphs 
public	TokenNamepublic	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getGlyphPositions	TokenNameIdentifier	 get Glyph Positions
(	TokenNameLPAREN	
int	TokenNameint	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
,	TokenNameCOMMA	
int	TokenNameint	
numEntries	TokenNameIdentifier	 num Entries
,	TokenNameCOMMA	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
positionReturn	TokenNameIdentifier	 position Return
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
positionReturn	TokenNameIdentifier	 position Return
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positionReturn	TokenNameIdentifier	 position Return
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
numEntries	TokenNameIdentifier	 num Entries
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
+	TokenNamePLUS	
numEntries	TokenNameIdentifier	 num Entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
positionReturn	TokenNameIdentifier	 position Return
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
positionReturn	TokenNameIdentifier	 position Return
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
beginGlyphIndex	TokenNameIdentifier	 begin Glyph Index
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
positionReturn	TokenNameIdentifier	 position Return
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets the transform of the specified glyph within this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Gets the transform of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
AffineTransform	TokenNameIdentifier	 Affine Transform
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the visual bounds of the specified glyph within the GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the visual bounds of the specified glyph within the GlyphVector. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getGlyphVisualBounds	TokenNameIdentifier	 get Glyph Visual Bounds
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Shape glyphOutline = awtGlyphVector.getGlyphOutline(glyphIndex); Rectangle2D glyphBounds = glyphOutline.getBounds2D(); */	TokenNameCOMMENT_BLOCK	 Shape glyphOutline = awtGlyphVector.getGlyphOutline(glyphIndex); Rectangle2D glyphBounds = glyphOutline.getBounds2D(); 
// -- start glyph cache code -- 	TokenNameCOMMENT_LINE	-- start glyph cache code -- 
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AWTGlyphGeometryCache	TokenNameIdentifier	 AWT Glyph Geometry Cache
.	TokenNameDOT	
Value	TokenNameIdentifier	 Value
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
AWTGVTFont	TokenNameIdentifier	 AWTGVT Font
.	TokenNameDOT	
getGlyphGeometry	TokenNameIdentifier	 get Glyph Geometry
(	TokenNameLPAREN	
gvtFont	TokenNameIdentifier	 gvt Font
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
,	TokenNameCOMMA	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
glyphPos	TokenNameIdentifier	 glyph Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
glyphBounds	TokenNameIdentifier	 glyph Bounds
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
getOutlineBounds2D	TokenNameIdentifier	 get Outline Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// -- end glyph cache code -- 	TokenNameCOMMENT_LINE	-- end glyph cache code -- 
AffineTransform	TokenNameIdentifier	 Affine Transform
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
glyphTransform	TokenNameIdentifier	 glyph Transform
=	TokenNameEQUAL	
getGlyphTransform	TokenNameIdentifier	 get Glyph Transform
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
concatenate	TokenNameIdentifier	 concatenate
(	TokenNameLPAREN	
glyphTransform	TokenNameIdentifier	 glyph Transform
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
scale	TokenNameIdentifier	 scale
(	TokenNameLPAREN	
scaleFactor	TokenNameIdentifier	 scale Factor
,	TokenNameCOMMA	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
glyphBounds	TokenNameIdentifier	 glyph Bounds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the number of glyphs in this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the number of glyphs in this GlyphVector. 
public	TokenNamepublic	
int	TokenNameint	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a Shape whose interior corresponds to the visual representation * of this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns a Shape whose interior corresponds to the visual representation of this GlyphVector. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
outline	TokenNameIdentifier	 outline
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
new	TokenNamenew	
GeneralPath	TokenNameIdentifier	 General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
glyphOutline	TokenNameIdentifier	 glyph Outline
=	TokenNameEQUAL	
getGlyphOutline	TokenNameIdentifier	 get Glyph Outline
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
glyphOutline	TokenNameIdentifier	 glyph Outline
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
outline	TokenNameIdentifier	 outline
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a Shape whose interior corresponds to the visual representation * of this GlyphVector, offset to x, y. */	TokenNameCOMMENT_JAVADOC	 Returns a Shape whose interior corresponds to the visual representation of this GlyphVector, offset to x, y. 
public	TokenNamepublic	
Shape	TokenNameIdentifier	 Shape
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
float	TokenNamefloat	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
float	TokenNamefloat	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
tr	TokenNameIdentifier	 tr
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
getTranslateInstance	TokenNameIdentifier	 get Translate Instance
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
tr	TokenNameIdentifier	 tr
.	TokenNameDOT	
createTransformedShape	TokenNameIdentifier	 create Transformed Shape
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
outline	TokenNameIdentifier	 outline
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the visual bounds of this GlyphVector The visual bounds is the * tightest rectangle enclosing all non-background pixels in the rendered * representation of this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Returns the visual bounds of this GlyphVector The visual bounds is the tightest rectangle enclosing all non-background pixels in the rendered representation of this GlyphVector. 
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getGeometricBounds	TokenNameIdentifier	 get Geometric Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
visualBounds	TokenNameIdentifier	 visual Bounds
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
outline	TokenNameIdentifier	 outline
.	TokenNameDOT	
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
visualBounds	TokenNameIdentifier	 visual Bounds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Assigns default positions to each glyph in this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Assigns default positions to each glyph in this GlyphVector. 
public	TokenNamepublic	
void	TokenNamevoid	
performDefaultLayout	TokenNameIdentifier	 perform Default Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
performDefaultLayout	TokenNameIdentifier	 perform Default Layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
[	TokenNameLBRACKET	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
shiftLeft	TokenNameIdentifier	 shift Left
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
-	TokenNameMINUS	
shiftLeft	TokenNameIdentifier	 shift Left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if c is a transparent arabic char then need to shift the 	TokenNameCOMMENT_LINE	if c is a transparent arabic char then need to shift the 
// following glyphs left so that the current glyph is overwritten 	TokenNameCOMMENT_LINE	following glyphs left so that the current glyph is overwritten 
/*char c =*/	TokenNameCOMMENT_BLOCK	char c =
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* if (ArabicTextHandler.arabicCharTransparent(c)) { int j; shiftLeft += getGlyphMetrics(i).getHorizontalAdvance(); for (j=i+1; j<getNumGlyphs(); j++) { char c2 = ci.setIndex(j+ci.getBeginIndex()); if (!ArabicTextHandler.arabicCharTransparent(c2)) break; shiftLeft += getGlyphMetrics(j).getHorizontalAdvance(); } if (j != getNumGlyphs()) { Point2D glyphPosBase = defaultGlyphPositions[j]; double rEdge = glyphPosBase.getX()+getGlyphMetrics(j).getHorizontalAdvance(); rEdge -= shiftLeft; for (int k=i; k<j; k++) { glyphTransforms [k] = null; glyphVisualBounds [k] = null; glyphLogicalBounds[k] = null; glyphOutlines [k] = null; glyphMetrics [k] = null; x = (float)rEdge-getGlyphMetrics(k).getHorizontalAdvance(); y = (float) (defaultGlyphPositions[k].getY() * scaleFactor); if (glyphPositions[k] == null) { glyphPositions[k] = new Point2D.Float(x,y); } else { glyphPositions[k].x = x; glyphPositions[k].y = y; } } i = j-1; } } else { */	TokenNameCOMMENT_BLOCK	 if (ArabicTextHandler.arabicCharTransparent(c)) { int j; shiftLeft += getGlyphMetrics(i).getHorizontalAdvance(); for (j=i+1; j<getNumGlyphs(); j++) { char c2 = ci.setIndex(j+ci.getBeginIndex()); if (!ArabicTextHandler.arabicCharTransparent(c2)) break; shiftLeft += getGlyphMetrics(j).getHorizontalAdvance(); } if (j != getNumGlyphs()) { Point2D glyphPosBase = defaultGlyphPositions[j]; double rEdge = glyphPosBase.getX()+getGlyphMetrics(j).getHorizontalAdvance(); rEdge -= shiftLeft; for (int k=i; k<j; k++) { glyphTransforms [k] = null; glyphVisualBounds [k] = null; glyphLogicalBounds[k] = null; glyphOutlines [k] = null; glyphMetrics [k] = null; x = (float)rEdge-getGlyphMetrics(k).getHorizontalAdvance(); y = (float) (defaultGlyphPositions[k].getY() scaleFactor); if (glyphPositions[k] == null) { glyphPositions[k] = new Point2D.Float(x,y); } else { glyphPositions[k].x = x; glyphPositions[k].y = y; } } i = j-1; } } else { 
if	TokenNameif	
(	TokenNameLPAREN	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
y	TokenNameIdentifier	 y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// } 	TokenNameCOMMENT_LINE	} 
}	TokenNameRBRACE	
// Need glyph pos for point after last char... 	TokenNameCOMMENT_LINE	Need glyph pos for point after last char... 
Point2D	TokenNameIdentifier	 Point2 D
glyphPos	TokenNameIdentifier	 glyph Pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
-	TokenNameMINUS	
shiftLeft	TokenNameIdentifier	 shift Left
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
glyphPos	TokenNameIdentifier	 glyph Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
scaleFactor	TokenNameIdentifier	 scale Factor
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the position of the specified glyph within this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Sets the position of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
void	TokenNamevoid	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
Point2D	TokenNameIdentifier	 Point2 D
newPos	TokenNameIdentifier	 new Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
newPos	TokenNameIdentifier	 new Pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
newPos	TokenNameIdentifier	 new Pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
glyphIndex	TokenNameIdentifier	 glyph Index
!=	TokenNameNOT_EQUAL	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets the transform of the specified glyph within this GlyphVector. */	TokenNameCOMMENT_JAVADOC	 Sets the transform of the specified glyph within this GlyphVector. 
public	TokenNamepublic	
void	TokenNamevoid	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
AffineTransform	TokenNameIdentifier	 Affine Transform
newTX	TokenNameIdentifier	 new TX
)	TokenNameRPAREN	
{	TokenNameLBRACE	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
newTX	TokenNameIdentifier	 new TX
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tells the glyph vector whether or not to draw the specified glyph. */	TokenNameCOMMENT_JAVADOC	 Tells the glyph vector whether or not to draw the specified glyph. 
public	TokenNamepublic	
void	TokenNamevoid	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
,	TokenNameCOMMA	
boolean	TokenNameboolean	
visible	TokenNameIdentifier	 visible
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
visible	TokenNameIdentifier	 visible
==	TokenNameEQUAL_EQUAL	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
visible	TokenNameIdentifier	 visible
;	TokenNameSEMICOLON	
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
visualBounds	TokenNameIdentifier	 visual Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logicalBounds	TokenNameIdentifier	 logical Bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
bounds2D	TokenNameIdentifier	 bounds2 D
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphVisualBounds	TokenNameIdentifier	 glyph Visual Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphLogicalBounds	TokenNameIdentifier	 glyph Logical Bounds
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphOutlines	TokenNameIdentifier	 glyph Outlines
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
glyphMetrics	TokenNameIdentifier	 glyph Metrics
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if specified glyph will be rendered. */	TokenNameCOMMENT_JAVADOC	 Returns true if specified glyph will be rendered. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isGlyphVisible	TokenNameIdentifier	 is Glyph Visible
(	TokenNameLPAREN	
int	TokenNameint	
glyphIndex	TokenNameIdentifier	 glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
glyphIndex	TokenNameIdentifier	 glyph Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the number of chars represented by the glyphs within the * specified range. * * @param startGlyphIndex The index of the first glyph in the range. * @param endGlyphIndex The index of the last glyph in the range. * @return The number of chars. */	TokenNameCOMMENT_JAVADOC	 Returns the number of chars represented by the glyphs within the specified range. * @param startGlyphIndex The index of the first glyph in the range. @param endGlyphIndex The index of the last glyph in the range. @return The number of chars. 
public	TokenNamepublic	
int	TokenNameint	
getCharacterCount	TokenNameIdentifier	 get Character Count
(	TokenNameLPAREN	
int	TokenNameint	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
,	TokenNameCOMMA	
int	TokenNameint	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
>=	TokenNameGREATER_EQUAL	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
=	TokenNameEQUAL	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
charCount	TokenNameIdentifier	 char Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
startGlyphIndex	TokenNameIdentifier	 start Glyph Index
+	TokenNamePLUS	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
endGlyphIndex	TokenNameIdentifier	 end Glyph Index
+	TokenNamePLUS	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getBeginIndex	TokenNameIdentifier	 get Begin Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
setIndex	TokenNameIdentifier	 set Index
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
charCount	TokenNameIdentifier	 char Count
+=	TokenNamePLUS_EQUAL	
ArabicTextHandler	TokenNameIdentifier	 Arabic Text Handler
.	TokenNameDOT	
getNumChars	TokenNameIdentifier	 get Num Chars
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
charCount	TokenNameIdentifier	 char Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Draws this glyph vector. */	TokenNameCOMMENT_JAVADOC	 Draws this glyph vector. 
public	TokenNamepublic	
void	TokenNamevoid	
draw	TokenNameIdentifier	 draw
(	TokenNameLPAREN	
Graphics2D	TokenNameIdentifier	 Graphics2 D
graphics2D	TokenNameIdentifier	 graphics2 D
,	TokenNameCOMMA	
AttributedCharacterIterator	TokenNameIdentifier	 Attributed Character Iterator
aci	TokenNameIdentifier	 aci
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
=	TokenNameEQUAL	
getNumGlyphs	TokenNameIdentifier	 get Num Glyphs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
tpi	TokenNameIdentifier	 tpi
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TextPaintInfo	TokenNameIdentifier	 Text Paint Info
)	TokenNameRPAREN	
aci	TokenNameIdentifier	 aci
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
GVTAttributedCharacterIterator	TokenNameIdentifier	 GVT Attributed Character Iterator
.	TokenNameDOT	
TextAttribute	TokenNameIdentifier	 Text Attribute
.	TokenNameDOT	
PAINT_INFO	TokenNameIdentifier	 PAINT  INFO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tpi	TokenNameIdentifier	 tpi
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
visible	TokenNameIdentifier	 visible
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Paint	TokenNameIdentifier	 Paint
fillPaint	TokenNameIdentifier	 fill Paint
=	TokenNameEQUAL	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
fillPaint	TokenNameIdentifier	 fill Paint
;	TokenNameSEMICOLON	
Stroke	TokenNameIdentifier	 Stroke
stroke	TokenNameIdentifier	 stroke
=	TokenNameEQUAL	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
strokeStroke	TokenNameIdentifier	 stroke Stroke
;	TokenNameSEMICOLON	
Paint	TokenNameIdentifier	 Paint
strokePaint	TokenNameIdentifier	 stroke Paint
=	TokenNameEQUAL	
tpi	TokenNameIdentifier	 tpi
.	TokenNameDOT	
strokePaint	TokenNameIdentifier	 stroke Paint
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
strokePaint	TokenNameIdentifier	 stroke Paint
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
stroke	TokenNameIdentifier	 stroke
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
drawGlyphVectorWorks	TokenNameIdentifier	 draw Glyph Vector Works
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
stroke	TokenNameIdentifier	 stroke
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
strokePaint	TokenNameIdentifier	 stroke Paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// Can't stroke with drawGlyphVector. 	TokenNameCOMMENT_LINE	Can't stroke with drawGlyphVector. 
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
instanceof	TokenNameinstanceof	
Color	TokenNameIdentifier	 Color
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// The coordinate system is different for drawGlyphVector. 	TokenNameCOMMENT_LINE	The coordinate system is different for drawGlyphVector. 
// So complex paints aren't positioned properly. 	TokenNameCOMMENT_LINE	So complex paints aren't positioned properly. 
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
v1	TokenNameIdentifier	 v1
=	TokenNameEQUAL	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
getRenderingHint	TokenNameIdentifier	 get Rendering Hint
(	TokenNameLPAREN	
RenderingHints	TokenNameIdentifier	 Rendering Hints
.	TokenNameDOT	
KEY_TEXT_ANTIALIASING	TokenNameIdentifier	 KEY  TEXT  ANTIALIASING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
v2	TokenNameIdentifier	 v2
=	TokenNameEQUAL	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
getRenderingHint	TokenNameIdentifier	 get Rendering Hint
(	TokenNameLPAREN	
RenderingHints	TokenNameIdentifier	 Rendering Hints
.	TokenNameDOT	
KEY_STROKE_CONTROL	TokenNameIdentifier	 KEY  STROKE  CONTROL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// text-rendering = geometricPrecision so fill shapes. 	TokenNameCOMMENT_LINE	text-rendering = geometricPrecision so fill shapes. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
v1	TokenNameIdentifier	 v1
==	TokenNameEQUAL_EQUAL	
RenderingHints	TokenNameIdentifier	 Rendering Hints
.	TokenNameDOT	
VALUE_TEXT_ANTIALIAS_ON	TokenNameIdentifier	 VALUE  TEXT  ANTIALIAS  ON
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
v2	TokenNameIdentifier	 v2
==	TokenNameEQUAL_EQUAL	
RenderingHints	TokenNameIdentifier	 Rendering Hints
.	TokenNameDOT	
VALUE_STROKE_PURE	TokenNameIdentifier	 VALUE  STROKE  PURE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
typeGRot	TokenNameIdentifier	 type G Rot
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
TYPE_GENERAL_ROTATION	TokenNameIdentifier	 TYPE  GENERAL  ROTATION
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
typeGTrans	TokenNameIdentifier	 type G Trans
=	TokenNameEQUAL	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
TYPE_GENERAL_TRANSFORM	TokenNameIdentifier	 TYPE  GENERAL  TRANSFORM
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check if usr->dev transform has general rotation, 	TokenNameCOMMENT_LINE	Check if usr->dev transform has general rotation, 
// or shear.. 	TokenNameCOMMENT_LINE	or shear.. 
AffineTransform	TokenNameIdentifier	 Affine Transform
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
getTransform	TokenNameIdentifier	 get Transform
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
&	TokenNameAND	
typeGTrans	TokenNameIdentifier	 type G Trans
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
&	TokenNameAND	
typeGRot	TokenNameIdentifier	 type G Rot
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
glyphVisible	TokenNameIdentifier	 glyph Visible
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
AffineTransform	TokenNameIdentifier	 Affine Transform
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
at	TokenNameIdentifier	 at
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
&	TokenNameAND	
~	TokenNameTWIDDLE	
AffineTransform	TokenNameIdentifier	 Affine Transform
.	TokenNameDOT	
TYPE_TRANSLATION	TokenNameIdentifier	 TYPE  TRANSLATION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Just translation 	TokenNameCOMMENT_LINE	Just translation 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
glyphVectorTransformWorks	TokenNameIdentifier	 glyph Vector Transform Works
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
&	TokenNameAND	
typeGTrans	TokenNameIdentifier	 type G Trans
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
&	TokenNameAND	
typeGRot	TokenNameIdentifier	 type G Rot
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// It's a simple 90Deg rotate, and we can put 	TokenNameCOMMENT_LINE	It's a simple 90Deg rotate, and we can put 
// it into the GlyphVector. 	TokenNameCOMMENT_LINE	it into the GlyphVector. 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// we can't (or it doesn't make sense 	TokenNameCOMMENT_LINE	we can't (or it doesn't make sense 
// to use the GlyphVector. 	TokenNameCOMMENT_LINE	to use the GlyphVector. 
useHinting	TokenNameIdentifier	 use Hinting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useHinting	TokenNameIdentifier	 use Hinting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
sf	TokenNameIdentifier	 sf
=	TokenNameEQUAL	
scaleFactor	TokenNameIdentifier	 scale Factor
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
mat	TokenNameIdentifier	 mat
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
glyphPositions	TokenNameIdentifier	 glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AffineTransform	TokenNameIdentifier	 Affine Transform
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
glyphTransforms	TokenNameIdentifier	 glyph Transforms
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
at	TokenNameIdentifier	 at
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Scale the translate portion of matrix, 	TokenNameCOMMENT_LINE	Scale the translate portion of matrix, 
// and add it into the position. 	TokenNameCOMMENT_LINE	and add it into the position. 
at	TokenNameIdentifier	 at
.	TokenNameDOT	
getMatrix	TokenNameIdentifier	 get Matrix
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
x	TokenNameIdentifier	 x
+=	TokenNamePLUS_EQUAL	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
y	TokenNameIdentifier	 y
+=	TokenNamePLUS_EQUAL	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// More than just translation. 	TokenNameCOMMENT_LINE	More than just translation. 
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
mat	TokenNameIdentifier	 mat
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
new	TokenNamenew	
AffineTransform	TokenNameIdentifier	 Affine Transform
(	TokenNameLPAREN	
mat	TokenNameIdentifier	 mat
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
at	TokenNameIdentifier	 at
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
/	TokenNameDIVIDE	
sf	TokenNameIdentifier	 sf
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
/	TokenNameDIVIDE	
sf	TokenNameIdentifier	 sf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
at	TokenNameIdentifier	 at
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
scale	TokenNameIdentifier	 scale
(	TokenNameLPAREN	
sf	TokenNameIdentifier	 sf
,	TokenNameCOMMA	
sf	TokenNameIdentifier	 sf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
setPaint	TokenNameIdentifier	 set Paint
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
drawGlyphVector	TokenNameIdentifier	 draw Glyph Vector
(	TokenNameLPAREN	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
scale	TokenNameIdentifier	 scale
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
sf	TokenNameIdentifier	 sf
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
sf	TokenNameIdentifier	 sf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
defaultGlyphPositions	TokenNameIdentifier	 default Glyph Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
awtGlyphVector	TokenNameIdentifier	 awt Glyph Vector
.	TokenNameDOT	
setGlyphTransform	TokenNameIdentifier	 set Glyph Transform
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Shape	TokenNameIdentifier	 Shape
outline	TokenNameIdentifier	 outline
=	TokenNameEQUAL	
getOutline	TokenNameIdentifier	 get Outline
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// check if we need to fill this glyph 	TokenNameCOMMENT_LINE	check if we need to fill this glyph 
if	TokenNameif	
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
setPaint	TokenNameIdentifier	 set Paint
(	TokenNameLPAREN	
fillPaint	TokenNameIdentifier	 fill Paint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
fill	TokenNameIdentifier	 fill
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check if we need to draw the outline of this glyph 	TokenNameCOMMENT_LINE	check if we need to draw the outline of this glyph 
if	TokenNameif	
(	TokenNameLPAREN	
stroke	TokenNameIdentifier	 stroke
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
strokePaint	TokenNameIdentifier	 stroke Paint
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
setStroke	TokenNameIdentifier	 set Stroke
(	TokenNameLPAREN	
stroke	TokenNameIdentifier	 stroke
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
setPaint	TokenNameIdentifier	 set Paint
(	TokenNameLPAREN	
strokePaint	TokenNameIdentifier	 stroke Paint
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
graphics2D	TokenNameIdentifier	 graphics2 D
.	TokenNameDOT	
draw	TokenNameIdentifier	 draw
(	TokenNameLPAREN	
outline	TokenNameIdentifier	 outline
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
