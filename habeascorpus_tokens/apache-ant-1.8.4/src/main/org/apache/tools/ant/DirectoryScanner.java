/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LinkedList	TokenNameIdentifier	 Linked List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
.	TokenNameDOT	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
Os	TokenNameIdentifier	 Os
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Resource	TokenNameIdentifier	 Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceFactory	TokenNameIdentifier	 Resource Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileResource	TokenNameIdentifier	 File Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
FileSelector	TokenNameIdentifier	 File Selector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
SelectorScanner	TokenNameIdentifier	 Selector Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
SelectorUtils	TokenNameIdentifier	 Selector Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
CollectionUtils	TokenNameIdentifier	 Collection Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolicLinkUtils	TokenNameIdentifier	 Symbolic Link Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
VectorSet	TokenNameIdentifier	 Vector Set
;	TokenNameSEMICOLON	
/** * Class for scanning a directory for files/directories which match certain * criteria. * <p> * These criteria consist of selectors and patterns which have been specified. * With the selectors you can select which files you want to have included. * Files which are not selected are excluded. With patterns you can include * or exclude files based on their filename. * <p> * The idea is simple. A given directory is recursively scanned for all files * and directories. Each file/directory is matched against a set of selectors, * including special support for matching against filenames with include and * and exclude patterns. Only files/directories which match at least one * pattern of the include pattern list or other file selector, and don't match * any pattern of the exclude pattern list or fail to match against a required * selector will be placed in the list of files/directories found. * <p> * When no list of include patterns is supplied, "**" will be used, which * means that everything will be matched. When no list of exclude patterns is * supplied, an empty list is used, such that nothing will be excluded. When * no selectors are supplied, none are applied. * <p> * The filename pattern matching is done as follows: * The name to be matched is split up in path segments. A path segment is the * name of a directory or file, which is bounded by * <code>File.separator</code> ('/' under UNIX, '\' under Windows). * For example, "abc/def/ghi/xyz.java" is split up in the segments "abc", * "def","ghi" and "xyz.java". * The same is done for the pattern against which should be matched. * <p> * The segments of the name and the pattern are then matched against each * other. When '**' is used for a path segment in the pattern, it matches * zero or more path segments of the name. * <p> * There is a special case regarding the use of <code>File.separator</code>s * at the beginning of the pattern and the string to match:<br> * When a pattern starts with a <code>File.separator</code>, the string * to match must also start with a <code>File.separator</code>. * When a pattern does not start with a <code>File.separator</code>, the * string to match may not start with a <code>File.separator</code>. * When one of these rules is not obeyed, the string will not * match. * <p> * When a name path segment is matched against a pattern path segment, the * following special characters can be used:<br> * '*' matches zero or more characters<br> * '?' matches one character. * <p> * Examples: * <p> * "**\*.class" matches all .class files/dirs in a directory tree. * <p> * "test\a??.java" matches all files/dirs which start with an 'a', then two * more characters and then ".java", in a directory called test. * <p> * "**" matches everything in a directory tree. * <p> * "**\test\**\XYZ*" matches all files/dirs which start with "XYZ" and where * there is a parent directory called test (e.g. "abc\test\def\ghi\XYZ123"). * <p> * Case sensitivity may be turned off if necessary. By default, it is * turned on. * <p> * Example of usage: * <pre> * String[] includes = {"**\\*.class"}; * String[] excludes = {"modules\\*\\**"}; * ds.setIncludes(includes); * ds.setExcludes(excludes); * ds.setBasedir(new File("test")); * ds.setCaseSensitive(true); * ds.scan(); * * System.out.println("FILES:"); * String[] files = ds.getIncludedFiles(); * for (int i = 0; i < files.length; i++) { * System.out.println(files[i]); * } * </pre> * This will scan a directory called test for .class files, but excludes all * files in all proper subdirectories of a directory called "modules" * */	TokenNameCOMMENT_JAVADOC	 Class for scanning a directory for files/directories which match certain criteria. <p> These criteria consist of selectors and patterns which have been specified. With the selectors you can select which files you want to have included. Files which are not selected are excluded. With patterns you can include or exclude files based on their filename. <p> The idea is simple. A given directory is recursively scanned for all files and directories. Each file/directory is matched against a set of selectors, including special support for matching against filenames with include and and exclude patterns. Only files/directories which match at least one pattern of the include pattern list or other file selector, and don't match any pattern of the exclude pattern list or fail to match against a required selector will be placed in the list of files/directories found. <p> When no list of include patterns is supplied, "**" will be used, which means that everything will be matched. When no list of exclude patterns is supplied, an empty list is used, such that nothing will be excluded. When no selectors are supplied, none are applied. <p> The filename pattern matching is done as follows: The name to be matched is split up in path segments. A path segment is the name of a directory or file, which is bounded by <code>File.separator</code> ('/' under UNIX, '\' under Windows). For example, "abc/def/ghi/xyz.java" is split up in the segments "abc", "def","ghi" and "xyz.java". The same is done for the pattern against which should be matched. <p> The segments of the name and the pattern are then matched against each other. When '**' is used for a path segment in the pattern, it matches zero or more path segments of the name. <p> There is a special case regarding the use of <code>File.separator</code>s at the beginning of the pattern and the string to match:<br> When a pattern starts with a <code>File.separator</code>, the string to match must also start with a <code>File.separator</code>. When a pattern does not start with a <code>File.separator</code>, the string to match may not start with a <code>File.separator</code>. When one of these rules is not obeyed, the string will not match. <p> When a name path segment is matched against a pattern path segment, the following special characters can be used:<br> '*' matches zero or more characters<br> '?' matches one character. <p> Examples: <p> "**\*.class" matches all .class files/dirs in a directory tree. <p> "test\a??.java" matches all files/dirs which start with an 'a', then two more characters and then ".java", in a directory called test. <p> "**" matches everything in a directory tree. <p> "**\test\**\XYZ*" matches all files/dirs which start with "XYZ" and where there is a parent directory called test (e.g. "abc\test\def\ghi\XYZ123"). <p> Case sensitivity may be turned off if necessary. By default, it is turned on. <p> Example of usage: <pre> String[] includes = {"**\\*.class"}; String[] excludes = {"modules\\*\\**"}; ds.setIncludes(includes); ds.setExcludes(excludes); ds.setBasedir(new File("test")); ds.setCaseSensitive(true); ds.scan(); * System.out.println("FILES:"); String[] files = ds.getIncludedFiles(); for (int i = 0; i < files.length; i++) { System.out.println(files[i]); } </pre> This will scan a directory called test for .class files, but excludes all files in all proper subdirectories of a directory called "modules" 
public	TokenNamepublic	
class	TokenNameclass	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
implements	TokenNameimplements	
FileScanner	TokenNameIdentifier	 File Scanner
,	TokenNameCOMMA	
SelectorScanner	TokenNameIdentifier	 Selector Scanner
,	TokenNameCOMMA	
ResourceFactory	TokenNameIdentifier	 Resource Factory
{	TokenNameLBRACE	
/** Is OpenVMS the operating system we're running on? */	TokenNameCOMMENT_JAVADOC	 Is OpenVMS the operating system we're running on? 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
ON_VMS	TokenNameIdentifier	 ON  VMS
=	TokenNameEQUAL	
Os	TokenNameIdentifier	 Os
.	TokenNameDOT	
isFamily	TokenNameIdentifier	 is Family
(	TokenNameLPAREN	
"openvms"	TokenNameStringLiteral	openvms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Patterns which should be excluded by default. * * <p>Note that you can now add patterns to the list of default * excludes. Added patterns will not become part of this array * that has only been kept around for backwards compatibility * reasons.</p> * * @deprecated since 1.6.x. * Use the {@link #getDefaultExcludes getDefaultExcludes} * method instead. */	TokenNameCOMMENT_JAVADOC	 Patterns which should be excluded by default. * <p>Note that you can now add patterns to the list of default excludes. Added patterns will not become part of this array that has only been kept around for backwards compatibility reasons.</p> * @deprecated since 1.6.x. Use the {@link #getDefaultExcludes getDefaultExcludes} method instead. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
DEFAULTEXCLUDES	TokenNameIdentifier	 DEFAULTEXCLUDES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
// Miscellaneous typical temporary files 	TokenNameCOMMENT_LINE	Miscellaneous typical temporary files 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/*~"	TokenNameStringLiteral	/*~
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/#*#"	TokenNameStringLiteral	/#*#
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.#*"	TokenNameStringLiteral	/.#*
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/%*%"	TokenNameStringLiteral	/%*%
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/._*"	TokenNameStringLiteral	/._*
,	TokenNameCOMMA	
// CVS 	TokenNameCOMMENT_LINE	CVS 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/CVS"	TokenNameStringLiteral	/CVS
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/CVS/"	TokenNameStringLiteral	/CVS/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.cvsignore"	TokenNameStringLiteral	/.cvsignore
,	TokenNameCOMMA	
// SCCS 	TokenNameCOMMENT_LINE	SCCS 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/SCCS"	TokenNameStringLiteral	/SCCS
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/SCCS/"	TokenNameStringLiteral	/SCCS/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
// Visual SourceSafe 	TokenNameCOMMENT_LINE	Visual SourceSafe 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/vssver.scc"	TokenNameStringLiteral	/vssver.scc
,	TokenNameCOMMA	
// Subversion 	TokenNameCOMMENT_LINE	Subversion 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.svn"	TokenNameStringLiteral	/.svn
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.svn/"	TokenNameStringLiteral	/.svn/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
// Git 	TokenNameCOMMENT_LINE	Git 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.git"	TokenNameStringLiteral	/.git
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.git/"	TokenNameStringLiteral	/.git/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.gitattributes"	TokenNameStringLiteral	/.gitattributes
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.gitignore"	TokenNameStringLiteral	/.gitignore
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.gitmodules"	TokenNameStringLiteral	/.gitmodules
,	TokenNameCOMMA	
// Mercurial 	TokenNameCOMMENT_LINE	Mercurial 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hg"	TokenNameStringLiteral	/.hg
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hg/"	TokenNameStringLiteral	/.hg/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hgignore"	TokenNameStringLiteral	/.hgignore
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hgsub"	TokenNameStringLiteral	/.hgsub
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hgsubstate"	TokenNameStringLiteral	/.hgsubstate
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.hgtags"	TokenNameStringLiteral	/.hgtags
,	TokenNameCOMMA	
// Bazaar 	TokenNameCOMMENT_LINE	Bazaar 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.bzr"	TokenNameStringLiteral	/.bzr
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.bzr/"	TokenNameStringLiteral	/.bzr/
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
,	TokenNameCOMMA	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.bzrignore"	TokenNameStringLiteral	/.bzrignore
,	TokenNameCOMMA	
// Mac 	TokenNameCOMMENT_LINE	Mac 
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
+	TokenNamePLUS	
"/.DS_Store"	TokenNameStringLiteral	/.DS_Store
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * default value for {@link #maxLevelsOfSymlinks maxLevelsOfSymlinks} * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 default value for {@link #maxLevelsOfSymlinks maxLevelsOfSymlinks} @since Ant 1.8.0 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_LEVELS_OF_SYMLINKS	TokenNameIdentifier	 MAX  LEVELS  OF  SYMLINKS
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * The end of the exception message if something that should be * there doesn't exist. */	TokenNameCOMMENT_JAVADOC	 The end of the exception message if something that should be there doesn't exist. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DOES_NOT_EXIST_POSTFIX	TokenNameIdentifier	 DOES  NOT  EXIST  POSTFIX
=	TokenNameEQUAL	
" does not exist."	TokenNameStringLiteral	 does not exist.
;	TokenNameSEMICOLON	
/** Helper. */	TokenNameCOMMENT_JAVADOC	 Helper. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
FileUtils	TokenNameIdentifier	 File Utils
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Helper. */	TokenNameCOMMENT_JAVADOC	 Helper. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
SymbolicLinkUtils	TokenNameIdentifier	 Symbolic Link Utils
SYMLINK_UTILS	TokenNameIdentifier	 SYMLINK  UTILS
=	TokenNameEQUAL	
SymbolicLinkUtils	TokenNameIdentifier	 Symbolic Link Utils
.	TokenNameDOT	
getSymbolicLinkUtils	TokenNameIdentifier	 get Symbolic Link Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Patterns which should be excluded by default. * * @see #addDefaultExcludes() */	TokenNameCOMMENT_JAVADOC	 Patterns which should be excluded by default. * @see #addDefaultExcludes() 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
defaultExcludes	TokenNameIdentifier	 default Excludes
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
resetDefaultExcludes	TokenNameIdentifier	 reset Default Excludes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CheckStyle:VisibilityModifier OFF - bc 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier OFF - bc 
/** The base directory to be scanned. */	TokenNameCOMMENT_JAVADOC	 The base directory to be scanned. 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
basedir	TokenNameIdentifier	 basedir
;	TokenNameSEMICOLON	
/** The patterns for the files to be included. */	TokenNameCOMMENT_JAVADOC	 The patterns for the files to be included. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
includes	TokenNameIdentifier	 includes
;	TokenNameSEMICOLON	
/** The patterns for the files to be excluded. */	TokenNameCOMMENT_JAVADOC	 The patterns for the files to be excluded. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
excludes	TokenNameIdentifier	 excludes
;	TokenNameSEMICOLON	
/** Selectors that will filter which files are in our candidate list. */	TokenNameCOMMENT_JAVADOC	 Selectors that will filter which files are in our candidate list. 
protected	TokenNameprotected	
FileSelector	TokenNameIdentifier	 File Selector
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectors	TokenNameIdentifier	 selectors
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * The files which matched at least one include and no excludes * and were selected. */	TokenNameCOMMENT_JAVADOC	 The files which matched at least one include and no excludes and were selected. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
filesIncluded	TokenNameIdentifier	 files Included
;	TokenNameSEMICOLON	
/** The files which did not match any includes or selectors. */	TokenNameCOMMENT_JAVADOC	 The files which did not match any includes or selectors. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
filesNotIncluded	TokenNameIdentifier	 files Not Included
;	TokenNameSEMICOLON	
/** * The files which matched at least one include and at least * one exclude. */	TokenNameCOMMENT_JAVADOC	 The files which matched at least one include and at least one exclude. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
filesExcluded	TokenNameIdentifier	 files Excluded
;	TokenNameSEMICOLON	
/** * The directories which matched at least one include and no excludes * and were selected. */	TokenNameCOMMENT_JAVADOC	 The directories which matched at least one include and no excludes and were selected. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
dirsIncluded	TokenNameIdentifier	 dirs Included
;	TokenNameSEMICOLON	
/** The directories which were found and did not match any includes. */	TokenNameCOMMENT_JAVADOC	 The directories which were found and did not match any includes. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
;	TokenNameSEMICOLON	
/** * The directories which matched at least one include and at least one * exclude. */	TokenNameCOMMENT_JAVADOC	 The directories which matched at least one include and at least one exclude. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
dirsExcluded	TokenNameIdentifier	 dirs Excluded
;	TokenNameSEMICOLON	
/** * The files which matched at least one include and no excludes and * which a selector discarded. */	TokenNameCOMMENT_JAVADOC	 The files which matched at least one include and no excludes and which a selector discarded. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
filesDeselected	TokenNameIdentifier	 files Deselected
;	TokenNameSEMICOLON	
/** * The directories which matched at least one include and no excludes * but which a selector discarded. */	TokenNameCOMMENT_JAVADOC	 The directories which matched at least one include and no excludes but which a selector discarded. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
dirsDeselected	TokenNameIdentifier	 dirs Deselected
;	TokenNameSEMICOLON	
/** Whether or not our results were built by a slow scan. */	TokenNameCOMMENT_JAVADOC	 Whether or not our results were built by a slow scan. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
haveSlowResults	TokenNameIdentifier	 have Slow Results
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Whether or not the file system should be treated as a case sensitive * one. */	TokenNameCOMMENT_JAVADOC	 Whether or not the file system should be treated as a case sensitive one. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** * Whether a missing base directory is an error. * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 Whether a missing base directory is an error. @since Ant 1.7.1 
protected	TokenNameprotected	
boolean	TokenNameboolean	
errorOnMissingDir	TokenNameIdentifier	 error On Missing Dir
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** * Whether or not symbolic links should be followed. * * @since Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Whether or not symbolic links should be followed. * @since Ant 1.5 
private	TokenNameprivate	
boolean	TokenNameboolean	
followSymlinks	TokenNameIdentifier	 follow Symlinks
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** Whether or not everything tested so far has been included. */	TokenNameCOMMENT_JAVADOC	 Whether or not everything tested so far has been included. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
everythingIncluded	TokenNameIdentifier	 everything Included
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// CheckStyle:VisibilityModifier ON 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier ON 
/** * List of all scanned directories. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 List of all scanned directories. * @since Ant 1.6 
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
scannedDirs	TokenNameIdentifier	 scanned Dirs
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Map of all include patterns that are full file names and don't * contain any wildcards. * * <p>Maps pattern string to TokenizedPath.</p> * * <p>If this instance is not case sensitive, the file names get * turned to upper case.</p> * * <p>Gets lazily initialized on the first invocation of * isIncluded or isExcluded and cleared at the end of the scan * method (cleared in clearCaches, actually).</p> * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Map of all include patterns that are full file names and don't contain any wildcards. * <p>Maps pattern string to TokenizedPath.</p> * <p>If this instance is not case sensitive, the file names get turned to upper case.</p> * <p>Gets lazily initialized on the first invocation of isIncluded or isExcluded and cleared at the end of the scan method (cleared in clearCaches, actually).</p> * @since Ant 1.8.0 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Map of all exclude patterns that are full file names and don't * contain any wildcards. * * <p>Maps pattern string to TokenizedPath.</p> * * <p>If this instance is not case sensitive, the file names get * turned to upper case.</p> * * <p>Gets lazily initialized on the first invocation of * isIncluded or isExcluded and cleared at the end of the scan * method (cleared in clearCaches, actually).</p> * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Map of all exclude patterns that are full file names and don't contain any wildcards. * <p>Maps pattern string to TokenizedPath.</p> * <p>If this instance is not case sensitive, the file names get turned to upper case.</p> * <p>Gets lazily initialized on the first invocation of isIncluded or isExcluded and cleared at the end of the scan method (cleared in clearCaches, actually).</p> * @since Ant 1.8.0 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
excludeNonPatterns	TokenNameIdentifier	 exclude Non Patterns
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Array of all include patterns that contain wildcards. * * <p>Gets lazily initialized on the first invocation of * isIncluded or isExcluded and cleared at the end of the scan * method (cleared in clearCaches, actually).</p> */	TokenNameCOMMENT_JAVADOC	 Array of all include patterns that contain wildcards. * <p>Gets lazily initialized on the first invocation of isIncluded or isExcluded and cleared at the end of the scan method (cleared in clearCaches, actually).</p> 
private	TokenNameprivate	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
includePatterns	TokenNameIdentifier	 include Patterns
;	TokenNameSEMICOLON	
/** * Array of all exclude patterns that contain wildcards. * * <p>Gets lazily initialized on the first invocation of * isIncluded or isExcluded and cleared at the end of the scan * method (cleared in clearCaches, actually).</p> */	TokenNameCOMMENT_JAVADOC	 Array of all exclude patterns that contain wildcards. * <p>Gets lazily initialized on the first invocation of isIncluded or isExcluded and cleared at the end of the scan method (cleared in clearCaches, actually).</p> 
private	TokenNameprivate	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
excludePatterns	TokenNameIdentifier	 exclude Patterns
;	TokenNameSEMICOLON	
/** * Have the non-pattern sets and pattern arrays for in- and * excludes been initialized? * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Have the non-pattern sets and pattern arrays for in- and excludes been initialized? * @since Ant 1.6.3 
private	TokenNameprivate	
boolean	TokenNameboolean	
areNonPatternSetsReady	TokenNameIdentifier	 are Non Pattern Sets Ready
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Scanning flag. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Scanning flag. * @since Ant 1.6.3 
private	TokenNameprivate	
boolean	TokenNameboolean	
scanning	TokenNameIdentifier	 scanning
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Scanning lock. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Scanning lock. * @since Ant 1.6.3 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
scanLock	TokenNameIdentifier	 scan Lock
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Slow scanning flag. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Slow scanning flag. * @since Ant 1.6.3 
private	TokenNameprivate	
boolean	TokenNameboolean	
slowScanning	TokenNameIdentifier	 slow Scanning
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * Slow scanning lock. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Slow scanning lock. * @since Ant 1.6.3 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
slowScanLock	TokenNameIdentifier	 slow Scan Lock
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Exception thrown during scan. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Exception thrown during scan. * @since Ant 1.6.3 
private	TokenNameprivate	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
illegal	TokenNameIdentifier	 illegal
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * The maximum number of times a symbolic link may be followed * during a scan. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 The maximum number of times a symbolic link may be followed during a scan. * @since Ant 1.8.0 
private	TokenNameprivate	
int	TokenNameint	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
=	TokenNameEQUAL	
MAX_LEVELS_OF_SYMLINKS	TokenNameIdentifier	 MAX  LEVELS  OF  SYMLINKS
;	TokenNameSEMICOLON	
/** * Absolute paths of all symlinks that haven't been followed but * would have been if followsymlinks had been true or * maxLevelsOfSymlinks had been higher. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Absolute paths of all symlinks that haven't been followed but would have been if followsymlinks had been true or maxLevelsOfSymlinks had been higher. * @since Ant 1.8.0 
private	TokenNameprivate	
Set	TokenNameIdentifier	 Set
/*<String>*/	TokenNameCOMMENT_BLOCK	<String>
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Sole constructor. */	TokenNameCOMMENT_JAVADOC	 Sole constructor. 
public	TokenNamepublic	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** * Test whether or not a given path matches the start of a given * pattern up to the first "**". * <p> * This is not a general purpose test and should only be used if you * can live with false positives. For example, <code>pattern=**\a</code> * and <code>str=b</code> will yield <code>true</code>. * * @param pattern The pattern to match against. Must not be * <code>null</code>. * @param str The path to match, as a String. Must not be * <code>null</code>. * * @return whether or not a given path matches the start of a given * pattern up to the first "**". */	TokenNameCOMMENT_JAVADOC	 Test whether or not a given path matches the start of a given pattern up to the first "**". <p> This is not a general purpose test and should only be used if you can live with false positives. For example, <code>pattern=**\a</code> and <code>str=b</code> will yield <code>true</code>. * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The path to match, as a String. Must not be <code>null</code>. * @return whether or not a given path matches the start of a given pattern up to the first "**". 
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
matchPatternStart	TokenNameIdentifier	 match Pattern Start
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
matchPatternStart	TokenNameIdentifier	 match Pattern Start
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a given path matches the start of a given * pattern up to the first "**". * <p> * This is not a general purpose test and should only be used if you * can live with false positives. For example, <code>pattern=**\a</code> * and <code>str=b</code> will yield <code>true</code>. * * @param pattern The pattern to match against. Must not be * <code>null</code>. * @param str The path to match, as a String. Must not be * <code>null</code>. * @param isCaseSensitive Whether or not matching should be performed * case sensitively. * * @return whether or not a given path matches the start of a given * pattern up to the first "**". */	TokenNameCOMMENT_JAVADOC	 Test whether or not a given path matches the start of a given pattern up to the first "**". <p> This is not a general purpose test and should only be used if you can live with false positives. For example, <code>pattern=**\a</code> and <code>str=b</code> will yield <code>true</code>. * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The path to match, as a String. Must not be <code>null</code>. @param isCaseSensitive Whether or not matching should be performed case sensitively. * @return whether or not a given path matches the start of a given pattern up to the first "**". 
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
matchPatternStart	TokenNameIdentifier	 match Pattern Start
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
matchPatternStart	TokenNameIdentifier	 match Pattern Start
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a given path matches a given pattern. * * @param pattern The pattern to match against. Must not be * <code>null</code>. * @param str The path to match, as a String. Must not be * <code>null</code>. * * @return <code>true</code> if the pattern matches against the string, * or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a given path matches a given pattern. * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The path to match, as a String. Must not be <code>null</code>. * @return <code>true</code> if the pattern matches against the string, or <code>false</code> otherwise. 
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a given path matches a given pattern. * * @param pattern The pattern to match against. Must not be * <code>null</code>. * @param str The path to match, as a String. Must not be * <code>null</code>. * @param isCaseSensitive Whether or not matching should be performed * case sensitively. * * @return <code>true</code> if the pattern matches against the string, * or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a given path matches a given pattern. * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The path to match, as a String. Must not be <code>null</code>. @param isCaseSensitive Whether or not matching should be performed case sensitively. * @return <code>true</code> if the pattern matches against the string, or <code>false</code> otherwise. 
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a string matches against a pattern. * The pattern may contain two special characters:<br> * '*' means zero or more characters<br> * '?' means one and only one character * * @param pattern The pattern to match against. * Must not be <code>null</code>. * @param str The string which must be matched against the pattern. * Must not be <code>null</code>. * * @return <code>true</code> if the string matches against the pattern, * or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a string matches against a pattern. The pattern may contain two special characters:<br> '*' means zero or more characters<br> '?' means one and only one character * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The string which must be matched against the pattern. Must not be <code>null</code>. * @return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
match	TokenNameIdentifier	 match
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
match	TokenNameIdentifier	 match
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a string matches against a pattern. * The pattern may contain two special characters:<br> * '*' means zero or more characters<br> * '?' means one and only one character * * @param pattern The pattern to match against. * Must not be <code>null</code>. * @param str The string which must be matched against the pattern. * Must not be <code>null</code>. * @param isCaseSensitive Whether or not matching should be performed * case sensitively. * * * @return <code>true</code> if the string matches against the pattern, * or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a string matches against a pattern. The pattern may contain two special characters:<br> '*' means zero or more characters<br> '?' means one and only one character * @param pattern The pattern to match against. Must not be <code>null</code>. @param str The string which must be matched against the pattern. Must not be <code>null</code>. @param isCaseSensitive Whether or not matching should be performed case sensitively. * @return <code>true</code> if the string matches against the pattern, or <code>false</code> otherwise. 
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
match	TokenNameIdentifier	 match
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
match	TokenNameIdentifier	 match
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
str	TokenNameIdentifier	 str
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the list of patterns that should be excluded by default. * * @return An array of <code>String</code> based on the current * contents of the <code>defaultExcludes</code> * <code>Set</code>. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Get the list of patterns that should be excluded by default. * @return An array of <code>String</code> based on the current contents of the <code>defaultExcludes</code> <code>Set</code>. * @since Ant 1.6 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getDefaultExcludes	TokenNameIdentifier	 get Default Excludes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
defaultExcludes	TokenNameIdentifier	 default Excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a pattern to the default excludes unless it is already a * default exclude. * * @param s A string to add as an exclude pattern. * @return <code>true</code> if the string was added; * <code>false</code> if it already existed. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Add a pattern to the default excludes unless it is already a default exclude. * @param s A string to add as an exclude pattern. @return <code>true</code> if the string was added; <code>false</code> if it already existed. * @since Ant 1.6 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
addDefaultExclude	TokenNameIdentifier	 add Default Exclude
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
defaultExcludes	TokenNameIdentifier	 default Excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove a string if it is a default exclude. * * @param s The string to attempt to remove. * @return <code>true</code> if <code>s</code> was a default * exclude (and thus was removed); * <code>false</code> if <code>s</code> was not * in the default excludes list to begin with. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Remove a string if it is a default exclude. * @param s The string to attempt to remove. @return <code>true</code> if <code>s</code> was a default exclude (and thus was removed); <code>false</code> if <code>s</code> was not in the default excludes list to begin with. * @since Ant 1.6 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
removeDefaultExclude	TokenNameIdentifier	 remove Default Exclude
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
defaultExcludes	TokenNameIdentifier	 default Excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Go back to the hardwired default exclude patterns. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Go back to the hardwired default exclude patterns. * @since Ant 1.6 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
resetDefaultExcludes	TokenNameIdentifier	 reset Default Excludes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
defaultExcludes	TokenNameIdentifier	 default Excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
DEFAULTEXCLUDES	TokenNameIdentifier	 DEFAULTEXCLUDES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
defaultExcludes	TokenNameIdentifier	 default Excludes
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
DEFAULTEXCLUDES	TokenNameIdentifier	 DEFAULTEXCLUDES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Set the base directory to be scanned. This is the directory which is * scanned recursively. All '/' and '\' characters are replaced by * <code>File.separatorChar</code>, so the separator used need not match * <code>File.separatorChar</code>. * * @param basedir The base directory to scan. */	TokenNameCOMMENT_JAVADOC	 Set the base directory to be scanned. This is the directory which is scanned recursively. All '/' and '\' characters are replaced by <code>File.separatorChar</code>, so the separator used need not match <code>File.separatorChar</code>. * @param basedir The base directory to scan. 
public	TokenNamepublic	
void	TokenNamevoid	
setBasedir	TokenNameIdentifier	 set Basedir
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
basedir	TokenNameIdentifier	 basedir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setBasedir	TokenNameIdentifier	 set Basedir
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the base directory to be scanned. This is the directory which is * scanned recursively. * * @param basedir The base directory for scanning. */	TokenNameCOMMENT_JAVADOC	 Set the base directory to be scanned. This is the directory which is scanned recursively. * @param basedir The base directory for scanning. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setBasedir	TokenNameIdentifier	 set Basedir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
basedir	TokenNameIdentifier	 basedir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
basedir	TokenNameIdentifier	 basedir
=	TokenNameEQUAL	
basedir	TokenNameIdentifier	 basedir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the base directory to be scanned. * This is the directory which is scanned recursively. * * @return the base directory to be scanned. */	TokenNameCOMMENT_JAVADOC	 Return the base directory to be scanned. This is the directory which is scanned recursively. * @return the base directory to be scanned. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
File	TokenNameIdentifier	 File
getBasedir	TokenNameIdentifier	 get Basedir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
basedir	TokenNameIdentifier	 basedir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find out whether include exclude patterns are matched in a * case sensitive way. * @return whether or not the scanning is case sensitive. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Find out whether include exclude patterns are matched in a case sensitive way. @return whether or not the scanning is case sensitive. @since Ant 1.6 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether or not include and exclude patterns are matched * in a case sensitive way. * * @param isCaseSensitive whether or not the file system should be * regarded as a case sensitive one. */	TokenNameCOMMENT_JAVADOC	 Set whether or not include and exclude patterns are matched in a case sensitive way. * @param isCaseSensitive whether or not the file system should be regarded as a case sensitive one. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setCaseSensitive	TokenNameIdentifier	 set Case Sensitive
(	TokenNameLPAREN	
boolean	TokenNameboolean	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
=	TokenNameEQUAL	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets whether or not a missing base directory is an error * * @param errorOnMissingDir whether or not a missing base directory * is an error * @since Ant 1.7.1 */	TokenNameCOMMENT_JAVADOC	 Sets whether or not a missing base directory is an error * @param errorOnMissingDir whether or not a missing base directory is an error @since Ant 1.7.1 
public	TokenNamepublic	
void	TokenNamevoid	
setErrorOnMissingDir	TokenNameIdentifier	 set Error On Missing Dir
(	TokenNameLPAREN	
boolean	TokenNameboolean	
errorOnMissingDir	TokenNameIdentifier	 error On Missing Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
errorOnMissingDir	TokenNameIdentifier	 error On Missing Dir
=	TokenNameEQUAL	
errorOnMissingDir	TokenNameIdentifier	 error On Missing Dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get whether or not a DirectoryScanner follows symbolic links. * * @return flag indicating whether symbolic links should be followed. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Get whether or not a DirectoryScanner follows symbolic links. * @return flag indicating whether symbolic links should be followed. * @since Ant 1.6 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
isFollowSymlinks	TokenNameIdentifier	 is Follow Symlinks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
followSymlinks	TokenNameIdentifier	 follow Symlinks
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether or not symbolic links should be followed. * * @param followSymlinks whether or not symbolic links should be followed. */	TokenNameCOMMENT_JAVADOC	 Set whether or not symbolic links should be followed. * @param followSymlinks whether or not symbolic links should be followed. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setFollowSymlinks	TokenNameIdentifier	 set Follow Symlinks
(	TokenNameLPAREN	
boolean	TokenNameboolean	
followSymlinks	TokenNameIdentifier	 follow Symlinks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
followSymlinks	TokenNameIdentifier	 follow Symlinks
=	TokenNameEQUAL	
followSymlinks	TokenNameIdentifier	 follow Symlinks
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The maximum number of times a symbolic link may be followed * during a scan. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 The maximum number of times a symbolic link may be followed during a scan. * @since Ant 1.8.0 
public	TokenNamepublic	
void	TokenNamevoid	
setMaxLevelsOfSymlinks	TokenNameIdentifier	 set Max Levels Of Symlinks
(	TokenNameLPAREN	
int	TokenNameint	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
=	TokenNameEQUAL	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the list of include patterns to use. All '/' and '\' characters * are replaced by <code>File.separatorChar</code>, so the separator used * need not match <code>File.separatorChar</code>. * <p> * When a pattern ends with a '/' or '\', "**" is appended. * * @param includes A list of include patterns. * May be <code>null</code>, indicating that all files * should be included. If a non-<code>null</code> * list is given, all elements must be * non-<code>null</code>. */	TokenNameCOMMENT_JAVADOC	 Set the list of include patterns to use. All '/' and '\' characters are replaced by <code>File.separatorChar</code>, so the separator used need not match <code>File.separatorChar</code>. <p> When a pattern ends with a '/' or '\', "**" is appended. * @param includes A list of include patterns. May be <code>null</code>, indicating that all files should be included. If a non-<code>null</code> list is given, all elements must be non-<code>null</code>. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setIncludes	TokenNameIdentifier	 set Includes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
includes	TokenNameIdentifier	 includes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includes	TokenNameIdentifier	 includes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
includes	TokenNameIdentifier	 includes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
includes	TokenNameIdentifier	 includes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
includes	TokenNameIdentifier	 includes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
normalizePattern	TokenNameIdentifier	 normalize Pattern
(	TokenNameLPAREN	
includes	TokenNameIdentifier	 includes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Set the list of exclude patterns to use. All '/' and '\' characters * are replaced by <code>File.separatorChar</code>, so the separator used * need not match <code>File.separatorChar</code>. * <p> * When a pattern ends with a '/' or '\', "**" is appended. * * @param excludes A list of exclude patterns. * May be <code>null</code>, indicating that no files * should be excluded. If a non-<code>null</code> list is * given, all elements must be non-<code>null</code>. */	TokenNameCOMMENT_JAVADOC	 Set the list of exclude patterns to use. All '/' and '\' characters are replaced by <code>File.separatorChar</code>, so the separator used need not match <code>File.separatorChar</code>. <p> When a pattern ends with a '/' or '\', "**" is appended. * @param excludes A list of exclude patterns. May be <code>null</code>, indicating that no files should be excluded. If a non-<code>null</code> list is given, all elements must be non-<code>null</code>. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setExcludes	TokenNameIdentifier	 set Excludes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
excludes	TokenNameIdentifier	 excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
normalizePattern	TokenNameIdentifier	 normalize Pattern
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add to the list of exclude patterns to use. All '/' and '\' * characters are replaced by <code>File.separatorChar</code>, so * the separator used need not match <code>File.separatorChar</code>. * <p> * When a pattern ends with a '/' or '\', "**" is appended. * * @param excludes A list of exclude patterns. * May be <code>null</code>, in which case the * exclude patterns don't get changed at all. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Add to the list of exclude patterns to use. All '/' and '\' characters are replaced by <code>File.separatorChar</code>, so the separator used need not match <code>File.separatorChar</code>. <p> When a pattern ends with a '/' or '\', "**" is appended. * @param excludes A list of exclude patterns. May be <code>null</code>, in which case the exclude patterns don't get changed at all. * @since Ant 1.6.3 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
addExcludes	TokenNameIdentifier	 add Excludes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
excludes	TokenNameIdentifier	 excludes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tmp	TokenNameIdentifier	 tmp
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmp	TokenNameIdentifier	 tmp
[	TokenNameLBRACKET	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
normalizePattern	TokenNameIdentifier	 normalize Pattern
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setExcludes	TokenNameIdentifier	 set Excludes
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * All '/' and '\' characters are replaced by * <code>File.separatorChar</code>, so the separator used need not * match <code>File.separatorChar</code>. * * <p> When a pattern ends with a '/' or '\', "**" is appended. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 All '/' and '\' characters are replaced by <code>File.separatorChar</code>, so the separator used need not match <code>File.separatorChar</code>. * <p> When a pattern ends with a '/' or '\', "**" is appended. * @since Ant 1.6.3 
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
normalizePattern	TokenNameIdentifier	 normalize Pattern
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pattern	TokenNameIdentifier	 pattern
+=	TokenNamePLUS_EQUAL	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
pattern	TokenNameIdentifier	 pattern
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the selectors that will select the filelist. * * @param selectors specifies the selectors to be invoked on a scan. */	TokenNameCOMMENT_JAVADOC	 Set the selectors that will select the filelist. * @param selectors specifies the selectors to be invoked on a scan. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setSelectors	TokenNameIdentifier	 set Selectors
(	TokenNameLPAREN	
FileSelector	TokenNameIdentifier	 File Selector
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
selectors	TokenNameIdentifier	 selectors
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
selectors	TokenNameIdentifier	 selectors
=	TokenNameEQUAL	
selectors	TokenNameIdentifier	 selectors
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return whether or not the scanner has included all the files or * directories it has come across so far. * * @return <code>true</code> if all files and directories which have * been found so far have been included. */	TokenNameCOMMENT_JAVADOC	 Return whether or not the scanner has included all the files or directories it has come across so far. * @return <code>true</code> if all files and directories which have been found so far have been included. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
isEverythingIncluded	TokenNameIdentifier	 is Everything Included
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
everythingIncluded	TokenNameIdentifier	 everything Included
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Scan for files which match at least one include pattern and don't match * any exclude patterns. If there are selectors then the files must pass * muster there, as well. Scans under basedir, if set; otherwise the * include patterns without leading wildcards specify the absolute paths of * the files that may be included. * * @exception IllegalStateException if the base directory was set * incorrectly (i.e. if it doesn't exist or isn't a directory). */	TokenNameCOMMENT_JAVADOC	 Scan for files which match at least one include pattern and don't match any exclude patterns. If there are selectors then the files must pass muster there, as well. Scans under basedir, if set; otherwise the include patterns without leading wildcards specify the absolute paths of the files that may be included. * @exception IllegalStateException if the base directory was set incorrectly (i.e. if it doesn't exist or isn't a directory). 
public	TokenNamepublic	
void	TokenNamevoid	
scan	TokenNameIdentifier	 scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
scanLock	TokenNameIdentifier	 scan Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
scanning	TokenNameIdentifier	 scanning
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
scanning	TokenNameIdentifier	 scanning
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
scanLock	TokenNameIdentifier	 scan Lock
.	TokenNameDOT	
wait	TokenNameIdentifier	 wait
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
illegal	TokenNameIdentifier	 illegal
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
illegal	TokenNameIdentifier	 illegal
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
scanning	TokenNameIdentifier	 scanning
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
savedBase	TokenNameIdentifier	 saved Base
=	TokenNameEQUAL	
basedir	TokenNameIdentifier	 basedir
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
illegal	TokenNameIdentifier	 illegal
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
clearResults	TokenNameIdentifier	 clear Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set in/excludes to reasonable defaults if needed: 	TokenNameCOMMENT_LINE	set in/excludes to reasonable defaults if needed: 
boolean	TokenNameboolean	
nullIncludes	TokenNameIdentifier	 null Includes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
includes	TokenNameIdentifier	 includes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
nullIncludes	TokenNameIdentifier	 null Includes
?	TokenNameQUESTION	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
}	TokenNameRBRACE	
:	TokenNameCOLON	
includes	TokenNameIdentifier	 includes
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
nullExcludes	TokenNameIdentifier	 null Excludes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
nullExcludes	TokenNameIdentifier	 null Excludes
?	TokenNameQUESTION	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
:	TokenNameCOLON	
excludes	TokenNameIdentifier	 excludes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
followSymlinks	TokenNameIdentifier	 follow Symlinks
&&	TokenNameAND_AND	
SYMLINK_UTILS	TokenNameIdentifier	 SYMLINK  UTILS
.	TokenNameDOT	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
basedir	TokenNameIdentifier	 basedir
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if no basedir and no includes, nothing to do: 	TokenNameCOMMENT_LINE	if no basedir and no includes, nothing to do: 
if	TokenNameif	
(	TokenNameLPAREN	
nullIncludes	TokenNameIdentifier	 null Includes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
errorOnMissingDir	TokenNameIdentifier	 error On Missing Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
illegal	TokenNameIdentifier	 illegal
=	TokenNameEQUAL	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"basedir "	TokenNameStringLiteral	basedir 
+	TokenNamePLUS	
basedir	TokenNameIdentifier	 basedir
+	TokenNamePLUS	
DOES_NOT_EXIST_POSTFIX	TokenNameIdentifier	 DOES  NOT  EXIST  POSTFIX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Nothing to do - basedir does not exist 	TokenNameCOMMENT_LINE	Nothing to do - basedir does not exist 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
illegal	TokenNameIdentifier	 illegal
=	TokenNameEQUAL	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"basedir "	TokenNameStringLiteral	basedir 
+	TokenNamePLUS	
basedir	TokenNameIdentifier	 basedir
+	TokenNamePLUS	
" is not a"	TokenNameStringLiteral	 is not a
+	TokenNamePLUS	
" directory."	TokenNameStringLiteral	 directory.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
illegal	TokenNameIdentifier	 illegal
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
illegal	TokenNameIdentifier	 illegal
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
.	TokenNameDOT	
EMPTY_PATH	TokenNameIdentifier	 EMPTY  PATH
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
.	TokenNameDOT	
EMPTY_PATH	TokenNameIdentifier	 EMPTY  PATH
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
basedir	TokenNameIdentifier	 basedir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dirsIncluded	TokenNameIdentifier	 dirs Included
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
checkIncludePatterns	TokenNameIdentifier	 check Include Patterns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clearCaches	TokenNameIdentifier	 clear Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
nullIncludes	TokenNameIdentifier	 null Includes
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
includes	TokenNameIdentifier	 includes
;	TokenNameSEMICOLON	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
nullExcludes	TokenNameIdentifier	 null Excludes
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
excludes	TokenNameIdentifier	 excludes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
basedir	TokenNameIdentifier	 basedir
=	TokenNameEQUAL	
savedBase	TokenNameIdentifier	 saved Base
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
scanLock	TokenNameIdentifier	 scan Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scanning	TokenNameIdentifier	 scanning
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
scanLock	TokenNameIdentifier	 scan Lock
.	TokenNameDOT	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * This routine is actually checking all the include patterns in * order to avoid scanning everything under base dir. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 This routine is actually checking all the include patterns in order to avoid scanning everything under base dir. @since Ant 1.6 
private	TokenNameprivate	
void	TokenNamevoid	
checkIncludePatterns	TokenNameIdentifier	 check Include Patterns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureNonPatternSetsReady	TokenNameIdentifier	 ensure Non Pattern Sets Ready
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
newroots	TokenNameIdentifier	 newroots
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// put in the newroots map the include patterns without 	TokenNameCOMMENT_LINE	put in the newroots map the include patterns without 
// wildcard tokens 	TokenNameCOMMENT_LINE	wildcard tokens 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
includePatterns	TokenNameIdentifier	 include Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
=	TokenNameEQUAL	
includePatterns	TokenNameIdentifier	 include Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
shouldSkipPattern	TokenNameIdentifier	 should Skip Pattern
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newroots	TokenNameIdentifier	 newroots
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
includePatterns	TokenNameIdentifier	 include Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
rtrimWildcardTokens	TokenNameIdentifier	 rtrim Wildcard Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
entry	TokenNameIdentifier	 entry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
shouldSkipPattern	TokenNameIdentifier	 should Skip Pattern
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newroots	TokenNameIdentifier	 newroots
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newroots	TokenNameIdentifier	 newroots
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
.	TokenNameDOT	
EMPTY_PATH	TokenNameIdentifier	 EMPTY  PATH
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are going to scan everything anyway 	TokenNameCOMMENT_LINE	we are going to scan everything anyway 
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// only scan directories that can include matched files or 	TokenNameCOMMENT_LINE	only scan directories that can include matched files or 
// directories 	TokenNameCOMMENT_LINE	directories 
Iterator	TokenNameIdentifier	 Iterator
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
newroots	TokenNameIdentifier	 newroots
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
canonBase	TokenNameIdentifier	 canon Base
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
canonBase	TokenNameIdentifier	 canon Base
=	TokenNameEQUAL	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
getCanonicalFile	TokenNameIdentifier	 get Canonical File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
entry	TokenNameIdentifier	 entry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
)	TokenNameRPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
currentPath	TokenNameIdentifier	 current Path
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
currentelement	TokenNameIdentifier	 currentelement
=	TokenNameEQUAL	
currentPath	TokenNameIdentifier	 current Path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
myfile	TokenNameIdentifier	 myfile
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// may be on a case insensitive file system. We want 	TokenNameCOMMENT_LINE	may be on a case insensitive file system. We want 
// the results to show what's really on the disk, so 	TokenNameCOMMENT_LINE	the results to show what's really on the disk, so 
// we need to double check. 	TokenNameCOMMENT_LINE	we need to double check. 
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
removeLeadingPath	TokenNameIdentifier	 remove Leading Path
(	TokenNameLPAREN	
canonBase	TokenNameIdentifier	 canon Base
,	TokenNameCOMMA	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
getCanonicalFile	TokenNameIdentifier	 get Canonical File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
||	TokenNameOR_OR	
ON_VMS	TokenNameIdentifier	 ON  VMS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
myfile	TokenNameIdentifier	 myfile
=	TokenNameEQUAL	
currentPath	TokenNameIdentifier	 current Path
.	TokenNameDOT	
findFile	TokenNameIdentifier	 find File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentelement	TokenNameIdentifier	 currentelement
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
removeLeadingPath	TokenNameIdentifier	 remove Leading Path
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
myfile	TokenNameIdentifier	 myfile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currentPath	TokenNameIdentifier	 current Path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPath	TokenNameIdentifier	 current Path
=	TokenNameEQUAL	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
currentPath	TokenNameIdentifier	 current Path
.	TokenNameDOT	
findFile	TokenNameIdentifier	 find File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// adapt currentelement to the case we've 	TokenNameCOMMENT_LINE	adapt currentelement to the case we've 
// actually found 	TokenNameCOMMENT_LINE	actually found 
currentelement	TokenNameIdentifier	 currentelement
=	TokenNameEQUAL	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
removeLeadingPath	TokenNameIdentifier	 remove Leading Path
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
myfile	TokenNameIdentifier	 myfile
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
currentPath	TokenNameIdentifier	 current Path
=	TokenNameEQUAL	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
followSymlinks	TokenNameIdentifier	 follow Symlinks
&&	TokenNameAND_AND	
currentPath	TokenNameIdentifier	 current Path
.	TokenNameDOT	
isSymlink	TokenNameIdentifier	 is Symlink
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
currentPath	TokenNameIdentifier	 current Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
currentPath	TokenNameIdentifier	 current Path
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
currentelement	TokenNameIdentifier	 currentelement
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
accountForIncludedDir	TokenNameIdentifier	 account For Included Dir
(	TokenNameLPAREN	
currentPath	TokenNameIdentifier	 current Path
,	TokenNameCOMMA	
myfile	TokenNameIdentifier	 myfile
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
myfile	TokenNameIdentifier	 myfile
,	TokenNameCOMMA	
currentPath	TokenNameIdentifier	 current Path
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
originalpattern	TokenNameIdentifier	 originalpattern
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
included	TokenNameIdentifier	 included
=	TokenNameEQUAL	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
originalpattern	TokenNameIdentifier	 originalpattern
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
:	TokenNameCOLON	
originalpattern	TokenNameIdentifier	 originalpattern
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
currentelement	TokenNameIdentifier	 currentelement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
included	TokenNameIdentifier	 included
)	TokenNameRPAREN	
{	TokenNameLBRACE	
accountForIncludedFile	TokenNameIdentifier	 account For Included File
(	TokenNameLPAREN	
currentPath	TokenNameIdentifier	 current Path
,	TokenNameCOMMA	
myfile	TokenNameIdentifier	 myfile
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * true if the pattern specifies a relative path without basedir * or an absolute path not inside basedir. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 true if the pattern specifies a relative path without basedir or an absolute path not inside basedir. * @since Ant 1.8.0 
private	TokenNameprivate	
boolean	TokenNameboolean	
shouldSkipPattern	TokenNameIdentifier	 should Skip Pattern
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
isAbsolutePath	TokenNameIdentifier	 is Absolute Path
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//skip abs. paths not under basedir, if set: 	TokenNameCOMMENT_LINE	skip abs. paths not under basedir, if set: 
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
matchPatternStart	TokenNameIdentifier	 match Pattern Start
(	TokenNameLPAREN	
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
basedir	TokenNameIdentifier	 basedir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//skip non-abs. paths if basedir == null: 	TokenNameCOMMENT_LINE	skip non-abs. paths if basedir == null: 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Clear the result caches for a scan. */	TokenNameCOMMENT_JAVADOC	 Clear the result caches for a scan. 
protected	TokenNameprotected	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
clearResults	TokenNameIdentifier	 clear Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filesIncluded	TokenNameIdentifier	 files Included
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filesNotIncluded	TokenNameIdentifier	 files Not Included
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filesExcluded	TokenNameIdentifier	 files Excluded
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filesDeselected	TokenNameIdentifier	 files Deselected
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirsIncluded	TokenNameIdentifier	 dirs Included
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
=	TokenNameEQUAL	
new	TokenNamenew	
VectorSet	TokenNameIdentifier	 Vector Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
everythingIncluded	TokenNameIdentifier	 everything Included
=	TokenNameEQUAL	
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scannedDirs	TokenNameIdentifier	 scanned Dirs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Top level invocation for a slow scan. A slow scan builds up a full * list of excluded/included files/directories, whereas a fast scan * will only have full results for included files, as it ignores * directories which can't possibly hold any included files/directories. * <p> * Returns immediately if a slow scan has already been completed. */	TokenNameCOMMENT_JAVADOC	 Top level invocation for a slow scan. A slow scan builds up a full list of excluded/included files/directories, whereas a fast scan will only have full results for included files, as it ignores directories which can't possibly hold any included files/directories. <p> Returns immediately if a slow scan has already been completed. 
protected	TokenNameprotected	
void	TokenNamevoid	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
slowScanLock	TokenNameIdentifier	 slow Scan Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
haveSlowResults	TokenNameIdentifier	 have Slow Results
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
slowScanning	TokenNameIdentifier	 slow Scanning
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
slowScanning	TokenNameIdentifier	 slow Scanning
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
slowScanLock	TokenNameIdentifier	 slow Scan Lock
.	TokenNameDOT	
wait	TokenNameIdentifier	 wait
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Empty 	TokenNameCOMMENT_LINE	Empty 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
slowScanning	TokenNameIdentifier	 slow Scanning
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set in/excludes to reasonable defaults if needed: 	TokenNameCOMMENT_LINE	set in/excludes to reasonable defaults if needed: 
boolean	TokenNameboolean	
nullIncludes	TokenNameIdentifier	 null Includes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
includes	TokenNameIdentifier	 includes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
nullIncludes	TokenNameIdentifier	 null Includes
?	TokenNameQUESTION	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
}	TokenNameRBRACE	
:	TokenNameCOLON	
includes	TokenNameIdentifier	 includes
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
nullExcludes	TokenNameIdentifier	 null Excludes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
nullExcludes	TokenNameIdentifier	 null Excludes
?	TokenNameQUESTION	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
:	TokenNameCOLON	
excludes	TokenNameIdentifier	 excludes
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
excl	TokenNameIdentifier	 excl
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
excl	TokenNameIdentifier	 excl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
notIncl	TokenNameIdentifier	 not Incl
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
notIncl	TokenNameIdentifier	 not Incl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ensureNonPatternSetsReady	TokenNameIdentifier	 ensure Non Pattern Sets Ready
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
processSlowScan	TokenNameIdentifier	 process Slow Scan
(	TokenNameLPAREN	
excl	TokenNameIdentifier	 excl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
processSlowScan	TokenNameIdentifier	 process Slow Scan
(	TokenNameLPAREN	
notIncl	TokenNameIdentifier	 not Incl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clearCaches	TokenNameIdentifier	 clear Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includes	TokenNameIdentifier	 includes
=	TokenNameEQUAL	
nullIncludes	TokenNameIdentifier	 null Includes
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
includes	TokenNameIdentifier	 includes
;	TokenNameSEMICOLON	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
nullExcludes	TokenNameIdentifier	 null Excludes
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
excludes	TokenNameIdentifier	 excludes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
slowScanLock	TokenNameIdentifier	 slow Scan Lock
)	TokenNameRPAREN	
{	TokenNameLBRACE	
haveSlowResults	TokenNameIdentifier	 have Slow Results
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
slowScanning	TokenNameIdentifier	 slow Scanning
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
slowScanLock	TokenNameIdentifier	 slow Scan Lock
.	TokenNameDOT	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
processSlowScan	TokenNameIdentifier	 process Slow Scan
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arr	TokenNameIdentifier	 arr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
arr	TokenNameIdentifier	 arr
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
arr	TokenNameIdentifier	 arr
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
||	TokenNameOR_OR	
contentsExcluded	TokenNameIdentifier	 contents Excluded
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
arr	TokenNameIdentifier	 arr
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Scan the given directory for files and directories. Found files and * directories are placed in their respective collections, based on the * matching of includes, excludes, and the selectors. When a directory * is found, it is scanned recursively. * * @param dir The directory to scan. Must not be <code>null</code>. * @param vpath The path relative to the base directory (needed to * prevent problems with an absolute path when using * dir). Must not be <code>null</code>. * @param fast Whether or not this call is part of a fast scan. * * @see #filesIncluded * @see #filesNotIncluded * @see #filesExcluded * @see #dirsIncluded * @see #dirsNotIncluded * @see #dirsExcluded * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Scan the given directory for files and directories. Found files and directories are placed in their respective collections, based on the matching of includes, excludes, and the selectors. When a directory is found, it is scanned recursively. * @param dir The directory to scan. Must not be <code>null</code>. @param vpath The path relative to the base directory (needed to prevent problems with an absolute path when using dir). Must not be <code>null</code>. @param fast Whether or not this call is part of a fast scan. * @see #filesIncluded @see #filesNotIncluded @see #filesExcluded @see #dirsIncluded @see #dirsNotIncluded @see #dirsExcluded @see #slowScan 
protected	TokenNameprotected	
void	TokenNamevoid	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
vpath	TokenNameIdentifier	 vpath
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
vpath	TokenNameIdentifier	 vpath
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Scan the given directory for files and directories. Found files and * directories are placed in their respective collections, based on the * matching of includes, excludes, and the selectors. When a directory * is found, it is scanned recursively. * * @param dir The directory to scan. Must not be <code>null</code>. * @param path The path relative to the base directory (needed to * prevent problems with an absolute path when using * dir). Must not be <code>null</code>. * @param fast Whether or not this call is part of a fast scan. * * @see #filesIncluded * @see #filesNotIncluded * @see #filesExcluded * @see #dirsIncluded * @see #dirsNotIncluded * @see #dirsExcluded * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Scan the given directory for files and directories. Found files and directories are placed in their respective collections, based on the matching of includes, excludes, and the selectors. When a directory is found, it is scanned recursively. * @param dir The directory to scan. Must not be <code>null</code>. @param path The path relative to the base directory (needed to prevent problems with an absolute path when using dir). Must not be <code>null</code>. @param fast Whether or not this call is part of a fast scan. * @see #filesIncluded @see #filesNotIncluded @see #filesExcluded @see #dirsIncluded @see #dirsNotIncluded @see #dirsExcluded @see #slowScan 
private	TokenNameprivate	
void	TokenNamevoid	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"dir must not be null."	TokenNameStringLiteral	dir must not be null.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newfiles	TokenNameIdentifier	 newfiles
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
newfiles	TokenNameIdentifier	 newfiles
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
+	TokenNamePLUS	
DOES_NOT_EXIST_POSTFIX	TokenNameIdentifier	 DOES  NOT  EXIST  POSTFIX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
+	TokenNamePLUS	
" is not a directory."	TokenNameStringLiteral	 is not a directory.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"IO error scanning directory '"	TokenNameStringLiteral	IO error scanning directory '
+	TokenNamePLUS	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
newfiles	TokenNameIdentifier	 newfiles
,	TokenNameCOMMA	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newfiles	TokenNameIdentifier	 newfiles
,	TokenNameCOMMA	
LinkedList	TokenNameIdentifier	 Linked List
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
vpath	TokenNameIdentifier	 vpath
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
vpath	TokenNameIdentifier	 vpath
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
vpath	TokenNameIdentifier	 vpath
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
vpath	TokenNameIdentifier	 vpath
+=	TokenNamePLUS_EQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// avoid double scanning of directories, can only happen in fast mode 	TokenNameCOMMENT_LINE	avoid double scanning of directories, can only happen in fast mode 
if	TokenNameif	
(	TokenNameLPAREN	
fast	TokenNameIdentifier	 fast
&&	TokenNameAND_AND	
hasBeenScanned	TokenNameIdentifier	 has Been Scanned
(	TokenNameLPAREN	
vpath	TokenNameIdentifier	 vpath
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
followSymlinks	TokenNameIdentifier	 follow Symlinks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
noLinks	TokenNameIdentifier	 no Links
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newfiles	TokenNameIdentifier	 newfiles
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SYMLINK_UTILS	TokenNameIdentifier	 SYMLINK  UTILS
.	TokenNameDOT	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
vpath	TokenNameIdentifier	 vpath
+	TokenNamePLUS	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
:	TokenNameCOLON	
filesExcluded	TokenNameIdentifier	 files Excluded
)	TokenNameRPAREN	
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
noLinks	TokenNameIdentifier	 no Links
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
"IOException caught while checking "	TokenNameStringLiteral	IOException caught while checking 
+	TokenNamePLUS	
"for links, couldn't get canonical path!"	TokenNameStringLiteral	for links, couldn't get canonical path!
;	TokenNameSEMICOLON	
// will be caught and redirected to Ant's logging system 	TokenNameCOMMENT_LINE	will be caught and redirected to Ant's logging system 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
noLinks	TokenNameIdentifier	 no Links
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
newfiles	TokenNameIdentifier	 newfiles
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
noLinks	TokenNameIdentifier	 no Links
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
noLinks	TokenNameIdentifier	 no Links
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
.	TokenNameDOT	
addFirst	TokenNameIdentifier	 add First
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newfiles	TokenNameIdentifier	 newfiles
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
vpath	TokenNameIdentifier	 vpath
+	TokenNamePLUS	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
newPath	TokenNameIdentifier	 new Path
=	TokenNameEQUAL	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
children	TokenNameIdentifier	 children
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isFile	TokenNameIdentifier	 is File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
accountForIncludedFile	TokenNameIdentifier	 account For Included File
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
everythingIncluded	TokenNameIdentifier	 everything Included
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
filesNotIncluded	TokenNameIdentifier	 files Not Included
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// dir 	TokenNameCOMMENT_LINE	dir 
if	TokenNameif	
(	TokenNameLPAREN	
followSymlinks	TokenNameIdentifier	 follow Symlinks
&&	TokenNameAND_AND	
causesIllegalSymlinkLoop	TokenNameIdentifier	 causes Illegal Symlink Loop
(	TokenNameLPAREN	
newfiles	TokenNameIdentifier	 newfiles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// will be caught and redirected to Ant's logging system 	TokenNameCOMMENT_LINE	will be caught and redirected to Ant's logging system 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"skipping symbolic link "	TokenNameStringLiteral	skipping symbolic link 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" -- too many levels of symbolic"	TokenNameStringLiteral	 -- too many levels of symbolic
+	TokenNamePLUS	
" links."	TokenNameStringLiteral	 links.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
accountForIncludedDir	TokenNameIdentifier	 account For Included Dir
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
everythingIncluded	TokenNameIdentifier	 everything Included
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fast	TokenNameIdentifier	 fast
&&	TokenNameAND_AND	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
contentsExcluded	TokenNameIdentifier	 contents Excluded
(	TokenNameLPAREN	
newPath	TokenNameIdentifier	 new Path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
newPath	TokenNameIdentifier	 new Path
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
newPath	TokenNameIdentifier	 new Path
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
followSymlinks	TokenNameIdentifier	 follow Symlinks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
.	TokenNameDOT	
removeFirst	TokenNameIdentifier	 remove First
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Process included file. * @param name path of the file relative to the directory of the FileSet. * @param file included File. */	TokenNameCOMMENT_JAVADOC	 Process included file. @param name path of the file relative to the directory of the FileSet. @param file included File. 
private	TokenNameprivate	
void	TokenNamevoid	
accountForIncludedFile	TokenNameIdentifier	 account For Included File
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processIncluded	TokenNameIdentifier	 process Included
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
filesIncluded	TokenNameIdentifier	 files Included
,	TokenNameCOMMA	
filesExcluded	TokenNameIdentifier	 files Excluded
,	TokenNameCOMMA	
filesDeselected	TokenNameIdentifier	 files Deselected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Process included directory. * @param name path of the directory relative to the directory of * the FileSet. * @param file directory as File. * @param fast whether to perform fast scans. */	TokenNameCOMMENT_JAVADOC	 Process included directory. @param name path of the directory relative to the directory of the FileSet. @param file directory as File. @param fast whether to perform fast scans. 
private	TokenNameprivate	
void	TokenNamevoid	
accountForIncludedDir	TokenNameIdentifier	 account For Included Dir
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processIncluded	TokenNameIdentifier	 process Included
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
dirsIncluded	TokenNameIdentifier	 dirs Included
,	TokenNameCOMMA	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
,	TokenNameCOMMA	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fast	TokenNameIdentifier	 fast
&&	TokenNameAND_AND	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
contentsExcluded	TokenNameIdentifier	 contents Excluded
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
accountForIncludedDir	TokenNameIdentifier	 account For Included Dir
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
LinkedList	TokenNameIdentifier	 Linked List
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processIncluded	TokenNameIdentifier	 process Included
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
dirsIncluded	TokenNameIdentifier	 dirs Included
,	TokenNameCOMMA	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
,	TokenNameCOMMA	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fast	TokenNameIdentifier	 fast
&&	TokenNameAND_AND	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
contentsExcluded	TokenNameIdentifier	 contents Excluded
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scandir	TokenNameIdentifier	 scandir
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
fast	TokenNameIdentifier	 fast
,	TokenNameCOMMA	
children	TokenNameIdentifier	 children
,	TokenNameCOMMA	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
processIncluded	TokenNameIdentifier	 process Included
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
inc	TokenNameIdentifier	 inc
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
exc	TokenNameIdentifier	 exc
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
des	TokenNameIdentifier	 des
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inc	TokenNameIdentifier	 inc
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
||	TokenNameOR_OR	
exc	TokenNameIdentifier	 exc
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
||	TokenNameOR_OR	
des	TokenNameIdentifier	 des
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
included	TokenNameIdentifier	 included
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exc	TokenNameIdentifier	 exc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
included	TokenNameIdentifier	 included
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
inc	TokenNameIdentifier	 inc
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
des	TokenNameIdentifier	 des
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
everythingIncluded	TokenNameIdentifier	 everything Included
&=	TokenNameAND_EQUAL	
included	TokenNameIdentifier	 included
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches against at least one include * pattern. * * @param name The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against at least one * include pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches against at least one include pattern. * @param name The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against at least one include pattern, or <code>false</code> otherwise. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches against at least one include * pattern. * * @param name The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against at least one * include pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches against at least one include pattern. * @param name The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against at least one include pattern, or <code>false</code> otherwise. 
private	TokenNameprivate	
boolean	TokenNameboolean	
isIncluded	TokenNameIdentifier	 is Included
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureNonPatternSetsReady	TokenNameIdentifier	 ensure Non Pattern Sets Ready
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
includePatterns	TokenNameIdentifier	 include Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includePatterns	TokenNameIdentifier	 include Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches the start of at least one include * pattern. * * @param name The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against the start of at * least one include pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches the start of at least one include pattern. * @param name The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against the start of at least one include pattern, or <code>false</code> otherwise. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches the start of at least one include * pattern. * * @param tokenizedName The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against the start of at * least one include pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches the start of at least one include pattern. * @param tokenizedName The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against the start of at least one include pattern, or <code>false</code> otherwise. 
private	TokenNameprivate	
boolean	TokenNameboolean	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
tokenizedName	TokenNameIdentifier	 tokenized Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
includePatterns	TokenNameIdentifier	 include Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
tokenizedName	TokenNameIdentifier	 tokenized Name
,	TokenNameCOMMA	
includePatterns	TokenNameIdentifier	 include Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
tokenizedName	TokenNameIdentifier	 tokenized Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toPattern	TokenNameIdentifier	 to Pattern
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches the start of the given * include pattern. * * @param tokenizedName The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against the start of the * include pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches the start of the given include pattern. * @param tokenizedName The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against the start of the include pattern, or <code>false</code> otherwise. 
private	TokenNameprivate	
boolean	TokenNameboolean	
couldHoldIncluded	TokenNameIdentifier	 could Hold Included
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
tokenizedName	TokenNameIdentifier	 tokenized Name
,	TokenNameCOMMA	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
tokenizedInclude	TokenNameIdentifier	 tokenized Include
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
tokenizedInclude	TokenNameIdentifier	 tokenized Include
.	TokenNameDOT	
matchStartOf	TokenNameIdentifier	 match Start Of
(	TokenNameLPAREN	
tokenizedName	TokenNameIdentifier	 tokenized Name
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isMorePowerfulThanExcludes	TokenNameIdentifier	 is More Powerful Than Excludes
(	TokenNameLPAREN	
tokenizedName	TokenNameIdentifier	 tokenized Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isDeeper	TokenNameIdentifier	 is Deeper
(	TokenNameLPAREN	
tokenizedInclude	TokenNameIdentifier	 tokenized Include
,	TokenNameCOMMA	
tokenizedName	TokenNameIdentifier	 tokenized Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Verify that a pattern specifies files deeper * than the level of the specified file. * @param pattern the pattern to check. * @param name the name to check. * @return whether the pattern is deeper than the name. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Verify that a pattern specifies files deeper than the level of the specified file. @param pattern the pattern to check. @param name the name to check. @return whether the pattern is deeper than the name. @since Ant 1.6.3 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDeeper	TokenNameIdentifier	 is Deeper
(	TokenNameLPAREN	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
pattern	TokenNameIdentifier	 pattern
,	TokenNameCOMMA	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pattern	TokenNameIdentifier	 pattern
.	TokenNameDOT	
containsPattern	TokenNameIdentifier	 contains Pattern
(	TokenNameLPAREN	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
)	TokenNameRPAREN	
||	TokenNameOR_OR	
pattern	TokenNameIdentifier	 pattern
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find out whether one particular include pattern is more powerful * than all the excludes. * Note: the power comparison is based on the length of the include pattern * and of the exclude patterns without the wildcards. * Ideally the comparison should be done based on the depth * of the match; that is to say how many file separators have been matched * before the first ** or the end of the pattern. * * IMPORTANT : this function should return false "with care". * * @param name the relative path to test. * @return true if there is no exclude pattern more powerful than * this include pattern. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Find out whether one particular include pattern is more powerful than all the excludes. Note: the power comparison is based on the length of the include pattern and of the exclude patterns without the wildcards. Ideally the comparison should be done based on the depth of the match; that is to say how many file separators have been matched before the first ** or the end of the pattern. * IMPORTANT : this function should return false "with care". * @param name the relative path to test. @return true if there is no exclude pattern more powerful than this include pattern. @since Ant 1.6 
private	TokenNameprivate	
boolean	TokenNameboolean	
isMorePowerfulThanExcludes	TokenNameIdentifier	 is More Powerful Than Excludes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
soughtexclude	TokenNameIdentifier	 soughtexclude
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
+	TokenNamePLUS	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
counter	TokenNameIdentifier	 counter
<	TokenNameLESS	
excludePatterns	TokenNameIdentifier	 exclude Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
counter	TokenNameIdentifier	 counter
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
excludePatterns	TokenNameIdentifier	 exclude Patterns
[	TokenNameLBRACKET	
counter	TokenNameIdentifier	 counter
]	TokenNameRBRACKET	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
soughtexclude	TokenNameIdentifier	 soughtexclude
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether all contents of the specified directory must be excluded. * @param path the path to check. * @return whether all the specified directory's contents are excluded. */	TokenNameCOMMENT_JAVADOC	 Test whether all contents of the specified directory must be excluded. @param path the path to check. @return whether all the specified directory's contents are excluded. 
/* package */	TokenNameCOMMENT_BLOCK	 package 
boolean	TokenNameboolean	
contentsExcluded	TokenNameIdentifier	 contents Excluded
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
excludePatterns	TokenNameIdentifier	 exclude Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
excludePatterns	TokenNameIdentifier	 exclude Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
DEEP_TREE_MATCH	TokenNameIdentifier	 DEEP  TREE  MATCH
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
excludePatterns	TokenNameIdentifier	 exclude Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
withoutLastToken	TokenNameIdentifier	 without Last Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches against at least one exclude * pattern. * * @param name The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against at least one * exclude pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches against at least one exclude pattern. * @param name The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against at least one exclude pattern, or <code>false</code> otherwise. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether or not a name matches against at least one exclude * pattern. * * @param name The name to match. Must not be <code>null</code>. * @return <code>true</code> when the name matches against at least one * exclude pattern, or <code>false</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether or not a name matches against at least one exclude pattern. * @param name The name to match. Must not be <code>null</code>. @return <code>true</code> when the name matches against at least one exclude pattern, or <code>false</code> otherwise. 
private	TokenNameprivate	
boolean	TokenNameboolean	
isExcluded	TokenNameIdentifier	 is Excluded
(	TokenNameLPAREN	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureNonPatternSetsReady	TokenNameIdentifier	 ensure Non Pattern Sets Ready
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
excludeNonPatterns	TokenNameIdentifier	 exclude Non Patterns
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
excludeNonPatterns	TokenNameIdentifier	 exclude Non Patterns
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
excludePatterns	TokenNameIdentifier	 exclude Patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
excludePatterns	TokenNameIdentifier	 exclude Patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
matchPath	TokenNameIdentifier	 match Path
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether a file should be selected. * * @param name the filename to check for selecting. * @param file the java.io.File object for this filename. * @return <code>false</code> when the selectors says that the file * should not be selected, <code>true</code> otherwise. */	TokenNameCOMMENT_JAVADOC	 Test whether a file should be selected. * @param name the filename to check for selecting. @param file the java.io.File object for this filename. @return <code>false</code> when the selectors says that the file should not be selected, <code>true</code> otherwise. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
selectors	TokenNameIdentifier	 selectors
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
selectors	TokenNameIdentifier	 selectors
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
selectors	TokenNameIdentifier	 selectors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isSelected	TokenNameIdentifier	 is Selected
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the files which matched at least one of the * include patterns and none of the exclude patterns. * The names are relative to the base directory. * * @return the names of the files which matched at least one of the * include patterns and none of the exclude patterns. */	TokenNameCOMMENT_JAVADOC	 Return the names of the files which matched at least one of the include patterns and none of the exclude patterns. The names are relative to the base directory. * @return the names of the files which matched at least one of the include patterns and none of the exclude patterns. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getIncludedFiles	TokenNameIdentifier	 get Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filesIncluded	TokenNameIdentifier	 files Included
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Must call scan() first"	TokenNameStringLiteral	Must call scan() first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
filesIncluded	TokenNameIdentifier	 files Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
filesIncluded	TokenNameIdentifier	 files Included
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the count of included files. * @return <code>int</code>. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Return the count of included files. @return <code>int</code>. @since Ant 1.6.3 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
int	TokenNameint	
getIncludedFilesCount	TokenNameIdentifier	 get Included Files Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filesIncluded	TokenNameIdentifier	 files Included
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Must call scan() first"	TokenNameStringLiteral	Must call scan() first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
filesIncluded	TokenNameIdentifier	 files Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the files which matched none of the include * patterns. The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed. * * @return the names of the files which matched none of the include * patterns. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Return the names of the files which matched none of the include patterns. The names are relative to the base directory. This involves performing a slow scan if one has not already been completed. * @return the names of the files which matched none of the include patterns. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getNotIncludedFiles	TokenNameIdentifier	 get Not Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
filesNotIncluded	TokenNameIdentifier	 files Not Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
filesNotIncluded	TokenNameIdentifier	 files Not Included
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the files which matched at least one of the * include patterns and at least one of the exclude patterns. * The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed. * * @return the names of the files which matched at least one of the * include patterns and at least one of the exclude patterns. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Return the names of the files which matched at least one of the include patterns and at least one of the exclude patterns. The names are relative to the base directory. This involves performing a slow scan if one has not already been completed. * @return the names of the files which matched at least one of the include patterns and at least one of the exclude patterns. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getExcludedFiles	TokenNameIdentifier	 get Excluded Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
filesExcluded	TokenNameIdentifier	 files Excluded
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
filesExcluded	TokenNameIdentifier	 files Excluded
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * <p>Return the names of the files which were selected out and * therefore not ultimately included.</p> * * <p>The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed.</p> * * @return the names of the files which were deselected. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 <p>Return the names of the files which were selected out and therefore not ultimately included.</p> * <p>The names are relative to the base directory. This involves performing a slow scan if one has not already been completed.</p> * @return the names of the files which were deselected. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getDeselectedFiles	TokenNameIdentifier	 get Deselected Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
filesDeselected	TokenNameIdentifier	 files Deselected
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
filesDeselected	TokenNameIdentifier	 files Deselected
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
files	TokenNameIdentifier	 files
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the directories which matched at least one of the * include patterns and none of the exclude patterns. * The names are relative to the base directory. * * @return the names of the directories which matched at least one of the * include patterns and none of the exclude patterns. */	TokenNameCOMMENT_JAVADOC	 Return the names of the directories which matched at least one of the include patterns and none of the exclude patterns. The names are relative to the base directory. * @return the names of the directories which matched at least one of the include patterns and none of the exclude patterns. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getIncludedDirectories	TokenNameIdentifier	 get Included Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dirsIncluded	TokenNameIdentifier	 dirs Included
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Must call scan() first"	TokenNameStringLiteral	Must call scan() first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsIncluded	TokenNameIdentifier	 dirs Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsIncluded	TokenNameIdentifier	 dirs Included
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the count of included directories. * @return <code>int</code>. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Return the count of included directories. @return <code>int</code>. @since Ant 1.6.3 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
int	TokenNameint	
getIncludedDirsCount	TokenNameIdentifier	 get Included Dirs Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dirsIncluded	TokenNameIdentifier	 dirs Included
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"Must call scan() first"	TokenNameStringLiteral	Must call scan() first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
dirsIncluded	TokenNameIdentifier	 dirs Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the directories which matched none of the include * patterns. The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed. * * @return the names of the directories which matched none of the include * patterns. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Return the names of the directories which matched none of the include patterns. The names are relative to the base directory. This involves performing a slow scan if one has not already been completed. * @return the names of the directories which matched none of the include patterns. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getNotIncludedDirectories	TokenNameIdentifier	 get Not Included Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsNotIncluded	TokenNameIdentifier	 dirs Not Included
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the names of the directories which matched at least one of the * include patterns and at least one of the exclude patterns. * The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed. * * @return the names of the directories which matched at least one of the * include patterns and at least one of the exclude patterns. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 Return the names of the directories which matched at least one of the include patterns and at least one of the exclude patterns. The names are relative to the base directory. This involves performing a slow scan if one has not already been completed. * @return the names of the directories which matched at least one of the include patterns and at least one of the exclude patterns. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getExcludedDirectories	TokenNameIdentifier	 get Excluded Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsExcluded	TokenNameIdentifier	 dirs Excluded
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * <p>Return the names of the directories which were selected out and * therefore not ultimately included.</p> * * <p>The names are relative to the base directory. This involves * performing a slow scan if one has not already been completed.</p> * * @return the names of the directories which were deselected. * * @see #slowScan */	TokenNameCOMMENT_JAVADOC	 <p>Return the names of the directories which were selected out and therefore not ultimately included.</p> * <p>The names are relative to the base directory. This involves performing a slow scan if one has not already been completed.</p> * @return the names of the directories which were deselected. * @see #slowScan 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getDeselectedDirectories	TokenNameIdentifier	 get Deselected Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowScan	TokenNameIdentifier	 slow Scan
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dirsDeselected	TokenNameIdentifier	 dirs Deselected
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Absolute paths of all symbolic links that haven't been followed * but would have been followed had followsymlinks been true or * maxLevelsOfSymlinks been bigger. * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Absolute paths of all symbolic links that haven't been followed but would have been followed had followsymlinks been true or maxLevelsOfSymlinks been bigger. * @since Ant 1.8.0 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getNotFollowedSymlinks	TokenNameIdentifier	 get Not Followed Symlinks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
links	TokenNameIdentifier	 links
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
links	TokenNameIdentifier	 links
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
notFollowedSymlinks	TokenNameIdentifier	 not Followed Symlinks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
links	TokenNameIdentifier	 links
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
links	TokenNameIdentifier	 links
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add default exclusions to the current exclusions set. */	TokenNameCOMMENT_JAVADOC	 Add default exclusions to the current exclusions set. 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
addDefaultExcludes	TokenNameIdentifier	 add Default Excludes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
excludesLength	TokenNameIdentifier	 excludes Length
=	TokenNameEQUAL	
excludes	TokenNameIdentifier	 excludes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
excludes	TokenNameIdentifier	 excludes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newExcludes	TokenNameIdentifier	 new Excludes
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
defaultExcludesTemp	TokenNameIdentifier	 default Excludes Temp
=	TokenNameEQUAL	
getDefaultExcludes	TokenNameIdentifier	 get Default Excludes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newExcludes	TokenNameIdentifier	 new Excludes
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
excludesLength	TokenNameIdentifier	 excludes Length
+	TokenNamePLUS	
defaultExcludesTemp	TokenNameIdentifier	 default Excludes Temp
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
excludesLength	TokenNameIdentifier	 excludes Length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
excludes	TokenNameIdentifier	 excludes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newExcludes	TokenNameIdentifier	 new Excludes
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
excludesLength	TokenNameIdentifier	 excludes Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
defaultExcludesTemp	TokenNameIdentifier	 default Excludes Temp
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newExcludes	TokenNameIdentifier	 new Excludes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
excludesLength	TokenNameIdentifier	 excludes Length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
defaultExcludesTemp	TokenNameIdentifier	 default Excludes Temp
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'/'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separatorChar	TokenNameIdentifier	 separator Char
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
excludes	TokenNameIdentifier	 excludes
=	TokenNameEQUAL	
newExcludes	TokenNameIdentifier	 new Excludes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the named resource. * @param name path name of the file relative to the dir attribute. * * @return the resource with the given name. * @since Ant 1.5.2 */	TokenNameCOMMENT_JAVADOC	 Get the named resource. @param name path name of the file relative to the dir attribute. * @return the resource with the given name. @since Ant 1.5.2 
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
Resource	TokenNameIdentifier	 Resource
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
basedir	TokenNameIdentifier	 basedir
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Has the directory with the given path relative to the base * directory already been scanned? * * <p>Registers the given directory as scanned as a side effect.</p> * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Has the directory with the given path relative to the base directory already been scanned? * <p>Registers the given directory as scanned as a side effect.</p> * @since Ant 1.6 
private	TokenNameprivate	
boolean	TokenNameboolean	
hasBeenScanned	TokenNameIdentifier	 has Been Scanned
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
vpath	TokenNameIdentifier	 vpath
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
scannedDirs	TokenNameIdentifier	 scanned Dirs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
vpath	TokenNameIdentifier	 vpath
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method is of interest for testing purposes. The returned * Set is live and should not be modified. * @return the Set of relative directory names that have been scanned. */	TokenNameCOMMENT_JAVADOC	 This method is of interest for testing purposes. The returned Set is live and should not be modified. @return the Set of relative directory names that have been scanned. 
/* package-private */	TokenNameCOMMENT_BLOCK	 package-private 
Set	TokenNameIdentifier	 Set
getScannedDirs	TokenNameIdentifier	 get Scanned Dirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
scannedDirs	TokenNameIdentifier	 scanned Dirs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Clear internal caches. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Clear internal caches. * @since Ant 1.6 
private	TokenNameprivate	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
clearCaches	TokenNameIdentifier	 clear Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excludeNonPatterns	TokenNameIdentifier	 exclude Non Patterns
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includePatterns	TokenNameIdentifier	 include Patterns
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
excludePatterns	TokenNameIdentifier	 exclude Patterns
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
areNonPatternSetsReady	TokenNameIdentifier	 are Non Pattern Sets Ready
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Ensure that the in|exclude &quot;patterns&quot; * have been properly divided up. * * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Ensure that the in|exclude &quot;patterns&quot; have been properly divided up. * @since Ant 1.6.3 
/* package */	TokenNameCOMMENT_BLOCK	 package 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
ensureNonPatternSetsReady	TokenNameIdentifier	 ensure Non Pattern Sets Ready
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
areNonPatternSetsReady	TokenNameIdentifier	 are Non Pattern Sets Ready
)	TokenNameRPAREN	
{	TokenNameLBRACE	
includePatterns	TokenNameIdentifier	 include Patterns
=	TokenNameEQUAL	
fillNonPatternSet	TokenNameIdentifier	 fill Non Pattern Set
(	TokenNameLPAREN	
includeNonPatterns	TokenNameIdentifier	 include Non Patterns
,	TokenNameCOMMA	
includes	TokenNameIdentifier	 includes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
excludePatterns	TokenNameIdentifier	 exclude Patterns
=	TokenNameEQUAL	
fillNonPatternSet	TokenNameIdentifier	 fill Non Pattern Set
(	TokenNameLPAREN	
excludeNonPatterns	TokenNameIdentifier	 exclude Non Patterns
,	TokenNameCOMMA	
excludes	TokenNameIdentifier	 excludes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
areNonPatternSetsReady	TokenNameIdentifier	 are Non Pattern Sets Ready
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add all patterns that are not real patterns (do not contain * wildcards) to the set and returns the real patterns. * * @param map Map to populate. * @param patterns String[] of patterns. * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Add all patterns that are not real patterns (do not contain wildcards) to the set and returns the real patterns. * @param map Map to populate. @param patterns String[] of patterns. @since Ant 1.8.0 
private	TokenNameprivate	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fillNonPatternSet	TokenNameIdentifier	 fill Non Pattern Set
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
map	TokenNameIdentifier	 map
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
patterns	TokenNameIdentifier	 patterns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
al	TokenNameIdentifier	 al
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
patterns	TokenNameIdentifier	 patterns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
SelectorUtils	TokenNameIdentifier	 Selector Utils
.	TokenNameDOT	
hasWildcards	TokenNameIdentifier	 has Wildcards
(	TokenNameLPAREN	
patterns	TokenNameIdentifier	 patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
isCaseSensitive	TokenNameIdentifier	 is Case Sensitive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
patterns	TokenNameIdentifier	 patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
:	TokenNameCOLON	
patterns	TokenNameIdentifier	 patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
new	TokenNamenew	
TokenizedPath	TokenNameIdentifier	 Tokenized Path
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
(	TokenNameLPAREN	
patterns	TokenNameIdentifier	 patterns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
TokenizedPattern	TokenNameIdentifier	 Tokenized Pattern
[	TokenNameLBRACKET	
al	TokenNameIdentifier	 al
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Would following the given directory cause a loop of symbolic * links deeper than allowed? * * <p>Can only happen if the given directory has been seen at * least more often than allowed during the current scan and it is * a symbolic link and enough other occurences of the same name * higher up are symbolic links that point to the same place.</p> * * @since Ant 1.8.0 */	TokenNameCOMMENT_JAVADOC	 Would following the given directory cause a loop of symbolic links deeper than allowed? * <p>Can only happen if the given directory has been seen at least more often than allowed during the current scan and it is a symbolic link and enough other occurences of the same name higher up are symbolic links that point to the same place.</p> * @since Ant 1.8.0 
private	TokenNameprivate	
boolean	TokenNameboolean	
causesIllegalSymlinkLoop	TokenNameIdentifier	 causes Illegal Symlink Loop
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
dirName	TokenNameIdentifier	 dir Name
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
LinkedList	TokenNameIdentifier	 Linked List
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
&&	TokenNameAND_AND	
CollectionUtils	TokenNameIdentifier	 Collection Utils
.	TokenNameDOT	
frequency	TokenNameIdentifier	 frequency
(	TokenNameLPAREN	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
,	TokenNameCOMMA	
dirName	TokenNameIdentifier	 dir Name
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
&&	TokenNameAND_AND	
SYMLINK_UTILS	TokenNameIdentifier	 SYMLINK  UTILS
.	TokenNameDOT	
isSymbolicLink	TokenNameIdentifier	 is Symbolic Link
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
dirName	TokenNameIdentifier	 dir Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ArrayList	TokenNameIdentifier	 Array List
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
resolveFile	TokenNameIdentifier	 resolve File
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
dirName	TokenNameIdentifier	 dir Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
relPath	TokenNameIdentifier	 rel Path
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
directoryNamesFollowed	TokenNameIdentifier	 directory Names Followed
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
relPath	TokenNameIdentifier	 rel Path
+=	TokenNamePLUS_EQUAL	
"../"	TokenNameStringLiteral	../
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dirName	TokenNameIdentifier	 dir Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
FILE_UTILS	TokenNameIdentifier	 FILE  UTILS
.	TokenNameDOT	
resolveFile	TokenNameIdentifier	 resolve File
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
relPath	TokenNameIdentifier	 rel Path
+	TokenNamePLUS	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
&&	TokenNameAND_AND	
CollectionUtils	TokenNameIdentifier	 Collection Utils
.	TokenNameDOT	
frequency	TokenNameIdentifier	 frequency
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxLevelsOfSymlinks	TokenNameIdentifier	 max Levels Of Symlinks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Caught error while checking for"	TokenNameStringLiteral	Caught error while checking for
+	TokenNamePLUS	
" symbolic links"	TokenNameStringLiteral	 symbolic links
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
