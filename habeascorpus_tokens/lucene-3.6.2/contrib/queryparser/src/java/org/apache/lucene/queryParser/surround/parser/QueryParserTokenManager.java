/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndQuery	TokenNameIdentifier	 Srnd Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
FieldsQuery	TokenNameIdentifier	 Fields Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
OrQuery	TokenNameIdentifier	 Or Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
AndQuery	TokenNameIdentifier	 And Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
NotQuery	TokenNameIdentifier	 Not Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
DistanceQuery	TokenNameIdentifier	 Distance Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndTermQuery	TokenNameIdentifier	 Srnd Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndPrefixQuery	TokenNameIdentifier	 Srnd Prefix Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
surround	TokenNameIdentifier	 surround
.	TokenNameDOT	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
SrndTruncQuery	TokenNameIdentifier	 Srnd Trunc Query
;	TokenNameSEMICOLON	
/** Token Manager. */	TokenNameCOMMENT_JAVADOC	 Token Manager. 
public	TokenNamepublic	
class	TokenNameclass	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
implements	TokenNameimplements	
QueryParserConstants	TokenNameIdentifier	 Query Parser Constants
{	TokenNameLBRACE	
/** Debug output. */	TokenNameCOMMENT_JAVADOC	 Debug output. 
public	TokenNamepublic	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
/** Set debug output. */	TokenNameCOMMENT_JAVADOC	 Set debug output. 
public	TokenNamepublic	
void	TokenNamevoid	
setDebugStream	TokenNameIdentifier	 set Debug Stream
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
ds	TokenNameIdentifier	 ds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_1	TokenNameIdentifier	 jj Stop String Literal Dfa 1
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_1	TokenNameIdentifier	 jj Start Nfa 1
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
jjStopStringLiteralDfa_1	TokenNameIdentifier	 jj Stop String Literal Dfa 1
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
40	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
41	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
44	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
58	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
94	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0xfffffffffffffffeL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec2	TokenNameIdentifier	 jjbit Vec2
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffe8faffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3fc000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
49	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
20	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
19	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3fc000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
20	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
21	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
22	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
49	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
20	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
23	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
24	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
25	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
25	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
26	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
42	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
18	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
29	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
30	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
31	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffe8faffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffe8faffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
33	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
42	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffe8faffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
35	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x8000040000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
35	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
36	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfbffecfaffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
36	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
37	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffe8faffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
37	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x400000004000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x80000000800000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
97	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
65	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
111	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
110	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
82	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
114	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
111	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
68	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
7	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
65	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
100	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
110	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
10	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
97	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
11	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
84	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
12	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
13	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
14	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
116	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
15	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
111	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
110	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
17	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x80000000800000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
11	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
18	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x400000004000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
24	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
15	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffefffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
28	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
29	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
29	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
31	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
36	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
37	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffbfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
37	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
24	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
15	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
36	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
37	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
37	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
46	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnextStates	TokenNameIdentifier	 jjnext States
=	TokenNameEQUAL	
{	TokenNameLBRACE	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
37	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
21	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
30	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
25	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec2	TokenNameIdentifier	 jjbit Vec2
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
&	TokenNameAND	
l1	TokenNameIdentifier	 l1
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Token literal values. */	TokenNameCOMMENT_JAVADOC	 Token literal values. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
=	TokenNameEQUAL	
{	TokenNameLBRACE	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"("	TokenNameStringLiteral	(
,	TokenNameCOMMA	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
","	TokenNameStringLiteral	,
,	TokenNameCOMMA	
":"	TokenNameStringLiteral	:
,	TokenNameCOMMA	
"^"	TokenNameStringLiteral	^
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lexer state names. */	TokenNameCOMMENT_JAVADOC	 Lexer state names. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lexStateNames	TokenNameIdentifier	 lex State Names
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"Boost"	TokenNameStringLiteral	Boost
,	TokenNameCOMMA	
"DEFAULT"	TokenNameStringLiteral	DEFAULT
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lex State array. */	TokenNameCOMMENT_JAVADOC	 Lex State array. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
=	TokenNameEQUAL	
{	TokenNameLBRACE	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoToken	TokenNameIdentifier	 jjto Token
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0xffff01L	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoSkip	TokenNameIdentifier	 jjto Skip
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x80L	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
CharStream	TokenNameIdentifier	 Char Stream
input_stream	TokenNameIdentifier	 input stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjrounds	TokenNameIdentifier	 jjrounds
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
38	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstateSet	TokenNameIdentifier	 jjstate Set
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
76	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
char	TokenNamechar	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
defaultLexState	TokenNameIdentifier	 default Lex State
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jjround	TokenNameIdentifier	 jjround
=	TokenNameEQUAL	
0x80000001	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0x80000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Switch to specified lex state. */	TokenNameCOMMENT_JAVADOC	 Switch to specified lex state. 
public	TokenNamepublic	
void	TokenNamevoid	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
lexState	TokenNameIdentifier	 lex State
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
"Error: Ignoring invalid lexical state : "	TokenNameStringLiteral	Error: Ignoring invalid lexical state : 
+	TokenNamePLUS	
lexState	TokenNameIdentifier	 lex State
+	TokenNamePLUS	
". State unchanged."	TokenNameStringLiteral	. State unchanged.
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
INVALID_LEXICAL_STATE	TokenNameIdentifier	 INVALID  LEXICAL  STATE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
lexState	TokenNameIdentifier	 lex State
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Token	TokenNameIdentifier	 Token
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
curTokenImage	TokenNameIdentifier	 cur Token Image
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
im	TokenNameIdentifier	 im
=	TokenNameEQUAL	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
curTokenImage	TokenNameIdentifier	 cur Token Image
=	TokenNameEQUAL	
(	TokenNameLPAREN	
im	TokenNameIdentifier	 im
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
im	TokenNameIdentifier	 im
;	TokenNameSEMICOLON	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginLine	TokenNameIdentifier	 get Begin Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginColumn	TokenNameIdentifier	 get Begin Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
Token	TokenNameIdentifier	 Token
.	TokenNameDOT	
newToken	TokenNameIdentifier	 new Token
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
,	TokenNameCOMMA	
curTokenImage	TokenNameIdentifier	 cur Token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
defaultLexState	TokenNameIdentifier	 default Lex State
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
;	TokenNameSEMICOLON	
int	TokenNameint	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
;	TokenNameSEMICOLON	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
EOFLoop	TokenNameIdentifier	 EOF Loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
BeginToken	TokenNameIdentifier	 Begin Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
curPos	TokenNameIdentifier	 cur Pos
-	TokenNameMINUS	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjtoToken	TokenNameIdentifier	 jjto Token
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
EOFLoop	TokenNameIdentifier	 EOF Loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
error_line	TokenNameIdentifier	 error line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e1	TokenNameIdentifier	 e1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\n'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\r'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
error_line	TokenNameIdentifier	 error line
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
error_column	TokenNameIdentifier	 error column
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
EOFSeen	TokenNameIdentifier	 EOF Seen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
EOFSeen	TokenNameIdentifier	 EOF Seen
,	TokenNameCOMMA	
curLexState	TokenNameIdentifier	 cur Lex State
,	TokenNameCOMMA	
error_line	TokenNameIdentifier	 error line
,	TokenNameCOMMA	
error_column	TokenNameIdentifier	 error column
,	TokenNameCOMMA	
error_after	TokenNameIdentifier	 error after
,	TokenNameCOMMA	
curChar	TokenNameIdentifier	 cur Char
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
LEXICAL_ERROR	TokenNameIdentifier	 LEXICAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jjround	TokenNameIdentifier	 jjround
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
int	TokenNameint	
state1	TokenNameIdentifier	 state1
,	TokenNameCOMMA	
int	TokenNameint	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state1	TokenNameIdentifier	 state1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
