/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataInput	TokenNameIdentifier	 Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
DataOutput	TokenNameIdentifier	 Data Output
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
reflect	TokenNameIdentifier	 reflect
.	TokenNameDOT	
Constructor	TokenNameIdentifier	 Constructor
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
reflect	TokenNameIdentifier	 reflect
.	TokenNameDOT	
InvocationTargetException	TokenNameIdentifier	 Invocation Target Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Joiner	TokenNameIdentifier	 Joiner
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Iterators	TokenNameIdentifier	 Iterators
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Ordering	TokenNameIdentifier	 Ordering
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
TypeSizes	TokenNameIdentifier	 Type Sizes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ISerializer	TokenNameIdentifier	 I Serializer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IVersionedSerializer	TokenNameIdentifier	 I Versioned Serializer
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
implements	TokenNameimplements	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
IntervalTree	TokenNameIdentifier	 Interval Tree
EMPTY_TREE	TokenNameIdentifier	 EMPTY  TREE
=	TokenNameEQUAL	
new	TokenNamenew	
IntervalTree	TokenNameIdentifier	 Interval Tree
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IntervalNode	TokenNameIdentifier	 Interval Node
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Ordering	TokenNameIdentifier	 Ordering
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
minOrdering	TokenNameIdentifier	 min Ordering
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Ordering	TokenNameIdentifier	 Ordering
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
maxOrdering	TokenNameIdentifier	 max Ordering
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
IntervalTree	TokenNameIdentifier	 Interval Tree
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intervals	TokenNameIdentifier	 intervals
,	TokenNameCOMMA	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntervalTree	TokenNameIdentifier	 Interval Tree
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
minOrdering	TokenNameIdentifier	 min Ordering
=	TokenNameEQUAL	
new	TokenNamenew	
Ordering	TokenNameIdentifier	 Ordering
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
I	TokenNameIdentifier	 I
interval1	TokenNameIdentifier	 interval1
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
interval2	TokenNameIdentifier	 interval2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval1	TokenNameIdentifier	 interval1
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
interval2	TokenNameIdentifier	 interval2
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxOrdering	TokenNameIdentifier	 max Ordering
=	TokenNameEQUAL	
new	TokenNamenew	
Ordering	TokenNameIdentifier	 Ordering
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
I	TokenNameIdentifier	 I
interval1	TokenNameIdentifier	 interval1
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
interval2	TokenNameIdentifier	 interval2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval1	TokenNameIdentifier	 interval1
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
interval2	TokenNameIdentifier	 interval2
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
head	TokenNameIdentifier	 head
=	TokenNameEQUAL	
intervals	TokenNameIdentifier	 intervals
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
intervals	TokenNameIdentifier	 intervals
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
IntervalNode	TokenNameIdentifier	 Interval Node
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
intervals	TokenNameIdentifier	 intervals
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
intervals	TokenNameIdentifier	 intervals
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intervals	TokenNameIdentifier	 intervals
,	TokenNameCOMMA	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
intervals	TokenNameIdentifier	 intervals
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
emptyTree	TokenNameIdentifier	 empty Tree
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
C	TokenNameIdentifier	 C
extends	TokenNameextends	
Comparable	TokenNameIdentifier	 Comparable
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intervals	TokenNameIdentifier	 intervals
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
intervals	TokenNameIdentifier	 intervals
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
emptyTree	TokenNameIdentifier	 empty Tree
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
Serializer	TokenNameIdentifier	 Serializer
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
serializer	TokenNameIdentifier	 serializer
(	TokenNameLPAREN	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
pointSerializer	TokenNameIdentifier	 point Serializer
,	TokenNameCOMMA	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
dataSerializer	TokenNameIdentifier	 data Serializer
,	TokenNameCOMMA	
Constructor	TokenNameIdentifier	 Constructor
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
constructor	TokenNameIdentifier	 constructor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Serializer	TokenNameIdentifier	 Serializer
(	TokenNameLPAREN	
pointSerializer	TokenNameIdentifier	 point Serializer
,	TokenNameCOMMA	
dataSerializer	TokenNameIdentifier	 data Serializer
,	TokenNameCOMMA	
constructor	TokenNameIdentifier	 constructor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
public	TokenNamepublic	
static	TokenNamestatic	
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
emptyTree	TokenNameIdentifier	 empty Tree
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
)	TokenNameRPAREN	
EMPTY_TREE	TokenNameIdentifier	 EMPTY  TREE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
intervalCount	TokenNameIdentifier	 interval Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
head	TokenNameIdentifier	 head
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
C	TokenNameIdentifier	 C
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
head	TokenNameIdentifier	 head
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
head	TokenNameIdentifier	 head
.	TokenNameDOT	
high	TokenNameIdentifier	 high
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
C	TokenNameIdentifier	 C
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
head	TokenNameIdentifier	 head
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
head	TokenNameIdentifier	 head
.	TokenNameDOT	
low	TokenNameIdentifier	 low
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
searchInterval	TokenNameIdentifier	 search Interval
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
head	TokenNameIdentifier	 head
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
head	TokenNameIdentifier	 head
.	TokenNameDOT	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
results	TokenNameIdentifier	 results
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
C	TokenNameIdentifier	 C
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
.	TokenNameDOT	
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
point	TokenNameIdentifier	 point
,	TokenNameCOMMA	
point	TokenNameIdentifier	 point
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
head	TokenNameIdentifier	 head
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
emptyIterator	TokenNameIdentifier	 empty Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
TreeIterator	TokenNameIdentifier	 Tree Iterator
(	TokenNameLPAREN	
head	TokenNameIdentifier	 head
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"<"	TokenNameStringLiteral	<
+	TokenNamePLUS	
Joiner	TokenNameIdentifier	 Joiner
.	TokenNameDOT	
on	TokenNameIdentifier	 on
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
+	TokenNamePLUS	
">"	TokenNameStringLiteral	>
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o	TokenNameIdentifier	 o
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
instanceof	TokenNameinstanceof	
IntervalTree	TokenNameIdentifier	 Interval Tree
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
IntervalTree	TokenNameIdentifier	 Interval Tree
that	TokenNameIdentifier	 that
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
)	TokenNameRPAREN	
o	TokenNameIdentifier	 o
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
elementsEqual	TokenNameIdentifier	 elements Equal
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
this	TokenNamethis	
)	TokenNameRPAREN	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
31	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
result	TokenNameIdentifier	 result
+	TokenNamePLUS	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
C	TokenNameIdentifier	 C
point1	TokenNameIdentifier	 point1
,	TokenNameCOMMA	
C	TokenNameIdentifier	 C
point2	TokenNameIdentifier	 point2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
point1	TokenNameIdentifier	 point1
,	TokenNameCOMMA	
point2	TokenNameIdentifier	 point2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
point1	TokenNameIdentifier	 point1
instanceof	TokenNameinstanceof	
Comparable	TokenNameIdentifier	 Comparable
;	TokenNameSEMICOLON	
assert	TokenNameassert	
point2	TokenNameIdentifier	 point2
instanceof	TokenNameinstanceof	
Comparable	TokenNameIdentifier	 Comparable
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Comparable	TokenNameIdentifier	 Comparable
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
)	TokenNameRPAREN	
point1	TokenNameIdentifier	 point1
)	TokenNameRPAREN	
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
point2	TokenNameIdentifier	 point2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
encloses	TokenNameIdentifier	 encloses
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
enclosing	TokenNameIdentifier	 enclosing
,	TokenNameCOMMA	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
enclosed	TokenNameIdentifier	 enclosed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
enclosing	TokenNameIdentifier	 enclosing
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
enclosed	TokenNameIdentifier	 enclosed
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
enclosing	TokenNameIdentifier	 enclosing
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
enclosed	TokenNameIdentifier	 enclosed
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
,	TokenNameCOMMA	
C	TokenNameIdentifier	 C
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval1	TokenNameIdentifier	 interval1
,	TokenNameCOMMA	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval2	TokenNameIdentifier	 interval2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
interval1	TokenNameIdentifier	 interval1
,	TokenNameCOMMA	
interval2	TokenNameIdentifier	 interval2
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
||	TokenNameOR_OR	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
interval1	TokenNameIdentifier	 interval1
,	TokenNameCOMMA	
interval2	TokenNameIdentifier	 interval2
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
IntervalNode	TokenNameIdentifier	 Interval Node
{	TokenNameLBRACE	
final	TokenNamefinal	
C	TokenNameIdentifier	 C
center	TokenNameIdentifier	 center
;	TokenNameSEMICOLON	
final	TokenNamefinal	
C	TokenNameIdentifier	 C
low	TokenNameIdentifier	 low
;	TokenNameSEMICOLON	
final	TokenNamefinal	
C	TokenNameIdentifier	 C
high	TokenNameIdentifier	 high
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intersectsLeft	TokenNameIdentifier	 intersects Left
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intersectsRight	TokenNameIdentifier	 intersects Right
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntervalNode	TokenNameIdentifier	 Interval Node
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
final	TokenNamefinal	
IntervalNode	TokenNameIdentifier	 Interval Node
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
public	TokenNamepublic	
IntervalNode	TokenNameIdentifier	 Interval Node
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
toBisect	TokenNameIdentifier	 to Bisect
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Creating IntervalNode from {}"	TokenNameStringLiteral	Creating IntervalNode from {}
,	TokenNameCOMMA	
toBisect	TokenNameIdentifier	 to Bisect
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Building IntervalTree with one interval will be a reasonably 	TokenNameCOMMENT_LINE	Building IntervalTree with one interval will be a reasonably 
// common case for range tombstones, so it's worth optimizing 	TokenNameCOMMENT_LINE	common case for range tombstones, so it's worth optimizing 
if	TokenNameif	
(	TokenNameLPAREN	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
I	TokenNameIdentifier	 I
interval	TokenNameIdentifier	 interval
=	TokenNameEQUAL	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
low	TokenNameIdentifier	 low
=	TokenNameEQUAL	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
;	TokenNameSEMICOLON	
center	TokenNameIdentifier	 center
=	TokenNameEQUAL	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
high	TokenNameIdentifier	 high
=	TokenNameEQUAL	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intersectsLeft	TokenNameIdentifier	 intersects Left
=	TokenNameEQUAL	
l	TokenNameIdentifier	 l
;	TokenNameSEMICOLON	
intersectsRight	TokenNameIdentifier	 intersects Right
=	TokenNameEQUAL	
l	TokenNameIdentifier	 l
;	TokenNameSEMICOLON	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Find min, median and max 	TokenNameCOMMENT_LINE	Find min, median and max 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
allEndpoints	TokenNameIdentifier	 all Endpoints
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
(	TokenNameLPAREN	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
I	TokenNameIdentifier	 I
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
toBisect	TokenNameIdentifier	 to Bisect
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Comparable	TokenNameIdentifier	 Comparable
)	TokenNameRPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
:	TokenNameCOLON	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"Interval min > max"	TokenNameStringLiteral	Interval min > max
;	TokenNameSEMICOLON	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
allEndpoints	TokenNameIdentifier	 all Endpoints
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Comparable	TokenNameIdentifier	 Comparable
>	TokenNameGREATER	
)	TokenNameRPAREN	
allEndpoints	TokenNameIdentifier	 all Endpoints
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
low	TokenNameIdentifier	 low
=	TokenNameEQUAL	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
center	TokenNameIdentifier	 center
=	TokenNameEQUAL	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
high	TokenNameIdentifier	 high
=	TokenNameEQUAL	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
allEndpoints	TokenNameIdentifier	 all Endpoints
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Separate interval in intersecting center, left of center and right of center 	TokenNameCOMMENT_LINE	Separate interval in intersecting center, left of center and right of center 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
intersects	TokenNameIdentifier	 intersects
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
leftSegment	TokenNameIdentifier	 left Segment
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
rightSegment	TokenNameIdentifier	 right Segment
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
I	TokenNameIdentifier	 I
candidate	TokenNameIdentifier	 candidate
:	TokenNameCOLON	
toBisect	TokenNameIdentifier	 to Bisect
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
center	TokenNameIdentifier	 center
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
leftSegment	TokenNameIdentifier	 left Segment
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
center	TokenNameIdentifier	 center
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
rightSegment	TokenNameIdentifier	 right Segment
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
intersects	TokenNameIdentifier	 intersects
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
candidate	TokenNameIdentifier	 candidate
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
intersectsLeft	TokenNameIdentifier	 intersects Left
=	TokenNameEQUAL	
minOrdering	TokenNameIdentifier	 min Ordering
.	TokenNameDOT	
sortedCopy	TokenNameIdentifier	 sorted Copy
(	TokenNameLPAREN	
intersects	TokenNameIdentifier	 intersects
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intersectsRight	TokenNameIdentifier	 intersects Right
=	TokenNameEQUAL	
maxOrdering	TokenNameIdentifier	 max Ordering
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
sortedCopy	TokenNameIdentifier	 sorted Copy
(	TokenNameLPAREN	
intersects	TokenNameIdentifier	 intersects
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
leftSegment	TokenNameIdentifier	 left Segment
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
IntervalNode	TokenNameIdentifier	 Interval Node
(	TokenNameLPAREN	
leftSegment	TokenNameIdentifier	 left Segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
rightSegment	TokenNameIdentifier	 right Segment
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
IntervalNode	TokenNameIdentifier	 Interval Node
(	TokenNameLPAREN	
rightSegment	TokenNameIdentifier	 right Segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
(	TokenNameLPAREN	
intersects	TokenNameIdentifier	 intersects
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
leftSegment	TokenNameIdentifier	 left Segment
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
rightSegment	TokenNameIdentifier	 right Segment
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
"intersects ("	TokenNameStringLiteral	intersects (
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
intersects	TokenNameIdentifier	 intersects
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") + leftSegment ("	TokenNameStringLiteral	) + leftSegment (
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
leftSegment	TokenNameIdentifier	 left Segment
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") + rightSegment ("	TokenNameStringLiteral	) + rightSegment (
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
rightSegment	TokenNameIdentifier	 right Segment
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") != toBisect ("	TokenNameStringLiteral	) != toBisect (
+	TokenNamePLUS	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
toBisect	TokenNameIdentifier	 to Bisect
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
void	TokenNamevoid	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
low	TokenNameIdentifier	 low
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
high	TokenNameIdentifier	 high
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
center	TokenNameIdentifier	 center
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Adds every interval contained in this node to the result set then search left and right for further 	TokenNameCOMMENT_LINE	Adds every interval contained in this node to the result set then search left and right for further 
// overlapping intervals 	TokenNameCOMMENT_LINE	overlapping intervals 
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
intersectsLeft	TokenNameIdentifier	 intersects Left
)	TokenNameRPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
center	TokenNameIdentifier	 center
,	TokenNameCOMMA	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Adds intervals i in intersects right as long as i.max >= searchInterval.min 	TokenNameCOMMENT_LINE	Adds intervals i in intersects right as long as i.max >= searchInterval.min 
// then search right 	TokenNameCOMMENT_LINE	then search right 
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
intersectsRight	TokenNameIdentifier	 intersects Right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
center	TokenNameIdentifier	 center
,	TokenNameCOMMA	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Adds intervals i in intersects left as long as i.min >= searchInterval.max 	TokenNameCOMMENT_LINE	Adds intervals i in intersects left as long as i.min >= searchInterval.max 
// then search left 	TokenNameCOMMENT_LINE	then search left 
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
intersectsLeft	TokenNameIdentifier	 intersects Left
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparePoints	TokenNameIdentifier	 compare Points
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
searchInterval	TokenNameIdentifier	 search Interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
searchInternal	TokenNameIdentifier	 search Internal
(	TokenNameLPAREN	
searchInterval	TokenNameIdentifier	 search Interval
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
TreeIterator	TokenNameIdentifier	 Tree Iterator
extends	TokenNameextends	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Deque	TokenNameIdentifier	 Deque
<	TokenNameLESS	
IntervalNode	TokenNameIdentifier	 Interval Node
>	TokenNameGREATER	
stack	TokenNameIdentifier	 stack
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayDeque	TokenNameIdentifier	 Array Deque
<	TokenNameLESS	
IntervalNode	TokenNameIdentifier	 Interval Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
TreeIterator	TokenNameIdentifier	 Tree Iterator
(	TokenNameLPAREN	
IntervalNode	TokenNameIdentifier	 Interval Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gotoMinOf	TokenNameIdentifier	 goto Min Of
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
I	TokenNameIdentifier	 I
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IntervalNode	TokenNameIdentifier	 Interval Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
stack	TokenNameIdentifier	 stack
.	TokenNameDOT	
pollFirst	TokenNameIdentifier	 poll First
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
intersectsLeft	TokenNameIdentifier	 intersects Left
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We know this is the smaller not returned yet, but before doing 	TokenNameCOMMENT_LINE	We know this is the smaller not returned yet, but before doing 
// its parent, we must do everyone on it's right. 	TokenNameCOMMENT_LINE	its parent, we must do everyone on it's right. 
gotoMinOf	TokenNameIdentifier	 goto Min Of
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
gotoMinOf	TokenNameIdentifier	 goto Min Of
(	TokenNameLPAREN	
IntervalNode	TokenNameIdentifier	 Interval Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stack	TokenNameIdentifier	 stack
.	TokenNameDOT	
offerFirst	TokenNameIdentifier	 offer First
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Serializer	TokenNameIdentifier	 Serializer
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
extends	TokenNameextends	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
implements	TokenNameimplements	
IVersionedSerializer	TokenNameIdentifier	 I Versioned Serializer
<	TokenNameLESS	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>>	TokenNameRIGHT_SHIFT	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
pointSerializer	TokenNameIdentifier	 point Serializer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
dataSerializer	TokenNameIdentifier	 data Serializer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Constructor	TokenNameIdentifier	 Constructor
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
constructor	TokenNameIdentifier	 constructor
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Serializer	TokenNameIdentifier	 Serializer
(	TokenNameLPAREN	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
pointSerializer	TokenNameIdentifier	 point Serializer
,	TokenNameCOMMA	
ISerializer	TokenNameIdentifier	 I Serializer
<	TokenNameLESS	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
dataSerializer	TokenNameIdentifier	 data Serializer
,	TokenNameCOMMA	
Constructor	TokenNameIdentifier	 Constructor
<	TokenNameLESS	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
constructor	TokenNameIdentifier	 constructor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
pointSerializer	TokenNameIdentifier	 point Serializer
=	TokenNameEQUAL	
pointSerializer	TokenNameIdentifier	 point Serializer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
dataSerializer	TokenNameIdentifier	 data Serializer
=	TokenNameEQUAL	
dataSerializer	TokenNameIdentifier	 data Serializer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
constructor	TokenNameIdentifier	 constructor
=	TokenNameEQUAL	
constructor	TokenNameIdentifier	 constructor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
,	TokenNameCOMMA	
DataOutput	TokenNameIdentifier	 Data Output
dos	TokenNameIdentifier	 dos
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
dos	TokenNameIdentifier	 dos
.	TokenNameDOT	
writeInt	TokenNameIdentifier	 write Int
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
it	TokenNameIdentifier	 it
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
dos	TokenNameIdentifier	 dos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
dos	TokenNameIdentifier	 dos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dataSerializer	TokenNameIdentifier	 data Serializer
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
dos	TokenNameIdentifier	 dos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Deserialize an IntervalTree whose keys use the natural ordering. * Use deserialize(DataInput, int, Comparator) instead if the interval * tree is to use a custom comparator, as the comparator is *not* * serialized. */	TokenNameCOMMENT_JAVADOC	 Deserialize an IntervalTree whose keys use the natural ordering. Use deserialize(DataInput, int, Comparator) instead if the interval tree is to use a custom comparator, as the comparator is *not* serialized. 
public	TokenNamepublic	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
DataInput	TokenNameIdentifier	 Data Input
dis	TokenNameIdentifier	 dis
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
dis	TokenNameIdentifier	 dis
,	TokenNameCOMMA	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
DataInput	TokenNameIdentifier	 Data Input
dis	TokenNameIdentifier	 dis
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
C	TokenNameIdentifier	 C
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
dis	TokenNameIdentifier	 dis
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
intervals	TokenNameIdentifier	 intervals
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
C	TokenNameIdentifier	 C
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
dis	TokenNameIdentifier	 dis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
C	TokenNameIdentifier	 C
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
dis	TokenNameIdentifier	 dis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
D	TokenNameIdentifier	 D
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
dataSerializer	TokenNameIdentifier	 data Serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
dis	TokenNameIdentifier	 dis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
intervals	TokenNameIdentifier	 intervals
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
constructor	TokenNameIdentifier	 constructor
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
IntervalTree	TokenNameIdentifier	 Interval Tree
(	TokenNameLPAREN	
intervals	TokenNameIdentifier	 intervals
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvocationTargetException	TokenNameIdentifier	 Invocation Target Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
,	TokenNameCOMMA	
TypeSizes	TokenNameIdentifier	 Type Sizes
typeSizes	TokenNameIdentifier	 type Sizes
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
typeSizes	TokenNameIdentifier	 type Sizes
.	TokenNameDOT	
sizeof	TokenNameIdentifier	 sizeof
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Interval	TokenNameIdentifier	 Interval
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
>	TokenNameGREATER	
interval	TokenNameIdentifier	 interval
:	TokenNameCOLON	
it	TokenNameIdentifier	 it
)	TokenNameRPAREN	
{	TokenNameLBRACE	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
typeSizes	TokenNameIdentifier	 type Sizes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
pointSerializer	TokenNameIdentifier	 point Serializer
.	TokenNameDOT	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
max	TokenNameIdentifier	 max
,	TokenNameCOMMA	
typeSizes	TokenNameIdentifier	 type Sizes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
size	TokenNameIdentifier	 size
+=	TokenNamePLUS_EQUAL	
dataSerializer	TokenNameIdentifier	 data Serializer
.	TokenNameDOT	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
interval	TokenNameIdentifier	 interval
.	TokenNameDOT	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
typeSizes	TokenNameIdentifier	 type Sizes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
IntervalTree	TokenNameIdentifier	 Interval Tree
<	TokenNameLESS	
C	TokenNameIdentifier	 C
,	TokenNameCOMMA	
D	TokenNameIdentifier	 D
,	TokenNameCOMMA	
I	TokenNameIdentifier	 I
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
,	TokenNameCOMMA	
int	TokenNameint	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
,	TokenNameCOMMA	
TypeSizes	TokenNameIdentifier	 Type Sizes
.	TokenNameDOT	
NATIVE	TokenNameIdentifier	 NATIVE
,	TokenNameCOMMA	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
