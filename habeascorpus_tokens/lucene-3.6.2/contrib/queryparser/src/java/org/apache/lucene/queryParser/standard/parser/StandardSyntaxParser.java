/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParser.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. StandardSyntaxParser.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
standard	TokenNameIdentifier	 standard
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
Message	TokenNameIdentifier	 Message
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
MessageImpl	TokenNameIdentifier	 Message Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
QueryNodeError	TokenNameIdentifier	 Query Node Error
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
QueryNodeException	TokenNameIdentifier	 Query Node Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
QueryNodeParseException	TokenNameIdentifier	 Query Node Parse Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
QueryParserMessages	TokenNameIdentifier	 Query Parser Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
AndQueryNode	TokenNameIdentifier	 And Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
BooleanQueryNode	TokenNameIdentifier	 Boolean Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
BoostQueryNode	TokenNameIdentifier	 Boost Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
FieldQueryNode	TokenNameIdentifier	 Field Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
FuzzyQueryNode	TokenNameIdentifier	 Fuzzy Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
GroupQueryNode	TokenNameIdentifier	 Group Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
OpaqueQueryNode	TokenNameIdentifier	 Opaque Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
OrQueryNode	TokenNameIdentifier	 Or Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
ParametricRangeQueryNode	TokenNameIdentifier	 Parametric Range Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
SlopQueryNode	TokenNameIdentifier	 Slop Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
ProximityQueryNode	TokenNameIdentifier	 Proximity Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
QueryNode	TokenNameIdentifier	 Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
QueryNodeImpl	TokenNameIdentifier	 Query Node Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
nodes	TokenNameIdentifier	 nodes
.	TokenNameDOT	
QuotedFieldQueryNode	TokenNameIdentifier	 Quoted Field Query Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
SyntaxParser	TokenNameIdentifier	 Syntax Parser
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
implements	TokenNameimplements	
SyntaxParser	TokenNameIdentifier	 Syntax Parser
,	TokenNameCOMMA	
StandardSyntaxParserConstants	TokenNameIdentifier	 Standard Syntax Parser Constants
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_NONE	TokenNameIdentifier	 CONJ  NONE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// syntax parser constructor 	TokenNameCOMMENT_LINE	syntax parser constructor 
public	TokenNamepublic	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}. * @param query the query string to be parsed. * @throws ParseException if the parsing fails */	TokenNameCOMMENT_JAVADOC	 Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}. @param query the query string to be parsed. @throws ParseException if the parsing fails 
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
QueryNodeParseException	TokenNameIdentifier	 Query Node Parse Exception
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// TopLevelQuery is a Query followed by the end-of-input (EOF) 	TokenNameCOMMENT_LINE	TopLevelQuery is a Query followed by the end-of-input (EOF) 
QueryNode	TokenNameIdentifier	 Query Node
querynode	TokenNameIdentifier	 querynode
=	TokenNameEQUAL	
TopLevelQuery	TokenNameIdentifier	 Top Level Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
querynode	TokenNameIdentifier	 querynode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParseException	TokenNameIdentifier	 Parse Exception
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tme	TokenNameIdentifier	 tme
.	TokenNameDOT	
setQuery	TokenNameIdentifier	 set Query
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
tme	TokenNameIdentifier	 tme
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Error	TokenNameIdentifier	 Error
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Message	TokenNameIdentifier	 Message
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
new	TokenNamenew	
MessageImpl	TokenNameIdentifier	 Message Impl
(	TokenNameLPAREN	
QueryParserMessages	TokenNameIdentifier	 Query Parser Messages
.	TokenNameDOT	
INVALID_SYNTAX_CANNOT_PARSE	TokenNameIdentifier	 INVALID  SYNTAX  CANNOT  PARSE
,	TokenNameCOMMA	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
tme	TokenNameIdentifier	 tme
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QueryNodeParseException	TokenNameIdentifier	 Query Node Parse Exception
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
QueryNodeParseException	TokenNameIdentifier	 Query Node Parse Exception
(	TokenNameLPAREN	
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
setQuery	TokenNameIdentifier	 set Query
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
setNonLocalizedMessage	TokenNameIdentifier	 set Non Localized Message
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// * Query ::= ( Clause )* 	TokenNameCOMMENT_LINE	* Query ::= ( Clause )* 
// * Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" ) 	TokenNameCOMMENT_LINE	* Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" ) 
final	TokenNamefinal	
public	TokenNamepublic	
int	TokenNameint	
Conjunction	TokenNameIdentifier	 Conjunction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_NONE	TokenNameIdentifier	 CONJ  NONE
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
AND	TokenNameIdentifier	 AND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
OR	TokenNameIdentifier	 OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
Modifiers	TokenNameIdentifier	 Modifiers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
.	TokenNameDOT	
MOD_NONE	TokenNameIdentifier	 MOD  NONE
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
PLUS	TokenNameIdentifier	 PLUS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
.	TokenNameDOT	
MOD_REQ	TokenNameIdentifier	 MOD  REQ
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
MINUS	TokenNameIdentifier	 MINUS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
.	TokenNameDOT	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NOT	TokenNameIdentifier	 NOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
.	TokenNameDOT	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This makes sure that there is no garbage after the query string 	TokenNameCOMMENT_LINE	This makes sure that there is no garbage after the query string 
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
TopLevelQuery	TokenNameIdentifier	 Top Level Query
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryNode	TokenNameIdentifier	 Query Node
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// These changes were made to introduce operator precedence: 	TokenNameCOMMENT_LINE	These changes were made to introduce operator precedence: 
// - Clause() now returns a QueryNode. 	TokenNameCOMMENT_LINE	- Clause() now returns a QueryNode. 
// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object 	TokenNameCOMMENT_LINE	- The modifiers are consumed by Clause() and returned as part of the QueryNode Object 
// - Query does not consume conjunctions (AND, OR) anymore. 	TokenNameCOMMENT_LINE	- Query does not consume conjunctions (AND, OR) anymore. 
// - This is now done by two new non-terminals: ConjClause and DisjClause 	TokenNameCOMMENT_LINE	- This is now done by two new non-terminals: ConjClause and DisjClause 
// The parse tree looks similar to this: 	TokenNameCOMMENT_LINE	The parse tree looks similar to this: 
// Query ::= DisjQuery ( DisjQuery )* 	TokenNameCOMMENT_LINE	Query ::= DisjQuery ( DisjQuery )* 
// DisjQuery ::= ConjQuery ( OR ConjQuery )* 	TokenNameCOMMENT_LINE	DisjQuery ::= ConjQuery ( OR ConjQuery )* 
// ConjQuery ::= Clause ( AND Clause )* 	TokenNameCOMMENT_LINE	ConjQuery ::= Clause ( AND Clause )* 
// Clause ::= [ Modifier ] ... 	TokenNameCOMMENT_LINE	Clause ::= [ Modifier ] ... 
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
QueryNode	TokenNameIdentifier	 Query Node
c	TokenNameIdentifier	 c
,	TokenNameCOMMA	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
DisjQuery	TokenNameIdentifier	 Disj Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_1	TokenNameIdentifier	 label 1
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
case	TokenNamecase	
LPAREN	TokenNameIdentifier	 LPAREN
:	TokenNameCOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_1	TokenNameIdentifier	 label 1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
DisjQuery	TokenNameIdentifier	 Disj Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
BooleanQueryNode	TokenNameIdentifier	 Boolean Query Node
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
DisjQuery	TokenNameIdentifier	 Disj Query
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryNode	TokenNameIdentifier	 Query Node
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
ConjQuery	TokenNameIdentifier	 Conj Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_2	TokenNameIdentifier	 label 2
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_2	TokenNameIdentifier	 label 2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
OR	TokenNameIdentifier	 OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ConjQuery	TokenNameIdentifier	 Conj Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
OrQueryNode	TokenNameIdentifier	 Or Query Node
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
ConjQuery	TokenNameIdentifier	 Conj Query
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryNode	TokenNameIdentifier	 Query Node
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
ModClause	TokenNameIdentifier	 Mod Clause
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
label_3	TokenNameIdentifier	 label 3
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_3	TokenNameIdentifier	 label 3
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
AND	TokenNameIdentifier	 AND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
ModClause	TokenNameIdentifier	 Mod Clause
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
<	TokenNameLESS	
QueryNode	TokenNameIdentifier	 Query Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
AndQueryNode	TokenNameIdentifier	 And Query Node
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// QueryNode Query(CharSequence field) : 	TokenNameCOMMENT_LINE	QueryNode Query(CharSequence field) : 
// { 	TokenNameCOMMENT_LINE	{ 
// List clauses = new ArrayList(); 	TokenNameCOMMENT_LINE	List clauses = new ArrayList(); 
// List modifiers = new ArrayList(); 	TokenNameCOMMENT_LINE	List modifiers = new ArrayList(); 
// QueryNode q, firstQuery=null; 	TokenNameCOMMENT_LINE	QueryNode q, firstQuery=null; 
// ModifierQueryNode.Modifier mods; 	TokenNameCOMMENT_LINE	ModifierQueryNode.Modifier mods; 
// int conj; 	TokenNameCOMMENT_LINE	int conj; 
// } 	TokenNameCOMMENT_LINE	} 
// { 	TokenNameCOMMENT_LINE	{ 
// mods=Modifiers() q=Clause(field) 	TokenNameCOMMENT_LINE	mods=Modifiers() q=Clause(field) 
// { 	TokenNameCOMMENT_LINE	{ 
// if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q; 	TokenNameCOMMENT_LINE	if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q; 
// 	TokenNameCOMMENT_LINE	 
// // do not create modifier nodes with MOD_NONE 	TokenNameCOMMENT_LINE	// do not create modifier nodes with MOD_NONE 
// if (mods != ModifierQueryNode.Modifier.MOD_NONE) { 	TokenNameCOMMENT_LINE	if (mods != ModifierQueryNode.Modifier.MOD_NONE) { 
// q = new ModifierQueryNode(q, mods); 	TokenNameCOMMENT_LINE	q = new ModifierQueryNode(q, mods); 
// } 	TokenNameCOMMENT_LINE	} 
// clauses.add(q); 	TokenNameCOMMENT_LINE	clauses.add(q); 
// } 	TokenNameCOMMENT_LINE	} 
// ( 	TokenNameCOMMENT_LINE	( 
// conj=Conjunction() mods=Modifiers() q=Clause(field) 	TokenNameCOMMENT_LINE	conj=Conjunction() mods=Modifiers() q=Clause(field) 
// { 	TokenNameCOMMENT_LINE	{ 
// // do not create modifier nodes with MOD_NONE 	TokenNameCOMMENT_LINE	// do not create modifier nodes with MOD_NONE 
// if (mods != ModifierQueryNode.Modifier.MOD_NONE) { 	TokenNameCOMMENT_LINE	if (mods != ModifierQueryNode.Modifier.MOD_NONE) { 
// q = new ModifierQueryNode(q, mods); 	TokenNameCOMMENT_LINE	q = new ModifierQueryNode(q, mods); 
// } 	TokenNameCOMMENT_LINE	} 
// clauses.add(q); 	TokenNameCOMMENT_LINE	clauses.add(q); 
// //TODO: figure out what to do with AND and ORs 	TokenNameCOMMENT_LINE	//TODO: figure out what to do with AND and ORs 
// } 	TokenNameCOMMENT_LINE	} 
// )* 	TokenNameCOMMENT_LINE	)* 
// { 	TokenNameCOMMENT_LINE	{ 
// if (clauses.size() == 1 && firstQuery != null) 	TokenNameCOMMENT_LINE	if (clauses.size() == 1 && firstQuery != null) 
// return firstQuery; 	TokenNameCOMMENT_LINE	return firstQuery; 
// else { 	TokenNameCOMMENT_LINE	else { 
// return new BooleanQueryNode(clauses); 	TokenNameCOMMENT_LINE	return new BooleanQueryNode(clauses); 
// } 	TokenNameCOMMENT_LINE	} 
// } 	TokenNameCOMMENT_LINE	} 
// } 	TokenNameCOMMENT_LINE	} 
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
ModClause	TokenNameIdentifier	 Mod Clause
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryNode	TokenNameIdentifier	 Query Node
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
mods	TokenNameIdentifier	 mods
;	TokenNameSEMICOLON	
mods	TokenNameIdentifier	 mods
=	TokenNameEQUAL	
Modifiers	TokenNameIdentifier	 Modifiers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Clause	TokenNameIdentifier	 Clause
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mods	TokenNameIdentifier	 mods
!=	TokenNameNOT_EQUAL	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
.	TokenNameDOT	
Modifier	TokenNameIdentifier	 Modifier
.	TokenNameDOT	
MOD_NONE	TokenNameIdentifier	 MOD  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
ModifierQueryNode	TokenNameIdentifier	 Modifier Query Node
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
mods	TokenNameIdentifier	 mods
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
Clause	TokenNameIdentifier	 Clause
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
QueryNode	TokenNameIdentifier	 Query Node
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
fieldToken	TokenNameIdentifier	 field Token
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fieldToken	TokenNameIdentifier	 field Token
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
fieldToken	TokenNameIdentifier	 field Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LPAREN	TokenNameIdentifier	 LPAREN
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
LPAREN	TokenNameIdentifier	 LPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RPAREN	TokenNameIdentifier	 RPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// avoid boosting null queries, such as those caused by stop words 	TokenNameCOMMENT_LINE	avoid boosting null queries, such as those caused by stop words 
if	TokenNameif	
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
BoostQueryNode	TokenNameIdentifier	 Boost Query Node
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Should this be handled somehow? (defaults to "no boost", if * boost number is invalid) */	TokenNameCOMMENT_BLOCK	 Should this be handled somehow? (defaults to "no boost", if boost number is invalid) 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
GroupQueryNode	TokenNameIdentifier	 Group Query Node
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
QueryNode	TokenNameIdentifier	 Query Node
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
CharSequence	TokenNameIdentifier	 Char Sequence
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
QueryNode	TokenNameIdentifier	 Query Node
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
qLower	TokenNameIdentifier	 q Lower
,	TokenNameCOMMA	
qUpper	TokenNameIdentifier	 q Upper
;	TokenNameSEMICOLON	
float	TokenNamefloat	
defaultMinSimilarity	TokenNameIdentifier	 default Min Similarity
=	TokenNameEQUAL	
0.5f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
FieldQueryNode	TokenNameIdentifier	 Field Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
9	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
11	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
12	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fuzzy	TokenNameIdentifier	 fuzzy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
fms	TokenNameIdentifier	 fms
=	TokenNameEQUAL	
defaultMinSimilarity	TokenNameIdentifier	 default Min Similarity
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fms	TokenNameIdentifier	 fms
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fms	TokenNameIdentifier	 fms
<	TokenNameLESS	
0.0f	TokenNameFloatingPointLiteral	
||	TokenNameOR_OR	
fms	TokenNameIdentifier	 fms
>	TokenNameGREATER	
1.0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
new	TokenNamenew	
MessageImpl	TokenNameIdentifier	 Message Impl
(	TokenNameLPAREN	
QueryParserMessages	TokenNameIdentifier	 Query Parser Messages
.	TokenNameDOT	
INVALID_SYNTAX_FUZZY_LIMITS	TokenNameIdentifier	 INVALID  SYNTAX  FUZZY  LIMITS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
FuzzyQueryNode	TokenNameIdentifier	 Fuzzy Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fms	TokenNameIdentifier	 fms
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
13	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_TO	TokenNameIdentifier	 RANGEIN  TO
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_TO	TokenNameIdentifier	 RANGEIN  TO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
14	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
15	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_END	TokenNameIdentifier	 RANGEIN  END
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
16	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qLower	TokenNameIdentifier	 q Lower
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
.	TokenNameDOT	
CompareOperator	TokenNameIdentifier	 Compare Operator
.	TokenNameDOT	
GE	TokenNameIdentifier	 GE
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
qUpper	TokenNameIdentifier	 q Upper
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
.	TokenNameDOT	
CompareOperator	TokenNameIdentifier	 Compare Operator
.	TokenNameDOT	
LE	TokenNameIdentifier	 LE
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricRangeQueryNode	TokenNameIdentifier	 Parametric Range Query Node
(	TokenNameLPAREN	
qLower	TokenNameIdentifier	 q Lower
,	TokenNameCOMMA	
qUpper	TokenNameIdentifier	 q Upper
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
17	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_TO	TokenNameIdentifier	 RANGEEX  TO
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_TO	TokenNameIdentifier	 RANGEEX  TO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
18	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
19	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_END	TokenNameIdentifier	 RANGEEX  END
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
20	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
qLower	TokenNameIdentifier	 q Lower
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
.	TokenNameDOT	
CompareOperator	TokenNameIdentifier	 Compare Operator
.	TokenNameDOT	
GT	TokenNameIdentifier	 GT
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
qUpper	TokenNameIdentifier	 q Upper
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
ParametricQueryNode	TokenNameIdentifier	 Parametric Query Node
.	TokenNameDOT	
CompareOperator	TokenNameIdentifier	 Compare Operator
.	TokenNameDOT	
LT	TokenNameIdentifier	 LT
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
ParametricRangeQueryNode	TokenNameIdentifier	 Parametric Range Query Node
(	TokenNameLPAREN	
qLower	TokenNameIdentifier	 q Lower
,	TokenNameCOMMA	
qUpper	TokenNameIdentifier	 q Upper
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
QUOTED	TokenNameIdentifier	 QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
QuotedFieldQueryNode	TokenNameIdentifier	 Quoted Field Query Node
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
EscapeQuerySyntaxImpl	TokenNameIdentifier	 Escape Query Syntax Impl
.	TokenNameDOT	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
21	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
22	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
phraseSlop	TokenNameIdentifier	 phrase Slop
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
phraseSlop	TokenNameIdentifier	 phrase Slop
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
SlopQueryNode	TokenNameIdentifier	 Slop Query Node
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
phraseSlop	TokenNameIdentifier	 phrase Slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Should this be handled somehow? (defaults to "no PhraseSlop", if * slop number is invalid) */	TokenNameCOMMENT_BLOCK	 Should this be handled somehow? (defaults to "no PhraseSlop", if slop number is invalid) 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
23	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// avoid boosting null queries, such as those caused by stop words 	TokenNameCOMMENT_LINE	avoid boosting null queries, such as those caused by stop words 
if	TokenNameif	
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
new	TokenNamenew	
BoostQueryNode	TokenNameIdentifier	 Boost Query Node
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Should this be handled somehow? (defaults to "no boost", if * boost number is invalid) */	TokenNameCOMMENT_BLOCK	 Should this be handled somehow? (defaults to "no boost", if boost number is invalid) 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Generated Token Manager. 
public	TokenNamepublic	
StandardSyntaxParserTokenManager	TokenNameIdentifier	 Standard Syntax Parser Token Manager
token_source	TokenNameIdentifier	 token source
;	TokenNameSEMICOLON	
JavaCharStream	TokenNameIdentifier	 Java Char Stream
jj_input_stream	TokenNameIdentifier	 jj input stream
;	TokenNameSEMICOLON	
/** Current token. */	TokenNameCOMMENT_JAVADOC	 Current token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
/** Next token. */	TokenNameCOMMENT_JAVADOC	 Next token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
jj_nt	TokenNameIdentifier	 jj nt
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_scanpos	TokenNameIdentifier	 jj scanpos
,	TokenNameCOMMA	
jj_lastpos	TokenNameIdentifier	 jj lastpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
final	TokenNamefinal	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1	TokenNameIdentifier	 jj la1
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
24	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1_0	TokenNameIdentifier	 jj la1 0
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la1_0	TokenNameIdentifier	 jj la1 0
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
0x300	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x300	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1c00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1c00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x763c00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x200	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x100	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x10000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x762000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x440000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x80000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x80000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x10000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x6000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x800000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x6000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x10000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x60000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x8000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x60000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x10000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x80000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x10000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x760000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Constructor with InputStream. */	TokenNameCOMMENT_JAVADOC	 Constructor with InputStream. 
public	TokenNamepublic	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor with InputStream and supplied encoding */	TokenNameCOMMENT_JAVADOC	 Constructor with InputStream and supplied encoding 
public	TokenNamepublic	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
jj_input_stream	TokenNameIdentifier	 jj input stream
=	TokenNameEQUAL	
new	TokenNamenew	
JavaCharStream	TokenNameIdentifier	 Java Char Stream
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
new	TokenNamenew	
StandardSyntaxParserTokenManager	TokenNameIdentifier	 Standard Syntax Parser Token Manager
(	TokenNameLPAREN	
jj_input_stream	TokenNameIdentifier	 jj input stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
jj_input_stream	TokenNameIdentifier	 jj input stream
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
UnsupportedEncodingException	TokenNameIdentifier	 Unsupported Encoding Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
jj_input_stream	TokenNameIdentifier	 jj input stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_input_stream	TokenNameIdentifier	 jj input stream
=	TokenNameEQUAL	
new	TokenNamenew	
JavaCharStream	TokenNameIdentifier	 Java Char Stream
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
new	TokenNamenew	
StandardSyntaxParserTokenManager	TokenNameIdentifier	 Standard Syntax Parser Token Manager
(	TokenNameLPAREN	
jj_input_stream	TokenNameIdentifier	 jj input stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_input_stream	TokenNameIdentifier	 jj input stream
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
jj_input_stream	TokenNameIdentifier	 jj input stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor with generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Constructor with generated Token Manager. 
public	TokenNamepublic	
StandardSyntaxParser	TokenNameIdentifier	 Standard Syntax Parser
(	TokenNameLPAREN	
StandardSyntaxParserTokenManager	TokenNameIdentifier	 Standard Syntax Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
StandardSyntaxParserTokenManager	TokenNameIdentifier	 Standard Syntax Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
oldToken	TokenNameIdentifier	 old Token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jj_gc	TokenNameIdentifier	 jj gc
>	TokenNameGREATER	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
<	TokenNameLESS	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
extends	TokenNameextends	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
Error	TokenNameIdentifier	 Error
{	TokenNameLBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
jj_ls	TokenNameIdentifier	 jj ls
=	TokenNameEQUAL	
new	TokenNamenew	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_rescan	TokenNameIdentifier	 jj rescan
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la	TokenNameIdentifier	 jj la
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
throw	TokenNamethrow	
jj_ls	TokenNameIdentifier	 jj ls
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the specific Token. */	TokenNameCOMMENT_JAVADOC	 Get the specific Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_nt	TokenNameIdentifier	 jj nt
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
jj_nt	TokenNameIdentifier	 jj nt
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
jj_expentries	TokenNameIdentifier	 jj expentries
=	TokenNameEQUAL	
new	TokenNamenew	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_expentry	TokenNameIdentifier	 jj expentry
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
100	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>=	TokenNameGREATER_EQUAL	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
jj_endpos	TokenNameIdentifier	 jj endpos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
oldentry	TokenNameIdentifier	 oldentry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Generate ParseException. */	TokenNameCOMMENT_JAVADOC	 Generate ParseException. 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
la1tokens	TokenNameIdentifier	 la1tokens
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
31	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_kind	TokenNameIdentifier	 jj kind
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
jj_kind	TokenNameIdentifier	 jj kind
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_la1_0	TokenNameIdentifier	 jj la1 0
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
31	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
exptokseq	TokenNameIdentifier	 exptokseq
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exptokseq	TokenNameIdentifier	 exptokseq
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
exptokseq	TokenNameIdentifier	 exptokseq
,	TokenNameCOMMA	
tokenImage	TokenNameIdentifier	 token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Enable tracing. */	TokenNameCOMMENT_JAVADOC	 Enable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
enable_tracing	TokenNameIdentifier	 enable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** Disable tracing. */	TokenNameCOMMENT_JAVADOC	 Disable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
disable_tracing	TokenNameIdentifier	 disable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
+	TokenNamePLUS	
xla	TokenNameIdentifier	 xla
-	TokenNameMINUS	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
JJCalls	TokenNameIdentifier	 JJ Calls
{	TokenNameLBRACE	
int	TokenNameint	
gen	TokenNameIdentifier	 gen
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
int	TokenNameint	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
JJCalls	TokenNameIdentifier	 JJ Calls
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
