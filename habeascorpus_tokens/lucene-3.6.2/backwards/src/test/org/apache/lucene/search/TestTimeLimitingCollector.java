package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BitSet	TokenNameIdentifier	 Bit Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
QueryParser	TokenNameIdentifier	 Query Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TimeLimitingCollector	TokenNameIdentifier	 Time Limiting Collector
.	TokenNameDOT	
TimeExceededException	TokenNameIdentifier	 Time Exceeded Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TimeLimitingCollector	TokenNameIdentifier	 Time Limiting Collector
.	TokenNameDOT	
TimerThread	TokenNameIdentifier	 Timer Thread
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Counter	TokenNameIdentifier	 Counter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
;	TokenNameSEMICOLON	
/** * Tests the {@link TimeLimitingCollector}. This test checks (1) search * correctness (regardless of timeout), (2) expected timeout behavior, * and (3) a sanity test with multiple searching threads. */	TokenNameCOMMENT_JAVADOC	 Tests the {@link TimeLimitingCollector}. This test checks (1) search correctness (regardless of timeout), (2) expected timeout behavior, and (3) a sanity test with multiple searching threads. 
public	TokenNamepublic	
class	TokenNameclass	
TestTimeLimitingCollector	TokenNameIdentifier	 Test Time Limiting Collector
extends	TokenNameextends	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SLOW_DOWN	TokenNameIdentifier	 SLOW  DOWN
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
=	TokenNameEQUAL	
17	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
SLOW_DOWN	TokenNameIdentifier	 SLOW  DOWN
;	TokenNameSEMICOLON	
// so searches can find about 17 docs. 	TokenNameCOMMENT_LINE	so searches can find about 17 docs. 
// max time allowed is relaxed for multithreading tests. 	TokenNameCOMMENT_LINE	max time allowed is relaxed for multithreading tests. 
// the multithread case fails when setting this to 1 (no slack) and launching many threads (>2000). 	TokenNameCOMMENT_LINE	the multithread case fails when setting this to 1 (no slack) and launching many threads (>2000). 
// but this is not a real failure, just noise. 	TokenNameCOMMENT_LINE	but this is not a real failure, just noise. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
MULTI_THREAD_SLACK	TokenNameIdentifier	 MULTI  THREAD  SLACK
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
N_DOCS	TokenNameIdentifier	 N  DOCS
=	TokenNameEQUAL	
3000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
N_THREADS	TokenNameIdentifier	 N  THREADS
=	TokenNameEQUAL	
50	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Searcher	TokenNameIdentifier	 Searcher
searcher	TokenNameIdentifier	 searcher
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
=	TokenNameEQUAL	
"body"	TokenNameStringLiteral	body
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Counter	TokenNameIdentifier	 Counter
counter	TokenNameIdentifier	 counter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
TimerThread	TokenNameIdentifier	 Timer Thread
counterThread	TokenNameIdentifier	 counter Thread
;	TokenNameSEMICOLON	
/** * initializes searcher with a document set */	TokenNameCOMMENT_JAVADOC	 initializes searcher with a document set 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setUp	TokenNameIdentifier	 set Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
setUp	TokenNameIdentifier	 set Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
Counter	TokenNameIdentifier	 Counter
.	TokenNameDOT	
newCounter	TokenNameIdentifier	 new Counter
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
=	TokenNameEQUAL	
new	TokenNamenew	
TimerThread	TokenNameIdentifier	 Timer Thread
(	TokenNameLPAREN	
counter	TokenNameIdentifier	 counter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
docText	TokenNameIdentifier	 doc Text
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero"	TokenNameStringLiteral	docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero
,	TokenNameCOMMA	
"one blah three"	TokenNameStringLiteral	one blah three
,	TokenNameCOMMA	
"one foo three multiOne"	TokenNameStringLiteral	one foo three multiOne
,	TokenNameCOMMA	
"one foobar three multiThree"	TokenNameStringLiteral	one foobar three multiThree
,	TokenNameCOMMA	
"blueberry pancakes"	TokenNameStringLiteral	blueberry pancakes
,	TokenNameCOMMA	
"blueberry pie"	TokenNameStringLiteral	blueberry pie
,	TokenNameCOMMA	
"blueberry strudel"	TokenNameStringLiteral	blueberry strudel
,	TokenNameCOMMA	
"blueberry pizza"	TokenNameStringLiteral	blueberry pizza
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
iw	TokenNameIdentifier	 iw
=	TokenNameEQUAL	
new	TokenNamenew	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
,	TokenNameCOMMA	
new	TokenNamenew	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
N_DOCS	TokenNameIdentifier	 N  DOCS
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
docText	TokenNameIdentifier	 doc Text
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
%	TokenNameREMAINDER	
docText	TokenNameIdentifier	 doc Text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
iw	TokenNameIdentifier	 iw
.	TokenNameDOT	
getReader	TokenNameIdentifier	 get Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iw	TokenNameIdentifier	 iw
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
searcher	TokenNameIdentifier	 searcher
=	TokenNameEQUAL	
newSearcher	TokenNameIdentifier	 new Searcher
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
qtxt	TokenNameIdentifier	 qtxt
=	TokenNameEQUAL	
"one"	TokenNameStringLiteral	one
;	TokenNameSEMICOLON	
// start from 1, so that the 0th doc never matches 	TokenNameCOMMENT_LINE	start from 1, so that the 0th doc never matches 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
docText	TokenNameIdentifier	 doc Text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
qtxt	TokenNameIdentifier	 qtxt
+=	TokenNamePLUS_EQUAL	
' '	TokenNameCharacterLiteral	
+	TokenNamePLUS	
docText	TokenNameIdentifier	 doc Text
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// large query so that search will be longer 	TokenNameCOMMENT_LINE	large query so that search will be longer 
}	TokenNameRBRACE	
QueryParser	TokenNameIdentifier	 Query Parser
queryParser	TokenNameIdentifier	 query Parser
=	TokenNameEQUAL	
new	TokenNamenew	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
,	TokenNameCOMMA	
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
MockAnalyzer	TokenNameIdentifier	 Mock Analyzer
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
qtxt	TokenNameIdentifier	 qtxt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// warm the searcher 	TokenNameCOMMENT_LINE	warm the searcher 
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
stopTimer	TokenNameIdentifier	 stop Timer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
RandomIndexWriter	TokenNameIdentifier	 Random Index Writer
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
new	TokenNamenew	
Document	TokenNameIdentifier	 Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
.	TokenNameDOT	
ANALYZED	TokenNameIdentifier	 ANALYZED
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iw	TokenNameIdentifier	 iw
.	TokenNameDOT	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
Collector	TokenNameIdentifier	 Collector
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
searcher	TokenNameIdentifier	 searcher
.	TokenNameDOT	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
collector	TokenNameIdentifier	 collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * test search correctness with no timeout */	TokenNameCOMMENT_JAVADOC	 test search correctness with no timeout 
public	TokenNamepublic	
void	TokenNamevoid	
testSearch	TokenNameIdentifier	 test Search
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doTestSearch	TokenNameIdentifier	 do Test Search
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
doTestSearch	TokenNameIdentifier	 do Test Search
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
totalResults	TokenNameIdentifier	 total Results
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
totalTLCResults	TokenNameIdentifier	 total TLC Results
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
myHc	TokenNameIdentifier	 my Hc
=	TokenNameEQUAL	
new	TokenNamenew	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
myHc	TokenNameIdentifier	 my Hc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalResults	TokenNameIdentifier	 total Results
=	TokenNameEQUAL	
myHc	TokenNameIdentifier	 my Hc
.	TokenNameDOT	
hitCount	TokenNameIdentifier	 hit Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
myHc	TokenNameIdentifier	 my Hc
=	TokenNameEQUAL	
new	TokenNamenew	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
oneHour	TokenNameIdentifier	 one Hour
=	TokenNameEQUAL	
3600000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Collector	TokenNameIdentifier	 Collector
tlCollector	TokenNameIdentifier	 tl Collector
=	TokenNameEQUAL	
createTimedCollector	TokenNameIdentifier	 create Timed Collector
(	TokenNameLPAREN	
myHc	TokenNameIdentifier	 my Hc
,	TokenNameCOMMA	
oneHour	TokenNameIdentifier	 one Hour
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
tlCollector	TokenNameIdentifier	 tl Collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalTLCResults	TokenNameIdentifier	 total TLC Results
=	TokenNameEQUAL	
myHc	TokenNameIdentifier	 my Hc
.	TokenNameDOT	
hitCount	TokenNameIdentifier	 hit Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"Unexpected exception: "	TokenNameStringLiteral	Unexpected exception: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//==fail 	TokenNameCOMMENT_LINE	==fail 
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"Wrong number of results!"	TokenNameStringLiteral	Wrong number of results!
,	TokenNameCOMMA	
totalResults	TokenNameIdentifier	 total Results
,	TokenNameCOMMA	
totalTLCResults	TokenNameIdentifier	 total TLC Results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Collector	TokenNameIdentifier	 Collector
createTimedCollector	TokenNameIdentifier	 create Timed Collector
(	TokenNameLPAREN	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
hc	TokenNameIdentifier	 hc
,	TokenNameCOMMA	
long	TokenNamelong	
timeAllowed	TokenNameIdentifier	 time Allowed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
greedy	TokenNameIdentifier	 greedy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TimeLimitingCollector	TokenNameIdentifier	 Time Limiting Collector
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
new	TokenNamenew	
TimeLimitingCollector	TokenNameIdentifier	 Time Limiting Collector
(	TokenNameLPAREN	
hc	TokenNameIdentifier	 hc
,	TokenNameCOMMA	
counter	TokenNameIdentifier	 counter
,	TokenNameCOMMA	
timeAllowed	TokenNameIdentifier	 time Allowed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
setGreedy	TokenNameIdentifier	 set Greedy
(	TokenNameLPAREN	
greedy	TokenNameIdentifier	 greedy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set to true to make sure at least one doc is collected. 	TokenNameCOMMENT_LINE	set to true to make sure at least one doc is collected. 
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test that timeout is obtained, and soon enough! */	TokenNameCOMMENT_JAVADOC	 Test that timeout is obtained, and soon enough! 
public	TokenNamepublic	
void	TokenNamevoid	
testTimeoutGreedy	TokenNameIdentifier	 test Timeout Greedy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test that timeout is obtained, and soon enough! */	TokenNameCOMMENT_JAVADOC	 Test that timeout is obtained, and soon enough! 
public	TokenNamepublic	
void	TokenNamevoid	
testTimeoutNotGreedy	TokenNameIdentifier	 test Timeout Not Greedy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
boolean	TokenNameboolean	
multiThreaded	TokenNameIdentifier	 multi Threaded
,	TokenNameCOMMA	
boolean	TokenNameboolean	
greedy	TokenNameIdentifier	 greedy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// setup 	TokenNameCOMMENT_LINE	setup 
MyHitCollector	TokenNameIdentifier	 My Hit Collector
myHc	TokenNameIdentifier	 my Hc
=	TokenNameEQUAL	
new	TokenNamenew	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
myHc	TokenNameIdentifier	 my Hc
.	TokenNameDOT	
setSlowDown	TokenNameIdentifier	 set Slow Down
(	TokenNameLPAREN	
SLOW_DOWN	TokenNameIdentifier	 SLOW  DOWN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collector	TokenNameIdentifier	 Collector
tlCollector	TokenNameIdentifier	 tl Collector
=	TokenNameEQUAL	
createTimedCollector	TokenNameIdentifier	 create Timed Collector
(	TokenNameLPAREN	
myHc	TokenNameIdentifier	 my Hc
,	TokenNameCOMMA	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
,	TokenNameCOMMA	
greedy	TokenNameIdentifier	 greedy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// search 	TokenNameCOMMENT_LINE	search 
TimeExceededException	TokenNameIdentifier	 Time Exceeded Exception
timoutException	TokenNameIdentifier	 timout Exception
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
tlCollector	TokenNameIdentifier	 tl Collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TimeExceededException	TokenNameIdentifier	 Time Exceeded Exception
x	TokenNameIdentifier	 x
)	TokenNameRPAREN	
{	TokenNameLBRACE	
timoutException	TokenNameIdentifier	 timout Exception
=	TokenNameEQUAL	
x	TokenNameIdentifier	 x
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"Unexpected exception: "	TokenNameStringLiteral	Unexpected exception: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//==fail 	TokenNameCOMMENT_LINE	==fail 
}	TokenNameRBRACE	
// must get exception 	TokenNameCOMMENT_LINE	must get exception 
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
"Timeout expected!"	TokenNameStringLiteral	Timeout expected!
,	TokenNameCOMMA	
timoutException	TokenNameIdentifier	 timout Exception
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// greediness affect last doc collected 	TokenNameCOMMENT_LINE	greediness affect last doc collected 
int	TokenNameint	
exceptionDoc	TokenNameIdentifier	 exception Doc
=	TokenNameEQUAL	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getLastDocCollected	TokenNameIdentifier	 get Last Doc Collected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastCollected	TokenNameIdentifier	 last Collected
=	TokenNameEQUAL	
myHc	TokenNameIdentifier	 my Hc
.	TokenNameDOT	
getLastDocCollected	TokenNameIdentifier	 get Last Doc Collected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"doc collected at timeout must be > 0!"	TokenNameStringLiteral	doc collected at timeout must be > 0!
,	TokenNameCOMMA	
exceptionDoc	TokenNameIdentifier	 exception Doc
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
greedy	TokenNameIdentifier	 greedy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"greedy="	TokenNameStringLiteral	greedy=
+	TokenNamePLUS	
greedy	TokenNameIdentifier	 greedy
+	TokenNamePLUS	
" exceptionDoc="	TokenNameStringLiteral	 exceptionDoc=
+	TokenNamePLUS	
exceptionDoc	TokenNameIdentifier	 exception Doc
+	TokenNamePLUS	
" != lastCollected="	TokenNameStringLiteral	 != lastCollected=
+	TokenNamePLUS	
lastCollected	TokenNameIdentifier	 last Collected
,	TokenNameCOMMA	
exceptionDoc	TokenNameIdentifier	 exception Doc
==	TokenNameEQUAL_EQUAL	
lastCollected	TokenNameIdentifier	 last Collected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"greedy, but no hits found!"	TokenNameStringLiteral	greedy, but no hits found!
,	TokenNameCOMMA	
myHc	TokenNameIdentifier	 my Hc
.	TokenNameDOT	
hitCount	TokenNameIdentifier	 hit Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"greedy="	TokenNameStringLiteral	greedy=
+	TokenNamePLUS	
greedy	TokenNameIdentifier	 greedy
+	TokenNamePLUS	
" exceptionDoc="	TokenNameStringLiteral	 exceptionDoc=
+	TokenNamePLUS	
exceptionDoc	TokenNameIdentifier	 exception Doc
+	TokenNamePLUS	
" not > lastCollected="	TokenNameStringLiteral	 not > lastCollected=
+	TokenNamePLUS	
lastCollected	TokenNameIdentifier	 last Collected
,	TokenNameCOMMA	
exceptionDoc	TokenNameIdentifier	 exception Doc
>	TokenNameGREATER	
lastCollected	TokenNameIdentifier	 last Collected
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// verify that elapsed time at exception is within valid limits 	TokenNameCOMMENT_LINE	verify that elapsed time at exception is within valid limits 
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeAllowed	TokenNameIdentifier	 get Time Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// a) Not too early 	TokenNameCOMMENT_LINE	a) Not too early 
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"elapsed="	TokenNameStringLiteral	elapsed=
+	TokenNamePLUS	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeElapsed	TokenNameIdentifier	 get Time Elapsed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" <= (allowed-resolution)="	TokenNameStringLiteral	 <= (allowed-resolution)=
+	TokenNamePLUS	
(	TokenNameLPAREN	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
-	TokenNameMINUS	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeElapsed	TokenNameIdentifier	 get Time Elapsed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
-	TokenNameMINUS	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// b) Not too late. 	TokenNameCOMMENT_LINE	b) Not too late. 
// This part is problematic in a busy test system, so we just print a warning. 	TokenNameCOMMENT_LINE	This part is problematic in a busy test system, so we just print a warning. 
// We already verified that a timeout occurred, we just can't be picky about how long it took. 	TokenNameCOMMENT_LINE	We already verified that a timeout occurred, we just can't be picky about how long it took. 
if	TokenNameif	
(	TokenNameLPAREN	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeElapsed	TokenNameIdentifier	 get Time Elapsed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
maxTime	TokenNameIdentifier	 max Time
(	TokenNameLPAREN	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Informative: timeout exceeded (no action required: most probably just "	TokenNameStringLiteral	Informative: timeout exceeded (no action required: most probably just 
+	TokenNamePLUS	
" because the test machine is slower than usual): "	TokenNameStringLiteral	 because the test machine is slower than usual): 
+	TokenNamePLUS	
"lastDoc="	TokenNameStringLiteral	lastDoc=
+	TokenNamePLUS	
exceptionDoc	TokenNameIdentifier	 exception Doc
+	TokenNamePLUS	
" ,&& allowed="	TokenNameStringLiteral	 ,&& allowed=
+	TokenNamePLUS	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeAllowed	TokenNameIdentifier	 get Time Allowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" ,&& elapsed="	TokenNameStringLiteral	 ,&& elapsed=
+	TokenNamePLUS	
timoutException	TokenNameIdentifier	 timout Exception
.	TokenNameDOT	
getTimeElapsed	TokenNameIdentifier	 get Time Elapsed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" >= "	TokenNameStringLiteral	 >= 
+	TokenNamePLUS	
maxTimeStr	TokenNameIdentifier	 max Time Str
(	TokenNameLPAREN	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
long	TokenNamelong	
maxTime	TokenNameIdentifier	 max Time
(	TokenNameLPAREN	
boolean	TokenNameboolean	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
+	TokenNamePLUS	
SLOW_DOWN	TokenNameIdentifier	 SLOW  DOWN
;	TokenNameSEMICOLON	
// some slack for less noise in this test 	TokenNameCOMMENT_LINE	some slack for less noise in this test 
if	TokenNameif	
(	TokenNameLPAREN	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
{	TokenNameLBRACE	
res	TokenNameIdentifier	 res
*=	TokenNameMULTIPLY_EQUAL	
MULTI_THREAD_SLACK	TokenNameIdentifier	 MULTI  THREAD  SLACK
;	TokenNameSEMICOLON	
// larger slack 	TokenNameCOMMENT_LINE	larger slack 
}	TokenNameRBRACE	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
maxTimeStr	TokenNameIdentifier	 max Time Str
(	TokenNameLPAREN	
boolean	TokenNameboolean	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
"( "	TokenNameStringLiteral	( 
+	TokenNamePLUS	
"2*resolution + TIME_ALLOWED + SLOW_DOWN = "	TokenNameStringLiteral	2*resolution + TIME_ALLOWED + SLOW_DOWN = 
+	TokenNamePLUS	
"2*"	TokenNameStringLiteral	2*
+	TokenNamePLUS	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" + "	TokenNameStringLiteral	 + 
+	TokenNamePLUS	
TIME_ALLOWED	TokenNameIdentifier	 TIME  ALLOWED
+	TokenNamePLUS	
" + "	TokenNameStringLiteral	 + 
+	TokenNamePLUS	
SLOW_DOWN	TokenNameIdentifier	 SLOW  DOWN
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
MULTI_THREAD_SLACK	TokenNameIdentifier	 MULTI  THREAD  SLACK
+	TokenNamePLUS	
" * "	TokenNameStringLiteral	 * 
+	TokenNamePLUS	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
maxTime	TokenNameIdentifier	 max Time
(	TokenNameLPAREN	
multiThreaded	TokenNameIdentifier	 multi Threaded
)	TokenNameRPAREN	
+	TokenNamePLUS	
" = "	TokenNameStringLiteral	 = 
+	TokenNamePLUS	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test timeout behavior when resolution is modified. */	TokenNameCOMMENT_JAVADOC	 Test timeout behavior when resolution is modified. 
public	TokenNamepublic	
void	TokenNamevoid	
testModifyResolution	TokenNameIdentifier	 test Modify Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// increase and test 	TokenNameCOMMENT_LINE	increase and test 
long	TokenNamelong	
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
TimerThread	TokenNameIdentifier	 Timer Thread
.	TokenNameDOT	
DEFAULT_RESOLUTION	TokenNameIdentifier	 DEFAULT  RESOLUTION
;	TokenNameSEMICOLON	
//400 	TokenNameCOMMENT_LINE	400 
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
setResolution	TokenNameIdentifier	 set Resolution
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
,	TokenNameCOMMA	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// decrease much and test 	TokenNameCOMMENT_LINE	decrease much and test 
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
setResolution	TokenNameIdentifier	 set Resolution
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
,	TokenNameCOMMA	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return to default and test 	TokenNameCOMMENT_LINE	return to default and test 
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
TimerThread	TokenNameIdentifier	 Timer Thread
.	TokenNameDOT	
DEFAULT_RESOLUTION	TokenNameIdentifier	 DEFAULT  RESOLUTION
;	TokenNameSEMICOLON	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
setResolution	TokenNameIdentifier	 set Resolution
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
,	TokenNameCOMMA	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
getResolution	TokenNameIdentifier	 get Resolution
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
counterThread	TokenNameIdentifier	 counter Thread
.	TokenNameDOT	
setResolution	TokenNameIdentifier	 set Resolution
(	TokenNameLPAREN	
TimerThread	TokenNameIdentifier	 Timer Thread
.	TokenNameDOT	
DEFAULT_RESOLUTION	TokenNameIdentifier	 DEFAULT  RESOLUTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Test correctness with multiple searching threads. */	TokenNameCOMMENT_JAVADOC	 Test correctness with multiple searching threads. 
public	TokenNamepublic	
void	TokenNamevoid	
testSearchMultiThreaded	TokenNameIdentifier	 test Search Multi Threaded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
doTestMultiThreads	TokenNameIdentifier	 do Test Multi Threads
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test correctness with multiple searching threads. */	TokenNameCOMMENT_JAVADOC	 Test correctness with multiple searching threads. 
public	TokenNamepublic	
void	TokenNamevoid	
testTimeoutMultiThreaded	TokenNameIdentifier	 test Timeout Multi Threaded
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
doTestMultiThreads	TokenNameIdentifier	 do Test Multi Threads
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
doTestMultiThreads	TokenNameIdentifier	 do Test Multi Threads
(	TokenNameLPAREN	
final	TokenNamefinal	
boolean	TokenNameboolean	
withTimeout	TokenNameIdentifier	 with Timeout
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
threadArray	TokenNameIdentifier	 thread Array
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
[	TokenNameLBRACKET	
N_THREADS	TokenNameIdentifier	 N  THREADS
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
BitSet	TokenNameIdentifier	 Bit Set
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
new	TokenNamenew	
BitSet	TokenNameIdentifier	 Bit Set
(	TokenNameLPAREN	
N_THREADS	TokenNameIdentifier	 N  THREADS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadArray	TokenNameIdentifier	 thread Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
num	TokenNameIdentifier	 num
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
threadArray	TokenNameIdentifier	 thread Array
[	TokenNameLBRACKET	
num	TokenNameIdentifier	 num
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
withTimeout	TokenNameIdentifier	 with Timeout
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doTestTimeout	TokenNameIdentifier	 do Test Timeout
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
doTestSearch	TokenNameIdentifier	 do Test Search
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
success	TokenNameIdentifier	 success
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
num	TokenNameIdentifier	 num
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadArray	TokenNameIdentifier	 thread Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadArray	TokenNameIdentifier	 thread Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadArray	TokenNameIdentifier	 thread Array
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadArray	TokenNameIdentifier	 thread Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
"some threads failed!"	TokenNameStringLiteral	some threads failed!
,	TokenNameCOMMA	
N_THREADS	TokenNameIdentifier	 N  THREADS
,	TokenNameCOMMA	
success	TokenNameIdentifier	 success
.	TokenNameDOT	
cardinality	TokenNameIdentifier	 cardinality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// counting collector that can slow down at collect(). 	TokenNameCOMMENT_LINE	counting collector that can slow down at collect(). 
private	TokenNameprivate	
class	TokenNameclass	
MyHitCollector	TokenNameIdentifier	 My Hit Collector
extends	TokenNameextends	
Collector	TokenNameIdentifier	 Collector
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
BitSet	TokenNameIdentifier	 Bit Set
bits	TokenNameIdentifier	 bits
=	TokenNameEQUAL	
new	TokenNamenew	
BitSet	TokenNameIdentifier	 Bit Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
slowdown	TokenNameIdentifier	 slowdown
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
lastDocCollected	TokenNameIdentifier	 last Doc Collected
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * amount of time to wait on each collect to simulate a long iteration */	TokenNameCOMMENT_JAVADOC	 amount of time to wait on each collect to simulate a long iteration 
public	TokenNamepublic	
void	TokenNamevoid	
setSlowDown	TokenNameIdentifier	 set Slow Down
(	TokenNameLPAREN	
int	TokenNameint	
milliseconds	TokenNameIdentifier	 milliseconds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
slowdown	TokenNameIdentifier	 slowdown
=	TokenNameEQUAL	
milliseconds	TokenNameIdentifier	 milliseconds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
hitCount	TokenNameIdentifier	 hit Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bits	TokenNameIdentifier	 bits
.	TokenNameDOT	
cardinality	TokenNameIdentifier	 cardinality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getLastDocCollected	TokenNameIdentifier	 get Last Doc Collected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lastDocCollected	TokenNameIdentifier	 last Doc Collected
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// scorer is not needed 	TokenNameCOMMENT_LINE	scorer is not needed 
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
docId	TokenNameIdentifier	 doc Id
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
+	TokenNamePLUS	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
slowdown	TokenNameIdentifier	 slowdown
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
slowdown	TokenNameIdentifier	 slowdown
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
(	TokenNameLPAREN	
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assert	TokenNameassert	
docId	TokenNameIdentifier	 doc Id
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
" base="	TokenNameStringLiteral	 base=
+	TokenNamePLUS	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
" doc="	TokenNameStringLiteral	 doc=
+	TokenNamePLUS	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
bits	TokenNameIdentifier	 bits
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
docId	TokenNameIdentifier	 doc Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastDocCollected	TokenNameIdentifier	 last Doc Collected
=	TokenNameEQUAL	
docId	TokenNameIdentifier	 doc Id
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
int	TokenNameint	
base	TokenNameIdentifier	 base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
base	TokenNameIdentifier	 base
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
acceptsDocsOutOfOrder	TokenNameIdentifier	 accepts Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
