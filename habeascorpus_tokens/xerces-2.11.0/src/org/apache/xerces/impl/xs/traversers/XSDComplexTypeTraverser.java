/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
traversers	TokenNameIdentifier	 traversers
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
SchemaDVFactory	TokenNameIdentifier	 Schema DV Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSFacets	TokenNameIdentifier	 XS Facets
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XInt	TokenNameIdentifier	 X Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DOMUtil	TokenNameIdentifier	 DOM Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
/** * A complex type definition schema component traverser. * * <complexType * abstract = boolean : false * block = (#all | List of (extension | restriction)) * final = (#all | List of (extension | restriction)) * id = ID * mixed = boolean : false * name = NCName * {any attributes with non-schema namespace . . .}> * Content: (annotation?, (simpleContent | complexContent | * ((group | all | choice | sequence)?, * ((attribute | attributeGroup)*, anyAttribute?)))) * </complexType> * * @xerces.internal * * @version $Id: XSDComplexTypeTraverser.java 834253 2009-11-09 22:07:23Z sandygao $ */	TokenNameCOMMENT_JAVADOC	 A complex type definition schema component traverser. * <complexType abstract = boolean : false block = (#all | List of (extension | restriction)) final = (#all | List of (extension | restriction)) id = ID mixed = boolean : false name = NCName {any attributes with non-schema namespace . . .}> Content: (annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))) </complexType> * @xerces.internal * @version $Id: XSDComplexTypeTraverser.java 834253 2009-11-09 22:07:23Z sandygao $ 
class	TokenNameclass	
XSDComplexTypeTraverser	TokenNameIdentifier	 XSD Complex Type Traverser
extends	TokenNameextends	
XSDAbstractParticleTraverser	TokenNameIdentifier	 XSD Abstract Particle Traverser
{	TokenNameLBRACE	
// size of stack to hold globals: 	TokenNameCOMMENT_LINE	size of stack to hold globals: 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
GLOBAL_NUM	TokenNameIdentifier	 GLOBAL  NUM
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fErrorContent	TokenNameIdentifier	 f Error Content
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
fErrorWildcard	TokenNameIdentifier	 f Error Wildcard
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
getErrorContent	TokenNameIdentifier	 get Error Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorContent	TokenNameIdentifier	 f Error Content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
getErrorWildcard	TokenNameIdentifier	 get Error Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMaxOccurs	TokenNameIdentifier	 f Max Occurs
=	TokenNameEQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
;	TokenNameSEMICOLON	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
new	TokenNamenew	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
=	TokenNameEQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
errorContent	TokenNameIdentifier	 error Content
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
errorContent	TokenNameIdentifier	 error Content
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
;	TokenNameSEMICOLON	
errorContent	TokenNameIdentifier	 error Content
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
group	TokenNameIdentifier	 group
;	TokenNameSEMICOLON	
fErrorContent	TokenNameIdentifier	 f Error Content
=	TokenNameEQUAL	
errorContent	TokenNameIdentifier	 error Content
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fErrorContent	TokenNameIdentifier	 f Error Content
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
getErrorWildcard	TokenNameIdentifier	 get Error Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorWildcard	TokenNameIdentifier	 f Error Wildcard
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
new	TokenNamenew	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
=	TokenNameEQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
PC_SKIP	TokenNameIdentifier	 PC  SKIP
;	TokenNameSEMICOLON	
fErrorWildcard	TokenNameIdentifier	 f Error Wildcard
=	TokenNameEQUAL	
wildcard	TokenNameIdentifier	 wildcard
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fErrorWildcard	TokenNameIdentifier	 f Error Wildcard
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// globals for building XSComplexTypeDecls 	TokenNameCOMMENT_LINE	globals for building XSComplexTypeDecls 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
fAttrGrp	TokenNameIdentifier	 f Attr Grp
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsAbstract	TokenNameIdentifier	 f Is Abstract
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// our own little stack to retain state when getGlobalDecls is called: 	TokenNameCOMMENT_LINE	our own little stack to retain state when getGlobalDecls is called: 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fGlobalStore	TokenNameIdentifier	 f Global Store
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
XSDComplexTypeTraverser	TokenNameIdentifier	 XSD Complex Type Traverser
(	TokenNameLPAREN	
XSDHandler	TokenNameIdentifier	 XSD Handler
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
extends	TokenNameextends	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
6802729912091130335L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errorSubstText	TokenNameIdentifier	 error Subst Text
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
errorElem	TokenNameIdentifier	 error Elem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msgKey	TokenNameIdentifier	 msg Key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
msgKey	TokenNameIdentifier	 msg Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
errorSubstText	TokenNameIdentifier	 error Subst Text
=	TokenNameEQUAL	
args	TokenNameIdentifier	 args
;	TokenNameSEMICOLON	
errorElem	TokenNameIdentifier	 error Elem
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Traverse local complexType declarations * * @param Element * @param XSDocumentInfo * @param SchemaGrammar * @return XSComplexTypeDecl */	TokenNameCOMMENT_JAVADOC	 Traverse local complexType declarations * @param Element @param XSDocumentInfo @param SchemaGrammar @return XSComplexTypeDecl 
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
complexTypeName	TokenNameIdentifier	 complex Type Name
=	TokenNameEQUAL	
genAnonTypeName	TokenNameIdentifier	 gen Anon Type Name
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentBackup	TokenNameIdentifier	 content Backup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
traverseComplexTypeDecl	TokenNameIdentifier	 traverse Complex Type Decl
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
complexTypeName	TokenNameIdentifier	 complex Type Name
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentRestore	TokenNameIdentifier	 content Restore
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to add the type to the grammar for later constraint checking 	TokenNameCOMMENT_LINE	need to add the type to the grammar for later constraint checking 
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addComplexTypeDecl	TokenNameIdentifier	 add Complex Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
setIsAnonymous	TokenNameIdentifier	 set Is Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Traverse global complexType declarations * * @param Element * @param XSDocumentInfo * @param SchemaGrammar * @return XSComplexTypeDecXSComplexTypeDecl */	TokenNameCOMMENT_JAVADOC	 Traverse global complexType declarations * @param Element @param XSDocumentInfo @param SchemaGrammar @return XSComplexTypeDecXSComplexTypeDecl 
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
complexTypeName	TokenNameIdentifier	 complex Type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAME	TokenNameIdentifier	 ATTIDX  NAME
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
contentBackup	TokenNameIdentifier	 content Backup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
traverseComplexTypeDecl	TokenNameIdentifier	 traverse Complex Type Decl
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
,	TokenNameCOMMA	
complexTypeName	TokenNameIdentifier	 complex Type Name
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
contentRestore	TokenNameIdentifier	 content Restore
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// need to add the type to the grammar for later constraint checking 	TokenNameCOMMENT_LINE	need to add the type to the grammar for later constraint checking 
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addComplexTypeDecl	TokenNameIdentifier	 add Complex Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
element2Locator	TokenNameIdentifier	 element2 Locator
(	TokenNameLPAREN	
complexTypeNode	TokenNameIdentifier	 complex Type Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
complexTypeName	TokenNameIdentifier	 complex Type Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXTYPE	TokenNameIdentifier	 ELT  COMPLEXTYPE
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexTypeNode	TokenNameIdentifier	 complex Type Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalComplexTypeDecl	TokenNameIdentifier	 add Global Complex Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// also add it to extended map 	TokenNameCOMMENT_LINE	also add it to extended map 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
schemaDocument2SystemId	TokenNameIdentifier	 schema Document2 System Id
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type2	TokenNameIdentifier	 type2
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalComplexTypeDecl	TokenNameIdentifier	 add Global Complex Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handle duplicates 	TokenNameCOMMENT_LINE	handle duplicates 
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type2	TokenNameIdentifier	 type2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
traverseComplexTypeDecl	TokenNameIdentifier	 traverse Complex Type Decl
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
complexTypeName	TokenNameIdentifier	 complex Type Name
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
=	TokenNameEQUAL	
new	TokenNamenew	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
=	TokenNameEQUAL	
new	TokenNamenew	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
abstractAtt	TokenNameIdentifier	 abstract Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_ABSTRACT	TokenNameIdentifier	 ATTIDX  ABSTRACT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
blockAtt	TokenNameIdentifier	 block Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BLOCK	TokenNameIdentifier	 ATTIDX  BLOCK
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
mixedAtt	TokenNameIdentifier	 mixed Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_MIXED	TokenNameIdentifier	 ATTIDX  MIXED
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
XInt	TokenNameIdentifier	 X Int
finalAtt	TokenNameIdentifier	 final Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FINAL	TokenNameIdentifier	 ATTIDX  FINAL
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
complexTypeName	TokenNameIdentifier	 complex Type Name
;	TokenNameSEMICOLON	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
.	TokenNameDOT	
setName	TokenNameIdentifier	 set Name
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
blockAtt	TokenNameIdentifier	 block Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fBlockDefault	TokenNameIdentifier	 f Block Default
:	TokenNameCOLON	
blockAtt	TokenNameIdentifier	 block Att
.	TokenNameDOT	
shortValue	TokenNameIdentifier	 short Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
finalAtt	TokenNameIdentifier	 final Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fFinalDefault	TokenNameIdentifier	 f Final Default
:	TokenNameCOLON	
finalAtt	TokenNameIdentifier	 final Att
.	TokenNameDOT	
shortValue	TokenNameIdentifier	 short Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//discard valid Block/Final 'Default' values that are invalid for Block/Final 	TokenNameCOMMENT_LINE	discard valid Block/Final 'Default' values that are invalid for Block/Final 
fBlock	TokenNameIdentifier	 f Block
&=	TokenNameAND_EQUAL	
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFinal	TokenNameIdentifier	 f Final
&=	TokenNameAND_EQUAL	
(	TokenNameLPAREN	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
|	TokenNameOR	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIsAbstract	TokenNameIdentifier	 f Is Abstract
=	TokenNameEQUAL	
(	TokenNameLPAREN	
abstractAtt	TokenNameIdentifier	 abstract Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
abstractAtt	TokenNameIdentifier	 abstract Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// --------------------------------------------------------------- 	TokenNameCOMMENT_LINE	--------------------------------------------------------------- 
// First, handle any ANNOTATION declaration and get next child 	TokenNameCOMMENT_LINE	First, handle any ANNOTATION declaration and get next child 
// --------------------------------------------------------------- 	TokenNameCOMMENT_LINE	--------------------------------------------------------------- 
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// --------------------------------------------------------------- 	TokenNameCOMMENT_LINE	--------------------------------------------------------------- 
// Process the content of the complex type definition 	TokenNameCOMMENT_LINE	Process the content of the complex type definition 
// --------------------------------------------------------------- 	TokenNameCOMMENT_LINE	--------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// EMPTY complexType with complexContent 	TokenNameCOMMENT_LINE	EMPTY complexType with complexContent 
// 	TokenNameCOMMENT_LINE	 
// set the base to the anyType 	TokenNameCOMMENT_LINE	set the base to the anyType 
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
processComplexContent	TokenNameIdentifier	 process Complex Content
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
mixedAtt	TokenNameIdentifier	 mixed Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLECONTENT	TokenNameIdentifier	 ELT  SIMPLECONTENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// SIMPLE CONTENT 	TokenNameCOMMENT_LINE	SIMPLE CONTENT 
// 	TokenNameCOMMENT_LINE	 
traverseSimpleContent	TokenNameIdentifier	 traverse Simple Content
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
elemTmp	TokenNameIdentifier	 elem Tmp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
siblingName	TokenNameIdentifier	 sibling Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
siblingName	TokenNameIdentifier	 sibling Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXCONTENT	TokenNameIdentifier	 ELT  COMPLEXCONTENT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
traverseComplexContent	TokenNameIdentifier	 traverse Complex Content
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
mixedAtt	TokenNameIdentifier	 mixed Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
elemTmp	TokenNameIdentifier	 elem Tmp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
siblingName	TokenNameIdentifier	 sibling Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
siblingName	TokenNameIdentifier	 sibling Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// We must have .... 	TokenNameCOMMENT_LINE	We must have .... 
// GROUP, ALL, SEQUENCE or CHOICE, followed by optional attributes 	TokenNameCOMMENT_LINE	GROUP, ALL, SEQUENCE or CHOICE, followed by optional attributes 
// Note that it's possible that only attributes are specified. 	TokenNameCOMMENT_LINE	Note that it's possible that only attributes are specified. 
// 	TokenNameCOMMENT_LINE	 
// set the base to the anyType 	TokenNameCOMMENT_LINE	set the base to the anyType 
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
processComplexContent	TokenNameIdentifier	 process Complex Content
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
mixedAtt	TokenNameIdentifier	 mixed Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
handleComplexTypeError	TokenNameIdentifier	 handle Complex Type Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
errorSubstText	TokenNameIdentifier	 error Subst Text
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
errorElem	TokenNameIdentifier	 error Elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
.	TokenNameDOT	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
fBaseType	TokenNameIdentifier	 f Base Type
,	TokenNameCOMMA	
fDerivedBy	TokenNameIdentifier	 f Derived By
,	TokenNameCOMMA	
fFinal	TokenNameIdentifier	 f Final
,	TokenNameCOMMA	
fBlock	TokenNameIdentifier	 f Block
,	TokenNameCOMMA	
fContentType	TokenNameIdentifier	 f Content Type
,	TokenNameCOMMA	
fIsAbstract	TokenNameIdentifier	 f Is Abstract
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
,	TokenNameCOMMA	
fParticle	TokenNameIdentifier	 f Particle
,	TokenNameCOMMA	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
,	TokenNameCOMMA	
fAnnotations	TokenNameIdentifier	 f Annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
traverseSimpleContent	TokenNameIdentifier	 traverse Simple Content
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
simpleContentElement	TokenNameIdentifier	 simple Content Element
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
throws	TokenNamethrows	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
simpleContentElement	TokenNameIdentifier	 simple Content Element
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Set content type 	TokenNameCOMMENT_LINE	Set content type 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
simpleContent	TokenNameIdentifier	 simple Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
,	TokenNameCOMMA	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
simpleContent	TokenNameIdentifier	 simple Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
simpleContentElement	TokenNameIdentifier	 simple Content Element
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If there are no children, return 	TokenNameCOMMENT_LINE	If there are no children, return 
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.2"	TokenNameStringLiteral	s4s-elt-invalid-content.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLECONTENT	TokenNameIdentifier	 ELT  SIMPLECONTENT
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// The content should be either "restriction" or "extension" 	TokenNameCOMMENT_LINE	The content should be either "restriction" or "extension" 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
String	TokenNameIdentifier	 String
simpleContentName	TokenNameIdentifier	 simple Content Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContentName	TokenNameIdentifier	 simple Content Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContentName	TokenNameIdentifier	 simple Content Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_EXTENSION	TokenNameIdentifier	 ELT  EXTENSION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
simpleContentName	TokenNameIdentifier	 simple Content Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
elemTmp	TokenNameIdentifier	 elem Tmp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
siblingName	TokenNameIdentifier	 sibling Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
siblingName	TokenNameIdentifier	 sibling Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
baseTypeName	TokenNameIdentifier	 base Type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BASE	TokenNameIdentifier	 ATTIDX  BASE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Need a base type. 	TokenNameCOMMENT_LINE	Need a base type. 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
baseTypeName	TokenNameIdentifier	 base Type Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
simpleContentName	TokenNameIdentifier	 simple Content Name
,	TokenNameCOMMA	
"base"	TokenNameStringLiteral	base
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
baseTypeName	TokenNameIdentifier	 base Type Name
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
baseComplexType	TokenNameIdentifier	 base Complex Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
baseFinalSet	TokenNameIdentifier	 base Final Set
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// If the base type is complex, it must have simpleContent 	TokenNameCOMMENT_LINE	If the base type is complex, it must have simpleContent 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseComplexType	TokenNameIdentifier	 base Complex Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
baseFinalSet	TokenNameIdentifier	 base Final Set
=	TokenNameEQUAL	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// base is a CT with simple content (both restriction and extension are OK) 	TokenNameCOMMENT_LINE	base is a CT with simple content (both restriction and extension are OK) 
if	TokenNameif	
(	TokenNameLPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// base is a CT with mixed/emptiable content (only restriction is OK) 	TokenNameCOMMENT_LINE	base is a CT with mixed/emptiable content (only restriction is OK) 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
&&	TokenNameAND_AND	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
emptiable	TokenNameIdentifier	 emptiable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"src-ct.2.1"	TokenNameStringLiteral	src-ct.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
// base is a ST (only extension is OK) 	TokenNameCOMMENT_LINE	base is a ST (only extension is OK) 
if	TokenNameif	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"src-ct.2.1"	TokenNameStringLiteral	src-ct.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
baseFinalSet	TokenNameIdentifier	 base Final Set
=	TokenNameEQUAL	
baseValidator	TokenNameIdentifier	 base Validator
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Check that the base permits the derivation 	TokenNameCOMMENT_LINE	Check that the base permits the derivation 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
baseFinalSet	TokenNameIdentifier	 base Final Set
&	TokenNameAND	
fDerivedBy	TokenNameIdentifier	 f Derived By
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
errorKey	TokenNameIdentifier	 error Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"cos-ct-extends.1.1"	TokenNameStringLiteral	cos-ct-extends.1.1
:	TokenNameCOLON	
"derivation-ok-restriction.1"	TokenNameStringLiteral	derivation-ok-restriction.1
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
errorKey	TokenNameIdentifier	 error Key
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
fBaseType	TokenNameIdentifier	 f Base Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Skip over any potential annotations 	TokenNameCOMMENT_LINE	Skip over any potential annotations 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
Element	TokenNameIdentifier	 Element
scElement	TokenNameIdentifier	 sc Element
=	TokenNameEQUAL	
simpleContent	TokenNameIdentifier	 simple Content
;	TokenNameSEMICOLON	
simpleContent	TokenNameIdentifier	 simple Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// traverse annotation if any 	TokenNameCOMMENT_LINE	traverse annotation if any 
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
simpleContent	TokenNameIdentifier	 simple Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
scElement	TokenNameIdentifier	 sc Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
scElement	TokenNameIdentifier	 sc Element
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
scElement	TokenNameIdentifier	 sc Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
scElement	TokenNameIdentifier	 sc Element
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Process a RESTRICTION 	TokenNameCOMMENT_LINE	Process a RESTRICTION 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// There may be a simple type definition in the restriction element 	TokenNameCOMMENT_LINE	There may be a simple type definition in the restriction element 
// The data type validator will be based on it, if specified 	TokenNameCOMMENT_LINE	The data type validator will be based on it, if specified 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fSimpleTypeTraverser	TokenNameIdentifier	 f Simple Type Traverser
.	TokenNameDOT	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//check that this datatype validator is validly derived from the base 	TokenNameCOMMENT_LINE	check that this datatype validator is validly derived from the base 
//according to derivation-ok-restriction 5.1.2.1 	TokenNameCOMMENT_LINE	according to derivation-ok-restriction 5.1.2.1 
if	TokenNameif	
(	TokenNameLPAREN	
baseValidator	TokenNameIdentifier	 base Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
checkSimpleDerivationOk	TokenNameIdentifier	 check Simple Derivation Ok
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"derivation-ok-restriction.5.2.2.1"	TokenNameStringLiteral	derivation-ok-restriction.5.2.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
;	TokenNameSEMICOLON	
simpleContent	TokenNameIdentifier	 simple Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this only happens when restricting a mixed/emptiable CT 	TokenNameCOMMENT_LINE	this only happens when restricting a mixed/emptiable CT 
// but there is no <simpleType>, which is required 	TokenNameCOMMENT_LINE	but there is no <simpleType>, which is required 
if	TokenNameif	
(	TokenNameLPAREN	
baseValidator	TokenNameIdentifier	 base Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"src-ct.2.2"	TokenNameStringLiteral	src-ct.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Traverse any facets 	TokenNameCOMMENT_LINE	Traverse any facets 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
Element	TokenNameIdentifier	 Element
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSFacets	TokenNameIdentifier	 XS Facets
facetData	TokenNameIdentifier	 facet Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
short	TokenNameshort	
presentFacets	TokenNameIdentifier	 present Facets
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
short	TokenNameshort	
fixedFacets	TokenNameIdentifier	 fixed Facets
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FacetInfo	TokenNameIdentifier	 Facet Info
fi	TokenNameIdentifier	 fi
=	TokenNameEQUAL	
traverseFacets	TokenNameIdentifier	 traverse Facets
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
nodeAfterFacets	TokenNameIdentifier	 node After Facets
;	TokenNameSEMICOLON	
facetData	TokenNameIdentifier	 facet Data
=	TokenNameEQUAL	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
facetdata	TokenNameIdentifier	 facetdata
;	TokenNameSEMICOLON	
presentFacets	TokenNameIdentifier	 present Facets
=	TokenNameEQUAL	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
fPresentFacets	TokenNameIdentifier	 f Present Facets
;	TokenNameSEMICOLON	
fixedFacets	TokenNameIdentifier	 fixed Facets
=	TokenNameEQUAL	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
fFixedFacets	TokenNameIdentifier	 f Fixed Facets
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
genAnonTypeName	TokenNameIdentifier	 gen Anon Type Name
(	TokenNameLPAREN	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeRestriction	TokenNameIdentifier	 create Type Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
.	TokenNameDOT	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
facetData	TokenNameIdentifier	 facet Data
,	TokenNameCOMMA	
presentFacets	TokenNameIdentifier	 present Facets
,	TokenNameCOMMA	
fixedFacets	TokenNameIdentifier	 fixed Facets
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
simpleContent	TokenNameIdentifier	 simple Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Recreate the type, ignoring the facets 	TokenNameCOMMENT_LINE	Recreate the type, ignoring the facets 
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeRestriction	TokenNameIdentifier	 create Type Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
)	TokenNameRPAREN	
.	TokenNameDOT	
setAnonymous	TokenNameIdentifier	 set Anonymous
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Traverse any attributes 	TokenNameCOMMENT_LINE	Traverse any attributes 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAttrOrAttrGroup	TokenNameIdentifier	 is Attr Or Attr Group
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
traverseAttrsAndAttrGrps	TokenNameIdentifier	 traverse Attrs And Attr Grps
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
mergeAttributes	TokenNameIdentifier	 merge Attributes
(	TokenNameLPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Prohibited uses must be removed after merge for RESTRICTION 	TokenNameCOMMENT_LINE	Prohibited uses must be removed after merge for RESTRICTION 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
removeProhibitedAttrs	TokenNameIdentifier	 remove Prohibited Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errArgs	TokenNameIdentifier	 err Args
=	TokenNameEQUAL	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
validRestrictionOf	TokenNameIdentifier	 valid Restriction Of
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
errArgs	TokenNameIdentifier	 err Args
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
errArgs	TokenNameIdentifier	 err Args
[	TokenNameLBRACKET	
errArgs	TokenNameIdentifier	 err Args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
errArgs	TokenNameIdentifier	 err Args
,	TokenNameCOMMA	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Process a EXTENSION 	TokenNameCOMMENT_LINE	Process a EXTENSION 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
else	TokenNameelse	
{	TokenNameLBRACE	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
baseValidator	TokenNameIdentifier	 base Validator
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
simpleContent	TokenNameIdentifier	 simple Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Traverse any attributes 	TokenNameCOMMENT_LINE	Traverse any attributes 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
Element	TokenNameIdentifier	 Element
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
simpleContent	TokenNameIdentifier	 simple Content
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAttrOrAttrGroup	TokenNameIdentifier	 is Attr Or Attr Group
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
traverseAttrsAndAttrGrps	TokenNameIdentifier	 traverse Attrs And Attr Grps
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove prohibited uses. Should be done prior to any merge. 	TokenNameCOMMENT_LINE	Remove prohibited uses. Should be done prior to any merge. 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
removeProhibitedAttrs	TokenNameIdentifier	 remove Prohibited Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
mergeAttributes	TokenNameIdentifier	 merge Attributes
(	TokenNameLPAREN	
baseComplexType	TokenNameIdentifier	 base Complex Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
simpleContentElement	TokenNameIdentifier	 simple Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// and finally, since we've nothing more to traverse, we can 	TokenNameCOMMENT_LINE	and finally, since we've nothing more to traverse, we can 
// return the attributes (and thereby reset the namespace support) 	TokenNameCOMMENT_LINE	return the attributes (and thereby reset the namespace support) 
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
simpleContentAttrValues	TokenNameIdentifier	 simple Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
traverseComplexContent	TokenNameIdentifier	 traverse Complex Content
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexContentElement	TokenNameIdentifier	 complex Content Element
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mixedOnType	TokenNameIdentifier	 mixed On Type
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
throws	TokenNamethrows	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
complexContentElement	TokenNameIdentifier	 complex Content Element
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Determine if this is mixed content 	TokenNameCOMMENT_LINE	Determine if this is mixed content 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
boolean	TokenNameboolean	
mixedContent	TokenNameIdentifier	 mixed Content
=	TokenNameEQUAL	
mixedOnType	TokenNameIdentifier	 mixed On Type
;	TokenNameSEMICOLON	
Boolean	TokenNameIdentifier	 Boolean
mixedAtt	TokenNameIdentifier	 mixed Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_MIXED	TokenNameIdentifier	 ATTIDX  MIXED
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mixedAtt	TokenNameIdentifier	 mixed Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mixedContent	TokenNameIdentifier	 mixed Content
=	TokenNameEQUAL	
mixedAtt	TokenNameIdentifier	 mixed Att
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Since the type must have complex content, set the simple type validators 	TokenNameCOMMENT_LINE	Since the type must have complex content, set the simple type validators 
// to null 	TokenNameCOMMENT_LINE	to null 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
complexContent	TokenNameIdentifier	 complex Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
complexContentElement	TokenNameIdentifier	 complex Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
complexContent	TokenNameIdentifier	 complex Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
complexContentElement	TokenNameIdentifier	 complex Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
complexContentElement	TokenNameIdentifier	 complex Content Element
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If there are no children, return 	TokenNameCOMMENT_LINE	If there are no children, return 
if	TokenNameif	
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.2"	TokenNameStringLiteral	s4s-elt-invalid-content.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_COMPLEXCONTENT	TokenNameIdentifier	 ELT  COMPLEXCONTENT
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContentElement	TokenNameIdentifier	 complex Content Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// The content should be either "restriction" or "extension" 	TokenNameCOMMENT_LINE	The content should be either "restriction" or "extension" 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
String	TokenNameIdentifier	 String
complexContentName	TokenNameIdentifier	 complex Content Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
complexContentName	TokenNameIdentifier	 complex Content Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
complexContentName	TokenNameIdentifier	 complex Content Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_EXTENSION	TokenNameIdentifier	 ELT  EXTENSION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
complexContentName	TokenNameIdentifier	 complex Content Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
elemTmp	TokenNameIdentifier	 elem Tmp
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
siblingName	TokenNameIdentifier	 sibling Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
siblingName	TokenNameIdentifier	 sibling Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elemTmp	TokenNameIdentifier	 elem Tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
baseTypeName	TokenNameIdentifier	 base Type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BASE	TokenNameIdentifier	 ATTIDX  BASE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Need a base type. Check that it's a complex type 	TokenNameCOMMENT_LINE	Need a base type. Check that it's a complex type 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
baseTypeName	TokenNameIdentifier	 base Type Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
complexContentName	TokenNameIdentifier	 complex Content Name
,	TokenNameCOMMA	
"base"	TokenNameStringLiteral	base
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
baseTypeName	TokenNameIdentifier	 base Type Name
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"src-ct.1"	TokenNameStringLiteral	src-ct.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
baseType	TokenNameIdentifier	 base Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
baseType	TokenNameIdentifier	 base Type
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Check that the base permits the derivation 	TokenNameCOMMENT_LINE	Check that the base permits the derivation 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
fDerivedBy	TokenNameIdentifier	 f Derived By
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
errorKey	TokenNameIdentifier	 error Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"cos-ct-extends.1.1"	TokenNameStringLiteral	cos-ct-extends.1.1
:	TokenNameCOLON	
"derivation-ok-restriction.1"	TokenNameStringLiteral	derivation-ok-restriction.1
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
errorKey	TokenNameIdentifier	 error Key
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
fBaseType	TokenNameIdentifier	 f Base Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Skip over any potential annotations 	TokenNameCOMMENT_LINE	Skip over any potential annotations 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
complexContent	TokenNameIdentifier	 complex Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// traverse annotation if any 	TokenNameCOMMENT_LINE	traverse annotation if any 
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
complexContent	TokenNameIdentifier	 complex Content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Process the content. Note: should I try to catch any complexType errors 	TokenNameCOMMENT_LINE	Process the content. Note: should I try to catch any complexType errors 
// here in order to return the attr array? 	TokenNameCOMMENT_LINE	here in order to return the attr array? 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
try	TokenNametry	
{	TokenNameLBRACE	
processComplexContent	TokenNameIdentifier	 process Complex Content
(	TokenNameLPAREN	
complexContent	TokenNameIdentifier	 complex Content
,	TokenNameCOMMA	
mixedContent	TokenNameIdentifier	 mixed Content
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Compose the final content and attribute uses 	TokenNameCOMMENT_LINE	Compose the final content and attribute uses 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
baseContent	TokenNameIdentifier	 base Content
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This is an RESTRICTION 	TokenNameCOMMENT_LINE	This is an RESTRICTION 
// N.B. derivation-ok-restriction.5.3 is checked under schema 	TokenNameCOMMENT_LINE	N.B. derivation-ok-restriction.5.3 is checked under schema 
// full checking. That's because we need to wait until locals are 	TokenNameCOMMENT_LINE	full checking. That's because we need to wait until locals are 
// traversed so that occurrence information is correct. 	TokenNameCOMMENT_LINE	traversed so that occurrence information is correct. 
if	TokenNameif	
(	TokenNameLPAREN	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
&&	TokenNameAND_AND	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"derivation-ok-restriction.5.4.1.2"	TokenNameStringLiteral	derivation-ok-restriction.5.4.1.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
mergeAttributes	TokenNameIdentifier	 merge Attributes
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove prohibited uses. Must be done after merge for RESTRICTION. 	TokenNameCOMMENT_LINE	Remove prohibited uses. Must be done after merge for RESTRICTION. 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
removeProhibitedAttrs	TokenNameIdentifier	 remove Prohibited Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errArgs	TokenNameIdentifier	 err Args
=	TokenNameEQUAL	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
validRestrictionOf	TokenNameIdentifier	 valid Restriction Of
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
errArgs	TokenNameIdentifier	 err Args
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
errArgs	TokenNameIdentifier	 err Args
[	TokenNameLBRACKET	
errArgs	TokenNameIdentifier	 err Args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
errArgs	TokenNameIdentifier	 err Args
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This is an EXTENSION 	TokenNameCOMMENT_LINE	This is an EXTENSION 
// Create the particle 	TokenNameCOMMENT_LINE	Create the particle 
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
baseContent	TokenNameIdentifier	 base Content
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Check if the contentType of the base is consistent with the new type 	TokenNameCOMMENT_LINE	Check if the contentType of the base is consistent with the new type 
// cos-ct-extends.1.4.3.2 	TokenNameCOMMENT_LINE	cos-ct-extends.1.4.3.2 
if	TokenNameif	
(	TokenNameLPAREN	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
&&	TokenNameAND_AND	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"cos-ct-extends.1.4.3.2.2.1.a"	TokenNameStringLiteral	cos-ct-extends.1.4.3.2.2.1.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
&&	TokenNameAND_AND	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"cos-ct-extends.1.4.3.2.2.1.b"	TokenNameStringLiteral	cos-ct-extends.1.4.3.2.2.1.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if the content of either type is an "all" model group, error. 	TokenNameCOMMENT_LINE	if the content of either type is an "all" model group, error. 
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
fParticle	TokenNameIdentifier	 f Particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
)	TokenNameRPAREN	
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_ALL	TokenNameIdentifier	 MODELGROUP  ALL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"cos-all-limited.1.2"	TokenNameStringLiteral	cos-all-limited.1.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// the "sequence" model group to contain both particles 	TokenNameCOMMENT_LINE	the "sequence" model group to contain both particles 
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
new	TokenNamenew	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fCompositor	TokenNameIdentifier	 f Compositor
=	TokenNameEQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticles	TokenNameIdentifier	 f Particles
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fParticle	TokenNameIdentifier	 f Particle
;	TokenNameSEMICOLON	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
// the particle to contain the above sequence 	TokenNameCOMMENT_LINE	the particle to contain the above sequence 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
new	TokenNamenew	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_MODELGROUP	TokenNameIdentifier	 PARTICLE  MODELGROUP
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
=	TokenNameEQUAL	
group	TokenNameIdentifier	 group
;	TokenNameSEMICOLON	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove prohibited uses. Must be done before merge for EXTENSION. 	TokenNameCOMMENT_LINE	Remove prohibited uses. Must be done before merge for EXTENSION. 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
removeProhibitedAttrs	TokenNameIdentifier	 remove Prohibited Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
mergeAttributes	TokenNameIdentifier	 merge Attributes
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
complexContent	TokenNameIdentifier	 complex Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// and *finally* we can legitimately return the attributes! 	TokenNameCOMMENT_LINE	and *finally* we can legitimately return the attributes! 
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
complexContentAttrValues	TokenNameIdentifier	 complex Content Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
derivationTypeAttrValues	TokenNameIdentifier	 derivation Type Attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end of traverseComplexContent 	TokenNameCOMMENT_LINE	end of traverseComplexContent 
// This method merges attribute uses from the base, into the derived set. 	TokenNameCOMMENT_LINE	This method merges attribute uses from the base, into the derived set. 
// LM: may want to merge with attributeGroup processing. 	TokenNameCOMMENT_LINE	LM: may want to merge with attributeGroup processing. 
private	TokenNameprivate	
void	TokenNamevoid	
mergeAttributes	TokenNameIdentifier	 merge Attributes
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
fromAttrGrp	TokenNameIdentifier	 from Attr Grp
,	TokenNameCOMMA	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
toAttrGrp	TokenNameIdentifier	 to Attr Grp
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
typeName	TokenNameIdentifier	 type Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
extension	TokenNameIdentifier	 extension
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
throws	TokenNamethrows	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
attrUseS	TokenNameIdentifier	 attr Use S
=	TokenNameEQUAL	
fromAttrGrp	TokenNameIdentifier	 from Attr Grp
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
oneAttrUse	TokenNameIdentifier	 one Attr Use
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
attrCount	TokenNameIdentifier	 attr Count
=	TokenNameEQUAL	
attrUseS	TokenNameIdentifier	 attr Use S
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
attrCount	TokenNameIdentifier	 attr Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oneAttrUse	TokenNameIdentifier	 one Attr Use
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
)	TokenNameRPAREN	
attrUseS	TokenNameIdentifier	 attr Use S
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
existingAttrUse	TokenNameIdentifier	 existing Attr Use
=	TokenNameEQUAL	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
getAttributeUse	TokenNameIdentifier	 get Attribute Use
(	TokenNameLPAREN	
oneAttrUse	TokenNameIdentifier	 one Attr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
oneAttrUse	TokenNameIdentifier	 one Attr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
existingAttrUse	TokenNameIdentifier	 existing Attr Use
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
idName	TokenNameIdentifier	 id Name
=	TokenNameEQUAL	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
addAttributeUse	TokenNameIdentifier	 add Attribute Use
(	TokenNameLPAREN	
oneAttrUse	TokenNameIdentifier	 one Attr Use
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
idName	TokenNameIdentifier	 id Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"ct-props-correct.5"	TokenNameStringLiteral	ct-props-correct.5
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
,	TokenNameCOMMA	
idName	TokenNameIdentifier	 id Name
,	TokenNameCOMMA	
oneAttrUse	TokenNameIdentifier	 one Attr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
existingAttrUse	TokenNameIdentifier	 existing Attr Use
!=	TokenNameNOT_EQUAL	
oneAttrUse	TokenNameIdentifier	 one Attr Use
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
extension	TokenNameIdentifier	 extension
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"ct-props-correct.4"	TokenNameStringLiteral	ct-props-correct.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
,	TokenNameCOMMA	
oneAttrUse	TokenNameIdentifier	 one Attr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Recover by using the attribute use from the base type, 	TokenNameCOMMENT_LINE	Recover by using the attribute use from the base type, 
// to make the resulting schema "more valid". 	TokenNameCOMMENT_LINE	to make the resulting schema "more valid". 
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
replaceAttributeUse	TokenNameIdentifier	 replace Attribute Use
(	TokenNameLPAREN	
existingAttrUse	TokenNameIdentifier	 existing Attr Use
,	TokenNameCOMMA	
oneAttrUse	TokenNameIdentifier	 one Attr Use
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// For extension, the wildcard must be formed by doing a union of the wildcards 	TokenNameCOMMENT_LINE	For extension, the wildcard must be formed by doing a union of the wildcards 
if	TokenNameif	
(	TokenNameLPAREN	
extension	TokenNameIdentifier	 extension
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
=	TokenNameEQUAL	
fromAttrGrp	TokenNameIdentifier	 from Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fromAttrGrp	TokenNameIdentifier	 from Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
=	TokenNameEQUAL	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
.	TokenNameDOT	
performUnionWith	TokenNameIdentifier	 perform Union With
(	TokenNameLPAREN	
fromAttrGrp	TokenNameIdentifier	 from Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
,	TokenNameCOMMA	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
toAttrGrp	TokenNameIdentifier	 to Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: XML Schema 1.0 2nd edition doesn't actually specify this constraint. It's a bug in the spec 	TokenNameCOMMENT_LINE	REVISIT: XML Schema 1.0 2nd edition doesn't actually specify this constraint. It's a bug in the spec 
// which will eventually be fixed. We're just guessing what the error code will be. If it turns out to be 	TokenNameCOMMENT_LINE	which will eventually be fixed. We're just guessing what the error code will be. If it turns out to be 
// something else we'll need to change it. -- mrglavas 	TokenNameCOMMENT_LINE	something else we'll need to change it. -- mrglavas 
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"src-ct.5"	TokenNameStringLiteral	src-ct.5
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
processComplexContent	TokenNameIdentifier	 process Complex Content
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexContentChild	TokenNameIdentifier	 complex Content Child
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isMixed	TokenNameIdentifier	 is Mixed
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isDerivation	TokenNameIdentifier	 is Derivation
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
throws	TokenNamethrows	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
{	TokenNameLBRACE	
Element	TokenNameIdentifier	 Element
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// whether there is a particle with empty model group 	TokenNameCOMMENT_LINE	whether there is a particle with empty model group 
boolean	TokenNameboolean	
emptyParticle	TokenNameIdentifier	 empty Particle
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ------------------------------------------------------------- 	TokenNameCOMMENT_LINE	------------------------------------------------------------- 
// GROUP, ALL, SEQUENCE or CHOICE, followed by attributes, if specified. 	TokenNameCOMMENT_LINE	GROUP, ALL, SEQUENCE or CHOICE, followed by attributes, if specified. 
// Note that it's possible that only attributes are specified. 	TokenNameCOMMENT_LINE	Note that it's possible that only attributes are specified. 
// ------------------------------------------------------------- 	TokenNameCOMMENT_LINE	------------------------------------------------------------- 
String	TokenNameIdentifier	 String
childName	TokenNameIdentifier	 child Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_GROUP	TokenNameIdentifier	 ELT  GROUP
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fGroupTraverser	TokenNameIdentifier	 f Group Traverser
.	TokenNameDOT	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SEQUENCE	TokenNameIdentifier	 ELT  SEQUENCE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
traverseSequence	TokenNameIdentifier	 traverse Sequence
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
NOT_ALL_CONTEXT	TokenNameIdentifier	 NOT  ALL  CONTEXT
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
emptyParticle	TokenNameIdentifier	 empty Particle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_CHOICE	TokenNameIdentifier	 ELT  CHOICE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
traverseChoice	TokenNameIdentifier	 traverse Choice
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
NOT_ALL_CONTEXT	TokenNameIdentifier	 NOT  ALL  CONTEXT
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fMinOccurs	TokenNameIdentifier	 f Min Occurs
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
emptyParticle	TokenNameIdentifier	 empty Particle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
childName	TokenNameIdentifier	 child Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ALL	TokenNameIdentifier	 ELT  ALL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
traverseAll	TokenNameIdentifier	 traverse All
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
PROCESSING_ALL_GP	TokenNameIdentifier	 PROCESSING  ALL  GP
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
group	TokenNameIdentifier	 group
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
group	TokenNameIdentifier	 group
.	TokenNameDOT	
fParticleCount	TokenNameIdentifier	 f Particle Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
emptyParticle	TokenNameIdentifier	 empty Particle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Should be attributes here - will check below... 	TokenNameCOMMENT_LINE	Should be attributes here - will check below... 
attrNode	TokenNameIdentifier	 attr Node
=	TokenNameEQUAL	
complexContentChild	TokenNameIdentifier	 complex Content Child
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if the particle is empty because there is no non-annotation chidren, 	TokenNameCOMMENT_LINE	if the particle is empty because there is no non-annotation chidren, 
// we need to make the particle itself null (so that the effective 	TokenNameCOMMENT_LINE	we need to make the particle itself null (so that the effective 
// content is empty). 	TokenNameCOMMENT_LINE	content is empty). 
if	TokenNameif	
(	TokenNameLPAREN	
emptyParticle	TokenNameIdentifier	 empty Particle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the first child 	TokenNameCOMMENT_LINE	get the first child 
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
complexContentChild	TokenNameIdentifier	 complex Content Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if it's annotation, get the next one 	TokenNameCOMMENT_LINE	if it's annotation, get the next one 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if there is no (non-annotation) children, mark particle empty 	TokenNameCOMMENT_LINE	if there is no (non-annotation) children, mark particle empty 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// child != null means we might have seen an element with 	TokenNameCOMMENT_LINE	child != null means we might have seen an element with 
// minOccurs == maxOccurs == 0 	TokenNameCOMMENT_LINE	minOccurs == maxOccurs == 0 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
particle	TokenNameIdentifier	 particle
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
isMixed	TokenNameIdentifier	 is Mixed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
particle	TokenNameIdentifier	 particle
=	TokenNameEQUAL	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
getEmptySequence	TokenNameIdentifier	 get Empty Sequence
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
// Set the content type 	TokenNameCOMMENT_LINE	Set the content type 
// ----------------------------------------------------------------------- 	TokenNameCOMMENT_LINE	----------------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isMixed	TokenNameIdentifier	 is Mixed
)	TokenNameRPAREN	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
;	TokenNameSEMICOLON	
else	TokenNameelse	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
;	TokenNameSEMICOLON	
// ------------------------------------------------------------- 	TokenNameCOMMENT_LINE	------------------------------------------------------------- 
// Now, process attributes 	TokenNameCOMMENT_LINE	Now, process attributes 
// ------------------------------------------------------------- 	TokenNameCOMMENT_LINE	------------------------------------------------------------- 
if	TokenNameif	
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAttrOrAttrGroup	TokenNameIdentifier	 is Attr Or Attr Group
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
attrNode	TokenNameIdentifier	 attr Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Element	TokenNameIdentifier	 Element
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
traverseAttrsAndAttrGrps	TokenNameIdentifier	 traverse Attrs And Attr Grps
(	TokenNameLPAREN	
attrNode	TokenNameIdentifier	 attr Node
,	TokenNameCOMMA	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ComplexTypeRecoverableError	TokenNameIdentifier	 Complex Type Recoverable Error
(	TokenNameLPAREN	
"s4s-elt-invalid-content.1"	TokenNameStringLiteral	s4s-elt-invalid-content.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Only remove prohibited attribute uses if this isn't a derived type 	TokenNameCOMMENT_LINE	Only remove prohibited attribute uses if this isn't a derived type 
// Derivation-specific code worries about this elsewhere 	TokenNameCOMMENT_LINE	Derivation-specific code worries about this elsewhere 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isDerivation	TokenNameIdentifier	 is Derivation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
removeProhibitedAttrs	TokenNameIdentifier	 remove Prohibited Attrs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end processComplexContent 	TokenNameCOMMENT_LINE	end processComplexContent 
private	TokenNameprivate	
boolean	TokenNameboolean	
isAttrOrAttrGroup	TokenNameIdentifier	 is Attr Or Attr Group
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
elementName	TokenNameIdentifier	 element Name
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTE	TokenNameIdentifier	 ELT  ATTRIBUTE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ATTRIBUTEGROUP	TokenNameIdentifier	 ELT  ATTRIBUTEGROUP
)	TokenNameRPAREN	
||	TokenNameOR_OR	
elementName	TokenNameIdentifier	 element Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANYATTRIBUTE	TokenNameIdentifier	 ELT  ANYATTRIBUTE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
traverseSimpleContentDecl	TokenNameIdentifier	 traverse Simple Content Decl
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
simpleContentDecl	TokenNameIdentifier	 simple Content Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
traverseComplexContentDecl	TokenNameIdentifier	 traverse Complex Content Decl
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexContentDecl	TokenNameIdentifier	 complex Content Decl
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mixedOnComplexTypeDecl	TokenNameIdentifier	 mixed On Complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/* * Generate a name for an anonymous type */	TokenNameCOMMENT_BLOCK	 Generate a name for an anonymous type 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
genAnonTypeName	TokenNameIdentifier	 gen Anon Type Name
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Generate a unique name for the anonymous type by concatenating together the 	TokenNameCOMMENT_LINE	Generate a unique name for the anonymous type by concatenating together the 
// names of parent nodes 	TokenNameCOMMENT_LINE	names of parent nodes 
// The name is quite good for debugging/error purposes, but we may want to 	TokenNameCOMMENT_LINE	The name is quite good for debugging/error purposes, but we may want to 
// revisit how this is done for performance reasons (LM). 	TokenNameCOMMENT_LINE	revisit how this is done for performance reasons (LM). 
StringBuffer	TokenNameIdentifier	 String Buffer
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
"#AnonType_"	TokenNameStringLiteral	#AnonType_
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
complexTypeDecl	TokenNameIdentifier	 complex Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
handleComplexTypeError	TokenNameIdentifier	 handle Complex Type Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
messageId	TokenNameIdentifier	 message Id
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
messageId	TokenNameIdentifier	 message Id
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
messageId	TokenNameIdentifier	 message Id
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Mock up the typeInfo structure so that there won't be problems during 	TokenNameCOMMENT_LINE	Mock up the typeInfo structure so that there won't be problems during 
// validation 	TokenNameCOMMENT_LINE	validation 
// 	TokenNameCOMMENT_LINE	 
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
getErrorContent	TokenNameIdentifier	 get Error Content
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// REVISIT: do we need to remove all attribute uses already added into 	TokenNameCOMMENT_LINE	REVISIT: do we need to remove all attribute uses already added into 
// the attribute group? maybe it's ok to leave them there. -SG 	TokenNameCOMMENT_LINE	the attribute group? maybe it's ok to leave them there. -SG 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
=	TokenNameEQUAL	
getErrorWildcard	TokenNameIdentifier	 get Error Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
contentBackup	TokenNameIdentifier	 content Backup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalStore	TokenNameIdentifier	 f Global Store
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
GLOBAL_NUM	TokenNameIdentifier	 GLOBAL  NUM
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
==	TokenNameEQUAL_EQUAL	
fGlobalStore	TokenNameIdentifier	 f Global Store
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArray	TokenNameIdentifier	 new Array
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
+	TokenNamePLUS	
GLOBAL_NUM	TokenNameIdentifier	 GLOBAL  NUM
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fIsAbstract	TokenNameIdentifier	 f Is Abstract
?	TokenNameQUESTION	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
TRUE	TokenNameIdentifier	 TRUE
:	TokenNameCOLON	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fName	TokenNameIdentifier	 f Name
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
// let's save ourselves a couple of objects... 	TokenNameCOMMENT_LINE	let's save ourselves a couple of objects... 
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fDerivedBy	TokenNameIdentifier	 f Derived By
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
fFinal	TokenNameIdentifier	 f Final
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fBlock	TokenNameIdentifier	 f Block
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
fContentType	TokenNameIdentifier	 f Content Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fBaseType	TokenNameIdentifier	 f Base Type
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fParticle	TokenNameIdentifier	 f Particle
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
;	TokenNameSEMICOLON	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fAnnotations	TokenNameIdentifier	 f Annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
contentRestore	TokenNameIdentifier	 content Restore
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fIsAbstract	TokenNameIdentifier	 f Is Abstract
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fComplexTypeDecl	TokenNameIdentifier	 f Complex Type Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fGlobalStore	TokenNameIdentifier	 f Global Store
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fGlobalStorePos	TokenNameIdentifier	 f Global Store Pos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addAnnotation	TokenNameIdentifier	 add Annotation
(	TokenNameLPAREN	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// it isn't very likely that there will be more than one annotation 	TokenNameCOMMENT_LINE	it isn't very likely that there will be more than one annotation 
// in a complexType decl. This saves us fromhaving to push/pop 	TokenNameCOMMENT_LINE	in a complexType decl. This saves us fromhaving to push/pop 
// one more object from the fGlobalStore, and that's bound 	TokenNameCOMMENT_LINE	one more object from the fGlobalStore, and that's bound 
// to be a savings for most applications 	TokenNameCOMMENT_LINE	to be a savings for most applications 
if	TokenNameif	
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempArray	TokenNameIdentifier	 temp Array
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
fAnnotations	TokenNameIdentifier	 f Annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tempArray	TokenNameIdentifier	 temp Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fAnnotations	TokenNameIdentifier	 f Annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
tempArray	TokenNameIdentifier	 temp Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fAnnotations	TokenNameIdentifier	 f Annotations
[	TokenNameLBRACKET	
fAnnotations	TokenNameIdentifier	 f Annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
annotation	TokenNameIdentifier	 annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
