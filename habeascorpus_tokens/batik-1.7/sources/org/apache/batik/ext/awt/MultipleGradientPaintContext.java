/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Color	TokenNameIdentifier	 Color
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
PaintContext	TokenNameIdentifier	 Paint Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
RenderingHints	TokenNameIdentifier	 Rendering Hints
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
color	TokenNameIdentifier	 color
.	TokenNameDOT	
ColorSpace	TokenNameIdentifier	 Color Space
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
AffineTransform	TokenNameIdentifier	 Affine Transform
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
NoninvertibleTransformException	TokenNameIdentifier	 Noninvertible Transform Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ColorModel	TokenNameIdentifier	 Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBuffer	TokenNameIdentifier	 Data Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
Raster	TokenNameIdentifier	 Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
WritableRaster	TokenNameIdentifier	 Writable Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
WeakReference	TokenNameIdentifier	 Weak Reference
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
;	TokenNameSEMICOLON	
/** * This is the superclass for all PaintContexts which use a multiple color * gradient to fill in their raster. It provides the actual color interpolation * functionality. Subclasses only have to deal with using the gradient to fill * pixels in a raster. * * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans * @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a> * @version $Id: MultipleGradientPaintContext.java 501922 2007-01-31 17:47:47Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 This is the superclass for all PaintContexts which use a multiple color gradient to fill in their raster. It provides the actual color interpolation functionality. Subclasses only have to deal with using the gradient to fill pixels in a raster. * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a> @version $Id: MultipleGradientPaintContext.java 501922 2007-01-31 17:47:47Z dvholten $ 
abstract	TokenNameabstract	
class	TokenNameclass	
MultipleGradientPaintContext	TokenNameIdentifier	 Multiple Gradient Paint Context
implements	TokenNameimplements	
PaintContext	TokenNameIdentifier	 Paint Context
{	TokenNameLBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** * The color model data is generated in (always un premult). */	TokenNameCOMMENT_JAVADOC	 The color model data is generated in (always un premult). 
protected	TokenNameprotected	
ColorModel	TokenNameIdentifier	 Color Model
dataModel	TokenNameIdentifier	 data Model
;	TokenNameSEMICOLON	
/** * PaintContext's output ColorModel ARGB if colors are not all * opaque, RGB otherwise. Linear and premult are matched to * output ColorModel. */	TokenNameCOMMENT_JAVADOC	 PaintContext's output ColorModel ARGB if colors are not all opaque, RGB otherwise. Linear and premult are matched to output ColorModel. 
protected	TokenNameprotected	
ColorModel	TokenNameIdentifier	 Color Model
model	TokenNameIdentifier	 model
;	TokenNameSEMICOLON	
/** Color model used if gradient colors are all opaque */	TokenNameCOMMENT_JAVADOC	 Color model used if gradient colors are all opaque 
private	TokenNameprivate	
static	TokenNamestatic	
ColorModel	TokenNameIdentifier	 Color Model
lrgbmodel_NA	TokenNameIdentifier	 lrgbmodel  NA
=	TokenNameEQUAL	
new	TokenNamenew	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xff0000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
ColorModel	TokenNameIdentifier	 Color Model
srgbmodel_NA	TokenNameIdentifier	 srgbmodel  NA
=	TokenNameEQUAL	
new	TokenNamenew	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xff0000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Color model used if some gradient colors are transparent */	TokenNameCOMMENT_JAVADOC	 Color model used if some gradient colors are transparent 
private	TokenNameprivate	
static	TokenNamestatic	
ColorModel	TokenNameIdentifier	 Color Model
lrgbmodel_A	TokenNameIdentifier	 lrgbmodel  A
=	TokenNameEQUAL	
new	TokenNamenew	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xff0000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
ColorModel	TokenNameIdentifier	 Color Model
srgbmodel_A	TokenNameIdentifier	 srgbmodel  A
=	TokenNameEQUAL	
new	TokenNamenew	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xff0000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0xFF000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** The cached colorModel */	TokenNameCOMMENT_JAVADOC	 The cached colorModel 
protected	TokenNameprotected	
static	TokenNamestatic	
ColorModel	TokenNameIdentifier	 Color Model
cachedModel	TokenNameIdentifier	 cached Model
;	TokenNameSEMICOLON	
/** The cached raster, which is reusable among instances */	TokenNameCOMMENT_JAVADOC	 The cached raster, which is reusable among instances 
protected	TokenNameprotected	
static	TokenNamestatic	
WeakReference	TokenNameIdentifier	 Weak Reference
cached	TokenNameIdentifier	 cached
;	TokenNameSEMICOLON	
/** Raster is reused whenever possible */	TokenNameCOMMENT_JAVADOC	 Raster is reused whenever possible 
protected	TokenNameprotected	
WritableRaster	TokenNameIdentifier	 Writable Raster
saved	TokenNameIdentifier	 saved
;	TokenNameSEMICOLON	
/** The method to use when painting out of the gradient bounds. */	TokenNameCOMMENT_JAVADOC	 The method to use when painting out of the gradient bounds. 
protected	TokenNameprotected	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
CycleMethodEnum	TokenNameIdentifier	 Cycle Method Enum
cycleMethod	TokenNameIdentifier	 cycle Method
;	TokenNameSEMICOLON	
/** The colorSpace in which to perform the interpolation */	TokenNameCOMMENT_JAVADOC	 The colorSpace in which to perform the interpolation 
protected	TokenNameprotected	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
ColorSpaceEnum	TokenNameIdentifier	 Color Space Enum
colorSpace	TokenNameIdentifier	 color Space
;	TokenNameSEMICOLON	
/** Elements of the inverse transform matrix. */	TokenNameCOMMENT_JAVADOC	 Elements of the inverse transform matrix. 
protected	TokenNameprotected	
float	TokenNamefloat	
a00	TokenNameIdentifier	 a00
,	TokenNameCOMMA	
a01	TokenNameIdentifier	 a01
,	TokenNameCOMMA	
a10	TokenNameIdentifier	 a10
,	TokenNameCOMMA	
a11	TokenNameIdentifier	 a11
,	TokenNameCOMMA	
a02	TokenNameIdentifier	 a02
,	TokenNameCOMMA	
a12	TokenNameIdentifier	 a12
;	TokenNameSEMICOLON	
/** This boolean specifies wether we are in simple lookup mode, where an * input value between 0 and 1 may be used to directly index into a single * array of gradient colors. If this boolean value is false, then we have * to use a 2-step process where we have to determine which gradient array * we fall into, then determine the index into that array. */	TokenNameCOMMENT_JAVADOC	 This boolean specifies wether we are in simple lookup mode, where an input value between 0 and 1 may be used to directly index into a single array of gradient colors. If this boolean value is false, then we have to use a 2-step process where we have to determine which gradient array we fall into, then determine the index into that array. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** This boolean indicates if the gradient appears to have sudden * discontinuities in it, this may be because of multiple stops * at the same location or use of the REPEATE mode. */	TokenNameCOMMENT_JAVADOC	 This boolean indicates if the gradient appears to have sudden discontinuities in it, this may be because of multiple stops at the same location or use of the REPEATE mode. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
hasDiscontinuity	TokenNameIdentifier	 has Discontinuity
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Size of gradients array for scaling the 0-1 index when looking up * colors the fast way. */	TokenNameCOMMENT_JAVADOC	 Size of gradients array for scaling the 0-1 index when looking up colors the fast way. 
protected	TokenNameprotected	
int	TokenNameint	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
;	TokenNameSEMICOLON	
/** * Array which contains the interpolated color values for each interval, * used by calculateSingleArrayGradient(). It is protected for possible * direct access by subclasses. */	TokenNameCOMMENT_JAVADOC	 Array which contains the interpolated color values for each interval, used by calculateSingleArrayGradient(). It is protected for possible direct access by subclasses. 
protected	TokenNameprotected	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gradient	TokenNameIdentifier	 gradient
;	TokenNameSEMICOLON	
/** Array of gradient arrays, one array for each interval. Used by * calculateMultipleArrayGradient(). */	TokenNameCOMMENT_JAVADOC	 Array of gradient arrays, one array for each interval. Used by calculateMultipleArrayGradient(). 
protected	TokenNameprotected	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
gradients	TokenNameIdentifier	 gradients
;	TokenNameSEMICOLON	
/** This holds the blend of all colors in the gradient. * we use this at extreamly low resolutions to ensure we * get a decent blend of the colors. */	TokenNameCOMMENT_JAVADOC	 This holds the blend of all colors in the gradient. we use this at extreamly low resolutions to ensure we get a decent blend of the colors. 
protected	TokenNameprotected	
int	TokenNameint	
gradientAverage	TokenNameIdentifier	 gradient Average
;	TokenNameSEMICOLON	
/** This holds the color to use when we are off the bottom of the * gradient */	TokenNameCOMMENT_JAVADOC	 This holds the color to use when we are off the bottom of the gradient 
protected	TokenNameprotected	
int	TokenNameint	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
;	TokenNameSEMICOLON	
/** This holds the color to use when we are off the top of the * gradient */	TokenNameCOMMENT_JAVADOC	 This holds the color to use when we are off the top of the gradient 
protected	TokenNameprotected	
int	TokenNameint	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
/** Length of the 2D slow lookup gradients array. */	TokenNameCOMMENT_JAVADOC	 Length of the 2D slow lookup gradients array. 
protected	TokenNameprotected	
int	TokenNameint	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
/** Normalized intervals array */	TokenNameCOMMENT_JAVADOC	 Normalized intervals array 
protected	TokenNameprotected	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
;	TokenNameSEMICOLON	
/** fractions array */	TokenNameCOMMENT_JAVADOC	 fractions array 
protected	TokenNameprotected	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fractions	TokenNameIdentifier	 fractions
;	TokenNameSEMICOLON	
/** Used to determine if gradient colors are all opaque */	TokenNameCOMMENT_JAVADOC	 Used to determine if gradient colors are all opaque 
private	TokenNameprivate	
int	TokenNameint	
transparencyTest	TokenNameIdentifier	 transparency Test
;	TokenNameSEMICOLON	
/** Colorspace conversion lookup tables */	TokenNameCOMMENT_JAVADOC	 Colorspace conversion lookup tables 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
SRGBtoLinearRGB	TokenNameIdentifier	 SRG Bto Linear RGB
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
256	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
LinearRGBtoSRGB	TokenNameIdentifier	 Linear RG Bto SRGB
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
256	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//build the tables 	TokenNameCOMMENT_LINE	build the tables 
static	TokenNamestatic	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
256	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SRGBtoLinearRGB	TokenNameIdentifier	 SRG Bto Linear RGB
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertSRGBtoLinearRGB	TokenNameIdentifier	 convert SRG Bto Linear RGB
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LinearRGBtoSRGB	TokenNameIdentifier	 Linear RG Bto SRGB
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertLinearRGBtoSRGB	TokenNameIdentifier	 convert Linear RG Bto SRGB
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Constant number of max colors between any 2 arbitrary colors. * Used for creating and indexing gradients arrays. */	TokenNameCOMMENT_JAVADOC	 Constant number of max colors between any 2 arbitrary colors. Used for creating and indexing gradients arrays. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
=	TokenNameEQUAL	
256	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
=	TokenNameEQUAL	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Maximum length of the fast single-array. If the estimated array size * is greater than this, switch over to the slow lookup method. * No particular reason for choosing this number, but it seems to provide * satisfactory performance for the common case (fast lookup). */	TokenNameCOMMENT_JAVADOC	 Maximum length of the fast single-array. If the estimated array size is greater than this, switch over to the slow lookup method. No particular reason for choosing this number, but it seems to provide satisfactory performance for the common case (fast lookup). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_GRADIENT_ARRAY_SIZE	TokenNameIdentifier	 MAX  GRADIENT  ARRAY  SIZE
=	TokenNameEQUAL	
5000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Constructor for superclass. Does some initialization, but leaves most * of the heavy-duty math for calculateGradient(), so the subclass may do * some other manipulation beforehand if necessary. This is not possible * if this computation is done in the superclass constructor which always * gets called first. **/	TokenNameCOMMENT_JAVADOC	 Constructor for superclass. Does some initialization, but leaves most of the heavy-duty math for calculateGradient(), so the subclass may do some other manipulation beforehand if necessary. This is not possible if this computation is done in the superclass constructor which always gets called first. *
protected	TokenNameprotected	
MultipleGradientPaintContext	TokenNameIdentifier	 Multiple Gradient Paint Context
(	TokenNameLPAREN	
ColorModel	TokenNameIdentifier	 Color Model
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
Rectangle	TokenNameIdentifier	 Rectangle
deviceBounds	TokenNameIdentifier	 device Bounds
,	TokenNameCOMMA	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
userBounds	TokenNameIdentifier	 user Bounds
,	TokenNameCOMMA	
AffineTransform	TokenNameIdentifier	 Affine Transform
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
RenderingHints	TokenNameIdentifier	 Rendering Hints
hints	TokenNameIdentifier	 hints
,	TokenNameCOMMA	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fractions	TokenNameIdentifier	 fractions
,	TokenNameCOMMA	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
colors	TokenNameIdentifier	 colors
,	TokenNameCOMMA	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
CycleMethodEnum	TokenNameIdentifier	 Cycle Method Enum
cycleMethod	TokenNameIdentifier	 cycle Method
,	TokenNameCOMMA	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
ColorSpaceEnum	TokenNameIdentifier	 Color Space Enum
colorSpace	TokenNameIdentifier	 color Space
)	TokenNameRPAREN	
throws	TokenNamethrows	
NoninvertibleTransformException	TokenNameIdentifier	 Noninvertible Transform Exception
{	TokenNameLBRACE	
//We have to deal with the cases where the 1st gradient stop is not 	TokenNameCOMMENT_LINE	We have to deal with the cases where the 1st gradient stop is not 
//equal to 0 and/or the last gradient stop is not equal to 1. 	TokenNameCOMMENT_LINE	equal to 0 and/or the last gradient stop is not equal to 1. 
//In both cases, create a new point and replicate the previous 	TokenNameCOMMENT_LINE	In both cases, create a new point and replicate the previous 
//extreme point's color. 	TokenNameCOMMENT_LINE	extreme point's color. 
boolean	TokenNameboolean	
fixFirst	TokenNameIdentifier	 fix First
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
fixLast	TokenNameIdentifier	 fix Last
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
//if the first gradient stop is not equal to zero, fix this condition 	TokenNameCOMMENT_LINE	if the first gradient stop is not equal to zero, fix this condition 
if	TokenNameif	
(	TokenNameLPAREN	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fixFirst	TokenNameIdentifier	 fix First
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//if the last gradient stop is not equal to one, fix this condition 	TokenNameCOMMENT_LINE	if the last gradient stop is not equal to one, fix this condition 
if	TokenNameif	
(	TokenNameLPAREN	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
1.0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fixLast	TokenNameIdentifier	 fix Last
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
len	TokenNameIdentifier	 len
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
len	TokenNameIdentifier	 len
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fractions	TokenNameIdentifier	 fractions
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
len	TokenNameIdentifier	 len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
loColors	TokenNameIdentifier	 lo Colors
=	TokenNameEQUAL	
new	TokenNamenew	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hiColors	TokenNameIdentifier	 hi Colors
=	TokenNameEQUAL	
new	TokenNamenew	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
len	TokenNameIdentifier	 len
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
colors	TokenNameIdentifier	 colors
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fixFirst	TokenNameIdentifier	 fix First
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.out.println("EQ Fracts"); 	TokenNameCOMMENT_LINE	System.out.println("EQ Fracts"); 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hasDiscontinuity	TokenNameIdentifier	 has Discontinuity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fixLast	TokenNameIdentifier	 fix Last
)	TokenNameRPAREN	
{	TokenNameLBRACE	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
colors	TokenNameIdentifier	 colors
[	TokenNameLBRACKET	
colors	TokenNameIdentifier	 colors
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The inverse transform is needed to from device to user space. 	TokenNameCOMMENT_LINE	The inverse transform is needed to from device to user space. 
// Get all the components of the inverse transform matrix. 	TokenNameCOMMENT_LINE	Get all the components of the inverse transform matrix. 
AffineTransform	TokenNameIdentifier	 Affine Transform
tInv	TokenNameIdentifier	 t Inv
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
createInverse	TokenNameIdentifier	 create Inverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
tInv	TokenNameIdentifier	 t Inv
.	TokenNameDOT	
getMatrix	TokenNameIdentifier	 get Matrix
(	TokenNameLPAREN	
m	TokenNameIdentifier	 m
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
a00	TokenNameIdentifier	 a00
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a10	TokenNameIdentifier	 a10
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a01	TokenNameIdentifier	 a01
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a11	TokenNameIdentifier	 a11
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a02	TokenNameIdentifier	 a02
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a12	TokenNameIdentifier	 a12
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//copy some flags 	TokenNameCOMMENT_LINE	copy some flags 
this	TokenNamethis	
.	TokenNameDOT	
cycleMethod	TokenNameIdentifier	 cycle Method
=	TokenNameEQUAL	
cycleMethod	TokenNameIdentifier	 cycle Method
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
colorSpace	TokenNameIdentifier	 color Space
=	TokenNameEQUAL	
colorSpace	TokenNameIdentifier	 color Space
;	TokenNameSEMICOLON	
// Setup an example Model, we may refine it later. 	TokenNameCOMMENT_LINE	Setup an example Model, we may refine it later. 
if	TokenNameif	
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
lrgbmodel_A	TokenNameIdentifier	 lrgbmodel  A
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dataModel	TokenNameIdentifier	 data Model
=	TokenNameEQUAL	
lrgbmodel_A	TokenNameIdentifier	 lrgbmodel  A
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
srgbmodel_A	TokenNameIdentifier	 srgbmodel  A
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dataModel	TokenNameIdentifier	 data Model
=	TokenNameEQUAL	
srgbmodel_A	TokenNameIdentifier	 srgbmodel  A
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Unsupported ColorSpace for interpolation"	TokenNameStringLiteral	Unsupported ColorSpace for interpolation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calculateGradientFractions	TokenNameIdentifier	 calculate Gradient Fractions
(	TokenNameLPAREN	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
hiColors	TokenNameIdentifier	 hi Colors
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
model	TokenNameIdentifier	 model
=	TokenNameEQUAL	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
coerceColorModel	TokenNameIdentifier	 coerce Color Model
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
,	TokenNameCOMMA	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** This function is the meat of this class. It calculates an array of * gradient colors based on an array of fractions and color values at those * fractions. */	TokenNameCOMMENT_JAVADOC	 This function is the meat of this class. It calculates an array of gradient colors based on an array of fractions and color values at those fractions. 
protected	TokenNameprotected	
final	TokenNamefinal	
void	TokenNamevoid	
calculateGradientFractions	TokenNameIdentifier	 calculate Gradient Fractions
(	TokenNameLPAREN	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hiColors	TokenNameIdentifier	 hi Colors
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if interpolation should occur in Linear RGB space, convert the 	TokenNameCOMMENT_LINE	if interpolation should occur in Linear RGB space, convert the 
//colors using the lookup table 	TokenNameCOMMENT_LINE	colors using the lookup table 
if	TokenNameif	
(	TokenNameLPAREN	
colorSpace	TokenNameIdentifier	 color Space
==	TokenNameEQUAL_EQUAL	
LinearGradientPaint	TokenNameIdentifier	 Linear Gradient Paint
.	TokenNameDOT	
LINEAR_RGB	TokenNameIdentifier	 LINEAR  RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
workTbl	TokenNameIdentifier	 work Tbl
=	TokenNameEQUAL	
SRGBtoLinearRGB	TokenNameIdentifier	 SRG Bto Linear RGB
;	TokenNameSEMICOLON	
// local is cheaper 	TokenNameCOMMENT_LINE	local is cheaper 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
loColors	TokenNameIdentifier	 lo Colors
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
interpolateColor	TokenNameIdentifier	 interpolate Color
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
,	TokenNameCOMMA	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
interpolateColor	TokenNameIdentifier	 interpolate Color
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
,	TokenNameCOMMA	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//initialize to be fully opaque for ANDing with colors 	TokenNameCOMMENT_LINE	initialize to be fully opaque for ANDing with colors 
transparencyTest	TokenNameIdentifier	 transparency Test
=	TokenNameEQUAL	
0xff000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
NO_CYCLE	TokenNameIdentifier	 NO  CYCLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Include overflow and underflow colors in transparency 	TokenNameCOMMENT_LINE	Include overflow and underflow colors in transparency 
// test. 	TokenNameCOMMENT_LINE	test. 
transparencyTest	TokenNameIdentifier	 transparency Test
&=	TokenNameAND_EQUAL	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
;	TokenNameSEMICOLON	
transparencyTest	TokenNameIdentifier	 transparency Test
&=	TokenNameAND_EQUAL	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//array of interpolation arrays 	TokenNameCOMMENT_LINE	array of interpolation arrays 
gradients	TokenNameIdentifier	 gradients
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fractions	TokenNameIdentifier	 fractions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
gradientsLength	TokenNameIdentifier	 gradients Length
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
// TODO ??? whats going on here 	TokenNameCOMMENT_LINE	TODO ??? whats going on here 
// ??? the following comments and the name Imin suggest, that we search for something small 	TokenNameCOMMENT_LINE	??? the following comments and the name Imin suggest, that we search for something small 
// ??? but the for-loop actually looks for the LARGEST value 	TokenNameCOMMENT_LINE	??? but the for-loop actually looks for the LARGEST value 
// Find smallest interval 	TokenNameCOMMENT_LINE	Find smallest interval 
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
float	TokenNamefloat	
Imin	TokenNameIdentifier	 Imin
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
workTbl	TokenNameIdentifier	 work Tbl
=	TokenNameEQUAL	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
;	TokenNameSEMICOLON	
// local is cheaper 	TokenNameCOMMENT_LINE	local is cheaper 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ??? find the LARGEST value in normalizedIntervals 	TokenNameCOMMENT_LINE	??? find the LARGEST value in normalizedIntervals 
Imin	TokenNameIdentifier	 Imin
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Imin	TokenNameIdentifier	 Imin
>	TokenNameGREATER	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
:	TokenNameCOLON	
Imin	TokenNameIdentifier	 Imin
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//estimate the size of the entire gradients array. 	TokenNameCOMMENT_LINE	estimate the size of the entire gradients array. 
//This is to prevent a tiny interval from causing the size of array to 	TokenNameCOMMENT_LINE	This is to prevent a tiny interval from causing the size of array to 
//explode. If the estimated size is too large, break to using 	TokenNameCOMMENT_LINE	explode. If the estimated size is too large, break to using 
//seperate arrays for each interval, and using an indexing scheme at 	TokenNameCOMMENT_LINE	seperate arrays for each interval, and using an indexing scheme at 
//look-up time. 	TokenNameCOMMENT_LINE	look-up time. 
int	TokenNameint	
estimatedSize	TokenNameIdentifier	 estimated Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Imin	TokenNameIdentifier	 Imin
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
estimatedSize	TokenNameIdentifier	 estimated Size
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
hasDiscontinuity	TokenNameIdentifier	 has Discontinuity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
workTbl	TokenNameIdentifier	 work Tbl
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
estimatedSize	TokenNameIdentifier	 estimated Size
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
/	TokenNameDIVIDE	
Imin	TokenNameIdentifier	 Imin
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
>	TokenNameGREATER	
MAX_GRADIENT_ARRAY_SIZE	TokenNameIdentifier	 MAX  GRADIENT  ARRAY  SIZE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//slow method 	TokenNameCOMMENT_LINE	slow method 
calculateMultipleArrayGradient	TokenNameIdentifier	 calculate Multiple Array Gradient
(	TokenNameLPAREN	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
hiColors	TokenNameIdentifier	 hi Colors
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
REPEAT	TokenNameIdentifier	 REPEAT
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
hasDiscontinuity	TokenNameIdentifier	 has Discontinuity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//fast method 	TokenNameCOMMENT_LINE	fast method 
calculateSingleArrayGradient	TokenNameIdentifier	 calculate Single Array Gradient
(	TokenNameLPAREN	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
hiColors	TokenNameIdentifier	 hi Colors
,	TokenNameCOMMA	
Imin	TokenNameIdentifier	 Imin
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
REPEAT	TokenNameIdentifier	 REPEAT
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
hasDiscontinuity	TokenNameIdentifier	 has Discontinuity
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Use the most 'economical' model (no alpha). 	TokenNameCOMMENT_LINE	Use the most 'economical' model (no alpha). 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
transparencyTest	TokenNameIdentifier	 transparency Test
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
lrgbmodel_NA	TokenNameIdentifier	 lrgbmodel  NA
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dataModel	TokenNameIdentifier	 data Model
=	TokenNameEQUAL	
lrgbmodel_NA	TokenNameIdentifier	 lrgbmodel  NA
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
srgbmodel_NA	TokenNameIdentifier	 srgbmodel  NA
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
dataModel	TokenNameIdentifier	 data Model
=	TokenNameEQUAL	
srgbmodel_NA	TokenNameIdentifier	 srgbmodel  NA
;	TokenNameSEMICOLON	
model	TokenNameIdentifier	 model
=	TokenNameEQUAL	
dataModel	TokenNameIdentifier	 data Model
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * We assume, that we always generate valid colors. When this is valid, we can compose the * color-value by ourselves and use the faster Color-ctor, which does not check the incoming values. * * @param workTbl typically SRGBtoLinearRGB * @param inColor the color to interpolate * @return the interpolated color */	TokenNameCOMMENT_JAVADOC	 We assume, that we always generate valid colors. When this is valid, we can compose the color-value by ourselves and use the faster Color-ctor, which does not check the incoming values. * @param workTbl typically SRGBtoLinearRGB @param inColor the color to interpolate @return the interpolated color 
private	TokenNameprivate	
static	TokenNamestatic	
Color	TokenNameIdentifier	 Color
interpolateColor	TokenNameIdentifier	 interpolate Color
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
workTbl	TokenNameIdentifier	 work Tbl
,	TokenNameCOMMA	
Color	TokenNameIdentifier	 Color
inColor	TokenNameIdentifier	 in Color
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
oldColor	TokenNameIdentifier	 old Color
=	TokenNameEQUAL	
inColor	TokenNameIdentifier	 in Color
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
newColorValue	TokenNameIdentifier	 new Color Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
oldColor	TokenNameIdentifier	 old Color
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
oldColor	TokenNameIdentifier	 old Color
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
oldColor	TokenNameIdentifier	 old Color
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
oldColor	TokenNameIdentifier	 old Color
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Color	TokenNameIdentifier	 Color
(	TokenNameLPAREN	
newColorValue	TokenNameIdentifier	 new Color Value
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * FAST LOOKUP METHOD * * This method calculates the gradient color values and places them in a * single int array, gradient[]. It does this by allocating space for * each interval based on its size relative to the smallest interval in * the array. The smallest interval is allocated 255 interpolated values * (the maximum number of unique in-between colors in a 24 bit color * system), and all other intervals are allocated * size = (255 * the ratio of their size to the smallest interval). * * This scheme expedites a speedy retrieval because the colors are * distributed along the array according to their user-specified * distribution. All that is needed is a relative index from 0 to 1. * * The only problem with this method is that the possibility exists for * the array size to balloon in the case where there is a * disproportionately small gradient interval. In this case the other * intervals will be allocated huge space, but much of that data is * redundant. We thus need to use the space conserving scheme below. * * @param Imin the size of the smallest interval * */	TokenNameCOMMENT_JAVADOC	 FAST LOOKUP METHOD * This method calculates the gradient color values and places them in a single int array, gradient[]. It does this by allocating space for each interval based on its size relative to the smallest interval in the array. The smallest interval is allocated 255 interpolated values (the maximum number of unique in-between colors in a 24 bit color system), and all other intervals are allocated size = (255 the ratio of their size to the smallest interval). * This scheme expedites a speedy retrieval because the colors are distributed along the array according to their user-specified distribution. All that is needed is a relative index from 0 to 1. * The only problem with this method is that the possibility exists for the array size to balloon in the case where there is a disproportionately small gradient interval. In this case the other intervals will be allocated huge space, but much of that data is redundant. We thus need to use the space conserving scheme below. * @param Imin the size of the smallest interval 
private	TokenNameprivate	
void	TokenNamevoid	
calculateSingleArrayGradient	TokenNameIdentifier	 calculate Single Array Gradient
(	TokenNameLPAREN	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hiColors	TokenNameIdentifier	 hi Colors
,	TokenNameCOMMA	
float	TokenNamefloat	
Imin	TokenNameIdentifier	 Imin
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//set the flag so we know later it is a non-simple lookup 	TokenNameCOMMENT_LINE	set the flag so we know later it is a non-simple lookup 
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
int	TokenNameint	
gradientsTot	TokenNameIdentifier	 gradients Tot
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//the eventual size of the single array 	TokenNameCOMMENT_LINE	the eventual size of the single array 
// These are fixed point 8.16 (start with 0.5) 	TokenNameCOMMENT_LINE	These are fixed point 8.16 (start with 0.5) 
int	TokenNameint	
aveA	TokenNameIdentifier	 ave A
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveR	TokenNameIdentifier	 ave R
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveG	TokenNameIdentifier	 ave G
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveB	TokenNameIdentifier	 ave B
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//for every interval (transition between 2 colors) 	TokenNameCOMMENT_LINE	for every interval (transition between 2 colors) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//create an array whose size is based on the ratio to the 	TokenNameCOMMENT_LINE	create an array whose size is based on the ratio to the 
//smallest interval. 	TokenNameCOMMENT_LINE	smallest interval. 
int	TokenNameint	
nGradients	TokenNameIdentifier	 n Gradients
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
/	TokenNameDIVIDE	
Imin	TokenNameIdentifier	 Imin
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
255f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gradientsTot	TokenNameIdentifier	 gradients Tot
+=	TokenNamePLUS_EQUAL	
nGradients	TokenNameIdentifier	 n Gradients
;	TokenNameSEMICOLON	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
nGradients	TokenNameIdentifier	 n Gradients
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//the the 2 colors (keyframes) to interpolate between 	TokenNameCOMMENT_LINE	the the 2 colors (keyframes) to interpolate between 
int	TokenNameint	
rgb1	TokenNameIdentifier	 rgb1
=	TokenNameEQUAL	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
rgb2	TokenNameIdentifier	 rgb2
=	TokenNameEQUAL	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//fill this array with the colors in between rgb1 and rgb2 	TokenNameCOMMENT_LINE	fill this array with the colors in between rgb1 and rgb2 
interpolate	TokenNameIdentifier	 interpolate
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
,	TokenNameCOMMA	
rgb2	TokenNameIdentifier	 rgb2
,	TokenNameCOMMA	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Calculate Average of two colors... 	TokenNameCOMMENT_LINE	Calculate Average of two colors... 
int	TokenNameint	
argb	TokenNameIdentifier	 argb
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
aveA	TokenNameIdentifier	 ave A
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveR	TokenNameIdentifier	 ave R
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveG	TokenNameIdentifier	 ave G
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveB	TokenNameIdentifier	 ave B
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if the colors are opaque, transparency should still be 0xff000000 	TokenNameCOMMENT_LINE	if the colors are opaque, transparency should still be 0xff000000 
transparencyTest	TokenNameIdentifier	 transparency Test
&=	TokenNameAND_EQUAL	
rgb1	TokenNameIdentifier	 rgb1
&	TokenNameAND	
rgb2	TokenNameIdentifier	 rgb2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveA	TokenNameIdentifier	 ave A
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveR	TokenNameIdentifier	 ave R
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveG	TokenNameIdentifier	 ave G
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveB	TokenNameIdentifier	 ave B
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Put all gradients in a single array 	TokenNameCOMMENT_LINE	Put all gradients in a single array 
gradient	TokenNameIdentifier	 gradient
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
gradientsTot	TokenNameIdentifier	 gradients Tot
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
curOffset	TokenNameIdentifier	 cur Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
gradient	TokenNameIdentifier	 gradient
,	TokenNameCOMMA	
curOffset	TokenNameIdentifier	 cur Offset
,	TokenNameCOMMA	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
curOffset	TokenNameIdentifier	 cur Offset
+=	TokenNamePLUS_EQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
hiColors	TokenNameIdentifier	 hi Colors
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if interpolation occurred in Linear RGB space, convert the 	TokenNameCOMMENT_LINE	if interpolation occurred in Linear RGB space, convert the 
//gradients back to SRGB using the lookup table 	TokenNameCOMMENT_LINE	gradients back to SRGB using the lookup table 
if	TokenNameif	
(	TokenNameLPAREN	
colorSpace	TokenNameIdentifier	 color Space
==	TokenNameEQUAL_EQUAL	
LinearGradientPaint	TokenNameIdentifier	 Linear Gradient Paint
.	TokenNameDOT	
LINEAR_RGB	TokenNameIdentifier	 LINEAR  RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertEntireColorLinearRGBtoSRGB	TokenNameIdentifier	 convert Entire Color Linear RG Bto SRGB
(	TokenNameLPAREN	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
convertEntireColorLinearRGBtoSRGB	TokenNameIdentifier	 convert Entire Color Linear RG Bto SRGB
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertEntireColorSRGBtoLinearRGB	TokenNameIdentifier	 convert Entire Color SRG Bto Linear RGB
(	TokenNameLPAREN	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
convertEntireColorSRGBtoLinearRGB	TokenNameIdentifier	 convert Entire Color SRG Bto Linear RGB
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * SLOW LOOKUP METHOD * * This method calculates the gradient color values for each interval and * places each into its own 255 size array. The arrays are stored in * gradients[][]. (255 is used because this is the maximum number of * unique colors between 2 arbitrary colors in a 24 bit color system) * * This method uses the minimum amount of space (only 255 * number of * intervals), but it aggravates the lookup procedure, because now we * have to find out which interval to select, then calculate the index * within that interval. This causes a significant performance hit, * because it requires this calculation be done for every point in * the rendering loop. * * For those of you who are interested, this is a classic example of the * time-space tradeoff. * */	TokenNameCOMMENT_JAVADOC	 SLOW LOOKUP METHOD * This method calculates the gradient color values for each interval and places each into its own 255 size array. The arrays are stored in gradients[][]. (255 is used because this is the maximum number of unique colors between 2 arbitrary colors in a 24 bit color system) * This method uses the minimum amount of space (only 255 number of intervals), but it aggravates the lookup procedure, because now we have to find out which interval to select, then calculate the index within that interval. This causes a significant performance hit, because it requires this calculation be done for every point in the rendering loop. * For those of you who are interested, this is a classic example of the time-space tradeoff. 
private	TokenNameprivate	
void	TokenNamevoid	
calculateMultipleArrayGradient	TokenNameIdentifier	 calculate Multiple Array Gradient
(	TokenNameLPAREN	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
loColors	TokenNameIdentifier	 lo Colors
,	TokenNameCOMMA	
Color	TokenNameIdentifier	 Color
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hiColors	TokenNameIdentifier	 hi Colors
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//set the flag so we know later it is a non-simple lookup 	TokenNameCOMMENT_LINE	set the flag so we know later it is a non-simple lookup 
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
int	TokenNameint	
rgb1	TokenNameIdentifier	 rgb1
;	TokenNameSEMICOLON	
//2 colors to interpolate 	TokenNameCOMMENT_LINE	2 colors to interpolate 
int	TokenNameint	
rgb2	TokenNameIdentifier	 rgb2
;	TokenNameSEMICOLON	
// These are fixed point 8.16 (start with 0.5) 	TokenNameCOMMENT_LINE	These are fixed point 8.16 (start with 0.5) 
int	TokenNameint	
aveA	TokenNameIdentifier	 ave A
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveR	TokenNameIdentifier	 ave R
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveG	TokenNameIdentifier	 ave G
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveB	TokenNameIdentifier	 ave B
=	TokenNameEQUAL	
0x008000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//for every interval (transition between 2 colors) 	TokenNameCOMMENT_LINE	for every interval (transition between 2 colors) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This interval will never actually be used (zero size) 	TokenNameCOMMENT_LINE	This interval will never actually be used (zero size) 
if	TokenNameif	
(	TokenNameLPAREN	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
//create an array of the maximum theoretical size for each interval 	TokenNameCOMMENT_LINE	create an array of the maximum theoretical size for each interval 
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//get the the 2 colors 	TokenNameCOMMENT_LINE	get the the 2 colors 
rgb1	TokenNameIdentifier	 rgb1
=	TokenNameEQUAL	
loColors	TokenNameIdentifier	 lo Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rgb2	TokenNameIdentifier	 rgb2
=	TokenNameEQUAL	
hiColors	TokenNameIdentifier	 hi Colors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getRGB	TokenNameIdentifier	 get RGB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//fill this array with the colors in between rgb1 and rgb2 	TokenNameCOMMENT_LINE	fill this array with the colors in between rgb1 and rgb2 
interpolate	TokenNameIdentifier	 interpolate
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
,	TokenNameCOMMA	
rgb2	TokenNameIdentifier	 rgb2
,	TokenNameCOMMA	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Calculate Average of two colors... 	TokenNameCOMMENT_LINE	Calculate Average of two colors... 
int	TokenNameint	
argb	TokenNameIdentifier	 argb
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
aveA	TokenNameIdentifier	 ave A
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveR	TokenNameIdentifier	 ave R
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveG	TokenNameIdentifier	 ave G
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
aveB	TokenNameIdentifier	 ave B
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
argb	TokenNameIdentifier	 argb
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if the colors are opaque, transparency should still be 0xff000000 	TokenNameCOMMENT_LINE	if the colors are opaque, transparency should still be 0xff000000 
transparencyTest	TokenNameIdentifier	 transparency Test
&=	TokenNameAND_EQUAL	
rgb1	TokenNameIdentifier	 rgb1
;	TokenNameSEMICOLON	
transparencyTest	TokenNameIdentifier	 transparency Test
&=	TokenNameAND_EQUAL	
rgb2	TokenNameIdentifier	 rgb2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveA	TokenNameIdentifier	 ave A
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveR	TokenNameIdentifier	 ave R
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveG	TokenNameIdentifier	 ave G
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
aveB	TokenNameIdentifier	 ave B
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if interpolation occurred in Linear RGB space, convert the 	TokenNameCOMMENT_LINE	if interpolation occurred in Linear RGB space, convert the 
//gradients back to SRGB using the lookup table 	TokenNameCOMMENT_LINE	gradients back to SRGB using the lookup table 
if	TokenNameif	
(	TokenNameLPAREN	
colorSpace	TokenNameIdentifier	 color Space
==	TokenNameEQUAL_EQUAL	
LinearGradientPaint	TokenNameIdentifier	 Linear Gradient Paint
.	TokenNameDOT	
LINEAR_RGB	TokenNameIdentifier	 LINEAR  RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertEntireColorLinearRGBtoSRGB	TokenNameIdentifier	 convert Entire Color Linear RG Bto SRGB
(	TokenNameLPAREN	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
convertEntireColorLinearRGBtoSRGB	TokenNameIdentifier	 convert Entire Color Linear RG Bto SRGB
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
convertEntireColorSRGBtoLinearRGB	TokenNameIdentifier	 convert Entire Color SRG Bto Linear RGB
(	TokenNameLPAREN	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
gradientAverage	TokenNameIdentifier	 gradient Average
=	TokenNameEQUAL	
convertEntireColorSRGBtoLinearRGB	TokenNameIdentifier	 convert Entire Color SRG Bto Linear RGB
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Yet another helper function. This one linearly interpolates between * 2 colors, filling up the output array. * * @param rgb1 the start color * @param rgb2 the end color * @param output the output array of colors... assuming this is not null or length 0. */	TokenNameCOMMENT_JAVADOC	 Yet another helper function. This one linearly interpolates between 2 colors, filling up the output array. * @param rgb1 the start color @param rgb2 the end color @param output the output array of colors... assuming this is not null or length 0. 
private	TokenNameprivate	
void	TokenNamevoid	
interpolate	TokenNameIdentifier	 interpolate
(	TokenNameLPAREN	
int	TokenNameint	
rgb1	TokenNameIdentifier	 rgb1
,	TokenNameCOMMA	
int	TokenNameint	
rgb2	TokenNameIdentifier	 rgb2
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nSteps	TokenNameIdentifier	 n Steps
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
//step between interpolated values. 	TokenNameCOMMENT_LINE	step between interpolated values. 
float	TokenNamefloat	
stepSize	TokenNameIdentifier	 step Size
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
nSteps	TokenNameIdentifier	 n Steps
;	TokenNameSEMICOLON	
//extract color components from packed integer 	TokenNameCOMMENT_LINE	extract color components from packed integer 
int	TokenNameint	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb1	TokenNameIdentifier	 rgb1
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// calculate the total change in alpha, red, green, blue 	TokenNameCOMMENT_LINE	calculate the total change in alpha, red, green, blue 
// the deltas can be negative ! 	TokenNameCOMMENT_LINE	the deltas can be negative ! 
int	TokenNameint	
da	TokenNameIdentifier	 da
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rgb2	TokenNameIdentifier	 rgb2
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
int	TokenNameint	
dr	TokenNameIdentifier	 dr
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rgb2	TokenNameIdentifier	 rgb2
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
int	TokenNameint	
dg	TokenNameIdentifier	 dg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rgb2	TokenNameIdentifier	 rgb2
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
int	TokenNameint	
db	TokenNameIdentifier	 db
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rgb2	TokenNameIdentifier	 rgb2
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// this method is a hotspot so we try to save some cycles 	TokenNameCOMMENT_LINE	this method is a hotspot so we try to save some cycles 
// pre-compute some intermediate values. 	TokenNameCOMMENT_LINE	pre-compute some intermediate values. 
// the multiplication by 2 is used to help with rounding. 	TokenNameCOMMENT_LINE	the multiplication by 2 is used to help with rounding. 
float	TokenNamefloat	
tempA	TokenNameIdentifier	 temp A
=	TokenNameEQUAL	
2.0f	TokenNameFloatingPointLiteral	
*	TokenNameMULTIPLY	
da	TokenNameIdentifier	 da
*	TokenNameMULTIPLY	
stepSize	TokenNameIdentifier	 step Size
;	TokenNameSEMICOLON	
float	TokenNamefloat	
tempR	TokenNameIdentifier	 temp R
=	TokenNameEQUAL	
2.0f	TokenNameFloatingPointLiteral	
*	TokenNameMULTIPLY	
dr	TokenNameIdentifier	 dr
*	TokenNameMULTIPLY	
stepSize	TokenNameIdentifier	 step Size
;	TokenNameSEMICOLON	
float	TokenNamefloat	
tempG	TokenNameIdentifier	 temp G
=	TokenNameEQUAL	
2.0f	TokenNameFloatingPointLiteral	
*	TokenNameMULTIPLY	
dg	TokenNameIdentifier	 dg
*	TokenNameMULTIPLY	
stepSize	TokenNameIdentifier	 step Size
;	TokenNameSEMICOLON	
float	TokenNamefloat	
tempB	TokenNameIdentifier	 temp B
=	TokenNameEQUAL	
2.0f	TokenNameFloatingPointLiteral	
*	TokenNameMULTIPLY	
db	TokenNameIdentifier	 db
*	TokenNameMULTIPLY	
stepSize	TokenNameIdentifier	 step Size
;	TokenNameSEMICOLON	
//for each step in the interval calculate the in-between color by 	TokenNameCOMMENT_LINE	for each step in the interval calculate the in-between color by 
//multiplying the normalized current position by the total color change 	TokenNameCOMMENT_LINE	multiplying the normalized current position by the total color change 
//(.5 is added to prevent truncation round-off error) 	TokenNameCOMMENT_LINE	(.5 is added to prevent truncation round-off error) 
// the previous implementation used a simple +0.5d to do some rounding. 	TokenNameCOMMENT_LINE	the previous implementation used a simple +0.5d to do some rounding. 
// but that is just rounding towards +inifitity. This results in 	TokenNameCOMMENT_LINE	but that is just rounding towards +inifitity. This results in 
// slightly different values (thus gradients) when you interpolate from 	TokenNameCOMMENT_LINE	slightly different values (thus gradients) when you interpolate from 
// color1 -> color2 	TokenNameCOMMENT_LINE	color1 -> color2 
// versus 	TokenNameCOMMENT_LINE	versus 
// color1 <- color2 	TokenNameCOMMENT_LINE	color1 <- color2 
// 	TokenNameCOMMENT_LINE	 
// this implementation uses an implied multiplication by 2 ( in tempX ) 	TokenNameCOMMENT_LINE	this implementation uses an implied multiplication by 2 ( in tempX ) 
// and then a signed right-shift to do signed rounding. 	TokenNameCOMMENT_LINE	and then a signed right-shift to do signed rounding. 
// this also spares a float-add per color-band. 	TokenNameCOMMENT_LINE	this also spares a float-add per color-band. 
// we could also save the shift when we use a different and-mask and a different left-shift, 	TokenNameCOMMENT_LINE	we could also save the shift when we use a different and-mask and a different left-shift, 
// but that would obfuscate too much... 	TokenNameCOMMENT_LINE	but that would obfuscate too much... 
// 	TokenNameCOMMENT_LINE	 
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rgb1	TokenNameIdentifier	 rgb1
;	TokenNameSEMICOLON	
// the start-color is fixed 	TokenNameCOMMENT_LINE	the start-color is fixed 
nSteps	TokenNameIdentifier	 n Steps
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// upto, but not including the last slot 	TokenNameCOMMENT_LINE	upto, but not including the last slot 
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
nSteps	TokenNameIdentifier	 n Steps
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rgb2	TokenNameIdentifier	 rgb2
;	TokenNameSEMICOLON	
// the last color is also fixed 	TokenNameCOMMENT_LINE	the last color is also fixed 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nSteps	TokenNameIdentifier	 n Steps
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
fI	TokenNameIdentifier	 f I
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fI	TokenNameIdentifier	 f I
*	TokenNameMULTIPLY	
tempA	TokenNameIdentifier	 temp A
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fI	TokenNameIdentifier	 f I
*	TokenNameMULTIPLY	
tempR	TokenNameIdentifier	 temp R
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fI	TokenNameIdentifier	 f I
*	TokenNameMULTIPLY	
tempG	TokenNameIdentifier	 temp G
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fI	TokenNameIdentifier	 f I
*	TokenNameMULTIPLY	
tempB	TokenNameIdentifier	 temp B
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Yet another helper function. This one extracts the color components * of an integer RGB triple, converts them from LinearRGB to SRGB, then * recompacts them into an int. */	TokenNameCOMMENT_JAVADOC	 Yet another helper function. This one extracts the color components of an integer RGB triple, converts them from LinearRGB to SRGB, then recompacts them into an int. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
convertEntireColorLinearRGBtoSRGB	TokenNameIdentifier	 convert Entire Color Linear RG Bto SRGB
(	TokenNameLPAREN	
int	TokenNameint	
rgb	TokenNameIdentifier	 rgb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//extract red, green, blue components 	TokenNameCOMMENT_LINE	extract red, green, blue components 
int	TokenNameint	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
rgb	TokenNameIdentifier	 rgb
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//use the lookup table 	TokenNameCOMMENT_LINE	use the lookup table 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
workTbl	TokenNameIdentifier	 work Tbl
=	TokenNameEQUAL	
LinearRGBtoSRGB	TokenNameIdentifier	 Linear RG Bto SRGB
;	TokenNameSEMICOLON	
// local is cheaper 	TokenNameCOMMENT_LINE	local is cheaper 
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
r1	TokenNameIdentifier	 r1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
g1	TokenNameIdentifier	 g1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
b1	TokenNameIdentifier	 b1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//re-compact the components 	TokenNameCOMMENT_LINE	re-compact the components 
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
b1	TokenNameIdentifier	 b1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Yet another helper function. This one extracts the color components * of an integer RGB triple, converts them from LinearRGB to SRGB, then * recompacts them into an int. */	TokenNameCOMMENT_JAVADOC	 Yet another helper function. This one extracts the color components of an integer RGB triple, converts them from LinearRGB to SRGB, then recompacts them into an int. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
convertEntireColorSRGBtoLinearRGB	TokenNameIdentifier	 convert Entire Color SRG Bto Linear RGB
(	TokenNameLPAREN	
int	TokenNameint	
rgb	TokenNameIdentifier	 rgb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//extract red, green, blue components 	TokenNameCOMMENT_LINE	extract red, green, blue components 
int	TokenNameint	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rgb	TokenNameIdentifier	 rgb
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
rgb	TokenNameIdentifier	 rgb
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//use the lookup table 	TokenNameCOMMENT_LINE	use the lookup table 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
workTbl	TokenNameIdentifier	 work Tbl
=	TokenNameEQUAL	
SRGBtoLinearRGB	TokenNameIdentifier	 SRG Bto Linear RGB
;	TokenNameSEMICOLON	
// local is cheaper 	TokenNameCOMMENT_LINE	local is cheaper 
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
r1	TokenNameIdentifier	 r1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
g1	TokenNameIdentifier	 g1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
workTbl	TokenNameIdentifier	 work Tbl
[	TokenNameLBRACKET	
b1	TokenNameIdentifier	 b1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//re-compact the components 	TokenNameCOMMENT_LINE	re-compact the components 
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
b1	TokenNameIdentifier	 b1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Helper function to index into the gradients array. This is necessary * because each interval has an array of colors with uniform size 255. * However, the color intervals are not necessarily of uniform length, so * a conversion is required. * * @param position the unmanipulated position. want to map this into the * range 0 to 1 * * @return integer color to display * */	TokenNameCOMMENT_JAVADOC	 Helper function to index into the gradients array. This is necessary because each interval has an array of colors with uniform size 255. However, the color intervals are not necessarily of uniform length, so a conversion is required. * @param position the unmanipulated position. want to map this into the range 0 to 1 * @return integer color to display 
protected	TokenNameprotected	
final	TokenNamefinal	
int	TokenNameint	
indexIntoGradientsArrays	TokenNameIdentifier	 index Into Gradients Arrays
(	TokenNameLPAREN	
float	TokenNamefloat	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//first, manipulate position value depending on the cycle method. 	TokenNameCOMMENT_LINE	first, manipulate position value depending on the cycle method. 
if	TokenNameif	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
NO_CYCLE	TokenNameIdentifier	 NO  CYCLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//upper bound is 1 	TokenNameCOMMENT_LINE	upper bound is 1 
return	TokenNamereturn	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//lower bound is 0 	TokenNameCOMMENT_LINE	lower bound is 0 
return	TokenNamereturn	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
REPEAT	TokenNameIdentifier	 REPEAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//get the fractional part 	TokenNameCOMMENT_LINE	get the fractional part 
//(modulo behavior discards integer component) 	TokenNameCOMMENT_LINE	(modulo behavior discards integer component) 
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
//position now be between -1 and 1 	TokenNameCOMMENT_LINE	position now be between -1 and 1 
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//force it to be in the range 0-1 	TokenNameCOMMENT_LINE	force it to be in the range 0-1 
}	TokenNameRBRACE	
int	TokenNameint	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
c1	TokenNameIdentifier	 c1
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
c2	TokenNameIdentifier	 c2
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
position	TokenNameIdentifier	 position
*=	TokenNameMULTIPLY_EQUAL	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
int	TokenNameint	
idx1	TokenNameIdentifier	 idx1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
gradient	TokenNameIdentifier	 gradient
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
return	TokenNamereturn	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
idx1	TokenNameIdentifier	 idx1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
idx1	TokenNameIdentifier	 idx1
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c1	TokenNameIdentifier	 c1
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
idx1	TokenNameIdentifier	 idx1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
c2	TokenNameIdentifier	 c2
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//for all the gradient interval arrays 	TokenNameCOMMENT_LINE	for all the gradient interval arrays 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//this is the array we want 	TokenNameCOMMENT_LINE	this is the array we want 
float	TokenNamefloat	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
/	TokenNameDIVIDE	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//this is the interval we want. 	TokenNameCOMMENT_LINE	this is the interval we want. 
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
gradientsLength	TokenNameIdentifier	 gradients Length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
-	TokenNameMINUS	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c1	TokenNameIdentifier	 c1
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
c2	TokenNameIdentifier	 c2
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c2	TokenNameIdentifier	 c2
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c2	TokenNameIdentifier	 c2
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c2	TokenNameIdentifier	 c2
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c2	TokenNameIdentifier	 c2
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
c1	TokenNameIdentifier	 c1
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
w	TokenNameIdentifier	 w
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return c1 + 	TokenNameCOMMENT_LINE	return c1 + 
// ((( ((((c2>>>24) )-((c1>>>24) ))*w)&0xFF0000)<< 8) | 	TokenNameCOMMENT_LINE	((( ((((c2>>>24) )-((c1>>>24) ))*w)&0xFF0000)<< 8) | 
// (( ((((c2>> 16)&0xFF)-((c1>> 16)&0xFF))*w)&0xFF0000) ) | 	TokenNameCOMMENT_LINE	(( ((((c2>> 16)&0xFF)-((c1>> 16)&0xFF))*w)&0xFF0000) ) | 
// (( ((((c2>> 8)&0xFF)-((c1>> 8)&0xFF))*w)&0xFF0000)>> 8) | 	TokenNameCOMMENT_LINE	(( ((((c2>> 8)&0xFF)-((c1>> 8)&0xFF))*w)&0xFF0000)>> 8) | 
// (( ((((c2 )&0xFF)-((c1 )&0xFF))*w)&0xFF0000)>>16)); 	TokenNameCOMMENT_LINE	(( ((((c2 )&0xFF)-((c1 )&0xFF))*w)&0xFF0000)>>16)); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//cycleMethod == MultipleGradientPaint.REFLECT 	TokenNameCOMMENT_LINE	cycleMethod == MultipleGradientPaint.REFLECT 
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
-	TokenNameMINUS	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
//take absolute value 	TokenNameCOMMENT_LINE	take absolute value 
}	TokenNameRBRACE	
int	TokenNameint	
part	TokenNameIdentifier	 part
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
//take the integer part 	TokenNameCOMMENT_LINE	take the integer part 
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
part	TokenNameIdentifier	 part
;	TokenNameSEMICOLON	
//get the fractional part 	TokenNameCOMMENT_LINE	get the fractional part 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
part	TokenNameIdentifier	 part
&	TokenNameAND	
0x00000001	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if integer part is odd 	TokenNameCOMMENT_LINE	if integer part is odd 
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
//want the reflected color instead 	TokenNameCOMMENT_LINE	want the reflected color instead 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//now, get the color based on this 0-1 position: 	TokenNameCOMMENT_LINE	now, get the color based on this 0-1 position: 
if	TokenNameif	
(	TokenNameLPAREN	
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//easy to compute: just scale index by array size 	TokenNameCOMMENT_LINE	easy to compute: just scale index by array size 
return	TokenNamereturn	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
*	TokenNameMULTIPLY	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//more complicated computation, to save space 	TokenNameCOMMENT_LINE	more complicated computation, to save space 
//for all the gradient interval arrays 	TokenNameCOMMENT_LINE	for all the gradient interval arrays 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//this is the array we want 	TokenNameCOMMENT_LINE	this is the array we want 
float	TokenNamefloat	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//this is the interval we want. 	TokenNameCOMMENT_LINE	this is the interval we want. 
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
/	TokenNameDIVIDE	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Helper function to index into the gradients array. This is necessary * because each interval has an array of colors with uniform size 255. * However, the color intervals are not necessarily of uniform length, so * a conversion is required. This version also does anti-aliasing by * averaging the gradient over position+/-(sz/2). * * @param position the unmanipulated position. want to map this into the * range 0 to 1 * @param sz the size in gradient space to average. * * @return ARGB integer color to display */	TokenNameCOMMENT_JAVADOC	 Helper function to index into the gradients array. This is necessary because each interval has an array of colors with uniform size 255. However, the color intervals are not necessarily of uniform length, so a conversion is required. This version also does anti-aliasing by averaging the gradient over position+/-(sz/2). * @param position the unmanipulated position. want to map this into the range 0 to 1 @param sz the size in gradient space to average. * @return ARGB integer color to display 
protected	TokenNameprotected	
final	TokenNamefinal	
int	TokenNameint	
indexGradientAntiAlias	TokenNameIdentifier	 index Gradient Anti Alias
(	TokenNameLPAREN	
float	TokenNamefloat	
position	TokenNameIdentifier	 position
,	TokenNameCOMMA	
float	TokenNamefloat	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//first, manipulate position value depending on the cycle method. 	TokenNameCOMMENT_LINE	first, manipulate position value depending on the cycle method. 
if	TokenNameif	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
NO_CYCLE	TokenNameIdentifier	 NO  CYCLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NO_CYCLE"	TokenNameStringLiteral	NO_CYCLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
+	TokenNamePLUS	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
;	TokenNameSEMICOLON	
int	TokenNameint	
interior	TokenNameIdentifier	 interior
;	TokenNameSEMICOLON	
float	TokenNamefloat	
top_weight	TokenNameIdentifier	 top weight
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bottom_weight	TokenNameIdentifier	 bottom weight
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
frac	TokenNameIdentifier	 frac
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
top_weight	TokenNameIdentifier	 top weight
=	TokenNameEQUAL	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
sz	TokenNameIdentifier	 sz
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bottom_weight	TokenNameIdentifier	 bottom weight
=	TokenNameEQUAL	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
/	TokenNameDIVIDE	
sz	TokenNameIdentifier	 sz
;	TokenNameSEMICOLON	
frac	TokenNameIdentifier	 frac
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
interior	TokenNameIdentifier	 interior
=	TokenNameEQUAL	
gradientAverage	TokenNameIdentifier	 gradient Average
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
frac	TokenNameIdentifier	 frac
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
interior	TokenNameIdentifier	 interior
=	TokenNameEQUAL	
getAntiAlias	TokenNameIdentifier	 get Anti Alias
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bottom_weight	TokenNameIdentifier	 bottom weight
=	TokenNameEQUAL	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
/	TokenNameDIVIDE	
sz	TokenNameIdentifier	 sz
;	TokenNameSEMICOLON	
frac	TokenNameIdentifier	 frac
=	TokenNameEQUAL	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
interior	TokenNameIdentifier	 interior
=	TokenNameEQUAL	
getAntiAlias	TokenNameIdentifier	 get Anti Alias
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
getAntiAlias	TokenNameIdentifier	 get Anti Alias
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
sz	TokenNameIdentifier	 sz
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
frac	TokenNameIdentifier	 frac
/	TokenNameDIVIDE	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
pA	TokenNameIdentifier	 p A
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
interior	TokenNameIdentifier	 interior
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
pR	TokenNameIdentifier	 p R
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
interior	TokenNameIdentifier	 interior
>>	TokenNameRIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
pG	TokenNameIdentifier	 p G
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
interior	TokenNameIdentifier	 interior
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
pB	TokenNameIdentifier	 p B
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
interior	TokenNameIdentifier	 interior
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bottom_weight	TokenNameIdentifier	 bottom weight
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
bPix	TokenNameIdentifier	 b Pix
=	TokenNameEQUAL	
gradientUnderflow	TokenNameIdentifier	 gradient Underflow
;	TokenNameSEMICOLON	
// System.out.println("ave: " + gradientAverage); 	TokenNameCOMMENT_LINE	System.out.println("ave: " + gradientAverage); 
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
bottom_weight	TokenNameIdentifier	 bottom weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pA	TokenNameIdentifier	 p A
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bPix	TokenNameIdentifier	 b Pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pR	TokenNameIdentifier	 p R
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bPix	TokenNameIdentifier	 b Pix
>>	TokenNameRIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pG	TokenNameIdentifier	 p G
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bPix	TokenNameIdentifier	 b Pix
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pB	TokenNameIdentifier	 p B
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bPix	TokenNameIdentifier	 b Pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
top_weight	TokenNameIdentifier	 top weight
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
tPix	TokenNameIdentifier	 t Pix
=	TokenNameEQUAL	
gradientOverflow	TokenNameIdentifier	 gradient Overflow
;	TokenNameSEMICOLON	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
top_weight	TokenNameIdentifier	 top weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pA	TokenNameIdentifier	 p A
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tPix	TokenNameIdentifier	 t Pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pR	TokenNameIdentifier	 p R
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tPix	TokenNameIdentifier	 t Pix
>>	TokenNameRIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pG	TokenNameIdentifier	 p G
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tPix	TokenNameIdentifier	 t Pix
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pB	TokenNameIdentifier	 p B
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tPix	TokenNameIdentifier	 t Pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pA	TokenNameIdentifier	 p A
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pR	TokenNameIdentifier	 p R
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pG	TokenNameIdentifier	 p G
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pB	TokenNameIdentifier	 p B
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// See how many times we are going to "wrap around" the gradient, 	TokenNameCOMMENT_LINE	See how many times we are going to "wrap around" the gradient, 
// array. 	TokenNameCOMMENT_LINE	array. 
int	TokenNameint	
intSz	TokenNameIdentifier	 int Sz
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
sz	TokenNameIdentifier	 sz
;	TokenNameSEMICOLON	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
1.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
intSz	TokenNameIdentifier	 int Sz
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We need to make sure that sz is < 1.0 otherwise 	TokenNameCOMMENT_LINE	We need to make sure that sz is < 1.0 otherwise 
// p1 and p2 my pass each other which will cause no end of 	TokenNameCOMMENT_LINE	p1 and p2 my pass each other which will cause no end of 
// trouble. 	TokenNameCOMMENT_LINE	trouble. 
sz	TokenNameIdentifier	 sz
-=	TokenNameMINUS_EQUAL	
intSz	TokenNameIdentifier	 int Sz
;	TokenNameSEMICOLON	
weight	TokenNameIdentifier	 weight
=	TokenNameEQUAL	
sz	TokenNameIdentifier	 sz
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
intSz	TokenNameIdentifier	 int Sz
+	TokenNamePLUS	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
<	TokenNameLESS	
0.1	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
// The part of the color from the location will be swamped 	TokenNameCOMMENT_LINE	The part of the color from the location will be swamped 
// by the averaged part of the gradient so just use the 	TokenNameCOMMENT_LINE	by the averaged part of the gradient so just use the 
// average color for the gradient. 	TokenNameCOMMENT_LINE	average color for the gradient. 
return	TokenNamereturn	
gradientAverage	TokenNameIdentifier	 gradient Average
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// So close to full gradient just use the average value... 	TokenNameCOMMENT_LINE	So close to full gradient just use the average value... 
if	TokenNameif	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
>	TokenNameGREATER	
0.99	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
gradientAverage	TokenNameIdentifier	 gradient Average
;	TokenNameSEMICOLON	
// Go up and down from position by 1/2 sz. 	TokenNameCOMMENT_LINE	Go up and down from position by 1/2 sz. 
float	TokenNamefloat	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
-	TokenNameMINUS	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
position	TokenNameIdentifier	 position
+	TokenNamePLUS	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"P1: "	TokenNameStringLiteral	P1: 
+	TokenNamePLUS	
p1	TokenNameIdentifier	 p1
+	TokenNamePLUS	
" P2: "	TokenNameStringLiteral	 P2: 
+	TokenNamePLUS	
p2	TokenNameIdentifier	 p2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// These indicate the direction to go from p1 and p2 when 	TokenNameCOMMENT_LINE	These indicate the direction to go from p1 and p2 when 
// averaging... 	TokenNameCOMMENT_LINE	averaging... 
boolean	TokenNameboolean	
p1_up	TokenNameIdentifier	 p1 up
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
p2_up	TokenNameIdentifier	 p2 up
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cycleMethod	TokenNameIdentifier	 cycle Method
==	TokenNameEQUAL_EQUAL	
MultipleGradientPaint	TokenNameIdentifier	 Multiple Gradient Paint
.	TokenNameDOT	
REPEAT	TokenNameIdentifier	 REPEAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"REPEAT"	TokenNameStringLiteral	REPEAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get positions between -1 and 1 	TokenNameCOMMENT_LINE	Get positions between -1 and 1 
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
p1	TokenNameIdentifier	 p1
-	TokenNameMINUS	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
// force to be in rage 0-1. 	TokenNameCOMMENT_LINE	force to be in rage 0-1. 
if	TokenNameif	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
p1	TokenNameIdentifier	 p1
+=	TokenNamePLUS_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
p2	TokenNameIdentifier	 p2
+=	TokenNamePLUS_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
//cycleMethod == MultipleGradientPaint.REFLECT 	TokenNameCOMMENT_LINE	cycleMethod == MultipleGradientPaint.REFLECT 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"REFLECT"	TokenNameStringLiteral	REFLECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//take absolute values 	TokenNameCOMMENT_LINE	take absolute values 
// Note when we reflect we change sense of p1/2_up. 	TokenNameCOMMENT_LINE	Note when we reflect we change sense of p1/2_up. 
if	TokenNameif	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
p1_up	TokenNameIdentifier	 p1 up
=	TokenNameEQUAL	
!	TokenNameNOT	
p1_up	TokenNameIdentifier	 p1 up
;	TokenNameSEMICOLON	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
-	TokenNameMINUS	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
p2_up	TokenNameIdentifier	 p2 up
=	TokenNameEQUAL	
!	TokenNameNOT	
p2_up	TokenNameIdentifier	 p2 up
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
p1_up	TokenNameIdentifier	 p1 up
=	TokenNameEQUAL	
!	TokenNameNOT	
p1_up	TokenNameIdentifier	 p1 up
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
;	TokenNameSEMICOLON	
part1	TokenNameIdentifier	 part1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
// take the integer part 	TokenNameCOMMENT_LINE	take the integer part 
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
p1	TokenNameIdentifier	 p1
-	TokenNameMINUS	
part1	TokenNameIdentifier	 part1
;	TokenNameSEMICOLON	
// get the fractional part 	TokenNameCOMMENT_LINE	get the fractional part 
part2	TokenNameIdentifier	 part2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
// take the integer part 	TokenNameCOMMENT_LINE	take the integer part 
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
part2	TokenNameIdentifier	 part2
;	TokenNameSEMICOLON	
// get the fractional part 	TokenNameCOMMENT_LINE	get the fractional part 
// if integer part is odd we want the reflected color instead. 	TokenNameCOMMENT_LINE	if integer part is odd we want the reflected color instead. 
// Note when we reflect we change sense of p1/2_up. 	TokenNameCOMMENT_LINE	Note when we reflect we change sense of p1/2_up. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
part1	TokenNameIdentifier	 part1
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
p1_up	TokenNameIdentifier	 p1 up
=	TokenNameEQUAL	
!	TokenNameNOT	
p1_up	TokenNameIdentifier	 p1 up
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
part2	TokenNameIdentifier	 part2
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
p2_up	TokenNameIdentifier	 p2 up
=	TokenNameEQUAL	
!	TokenNameNOT	
p2_up	TokenNameIdentifier	 p2 up
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check if in the end they just got switched around. 	TokenNameCOMMENT_LINE	Check if in the end they just got switched around. 
// this commonly happens if they both end up negative. 	TokenNameCOMMENT_LINE	this commonly happens if they both end up negative. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
>	TokenNameGREATER	
p2	TokenNameIdentifier	 p2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
p1_up	TokenNameIdentifier	 p1 up
&&	TokenNameAND_AND	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
p1	TokenNameIdentifier	 p1
=	TokenNameEQUAL	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
p2	TokenNameIdentifier	 p2
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
p1_up	TokenNameIdentifier	 p1 up
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
p2_up	TokenNameIdentifier	 p2 up
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
getAntiAlias	TokenNameIdentifier	 get Anti Alias
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
p1_up	TokenNameIdentifier	 p1 up
,	TokenNameCOMMA	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
p2_up	TokenNameIdentifier	 p2 up
,	TokenNameCOMMA	
sz	TokenNameIdentifier	 sz
,	TokenNameCOMMA	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
getAntiAlias	TokenNameIdentifier	 get Anti Alias
(	TokenNameLPAREN	
float	TokenNamefloat	
p1	TokenNameIdentifier	 p1
,	TokenNameCOMMA	
boolean	TokenNameboolean	
p1_up	TokenNameIdentifier	 p1 up
,	TokenNameCOMMA	
float	TokenNamefloat	
p2	TokenNameIdentifier	 p2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
p2_up	TokenNameIdentifier	 p2 up
,	TokenNameCOMMA	
float	TokenNamefloat	
sz	TokenNameIdentifier	 sz
,	TokenNameCOMMA	
float	TokenNamefloat	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Until the last set of ops these are 28.4 fixed point values. 	TokenNameCOMMENT_LINE	Until the last set of ops these are 28.4 fixed point values. 
int	TokenNameint	
ach	TokenNameIdentifier	 ach
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
rch	TokenNameIdentifier	 rch
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
gch	TokenNameIdentifier	 gch
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bch	TokenNameIdentifier	 bch
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSimpleLookup	TokenNameIdentifier	 is Simple Lookup
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p1	TokenNameIdentifier	 p1
*=	TokenNameMULTIPLY_EQUAL	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
;	TokenNameSEMICOLON	
p2	TokenNameIdentifier	 p2
*=	TokenNameMULTIPLY_EQUAL	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
;	TokenNameSEMICOLON	
int	TokenNameint	
idx1	TokenNameIdentifier	 idx1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p1	TokenNameIdentifier	 p1
;	TokenNameSEMICOLON	
int	TokenNameint	
idx2	TokenNameIdentifier	 idx2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
p2	TokenNameIdentifier	 p2
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
pix	TokenNameIdentifier	 pix
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p1_up	TokenNameIdentifier	 p1 up
&&	TokenNameAND_AND	
!	TokenNameNOT	
p2_up	TokenNameIdentifier	 p2 up
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
<=	TokenNameLESS_EQUAL	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
==	TokenNameEQUAL_EQUAL	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
return	TokenNamereturn	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
idx1	TokenNameIdentifier	 idx1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Sum between idx1 and idx2. 	TokenNameCOMMENT_LINE	Sum between idx1 and idx2. 
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
idx2	TokenNameIdentifier	 idx2
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Do the bulk of the work, all the whole gradient entries 	TokenNameCOMMENT_LINE	Do the bulk of the work, all the whole gradient entries 
// for idx1 and idx2. 	TokenNameCOMMENT_LINE	for idx1 and idx2. 
int	TokenNameint	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
int	TokenNameint	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p1_up	TokenNameIdentifier	 p1 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
idx1	TokenNameIdentifier	 idx1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
idx2	TokenNameIdentifier	 idx2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
idx2	TokenNameIdentifier	 idx2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
norm	TokenNameIdentifier	 norm
,	TokenNameCOMMA	
isz	TokenNameIdentifier	 isz
;	TokenNameSEMICOLON	
// Normalize the summation so far... 	TokenNameCOMMENT_LINE	Normalize the summation so far... 
isz	TokenNameIdentifier	 isz
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
*	TokenNameMULTIPLY	
fastGradientArraySize	TokenNameIdentifier	 fast Gradient Array Size
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ach	TokenNameIdentifier	 ach
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rch	TokenNameIdentifier	 rch
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
gch	TokenNameIdentifier	 gch
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bch	TokenNameIdentifier	 bch
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Clean up with the partial buckets at each end. 	TokenNameCOMMENT_LINE	Clean up with the partial buckets at each end. 
if	TokenNameif	
(	TokenNameLPAREN	
p1_up	TokenNameIdentifier	 p1 up
)	TokenNameRPAREN	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
-	TokenNameMINUS	
idx1	TokenNameIdentifier	 idx1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
-	TokenNameMINUS	
idx1	TokenNameIdentifier	 idx1
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
idx1	TokenNameIdentifier	 idx1
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
isz	TokenNameIdentifier	 isz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradient	TokenNameIdentifier	 gradient
[	TokenNameLBRACKET	
idx2	TokenNameIdentifier	 idx2
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Round and drop the 4bits frac. 	TokenNameCOMMENT_LINE	Round and drop the 4bits frac. 
ach	TokenNameIdentifier	 ach
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ach	TokenNameIdentifier	 ach
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rch	TokenNameIdentifier	 rch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
gch	TokenNameIdentifier	 gch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bch	TokenNameIdentifier	 bch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
idx1	TokenNameIdentifier	 idx1
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
idx2	TokenNameIdentifier	 idx2
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Find which gradient interval our points fall into. 	TokenNameCOMMENT_LINE	Find which gradient interval our points fall into. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
p1	TokenNameIdentifier	 p1
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
i1	TokenNameIdentifier	 i1
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//this is the array we want 	TokenNameCOMMENT_LINE	this is the array we want 
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
p1	TokenNameIdentifier	 p1
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
f1	TokenNameIdentifier	 f1
/	TokenNameDIVIDE	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//this is the interval we want. 	TokenNameCOMMENT_LINE	this is the interval we want. 
idx1	TokenNameIdentifier	 idx1
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
f1	TokenNameIdentifier	 f1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i2	TokenNameIdentifier	 i2
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
p2	TokenNameIdentifier	 p2
<	TokenNameLESS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
i2	TokenNameIdentifier	 i2
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//this is the array we want 	TokenNameCOMMENT_LINE	this is the array we want 
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
p2	TokenNameIdentifier	 p2
-	TokenNameMINUS	
fractions	TokenNameIdentifier	 fractions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
f2	TokenNameIdentifier	 f2
/	TokenNameDIVIDE	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//this is the interval we want. 	TokenNameCOMMENT_LINE	this is the interval we want. 
idx2	TokenNameIdentifier	 idx2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
f2	TokenNameIdentifier	 f2
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i1	TokenNameIdentifier	 i1
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i1	TokenNameIdentifier	 i1
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
f1	TokenNameIdentifier	 f1
=	TokenNameEQUAL	
idx1	TokenNameIdentifier	 idx1
=	TokenNameEQUAL	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i2	TokenNameIdentifier	 i2
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
f2	TokenNameIdentifier	 f2
=	TokenNameEQUAL	
idx2	TokenNameIdentifier	 idx2
=	TokenNameEQUAL	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"I1: "	TokenNameStringLiteral	I1: 
+	TokenNamePLUS	
i1	TokenNameIdentifier	 i1
+	TokenNamePLUS	
" Idx1: "	TokenNameStringLiteral	 Idx1: 
+	TokenNamePLUS	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
" I2: "	TokenNameStringLiteral	 I2: 
+	TokenNamePLUS	
i2	TokenNameIdentifier	 i2
+	TokenNamePLUS	
" Idx2: "	TokenNameStringLiteral	 Idx2: 
+	TokenNamePLUS	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Simple case within one gradient array (so the average 	TokenNameCOMMENT_LINE	Simple case within one gradient array (so the average 
// of the two idx gives us the true average of colors). 	TokenNameCOMMENT_LINE	of the two idx gives us the true average of colors). 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i1	TokenNameIdentifier	 i1
==	TokenNameEQUAL_EQUAL	
i2	TokenNameIdentifier	 i2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
<=	TokenNameLESS_EQUAL	
idx2	TokenNameIdentifier	 idx2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
p1_up	TokenNameIdentifier	 p1 up
&&	TokenNameAND_AND	
!	TokenNameNOT	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
return	TokenNamereturn	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
idx2	TokenNameIdentifier	 idx2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// i1 != i2 	TokenNameCOMMENT_LINE	i1 != i2 
int	TokenNameint	
pix	TokenNameIdentifier	 pix
,	TokenNameCOMMA	
norm	TokenNameIdentifier	 norm
;	TokenNameSEMICOLON	
int	TokenNameint	
base	TokenNameIdentifier	 base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i1	TokenNameIdentifier	 i1
<	TokenNameLESS	
i2	TokenNameIdentifier	 i2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
p1_up	TokenNameIdentifier	 p1 up
&&	TokenNameAND_AND	
!	TokenNameNOT	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
-	TokenNameMINUS	
f1	TokenNameIdentifier	 f1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
i1	TokenNameIdentifier	 i1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
i2	TokenNameIdentifier	 i2
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx2	TokenNameIdentifier	 idx2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p1_up	TokenNameIdentifier	 p1 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
-	TokenNameMINUS	
f1	TokenNameIdentifier	 f1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
f1	TokenNameIdentifier	 f1
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx1	TokenNameIdentifier	 idx1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
-	TokenNameMINUS	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx2	TokenNameIdentifier	 idx2
+	TokenNamePLUS	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
f2	TokenNameIdentifier	 f2
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
GRADIENT_SIZE_INDEX	TokenNameIdentifier	 GRADIENT  SIZE  INDEX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
idx2	TokenNameIdentifier	 idx2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// p1_up and p2_up are just used to set the loop-boundarys, 	TokenNameCOMMENT_LINE	p1_up and p2_up are just used to set the loop-boundarys, 
// then we loop from iStart to iEnd 	TokenNameCOMMENT_LINE	then we loop from iStart to iEnd 
int	TokenNameint	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
int	TokenNameint	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p1_up	TokenNameIdentifier	 p1 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
i1	TokenNameIdentifier	 i1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
i1	TokenNameIdentifier	 i1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p2_up	TokenNameIdentifier	 p2 up
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
i2	TokenNameIdentifier	 i2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
gradientsLength	TokenNameIdentifier	 gradients Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
iStart	TokenNameIdentifier	 i Start
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
iEnd	TokenNameIdentifier	 i End
=	TokenNameEQUAL	
i2	TokenNameIdentifier	 i2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iStart	TokenNameIdentifier	 i Start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
iEnd	TokenNameIdentifier	 i End
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
norm	TokenNameIdentifier	 norm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
*	TokenNameMULTIPLY	
normalizedIntervals	TokenNameIdentifier	 normalized Intervals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pix	TokenNameIdentifier	 pix
=	TokenNameEQUAL	
gradients	TokenNameIdentifier	 gradients
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
GRADIENT_SIZE	TokenNameIdentifier	 GRADIENT  SIZE
>>	TokenNameRIGHT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pix	TokenNameIdentifier	 pix
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ach	TokenNameIdentifier	 ach
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ach	TokenNameIdentifier	 ach
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rch	TokenNameIdentifier	 rch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
gch	TokenNameIdentifier	 gch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bch	TokenNameIdentifier	 bch
+	TokenNamePLUS	
0x08	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Pix: ["	TokenNameStringLiteral	Pix: [
+	TokenNamePLUS	
ach	TokenNameIdentifier	 ach
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
rch	TokenNameIdentifier	 rch
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
gch	TokenNameIdentifier	 gch
+	TokenNamePLUS	
", "	TokenNameStringLiteral	, 
+	TokenNamePLUS	
bch	TokenNameIdentifier	 bch
+	TokenNamePLUS	
']'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// System.out.println("ave: " + gradientAverage); 	TokenNameCOMMENT_LINE	System.out.println("ave: " + gradientAverage); 
int	TokenNameint	
aveW	TokenNameIdentifier	 ave W
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
aveA	TokenNameIdentifier	 ave A
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
aveW	TokenNameIdentifier	 ave W
;	TokenNameSEMICOLON	
int	TokenNameint	
aveR	TokenNameIdentifier	 ave R
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
aveW	TokenNameIdentifier	 ave W
;	TokenNameSEMICOLON	
int	TokenNameint	
aveG	TokenNameIdentifier	 ave G
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
aveW	TokenNameIdentifier	 ave W
;	TokenNameSEMICOLON	
int	TokenNameint	
aveB	TokenNameIdentifier	 ave B
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gradientAverage	TokenNameIdentifier	 gradient Average
)	TokenNameRPAREN	
&	TokenNameAND	
0xFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
aveW	TokenNameIdentifier	 ave W
;	TokenNameSEMICOLON	
int	TokenNameint	
iw	TokenNameIdentifier	 iw
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ach	TokenNameIdentifier	 ach
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ach	TokenNameIdentifier	 ach
*	TokenNameMULTIPLY	
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
+	TokenNamePLUS	
aveA	TokenNameIdentifier	 ave A
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rch	TokenNameIdentifier	 rch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rch	TokenNameIdentifier	 rch
*	TokenNameMULTIPLY	
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
+	TokenNamePLUS	
aveR	TokenNameIdentifier	 ave R
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
gch	TokenNameIdentifier	 gch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
gch	TokenNameIdentifier	 gch
*	TokenNameMULTIPLY	
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
+	TokenNamePLUS	
aveG	TokenNameIdentifier	 ave G
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bch	TokenNameIdentifier	 bch
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bch	TokenNameIdentifier	 bch
*	TokenNameMULTIPLY	
iw	TokenNameIdentifier	 iw
)	TokenNameRPAREN	
+	TokenNamePLUS	
aveB	TokenNameIdentifier	 ave B
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ach	TokenNameIdentifier	 ach
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
rch	TokenNameIdentifier	 rch
<<	TokenNameLEFT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
gch	TokenNameIdentifier	 gch
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
bch	TokenNameIdentifier	 bch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Helper function to convert a color component in sRGB space to linear * RGB space. Used to build a static lookup table. */	TokenNameCOMMENT_JAVADOC	 Helper function to convert a color component in sRGB space to linear RGB space. Used to build a static lookup table. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
convertSRGBtoLinearRGB	TokenNameIdentifier	 convert SRG Bto Linear RGB
(	TokenNameLPAREN	
int	TokenNameint	
color	TokenNameIdentifier	 color
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use of float and double arithmetic gives exactly same results 	TokenNameCOMMENT_LINE	use of float and double arithmetic gives exactly same results 
float	TokenNamefloat	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
float	TokenNamefloat	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
color	TokenNameIdentifier	 color
/	TokenNameDIVIDE	
255.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
<=	TokenNameLESS_EQUAL	
0.04045f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
/	TokenNameDIVIDE	
12.92f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
pow	TokenNameIdentifier	 pow
(	TokenNameLPAREN	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
+	TokenNamePLUS	
0.055	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1.055	TokenNameDoubleLiteral	
,	TokenNameCOMMA	
2.4	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
round	TokenNameIdentifier	 round
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
*	TokenNameMULTIPLY	
255.0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
o	TokenNameIdentifier	 o
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Helper function to convert a color component in linear RGB space to * SRGB space. Used to build a static lookup table. */	TokenNameCOMMENT_JAVADOC	 Helper function to convert a color component in linear RGB space to SRGB space. Used to build a static lookup table. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
convertLinearRGBtoSRGB	TokenNameIdentifier	 convert Linear RG Bto SRGB
(	TokenNameLPAREN	
int	TokenNameint	
color	TokenNameIdentifier	 color
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use of float and double arithmetic gives exactly same results 	TokenNameCOMMENT_LINE	use of float and double arithmetic gives exactly same results 
float	TokenNamefloat	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
float	TokenNamefloat	
input	TokenNameIdentifier	 input
=	TokenNameEQUAL	
color	TokenNameIdentifier	 color
/	TokenNameDIVIDE	
255.0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
<=	TokenNameLESS_EQUAL	
0.0031308f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
*	TokenNameMULTIPLY	
12.92f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
(	TokenNameLPAREN	
1.055f	TokenNameFloatingPointLiteral	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
pow	TokenNameIdentifier	 pow
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
(	TokenNameLPAREN	
1.0	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
2.4	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
0.055f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
round	TokenNameIdentifier	 round
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
*	TokenNameMULTIPLY	
255.0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
o	TokenNameIdentifier	 o
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Superclass getRaster... */	TokenNameCOMMENT_JAVADOC	 Superclass getRaster... 
public	TokenNamepublic	
final	TokenNamefinal	
Raster	TokenNameIdentifier	 Raster
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
int	TokenNameint	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
int	TokenNameint	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
int	TokenNameint	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
int	TokenNameint	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
h	TokenNameIdentifier	 h
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// If working raster is big enough, reuse it. Otherwise, 	TokenNameCOMMENT_LINE	If working raster is big enough, reuse it. Otherwise, 
// build a large enough new one. 	TokenNameCOMMENT_LINE	build a large enough new one. 
// 	TokenNameCOMMENT_LINE	 
WritableRaster	TokenNameIdentifier	 Writable Raster
raster	TokenNameIdentifier	 raster
=	TokenNameEQUAL	
saved	TokenNameIdentifier	 saved
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
raster	TokenNameIdentifier	 raster
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
w	TokenNameIdentifier	 w
||	TokenNameOR_OR	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
{	TokenNameLBRACE	
raster	TokenNameIdentifier	 raster
=	TokenNameEQUAL	
getCachedRaster	TokenNameIdentifier	 get Cached Raster
(	TokenNameLPAREN	
dataModel	TokenNameIdentifier	 data Model
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
saved	TokenNameIdentifier	 saved
=	TokenNameEQUAL	
raster	TokenNameIdentifier	 raster
;	TokenNameSEMICOLON	
// NOTE:We would like to use 'x' & 'y' here instead of 	TokenNameCOMMENT_LINE	NOTE:We would like to use 'x' & 'y' here instead of 
// '0', '0' but this will fail on MacOSX. Since it 	TokenNameCOMMENT_LINE	'0', '0' but this will fail on MacOSX. Since it 
// doesn't have an effect on other JVMs. 	TokenNameCOMMENT_LINE	doesn't have an effect on other JVMs. 
raster	TokenNameIdentifier	 raster
=	TokenNameEQUAL	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
createWritableChild	TokenNameIdentifier	 create Writable Child
(	TokenNameLPAREN	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
h	TokenNameIdentifier	 h
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Access raster internal int array. Because we use a DirectColorModel, 	TokenNameCOMMENT_LINE	Access raster internal int array. Because we use a DirectColorModel, 
// we know the DataBuffer is of type DataBufferInt and the SampleModel 	TokenNameCOMMENT_LINE	we know the DataBuffer is of type DataBufferInt and the SampleModel 
// is SinglePixelPackedSampleModel. 	TokenNameCOMMENT_LINE	is SinglePixelPackedSampleModel. 
// Adjust for initial offset in DataBuffer and also for the scanline 	TokenNameCOMMENT_LINE	Adjust for initial offset in DataBuffer and also for the scanline 
// stride. 	TokenNameCOMMENT_LINE	stride. 
// 	TokenNameCOMMENT_LINE	 
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
rasterDB	TokenNameIdentifier	 raster DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pixels	TokenNameIdentifier	 pixels
=	TokenNameEQUAL	
rasterDB	TokenNameIdentifier	 raster DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
off	TokenNameIdentifier	 off
=	TokenNameEQUAL	
rasterDB	TokenNameIdentifier	 raster DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
scanlineStride	TokenNameIdentifier	 scanline Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
raster	TokenNameIdentifier	 raster
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
adjust	TokenNameIdentifier	 adjust
=	TokenNameEQUAL	
scanlineStride	TokenNameIdentifier	 scanline Stride
-	TokenNameMINUS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
fillRaster	TokenNameIdentifier	 fill Raster
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
,	TokenNameCOMMA	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
adjust	TokenNameIdentifier	 adjust
,	TokenNameCOMMA	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//delegate to subclass. 	TokenNameCOMMENT_LINE	delegate to subclass. 
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
coerceData	TokenNameIdentifier	 coerce Data
(	TokenNameLPAREN	
raster	TokenNameIdentifier	 raster
,	TokenNameCOMMA	
dataModel	TokenNameIdentifier	 data Model
,	TokenNameCOMMA	
model	TokenNameIdentifier	 model
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
raster	TokenNameIdentifier	 raster
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Subclasses should implement this. */	TokenNameCOMMENT_JAVADOC	 Subclasses should implement this. 
protected	TokenNameprotected	
abstract	TokenNameabstract	
void	TokenNamevoid	
fillRaster	TokenNameIdentifier	 fill Raster
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pixels	TokenNameIdentifier	 pixels
,	TokenNameCOMMA	
int	TokenNameint	
off	TokenNameIdentifier	 off
,	TokenNameCOMMA	
int	TokenNameint	
adjust	TokenNameIdentifier	 adjust
,	TokenNameCOMMA	
int	TokenNameint	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
int	TokenNameint	
y	TokenNameIdentifier	 y
,	TokenNameCOMMA	
int	TokenNameint	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
int	TokenNameint	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Took this cacheRaster code from GradientPaint. It appears to recycle * rasters for use by any other instance, as long as they are sufficiently * large. */	TokenNameCOMMENT_JAVADOC	 Took this cacheRaster code from GradientPaint. It appears to recycle rasters for use by any other instance, as long as they are sufficiently large. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
synchronized	TokenNamesynchronized	
WritableRaster	TokenNameIdentifier	 Writable Raster
getCachedRaster	TokenNameIdentifier	 get Cached Raster
(	TokenNameLPAREN	
ColorModel	TokenNameIdentifier	 Color Model
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
int	TokenNameint	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
int	TokenNameint	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cm	TokenNameIdentifier	 cm
==	TokenNameEQUAL_EQUAL	
cachedModel	TokenNameIdentifier	 cached Model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
WritableRaster	TokenNameIdentifier	 Writable Raster
ras	TokenNameIdentifier	 ras
=	TokenNameEQUAL	
(	TokenNameLPAREN	
WritableRaster	TokenNameIdentifier	 Writable Raster
)	TokenNameRPAREN	
cached	TokenNameIdentifier	 cached
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ras	TokenNameIdentifier	 ras
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
w	TokenNameIdentifier	 w
&&	TokenNameAND_AND	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cached	TokenNameIdentifier	 cached
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ras	TokenNameIdentifier	 ras
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Don't create rediculously small rasters... 	TokenNameCOMMENT_LINE	Don't create rediculously small rasters... 
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
h	TokenNameIdentifier	 h
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
h	TokenNameIdentifier	 h
=	TokenNameEQUAL	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cm	TokenNameIdentifier	 cm
.	TokenNameDOT	
createCompatibleWritableRaster	TokenNameIdentifier	 create Compatible Writable Raster
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
,	TokenNameCOMMA	
h	TokenNameIdentifier	 h
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Took this cacheRaster code from GradientPaint. It appears to recycle * rasters for use by any other instance, as long as they are sufficiently * large. */	TokenNameCOMMENT_JAVADOC	 Took this cacheRaster code from GradientPaint. It appears to recycle rasters for use by any other instance, as long as they are sufficiently large. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
putCachedRaster	TokenNameIdentifier	 put Cached Raster
(	TokenNameLPAREN	
ColorModel	TokenNameIdentifier	 Color Model
cm	TokenNameIdentifier	 cm
,	TokenNameCOMMA	
WritableRaster	TokenNameIdentifier	 Writable Raster
ras	TokenNameIdentifier	 ras
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cached	TokenNameIdentifier	 cached
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
WritableRaster	TokenNameIdentifier	 Writable Raster
cras	TokenNameIdentifier	 cras
=	TokenNameEQUAL	
(	TokenNameLPAREN	
WritableRaster	TokenNameIdentifier	 Writable Raster
)	TokenNameRPAREN	
cached	TokenNameIdentifier	 cached
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cras	TokenNameIdentifier	 cras
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
cw	TokenNameIdentifier	 cw
=	TokenNameEQUAL	
cras	TokenNameIdentifier	 cras
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
cras	TokenNameIdentifier	 cras
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
iw	TokenNameIdentifier	 iw
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
ih	TokenNameIdentifier	 ih
=	TokenNameEQUAL	
ras	TokenNameIdentifier	 ras
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cw	TokenNameIdentifier	 cw
>=	TokenNameGREATER_EQUAL	
iw	TokenNameIdentifier	 iw
&&	TokenNameAND_AND	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
ih	TokenNameIdentifier	 ih
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cw	TokenNameIdentifier	 cw
*	TokenNameMULTIPLY	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
iw	TokenNameIdentifier	 iw
*	TokenNameMULTIPLY	
ih	TokenNameIdentifier	 ih
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
cachedModel	TokenNameIdentifier	 cached Model
=	TokenNameEQUAL	
cm	TokenNameIdentifier	 cm
;	TokenNameSEMICOLON	
cached	TokenNameIdentifier	 cached
=	TokenNameEQUAL	
new	TokenNamenew	
WeakReference	TokenNameIdentifier	 Weak Reference
(	TokenNameLPAREN	
ras	TokenNameIdentifier	 ras
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Release the resources allocated for the operation. */	TokenNameCOMMENT_JAVADOC	 Release the resources allocated for the operation. 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
dispose	TokenNameIdentifier	 dispose
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
saved	TokenNameIdentifier	 saved
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
putCachedRaster	TokenNameIdentifier	 put Cached Raster
(	TokenNameLPAREN	
model	TokenNameIdentifier	 model
,	TokenNameCOMMA	
saved	TokenNameIdentifier	 saved
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
saved	TokenNameIdentifier	 saved
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Return the ColorModel of the output. */	TokenNameCOMMENT_JAVADOC	 Return the ColorModel of the output. 
public	TokenNamepublic	
final	TokenNamefinal	
ColorModel	TokenNameIdentifier	 Color Model
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
model	TokenNameIdentifier	 model
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
