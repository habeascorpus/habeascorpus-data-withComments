/* Generated By:JavaCC: Do not edit this line. QueryParser.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. QueryParser.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
Collator	TokenNameIdentifier	 Collator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
DateFormat	TokenNameIdentifier	 Date Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Calendar	TokenNameIdentifier	 Calendar
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Date	TokenNameIdentifier	 Date
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
CachingTokenFilter	TokenNameIdentifier	 Caching Token Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
DateField	TokenNameIdentifier	 Date Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
DateTools	TokenNameIdentifier	 Date Tools
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MatchAllDocsQuery	TokenNameIdentifier	 Match All Docs Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PhraseQuery	TokenNameIdentifier	 Phrase Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PrefixQuery	TokenNameIdentifier	 Prefix Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
VirtualMethod	TokenNameIdentifier	 Virtual Method
;	TokenNameSEMICOLON	
/** * This class is generated by JavaCC. The most important method is * {@link #parse(String)}. * * The syntax for query strings is as follows: * A Query is a series of clauses. * A clause may be prefixed by: * <ul> * <li> a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating * that the clause is required or prohibited respectively; or * <li> a term followed by a colon, indicating the field to be searched. * This enables one to construct queries which search multiple fields. * </ul> * * A clause may be either: * <ul> * <li> a term, indicating all the documents that contain this term; or * <li> a nested query, enclosed in parentheses. Note that this may be used * with a <code>+</code>/<code>-</code> prefix to require any of a set of * terms. * </ul> * * Thus, in BNF, the query grammar is: * <pre> * Query ::= ( Clause )* * Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" ) * </pre> * * <p> * Examples of appropriately formatted queries can be found in the <a * href="../../../../../../queryparsersyntax.html">query syntax * documentation</a>. * </p> * * <p> * In {@link TermRangeQuery}s, QueryParser tries to detect date values, e.g. * <tt>date:[6/1/2005 TO 6/4/2005]</tt> produces a range query that searches * for "date" fields between 2005-06-01 and 2005-06-04. Note that the format * of the accepted input depends on {@link #setLocale(Locale) the locale}. * By default a date is converted into a search term using the deprecated * {@link DateField} for compatibility reasons. * To use the new {@link DateTools} to convert dates, a * {@link org.apache.lucene.document.DateTools.Resolution} has to be set. * </p> * <p> * The date resolution that shall be used for RangeQueries can be set * using {@link #setDateResolution(DateTools.Resolution)} * or {@link #setDateResolution(String, DateTools.Resolution)}. The former * sets the default date resolution for all fields, whereas the latter can * be used to set field specific date resolutions. Field specific date * resolutions take, if set, precedence over the default date resolution. * </p> * <p> * If you use neither {@link DateField} nor {@link DateTools} in your * index, you can create your own * query parser that inherits QueryParser and overwrites * {@link #getRangeQuery(String, String, String, boolean)} to * use a different method for date conversion. * </p> * * <p>Note that QueryParser is <em>not</em> thread-safe.</p> * * <p><b>NOTE</b>: there is a new QueryParser in contrib, which matches * the same syntax as this class, but is more modular, * enabling substantial customization to how a query is created. * * <a name="version"/> * <p><b>NOTE</b>: You must specify the required {@link Version} * compatibility when creating QueryParser: * <ul> * <li> As of 2.9, {@link #setEnablePositionIncrements} is true by * default. * <li> As of 3.1, {@link #setAutoGeneratePhraseQueries} is false by * default. * </ul> */	TokenNameCOMMENT_JAVADOC	 This class is generated by JavaCC. The most important method is {@link #parse(String)}. * The syntax for query strings is as follows: A Query is a series of clauses. A clause may be prefixed by: <ul> <li> a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating that the clause is required or prohibited respectively; or <li> a term followed by a colon, indicating the field to be searched. This enables one to construct queries which search multiple fields. </ul> * A clause may be either: <ul> <li> a term, indicating all the documents that contain this term; or <li> a nested query, enclosed in parentheses. Note that this may be used with a <code>+</code>/<code>-</code> prefix to require any of a set of terms. </ul> * Thus, in BNF, the query grammar is: <pre> Query ::= ( Clause )* Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" ) </pre> * <p> Examples of appropriately formatted queries can be found in the <a href="../../../../../../queryparsersyntax.html">query syntax documentation</a>. </p> * <p> In {@link TermRangeQuery}s, QueryParser tries to detect date values, e.g. <tt>date:[6/1/2005 TO 6/4/2005]</tt> produces a range query that searches for "date" fields between 2005-06-01 and 2005-06-04. Note that the format of the accepted input depends on {@link #setLocale(Locale) the locale}. By default a date is converted into a search term using the deprecated {@link DateField} for compatibility reasons. To use the new {@link DateTools} to convert dates, a {@link org.apache.lucene.document.DateTools.Resolution} has to be set. </p> <p> The date resolution that shall be used for RangeQueries can be set using {@link #setDateResolution(DateTools.Resolution)} or {@link #setDateResolution(String, DateTools.Resolution)}. The former sets the default date resolution for all fields, whereas the latter can be used to set field specific date resolutions. Field specific date resolutions take, if set, precedence over the default date resolution. </p> <p> If you use neither {@link DateField} nor {@link DateTools} in your index, you can create your own query parser that inherits QueryParser and overwrites {@link #getRangeQuery(String, String, String, boolean)} to use a different method for date conversion. </p> * <p>Note that QueryParser is <em>not</em> thread-safe.</p> * <p><b>NOTE</b>: there is a new QueryParser in contrib, which matches the same syntax as this class, but is more modular, enabling substantial customization to how a query is created. * <a name="version"/> <p><b>NOTE</b>: You must specify the required {@link Version} compatibility when creating QueryParser: <ul> <li> As of 2.9, {@link #setEnablePositionIncrements} is true by default. <li> As of 3.1, {@link #setAutoGeneratePhraseQueries} is false by default. </ul> 
public	TokenNamepublic	
class	TokenNameclass	
QueryParser	TokenNameIdentifier	 Query Parser
implements	TokenNameimplements	
QueryParserConstants	TokenNameIdentifier	 Query Parser Constants
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_NONE	TokenNameIdentifier	 CONJ  NONE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MOD_NONE	TokenNameIdentifier	 MOD  NONE
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MOD_REQ	TokenNameIdentifier	 MOD  REQ
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// make it possible to call setDefaultOperator() without accessing 	TokenNameCOMMENT_LINE	make it possible to call setDefaultOperator() without accessing 
// the nested class: 	TokenNameCOMMENT_LINE	the nested class: 
/** Alternative form of QueryParser.Operator.AND */	TokenNameCOMMENT_JAVADOC	 Alternative form of QueryParser.Operator.AND 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Operator	TokenNameIdentifier	 Operator
AND_OPERATOR	TokenNameIdentifier	 AND  OPERATOR
=	TokenNameEQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
AND	TokenNameIdentifier	 AND
;	TokenNameSEMICOLON	
/** Alternative form of QueryParser.Operator.OR */	TokenNameCOMMENT_JAVADOC	 Alternative form of QueryParser.Operator.OR 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Operator	TokenNameIdentifier	 Operator
OR_OPERATOR	TokenNameIdentifier	 OR  OPERATOR
=	TokenNameEQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
OR	TokenNameIdentifier	 OR
;	TokenNameSEMICOLON	
/** The actual operator that parser uses to combine query terms */	TokenNameCOMMENT_JAVADOC	 The actual operator that parser uses to combine query terms 
private	TokenNameprivate	
Operator	TokenNameIdentifier	 Operator
operator	TokenNameIdentifier	 operator
=	TokenNameEQUAL	
OR_OPERATOR	TokenNameIdentifier	 OR  OPERATOR
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
RewriteMethod	TokenNameIdentifier	 Rewrite Method
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
=	TokenNameEQUAL	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
CONSTANT_SCORE_AUTO_REWRITE_DEFAULT	TokenNameIdentifier	 CONSTANT  SCORE  AUTO  REWRITE  DEFAULT
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
;	TokenNameSEMICOLON	
int	TokenNameint	
phraseSlop	TokenNameIdentifier	 phrase Slop
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
=	TokenNameEQUAL	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
.	TokenNameDOT	
defaultMinSimilarity	TokenNameIdentifier	 default Min Similarity
;	TokenNameSEMICOLON	
int	TokenNameint	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
=	TokenNameEQUAL	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
.	TokenNameDOT	
defaultPrefixLength	TokenNameIdentifier	 default Prefix Length
;	TokenNameSEMICOLON	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the default date resolution 	TokenNameCOMMENT_LINE	the default date resolution 
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
dateResolution	TokenNameIdentifier	 date Resolution
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// maps field names to date resolutions 	TokenNameCOMMENT_LINE	maps field names to date resolutions 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
>	TokenNameGREATER	
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// The collator to use when determining range inclusion, 	TokenNameCOMMENT_LINE	The collator to use when determining range inclusion, 
// for use when constructing RangeQuerys. 	TokenNameCOMMENT_LINE	for use when constructing RangeQuerys. 
Collator	TokenNameIdentifier	 Collator
rangeCollator	TokenNameIdentifier	 range Collator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** @deprecated remove when getFieldQuery is removed */	TokenNameCOMMENT_JAVADOC	 @deprecated remove when getFieldQuery is removed 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
VirtualMethod	TokenNameIdentifier	 Virtual Method
<	TokenNameLESS	
QueryParser	TokenNameIdentifier	 Query Parser
>	TokenNameGREATER	
getFieldQueryMethod	TokenNameIdentifier	 get Field Query Method
=	TokenNameEQUAL	
new	TokenNamenew	
VirtualMethod	TokenNameIdentifier	 Virtual Method
<	TokenNameLESS	
QueryParser	TokenNameIdentifier	 Query Parser
>	TokenNameGREATER	
(	TokenNameLPAREN	
QueryParser	TokenNameIdentifier	 Query Parser
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
"getFieldQuery"	TokenNameStringLiteral	getFieldQuery
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** @deprecated remove when getFieldQuery is removed */	TokenNameCOMMENT_JAVADOC	 @deprecated remove when getFieldQuery is removed 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
VirtualMethod	TokenNameIdentifier	 Virtual Method
<	TokenNameLESS	
QueryParser	TokenNameIdentifier	 Query Parser
>	TokenNameGREATER	
getFieldQueryWithQuotedMethod	TokenNameIdentifier	 get Field Query With Quoted Method
=	TokenNameEQUAL	
new	TokenNamenew	
VirtualMethod	TokenNameIdentifier	 Virtual Method
<	TokenNameLESS	
QueryParser	TokenNameIdentifier	 Query Parser
>	TokenNameGREATER	
(	TokenNameLPAREN	
QueryParser	TokenNameIdentifier	 Query Parser
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
"getFieldQuery"	TokenNameStringLiteral	getFieldQuery
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
class	TokenNameclass	
,	TokenNameCOMMA	
boolean	TokenNameboolean	
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** @deprecated remove when getFieldQuery is removed */	TokenNameCOMMENT_JAVADOC	 @deprecated remove when getFieldQuery is removed 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
hasNewAPI	TokenNameIdentifier	 has New API
=	TokenNameEQUAL	
VirtualMethod	TokenNameIdentifier	 Virtual Method
.	TokenNameDOT	
compareImplementationDistance	TokenNameIdentifier	 compare Implementation Distance
(	TokenNameLPAREN	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getFieldQueryWithQuotedMethod	TokenNameIdentifier	 get Field Query With Quoted Method
,	TokenNameCOMMA	
getFieldQueryMethod	TokenNameIdentifier	 get Field Query Method
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// its ok for both to be overridden 	TokenNameCOMMENT_LINE	its ok for both to be overridden 
private	TokenNameprivate	
boolean	TokenNameboolean	
autoGeneratePhraseQueries	TokenNameIdentifier	 auto Generate Phrase Queries
;	TokenNameSEMICOLON	
/** The default operator for parsing queries. * Use {@link QueryParser#setDefaultOperator} to change it. */	TokenNameCOMMENT_JAVADOC	 The default operator for parsing queries. Use {@link QueryParser#setDefaultOperator} to change it. 
static	TokenNamestatic	
public	TokenNamepublic	
enum	TokenNameenum	
Operator	TokenNameIdentifier	 Operator
{	TokenNameLBRACE	
OR	TokenNameIdentifier	 OR
,	TokenNameCOMMA	
AND	TokenNameIdentifier	 AND
}	TokenNameRBRACE	
/** Constructs a query parser. * @param matchVersion Lucene version to match. See <a href="#version">above</a>. * @param f the default field for query terms. * @param a used to find terms in the query text. */	TokenNameCOMMENT_JAVADOC	 Constructs a query parser. @param matchVersion Lucene version to match. See <a href="#version">above</a>. @param f the default field for query terms. @param a used to find terms in the query text. 
public	TokenNamepublic	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
matchVersion	TokenNameIdentifier	 match Version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
new	TokenNamenew	
FastCharStream	TokenNameIdentifier	 Fast Char Stream
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchVersion	TokenNameIdentifier	 match Version
.	TokenNameDOT	
onOrAfter	TokenNameIdentifier	 on Or After
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_29	TokenNameIdentifier	 LUCENE 29
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
matchVersion	TokenNameIdentifier	 match Version
.	TokenNameDOT	
onOrAfter	TokenNameIdentifier	 on Or After
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_31	TokenNameIdentifier	 LUCENE 31
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setAutoGeneratePhraseQueries	TokenNameIdentifier	 set Auto Generate Phrase Queries
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setAutoGeneratePhraseQueries	TokenNameIdentifier	 set Auto Generate Phrase Queries
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Parses a query string, returning a {@link org.apache.lucene.search.Query}. * @param query the query string to be parsed. * @throws ParseException if the parsing fails */	TokenNameCOMMENT_JAVADOC	 Parses a query string, returning a {@link org.apache.lucene.search.Query}. @param query the query string to be parsed. @throws ParseException if the parsing fails 
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
new	TokenNamenew	
FastCharStream	TokenNameIdentifier	 Fast Char Stream
(	TokenNameLPAREN	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// TopLevelQuery is a Query followed by the end-of-input (EOF) 	TokenNameCOMMENT_LINE	TopLevelQuery is a Query followed by the end-of-input (EOF) 
Query	TokenNameIdentifier	 Query
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
TopLevelQuery	TokenNameIdentifier	 Top Level Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
res	TokenNameIdentifier	 res
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
res	TokenNameIdentifier	 res
:	TokenNameCOLON	
newBooleanQuery	TokenNameIdentifier	 new Boolean Query
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParseException	TokenNameIdentifier	 Parse Exception
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// rethrow to include the original query: 	TokenNameCOMMENT_LINE	rethrow to include the original query: 
ParseException	TokenNameIdentifier	 Parse Exception
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Cannot parse '"	TokenNameStringLiteral	Cannot parse '
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
+	TokenNamePLUS	
"': "	TokenNameStringLiteral	': 
+	TokenNamePLUS	
tme	TokenNameIdentifier	 tme
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
initCause	TokenNameIdentifier	 init Cause
(	TokenNameLPAREN	
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ParseException	TokenNameIdentifier	 Parse Exception
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Cannot parse '"	TokenNameStringLiteral	Cannot parse '
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
+	TokenNamePLUS	
"': "	TokenNameStringLiteral	': 
+	TokenNamePLUS	
tme	TokenNameIdentifier	 tme
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
initCause	TokenNameIdentifier	 init Cause
(	TokenNameLPAREN	
tme	TokenNameIdentifier	 tme
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BooleanQuery	TokenNameIdentifier	 Boolean Query
.	TokenNameDOT	
TooManyClauses	TokenNameIdentifier	 Too Many Clauses
tmc	TokenNameIdentifier	 tmc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ParseException	TokenNameIdentifier	 Parse Exception
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Cannot parse '"	TokenNameStringLiteral	Cannot parse '
+	TokenNamePLUS	
query	TokenNameIdentifier	 query
+	TokenNamePLUS	
"': too many boolean clauses"	TokenNameStringLiteral	': too many boolean clauses
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
initCause	TokenNameIdentifier	 init Cause
(	TokenNameLPAREN	
tmc	TokenNameIdentifier	 tmc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return Returns the analyzer. */	TokenNameCOMMENT_JAVADOC	 @return Returns the analyzer. 
public	TokenNamepublic	
Analyzer	TokenNameIdentifier	 Analyzer
getAnalyzer	TokenNameIdentifier	 get Analyzer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return Returns the field. */	TokenNameCOMMENT_JAVADOC	 @return Returns the field. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getField	TokenNameIdentifier	 get Field
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
field	TokenNameIdentifier	 field
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setAutoGeneratePhraseQueries(boolean) */	TokenNameCOMMENT_JAVADOC	 @see #setAutoGeneratePhraseQueries(boolean) 
public	TokenNamepublic	
final	TokenNamefinal	
boolean	TokenNameboolean	
getAutoGeneratePhraseQueries	TokenNameIdentifier	 get Auto Generate Phrase Queries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
autoGeneratePhraseQueries	TokenNameIdentifier	 auto Generate Phrase Queries
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set to true if phrase queries will be automatically generated * when the analyzer returns more than one term from whitespace * delimited text. * NOTE: this behavior may not be suitable for all languages. * <p> * Set to false if phrase queries should only be generated when * surrounded by double quotes. */	TokenNameCOMMENT_JAVADOC	 Set to true if phrase queries will be automatically generated when the analyzer returns more than one term from whitespace delimited text. NOTE: this behavior may not be suitable for all languages. <p> Set to false if phrase queries should only be generated when surrounded by double quotes. 
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
setAutoGeneratePhraseQueries	TokenNameIdentifier	 set Auto Generate Phrase Queries
(	TokenNameLPAREN	
boolean	TokenNameboolean	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
false	TokenNamefalse	
&&	TokenNameAND_AND	
!	TokenNameNOT	
hasNewAPI	TokenNameIdentifier	 has New API
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"You must implement the new API: getFieldQuery(String,String,boolean)"	TokenNameStringLiteral	You must implement the new API: getFieldQuery(String,String,boolean)
+	TokenNamePLUS	
" to use setAutoGeneratePhraseQueries(false)"	TokenNameStringLiteral	 to use setAutoGeneratePhraseQueries(false)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
autoGeneratePhraseQueries	TokenNameIdentifier	 auto Generate Phrase Queries
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the minimal similarity for fuzzy queries. */	TokenNameCOMMENT_JAVADOC	 Get the minimal similarity for fuzzy queries. 
public	TokenNamepublic	
float	TokenNamefloat	
getFuzzyMinSim	TokenNameIdentifier	 get Fuzzy Min Sim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the minimum similarity for fuzzy queries. * Default is 0.5f. */	TokenNameCOMMENT_JAVADOC	 Set the minimum similarity for fuzzy queries. Default is 0.5f. 
public	TokenNamepublic	
void	TokenNamevoid	
setFuzzyMinSim	TokenNameIdentifier	 set Fuzzy Min Sim
(	TokenNameLPAREN	
float	TokenNamefloat	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
=	TokenNameEQUAL	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the prefix length for fuzzy queries. * @return Returns the fuzzyPrefixLength. */	TokenNameCOMMENT_JAVADOC	 Get the prefix length for fuzzy queries. @return Returns the fuzzyPrefixLength. 
public	TokenNamepublic	
int	TokenNameint	
getFuzzyPrefixLength	TokenNameIdentifier	 get Fuzzy Prefix Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the prefix length for fuzzy queries. Default is 0. * @param fuzzyPrefixLength The fuzzyPrefixLength to set. */	TokenNameCOMMENT_JAVADOC	 Set the prefix length for fuzzy queries. Default is 0. @param fuzzyPrefixLength The fuzzyPrefixLength to set. 
public	TokenNamepublic	
void	TokenNamevoid	
setFuzzyPrefixLength	TokenNameIdentifier	 set Fuzzy Prefix Length
(	TokenNameLPAREN	
int	TokenNameint	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
=	TokenNameEQUAL	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the default slop for phrases. If zero, then exact phrase matches * are required. Default value is zero. */	TokenNameCOMMENT_JAVADOC	 Sets the default slop for phrases. If zero, then exact phrase matches are required. Default value is zero. 
public	TokenNamepublic	
void	TokenNamevoid	
setPhraseSlop	TokenNameIdentifier	 set Phrase Slop
(	TokenNameLPAREN	
int	TokenNameint	
phraseSlop	TokenNameIdentifier	 phrase Slop
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
phraseSlop	TokenNameIdentifier	 phrase Slop
=	TokenNameEQUAL	
phraseSlop	TokenNameIdentifier	 phrase Slop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets the default slop for phrases. */	TokenNameCOMMENT_JAVADOC	 Gets the default slop for phrases. 
public	TokenNamepublic	
int	TokenNameint	
getPhraseSlop	TokenNameIdentifier	 get Phrase Slop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
phraseSlop	TokenNameIdentifier	 phrase Slop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set to <code>true</code> to allow leading wildcard characters. * <p> * When set, <code>*</code> or <code>?</code> are allowed as * the first character of a PrefixQuery and WildcardQuery. * Note that this can produce very slow * queries on big indexes. * <p> * Default: false. */	TokenNameCOMMENT_JAVADOC	 Set to <code>true</code> to allow leading wildcard characters. <p> When set, <code>*</code> or <code>?</code> are allowed as the first character of a PrefixQuery and WildcardQuery. Note that this can produce very slow queries on big indexes. <p> Default: false. 
public	TokenNamepublic	
void	TokenNamevoid	
setAllowLeadingWildcard	TokenNameIdentifier	 set Allow Leading Wildcard
(	TokenNameLPAREN	
boolean	TokenNameboolean	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
=	TokenNameEQUAL	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setAllowLeadingWildcard(boolean) */	TokenNameCOMMENT_JAVADOC	 @see #setAllowLeadingWildcard(boolean) 
public	TokenNamepublic	
boolean	TokenNameboolean	
getAllowLeadingWildcard	TokenNameIdentifier	 get Allow Leading Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set to <code>true</code> to enable position increments in result query. * <p> * When set, result phrase and multi-phrase queries will * be aware of position increments. * Useful when e.g. a StopFilter increases the position increment of * the token that follows an omitted token. * <p> * Default: false. */	TokenNameCOMMENT_JAVADOC	 Set to <code>true</code> to enable position increments in result query. <p> When set, result phrase and multi-phrase queries will be aware of position increments. Useful when e.g. a StopFilter increases the position increment of the token that follows an omitted token. <p> Default: false. 
public	TokenNamepublic	
void	TokenNamevoid	
setEnablePositionIncrements	TokenNameIdentifier	 set Enable Position Increments
(	TokenNameLPAREN	
boolean	TokenNameboolean	
enable	TokenNameIdentifier	 enable
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
=	TokenNameEQUAL	
enable	TokenNameIdentifier	 enable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setEnablePositionIncrements(boolean) */	TokenNameCOMMENT_JAVADOC	 @see #setEnablePositionIncrements(boolean) 
public	TokenNamepublic	
boolean	TokenNameboolean	
getEnablePositionIncrements	TokenNameIdentifier	 get Enable Position Increments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the boolean operator of the QueryParser. * In default mode (<code>OR_OPERATOR</code>) terms without any modifiers * are considered optional: for example <code>capital of Hungary</code> is equal to * <code>capital OR of OR Hungary</code>.<br/> * In <code>AND_OPERATOR</code> mode terms are considered to be in conjunction: the * above mentioned query is parsed as <code>capital AND of AND Hungary</code> */	TokenNameCOMMENT_JAVADOC	 Sets the boolean operator of the QueryParser. In default mode (<code>OR_OPERATOR</code>) terms without any modifiers are considered optional: for example <code>capital of Hungary</code> is equal to <code>capital OR of OR Hungary</code>.<br/> In <code>AND_OPERATOR</code> mode terms are considered to be in conjunction: the above mentioned query is parsed as <code>capital AND of AND Hungary</code> 
public	TokenNamepublic	
void	TokenNamevoid	
setDefaultOperator	TokenNameIdentifier	 set Default Operator
(	TokenNameLPAREN	
Operator	TokenNameIdentifier	 Operator
op	TokenNameIdentifier	 op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
=	TokenNameEQUAL	
op	TokenNameIdentifier	 op
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Gets implicit operator setting, which will be either AND_OPERATOR * or OR_OPERATOR. */	TokenNameCOMMENT_JAVADOC	 Gets implicit operator setting, which will be either AND_OPERATOR or OR_OPERATOR. 
public	TokenNamepublic	
Operator	TokenNameIdentifier	 Operator
getDefaultOperator	TokenNameIdentifier	 get Default Operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
operator	TokenNameIdentifier	 operator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically * lower-cased or not. Default is <code>true</code>. */	TokenNameCOMMENT_JAVADOC	 Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically lower-cased or not. Default is <code>true</code>. 
public	TokenNamepublic	
void	TokenNamevoid	
setLowercaseExpandedTerms	TokenNameIdentifier	 set Lowercase Expanded Terms
(	TokenNameLPAREN	
boolean	TokenNameboolean	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
=	TokenNameEQUAL	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setLowercaseExpandedTerms(boolean) */	TokenNameCOMMENT_JAVADOC	 @see #setLowercaseExpandedTerms(boolean) 
public	TokenNamepublic	
boolean	TokenNameboolean	
getLowercaseExpandedTerms	TokenNameIdentifier	 get Lowercase Expanded Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * By default QueryParser uses {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} * when creating a PrefixQuery, WildcardQuery or RangeQuery. This implementation is generally preferable because it * a) Runs faster b) Does not have the scarcity of terms unduly influence score * c) avoids any "TooManyBooleanClauses" exception. * However, if your application really needs to use the * old-fashioned BooleanQuery expansion rewriting and the above * points are not relevant then use this to change * the rewrite method. */	TokenNameCOMMENT_JAVADOC	 By default QueryParser uses {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} when creating a PrefixQuery, WildcardQuery or RangeQuery. This implementation is generally preferable because it a) Runs faster b) Does not have the scarcity of terms unduly influence score c) avoids any "TooManyBooleanClauses" exception. However, if your application really needs to use the old-fashioned BooleanQuery expansion rewriting and the above points are not relevant then use this to change the rewrite method. 
public	TokenNamepublic	
void	TokenNamevoid	
setMultiTermRewriteMethod	TokenNameIdentifier	 set Multi Term Rewrite Method
(	TokenNameLPAREN	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
RewriteMethod	TokenNameIdentifier	 Rewrite Method
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
=	TokenNameEQUAL	
method	TokenNameIdentifier	 method
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see #setMultiTermRewriteMethod */	TokenNameCOMMENT_JAVADOC	 @see #setMultiTermRewriteMethod 
public	TokenNamepublic	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
.	TokenNameDOT	
RewriteMethod	TokenNameIdentifier	 Rewrite Method
getMultiTermRewriteMethod	TokenNameIdentifier	 get Multi Term Rewrite Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set locale used by date range parsing. */	TokenNameCOMMENT_JAVADOC	 Set locale used by date range parsing. 
public	TokenNamepublic	
void	TokenNamevoid	
setLocale	TokenNameIdentifier	 set Locale
(	TokenNameLPAREN	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
locale	TokenNameIdentifier	 locale
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns current locale, allowing access by subclasses. */	TokenNameCOMMENT_JAVADOC	 Returns current locale, allowing access by subclasses. 
public	TokenNamepublic	
Locale	TokenNameIdentifier	 Locale
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
locale	TokenNameIdentifier	 locale
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the default date resolution used by RangeQueries for fields for which no * specific date resolutions has been set. Field specific resolutions can be set * with {@link #setDateResolution(String, DateTools.Resolution)}. * * @param dateResolution the default date resolution to set */	TokenNameCOMMENT_JAVADOC	 Sets the default date resolution used by RangeQueries for fields for which no specific date resolutions has been set. Field specific resolutions can be set with {@link #setDateResolution(String, DateTools.Resolution)}. * @param dateResolution the default date resolution to set 
public	TokenNamepublic	
void	TokenNamevoid	
setDateResolution	TokenNameIdentifier	 set Date Resolution
(	TokenNameLPAREN	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
dateResolution	TokenNameIdentifier	 date Resolution
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dateResolution	TokenNameIdentifier	 date Resolution
=	TokenNameEQUAL	
dateResolution	TokenNameIdentifier	 date Resolution
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the date resolution used by RangeQueries for a specific field. * * @param fieldName field for which the date resolution is to be set * @param dateResolution date resolution to set */	TokenNameCOMMENT_JAVADOC	 Sets the date resolution used by RangeQueries for a specific field. * @param fieldName field for which the date resolution is to be set @param dateResolution date resolution to set 
public	TokenNamepublic	
void	TokenNamevoid	
setDateResolution	TokenNameIdentifier	 set Date Resolution
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
,	TokenNameCOMMA	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
dateResolution	TokenNameIdentifier	 date Resolution
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Field cannot be null."	TokenNameStringLiteral	Field cannot be null.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// lazily initialize HashMap 	TokenNameCOMMENT_LINE	lazily initialize HashMap 
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
,	TokenNameCOMMA	
dateResolution	TokenNameIdentifier	 date Resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the date resolution that is used by RangeQueries for the given field. * Returns null, if no default or field specific date resolution has been set * for the given field. * */	TokenNameCOMMENT_JAVADOC	 Returns the date resolution that is used by RangeQueries for the given field. Returns null, if no default or field specific date resolution has been set for the given field. 
public	TokenNamepublic	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
getDateResolution	TokenNameIdentifier	 get Date Resolution
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Field cannot be null."	TokenNameStringLiteral	Field cannot be null.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no field specific date resolutions set; return default date resolution instead 	TokenNameCOMMENT_LINE	no field specific date resolutions set; return default date resolution instead 
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
dateResolution	TokenNameIdentifier	 date Resolution
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
fieldToDateResolution	TokenNameIdentifier	 field To Date Resolution
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fieldName	TokenNameIdentifier	 field Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no date resolutions set for the given field; return default date resolution instead 	TokenNameCOMMENT_LINE	no date resolutions set for the given field; return default date resolution instead 
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
dateResolution	TokenNameIdentifier	 date Resolution
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
resolution	TokenNameIdentifier	 resolution
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sets the collator used to determine index term inclusion in ranges * for RangeQuerys. * <p/> * <strong>WARNING:</strong> Setting the rangeCollator to a non-null * collator using this method will cause every single index Term in the * Field referenced by lowerTerm and/or upperTerm to be examined. * Depending on the number of index Terms in this Field, the operation could * be very slow. * * @param rc the collator to use when constructing RangeQuerys */	TokenNameCOMMENT_JAVADOC	 Sets the collator used to determine index term inclusion in ranges for RangeQuerys. <p/> <strong>WARNING:</strong> Setting the rangeCollator to a non-null collator using this method will cause every single index Term in the Field referenced by lowerTerm and/or upperTerm to be examined. Depending on the number of index Terms in this Field, the operation could be very slow. * @param rc the collator to use when constructing RangeQuerys 
public	TokenNamepublic	
void	TokenNamevoid	
setRangeCollator	TokenNameIdentifier	 set Range Collator
(	TokenNameLPAREN	
Collator	TokenNameIdentifier	 Collator
rc	TokenNameIdentifier	 rc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rangeCollator	TokenNameIdentifier	 range Collator
=	TokenNameEQUAL	
rc	TokenNameIdentifier	 rc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return the collator used to determine index term inclusion in ranges * for RangeQuerys. */	TokenNameCOMMENT_JAVADOC	 @return the collator used to determine index term inclusion in ranges for RangeQuerys. 
public	TokenNamepublic	
Collator	TokenNameIdentifier	 Collator
getRangeCollator	TokenNameIdentifier	 get Range Collator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rangeCollator	TokenNameIdentifier	 range Collator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
addClause	TokenNameIdentifier	 add Clause
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
BooleanClause	TokenNameIdentifier	 Boolean Clause
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
,	TokenNameCOMMA	
int	TokenNameint	
conj	TokenNameIdentifier	 conj
,	TokenNameCOMMA	
int	TokenNameint	
mods	TokenNameIdentifier	 mods
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
required	TokenNameIdentifier	 required
,	TokenNameCOMMA	
prohibited	TokenNameIdentifier	 prohibited
;	TokenNameSEMICOLON	
// If this term is introduced by AND, make the preceding term required, 	TokenNameCOMMENT_LINE	If this term is introduced by AND, make the preceding term required, 
// unless it's already prohibited 	TokenNameCOMMENT_LINE	unless it's already prohibited 
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
conj	TokenNameIdentifier	 conj
==	TokenNameEQUAL_EQUAL	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BooleanClause	TokenNameIdentifier	 Boolean Clause
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isProhibited	TokenNameIdentifier	 is Prohibited
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setOccur	TokenNameIdentifier	 set Occur
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST	TokenNameIdentifier	 MUST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
operator	TokenNameIdentifier	 operator
==	TokenNameEQUAL_EQUAL	
AND_OPERATOR	TokenNameIdentifier	 AND  OPERATOR
&&	TokenNameAND_AND	
conj	TokenNameIdentifier	 conj
==	TokenNameEQUAL_EQUAL	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this term is introduced by OR, make the preceding term optional, 	TokenNameCOMMENT_LINE	If this term is introduced by OR, make the preceding term optional, 
// unless it's prohibited (that means we leave -a OR b but +a OR b-->a OR b) 	TokenNameCOMMENT_LINE	unless it's prohibited (that means we leave -a OR b but +a OR b-->a OR b) 
// notice if the input is a OR b, first term is parsed as required; without 	TokenNameCOMMENT_LINE	notice if the input is a OR b, first term is parsed as required; without 
// this modification a OR b would parsed as +a OR b 	TokenNameCOMMENT_LINE	this modification a OR b would parsed as +a OR b 
BooleanClause	TokenNameIdentifier	 Boolean Clause
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isProhibited	TokenNameIdentifier	 is Prohibited
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setOccur	TokenNameIdentifier	 set Occur
(	TokenNameLPAREN	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We might have been passed a null query; the term might have been 	TokenNameCOMMENT_LINE	We might have been passed a null query; the term might have been 
// filtered away by the analyzer. 	TokenNameCOMMENT_LINE	filtered away by the analyzer. 
if	TokenNameif	
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
operator	TokenNameIdentifier	 operator
==	TokenNameEQUAL_EQUAL	
OR_OPERATOR	TokenNameIdentifier	 OR  OPERATOR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We set REQUIRED if we're introduced by AND or +; PROHIBITED if 	TokenNameCOMMENT_LINE	We set REQUIRED if we're introduced by AND or +; PROHIBITED if 
// introduced by NOT or -; make sure not to set both. 	TokenNameCOMMENT_LINE	introduced by NOT or -; make sure not to set both. 
prohibited	TokenNameIdentifier	 prohibited
=	TokenNameEQUAL	
(	TokenNameLPAREN	
mods	TokenNameIdentifier	 mods
==	TokenNameEQUAL_EQUAL	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
(	TokenNameLPAREN	
mods	TokenNameIdentifier	 mods
==	TokenNameEQUAL_EQUAL	
MOD_REQ	TokenNameIdentifier	 MOD  REQ
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
conj	TokenNameIdentifier	 conj
==	TokenNameEQUAL_EQUAL	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
&&	TokenNameAND_AND	
!	TokenNameNOT	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
{	TokenNameLBRACE	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// We set PROHIBITED if we're introduced by NOT or -; We set REQUIRED 	TokenNameCOMMENT_LINE	We set PROHIBITED if we're introduced by NOT or -; We set REQUIRED 
// if not PROHIBITED and not introduced by OR 	TokenNameCOMMENT_LINE	if not PROHIBITED and not introduced by OR 
prohibited	TokenNameIdentifier	 prohibited
=	TokenNameEQUAL	
(	TokenNameLPAREN	
mods	TokenNameIdentifier	 mods
==	TokenNameEQUAL_EQUAL	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
(	TokenNameLPAREN	
!	TokenNameNOT	
prohibited	TokenNameIdentifier	 prohibited
&&	TokenNameAND_AND	
conj	TokenNameIdentifier	 conj
!=	TokenNameNOT_EQUAL	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
&&	TokenNameAND_AND	
!	TokenNameNOT	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newBooleanClause	TokenNameIdentifier	 new Boolean Clause
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST	TokenNameIdentifier	 MUST
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
required	TokenNameIdentifier	 required
&&	TokenNameAND_AND	
!	TokenNameNOT	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newBooleanClause	TokenNameIdentifier	 new Boolean Clause
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
required	TokenNameIdentifier	 required
&&	TokenNameAND_AND	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newBooleanClause	TokenNameIdentifier	 new Boolean Clause
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST_NOT	TokenNameIdentifier	 MUST  NOT
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Clause cannot be both required and prohibited"	TokenNameStringLiteral	Clause cannot be both required and prohibited
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @deprecated Use {@link #getFieldQuery(String,String,boolean)} instead. */	TokenNameCOMMENT_JAVADOC	 @deprecated Use {@link #getFieldQuery(String,String,boolean)} instead. 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
queryText	TokenNameIdentifier	 query Text
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
// treat the text as if it was quoted, to drive phrase logic with old versions. 	TokenNameCOMMENT_LINE	treat the text as if it was quoted, to drive phrase logic with old versions. 
return	TokenNamereturn	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
boolean	TokenNameboolean	
quoted	TokenNameIdentifier	 quoted
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
// Use the analyzer to get all the tokens, and then build a TermQuery, 	TokenNameCOMMENT_LINE	Use the analyzer to get all the tokens, and then build a TermQuery, 
// PhraseQuery, or nothing based on the term count 	TokenNameCOMMENT_LINE	PhraseQuery, or nothing based on the term count 
TokenStream	TokenNameIdentifier	 Token Stream
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
.	TokenNameDOT	
reusableTokenStream	TokenNameIdentifier	 reusable Token Stream
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
queryText	TokenNameIdentifier	 query Text
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
source	TokenNameIdentifier	 source
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
source	TokenNameIdentifier	 source
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
.	TokenNameDOT	
tokenStream	TokenNameIdentifier	 token Stream
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
new	TokenNamenew	
StringReader	TokenNameIdentifier	 String Reader
(	TokenNameLPAREN	
queryText	TokenNameIdentifier	 query Text
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CachingTokenFilter	TokenNameIdentifier	 Caching Token Filter
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
CachingTokenFilter	TokenNameIdentifier	 Caching Token Filter
(	TokenNameLPAREN	
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
posIncrAtt	TokenNameIdentifier	 pos Incr Att
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
numTokens	TokenNameIdentifier	 num Tokens
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// success==false if we hit an exception 	TokenNameCOMMENT_LINE	success==false if we hit an exception 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
hasAttribute	TokenNameIdentifier	 has Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
hasAttribute	TokenNameIdentifier	 has Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
positionCount	TokenNameIdentifier	 position Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
severalTokensAtSamePosition	TokenNameIdentifier	 several Tokens At Same Position
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
termAtt	TokenNameIdentifier	 term Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numTokens	TokenNameIdentifier	 num Tokens
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
int	TokenNameint	
positionIncrement	TokenNameIdentifier	 position Increment
=	TokenNameEQUAL	
(	TokenNameLPAREN	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
positionIncrement	TokenNameIdentifier	 position Increment
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positionCount	TokenNameIdentifier	 position Count
+=	TokenNamePLUS_EQUAL	
positionIncrement	TokenNameIdentifier	 position Increment
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
severalTokensAtSamePosition	TokenNameIdentifier	 several Tokens At Same Position
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// rewind the buffer stream 	TokenNameCOMMENT_LINE	rewind the buffer stream 
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// close original stream - all tokens buffered 	TokenNameCOMMENT_LINE	close original stream - all tokens buffered 
source	TokenNameIdentifier	 source
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore 	TokenNameCOMMENT_LINE	ignore 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numTokens	TokenNameIdentifier	 num Tokens
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numTokens	TokenNameIdentifier	 num Tokens
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
hasNext	TokenNameIdentifier	 has Next
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// safe to ignore, because we know the number of tokens 	TokenNameCOMMENT_LINE	safe to ignore, because we know the number of tokens 
}	TokenNameRBRACE	
return	TokenNamereturn	
newTermQuery	TokenNameIdentifier	 new Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
severalTokensAtSamePosition	TokenNameIdentifier	 several Tokens At Same Position
||	TokenNameOR_OR	
(	TokenNameLPAREN	
!	TokenNameNOT	
quoted	TokenNameIdentifier	 quoted
&&	TokenNameAND_AND	
!	TokenNameNOT	
autoGeneratePhraseQueries	TokenNameIdentifier	 auto Generate Phrase Queries
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
positionCount	TokenNameIdentifier	 position Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
!	TokenNameNOT	
quoted	TokenNameIdentifier	 quoted
&&	TokenNameAND_AND	
!	TokenNameNOT	
autoGeneratePhraseQueries	TokenNameIdentifier	 auto Generate Phrase Queries
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no phrase query: 	TokenNameCOMMENT_LINE	no phrase query: 
BooleanQuery	TokenNameIdentifier	 Boolean Query
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
newBooleanQuery	TokenNameIdentifier	 new Boolean Query
(	TokenNameLPAREN	
positionCount	TokenNameIdentifier	 position Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
occur	TokenNameIdentifier	 occur
=	TokenNameEQUAL	
positionCount	TokenNameIdentifier	 position Count
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
operator	TokenNameIdentifier	 operator
==	TokenNameEQUAL_EQUAL	
AND_OPERATOR	TokenNameIdentifier	 AND  OPERATOR
?	TokenNameQUESTION	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
MUST	TokenNameIdentifier	 MUST
:	TokenNameCOLON	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
.	TokenNameDOT	
SHOULD	TokenNameIdentifier	 SHOULD
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTokens	TokenNameIdentifier	 num Tokens
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
hasNext	TokenNameIdentifier	 has Next
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// safe to ignore, because we know the number of tokens 	TokenNameCOMMENT_LINE	safe to ignore, because we know the number of tokens 
}	TokenNameRBRACE	
Query	TokenNameIdentifier	 Query
currentQuery	TokenNameIdentifier	 current Query
=	TokenNameEQUAL	
newTermQuery	TokenNameIdentifier	 new Term Query
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
currentQuery	TokenNameIdentifier	 current Query
,	TokenNameCOMMA	
occur	TokenNameIdentifier	 occur
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// phrase query: 	TokenNameCOMMENT_LINE	phrase query: 
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
mpq	TokenNameIdentifier	 mpq
=	TokenNameEQUAL	
newMultiPhraseQuery	TokenNameIdentifier	 new Multi Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mpq	TokenNameIdentifier	 mpq
.	TokenNameDOT	
setSlop	TokenNameIdentifier	 set Slop
(	TokenNameLPAREN	
phraseSlop	TokenNameIdentifier	 phrase Slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
multiTerms	TokenNameIdentifier	 multi Terms
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTokens	TokenNameIdentifier	 num Tokens
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
positionIncrement	TokenNameIdentifier	 position Increment
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
hasNext	TokenNameIdentifier	 has Next
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positionIncrement	TokenNameIdentifier	 position Increment
=	TokenNameEQUAL	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// safe to ignore, because we know the number of tokens 	TokenNameCOMMENT_LINE	safe to ignore, because we know the number of tokens 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
positionIncrement	TokenNameIdentifier	 position Increment
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mpq	TokenNameIdentifier	 mpq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
mpq	TokenNameIdentifier	 mpq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
position	TokenNameIdentifier	 position
+=	TokenNamePLUS_EQUAL	
positionIncrement	TokenNameIdentifier	 position Increment
;	TokenNameSEMICOLON	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mpq	TokenNameIdentifier	 mpq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
mpq	TokenNameIdentifier	 mpq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
multiTerms	TokenNameIdentifier	 multi Terms
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
mpq	TokenNameIdentifier	 mpq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
PhraseQuery	TokenNameIdentifier	 Phrase Query
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
newPhraseQuery	TokenNameIdentifier	 new Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
setSlop	TokenNameIdentifier	 set Slop
(	TokenNameLPAREN	
phraseSlop	TokenNameIdentifier	 phrase Slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTokens	TokenNameIdentifier	 num Tokens
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
positionIncrement	TokenNameIdentifier	 position Increment
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
hasNext	TokenNameIdentifier	 has Next
==	TokenNameEQUAL_EQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positionIncrement	TokenNameIdentifier	 position Increment
=	TokenNameEQUAL	
posIncrAtt	TokenNameIdentifier	 pos Incr Att
.	TokenNameDOT	
getPositionIncrement	TokenNameIdentifier	 get Position Increment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// safe to ignore, because we know the number of tokens 	TokenNameCOMMENT_LINE	safe to ignore, because we know the number of tokens 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
enablePositionIncrements	TokenNameIdentifier	 enable Position Increments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
position	TokenNameIdentifier	 position
+=	TokenNamePLUS_EQUAL	
positionIncrement	TokenNameIdentifier	 position Increment
;	TokenNameSEMICOLON	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
,	TokenNameCOMMA	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
pq	TokenNameIdentifier	 pq
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Base implementation delegates to {@link #getFieldQuery(String,String,boolean)}. * This method may be overridden, for example, to return * a SpanNearQuery instead of a PhraseQuery. * * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Base implementation delegates to {@link #getFieldQuery(String,String,boolean)}. This method may be overridden, for example, to return a SpanNearQuery instead of a PhraseQuery. * @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
int	TokenNameint	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
hasNewAPI	TokenNameIdentifier	 has New API
?	TokenNameQUESTION	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
queryText	TokenNameIdentifier	 query Text
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
:	TokenNameCOLON	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
queryText	TokenNameIdentifier	 query Text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PhraseQuery	TokenNameIdentifier	 Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
setSlop	TokenNameIdentifier	 set Slop
(	TokenNameLPAREN	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
instanceof	TokenNameinstanceof	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
)	TokenNameRPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
.	TokenNameDOT	
setSlop	TokenNameIdentifier	 set Slop
(	TokenNameLPAREN	
slop	TokenNameIdentifier	 slop
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getRangeQuery	TokenNameIdentifier	 get Range Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
part1	TokenNameIdentifier	 part1
=	TokenNameEQUAL	
part1	TokenNameIdentifier	 part1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
part1	TokenNameIdentifier	 part1
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
part2	TokenNameIdentifier	 part2
=	TokenNameEQUAL	
part2	TokenNameIdentifier	 part2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
part2	TokenNameIdentifier	 part2
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DateFormat	TokenNameIdentifier	 Date Format
df	TokenNameIdentifier	 df
=	TokenNameEQUAL	
DateFormat	TokenNameIdentifier	 Date Format
.	TokenNameDOT	
getDateInstance	TokenNameIdentifier	 get Date Instance
(	TokenNameLPAREN	
DateFormat	TokenNameIdentifier	 Date Format
.	TokenNameDOT	
SHORT	TokenNameIdentifier	 SHORT
,	TokenNameCOMMA	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
df	TokenNameIdentifier	 df
.	TokenNameDOT	
setLenient	TokenNameIdentifier	 set Lenient
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
Resolution	TokenNameIdentifier	 Resolution
resolution	TokenNameIdentifier	 resolution
=	TokenNameEQUAL	
getDateResolution	TokenNameIdentifier	 get Date Resolution
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Date	TokenNameIdentifier	 Date
d1	TokenNameIdentifier	 d1
=	TokenNameEQUAL	
df	TokenNameIdentifier	 df
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
part1	TokenNameIdentifier	 part1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no default or field specific date resolution has been set, 	TokenNameCOMMENT_LINE	no default or field specific date resolution has been set, 
// use deprecated DateField to maintain compatibility with 	TokenNameCOMMENT_LINE	use deprecated DateField to maintain compatibility with 
// pre-1.9 Lucene versions. 	TokenNameCOMMENT_LINE	pre-1.9 Lucene versions. 
part1	TokenNameIdentifier	 part1
=	TokenNameEQUAL	
DateField	TokenNameIdentifier	 Date Field
.	TokenNameDOT	
dateToString	TokenNameIdentifier	 date To String
(	TokenNameLPAREN	
d1	TokenNameIdentifier	 d1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
part1	TokenNameIdentifier	 part1
=	TokenNameEQUAL	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
dateToString	TokenNameIdentifier	 date To String
(	TokenNameLPAREN	
d1	TokenNameIdentifier	 d1
,	TokenNameCOMMA	
resolution	TokenNameIdentifier	 resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
Date	TokenNameIdentifier	 Date
d2	TokenNameIdentifier	 d2
=	TokenNameEQUAL	
df	TokenNameIdentifier	 df
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
part2	TokenNameIdentifier	 part2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The user can only specify the date, not the time, so make sure 	TokenNameCOMMENT_LINE	The user can only specify the date, not the time, so make sure 
// the time is set to the latest possible time of that date to really 	TokenNameCOMMENT_LINE	the time is set to the latest possible time of that date to really 
// include all documents: 	TokenNameCOMMENT_LINE	include all documents: 
Calendar	TokenNameIdentifier	 Calendar
cal	TokenNameIdentifier	 cal
=	TokenNameEQUAL	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
setTime	TokenNameIdentifier	 set Time
(	TokenNameLPAREN	
d2	TokenNameIdentifier	 d2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
HOUR_OF_DAY	TokenNameIdentifier	 HOUR  OF  DAY
,	TokenNameCOMMA	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
MINUTE	TokenNameIdentifier	 MINUTE
,	TokenNameCOMMA	
59	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
SECOND	TokenNameIdentifier	 SECOND
,	TokenNameCOMMA	
59	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
Calendar	TokenNameIdentifier	 Calendar
.	TokenNameDOT	
MILLISECOND	TokenNameIdentifier	 MILLISECOND
,	TokenNameCOMMA	
999	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
d2	TokenNameIdentifier	 d2
=	TokenNameEQUAL	
cal	TokenNameIdentifier	 cal
.	TokenNameDOT	
getTime	TokenNameIdentifier	 get Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resolution	TokenNameIdentifier	 resolution
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no default or field specific date resolution has been set, 	TokenNameCOMMENT_LINE	no default or field specific date resolution has been set, 
// use deprecated DateField to maintain compatibility with 	TokenNameCOMMENT_LINE	use deprecated DateField to maintain compatibility with 
// pre-1.9 Lucene versions. 	TokenNameCOMMENT_LINE	pre-1.9 Lucene versions. 
part2	TokenNameIdentifier	 part2
=	TokenNameEQUAL	
DateField	TokenNameIdentifier	 Date Field
.	TokenNameDOT	
dateToString	TokenNameIdentifier	 date To String
(	TokenNameLPAREN	
d2	TokenNameIdentifier	 d2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
part2	TokenNameIdentifier	 part2
=	TokenNameEQUAL	
DateTools	TokenNameIdentifier	 Date Tools
.	TokenNameDOT	
dateToString	TokenNameIdentifier	 date To String
(	TokenNameLPAREN	
d2	TokenNameIdentifier	 d2
,	TokenNameCOMMA	
resolution	TokenNameIdentifier	 resolution
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
newRangeQuery	TokenNameIdentifier	 new Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new BooleanQuery instance * @param disableCoord disable coord * @return new BooleanQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new BooleanQuery instance @param disableCoord disable coord @return new BooleanQuery instance 
protected	TokenNameprotected	
BooleanQuery	TokenNameIdentifier	 Boolean Query
newBooleanQuery	TokenNameIdentifier	 new Boolean Query
(	TokenNameLPAREN	
boolean	TokenNameboolean	
disableCoord	TokenNameIdentifier	 disable Coord
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
BooleanQuery	TokenNameIdentifier	 Boolean Query
(	TokenNameLPAREN	
disableCoord	TokenNameIdentifier	 disable Coord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new BooleanClause instance * @param q sub query * @param occur how this clause should occur when matching documents * @return new BooleanClause instance */	TokenNameCOMMENT_JAVADOC	 Builds a new BooleanClause instance @param q sub query @param occur how this clause should occur when matching documents @return new BooleanClause instance 
protected	TokenNameprotected	
BooleanClause	TokenNameIdentifier	 Boolean Clause
newBooleanClause	TokenNameIdentifier	 new Boolean Clause
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
occur	TokenNameIdentifier	 occur
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
BooleanClause	TokenNameIdentifier	 Boolean Clause
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
occur	TokenNameIdentifier	 occur
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new TermQuery instance * @param term term * @return new TermQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new TermQuery instance @param term term @return new TermQuery instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newTermQuery	TokenNameIdentifier	 new Term Query
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TermQuery	TokenNameIdentifier	 Term Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new PhraseQuery instance * @return new PhraseQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new PhraseQuery instance @return new PhraseQuery instance 
protected	TokenNameprotected	
PhraseQuery	TokenNameIdentifier	 Phrase Query
newPhraseQuery	TokenNameIdentifier	 new Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
PhraseQuery	TokenNameIdentifier	 Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new MultiPhraseQuery instance * @return new MultiPhraseQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new MultiPhraseQuery instance @return new MultiPhraseQuery instance 
protected	TokenNameprotected	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
newMultiPhraseQuery	TokenNameIdentifier	 new Multi Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new PrefixQuery instance * @param prefix Prefix term * @return new PrefixQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new PrefixQuery instance @param prefix Prefix term @return new PrefixQuery instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newPrefixQuery	TokenNameIdentifier	 new Prefix Query
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PrefixQuery	TokenNameIdentifier	 Prefix Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
new	TokenNamenew	
PrefixQuery	TokenNameIdentifier	 Prefix Query
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
setRewriteMethod	TokenNameIdentifier	 set Rewrite Method
(	TokenNameLPAREN	
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new FuzzyQuery instance * @param term Term * @param minimumSimilarity minimum similarity * @param prefixLength prefix length * @return new FuzzyQuery Instance */	TokenNameCOMMENT_JAVADOC	 Builds a new FuzzyQuery instance @param term Term @param minimumSimilarity minimum similarity @param prefixLength prefix length @return new FuzzyQuery Instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newFuzzyQuery	TokenNameIdentifier	 new Fuzzy Query
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
float	TokenNamefloat	
minimumSimilarity	TokenNameIdentifier	 minimum Similarity
,	TokenNameCOMMA	
int	TokenNameint	
prefixLength	TokenNameIdentifier	 prefix Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// FuzzyQuery doesn't yet allow constant score rewrite 	TokenNameCOMMENT_LINE	FuzzyQuery doesn't yet allow constant score rewrite 
return	TokenNamereturn	
new	TokenNamenew	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
minimumSimilarity	TokenNameIdentifier	 minimum Similarity
,	TokenNameCOMMA	
prefixLength	TokenNameIdentifier	 prefix Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new TermRangeQuery instance * @param field Field * @param part1 min * @param part2 max * @param inclusive true if range is inclusive * @return new TermRangeQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new TermRangeQuery instance @param field Field @param part1 min @param part2 max @param inclusive true if range is inclusive @return new TermRangeQuery instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newRangeQuery	TokenNameIdentifier	 new Range Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
boolean	TokenNameboolean	
inclusive	TokenNameIdentifier	 inclusive
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
new	TokenNamenew	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
part1	TokenNameIdentifier	 part1
,	TokenNameCOMMA	
part2	TokenNameIdentifier	 part2
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
,	TokenNameCOMMA	
inclusive	TokenNameIdentifier	 inclusive
,	TokenNameCOMMA	
rangeCollator	TokenNameIdentifier	 range Collator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
setRewriteMethod	TokenNameIdentifier	 set Rewrite Method
(	TokenNameLPAREN	
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new MatchAllDocsQuery instance * @return new MatchAllDocsQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new MatchAllDocsQuery instance @return new MatchAllDocsQuery instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newMatchAllDocsQuery	TokenNameIdentifier	 new Match All Docs Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
MatchAllDocsQuery	TokenNameIdentifier	 Match All Docs Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Builds a new WildcardQuery instance * @param t wildcard term * @return new WildcardQuery instance */	TokenNameCOMMENT_JAVADOC	 Builds a new WildcardQuery instance @param t wildcard term @return new WildcardQuery instance 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
newWildcardQuery	TokenNameIdentifier	 new Wildcard Query
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
new	TokenNamenew	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
setRewriteMethod	TokenNameIdentifier	 set Rewrite Method
(	TokenNameLPAREN	
multiTermRewriteMethod	TokenNameIdentifier	 multi Term Rewrite Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory method for generating query, given a set of clauses. * By default creates a boolean query composed of clauses passed in. * * Can be overridden by extending classes, to modify query being * returned. * * @param clauses List that contains {@link BooleanClause} instances * to join. * * @return Resulting {@link Query} object. * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Factory method for generating query, given a set of clauses. By default creates a boolean query composed of clauses passed in. * Can be overridden by extending classes, to modify query being returned. * @param clauses List that contains {@link BooleanClause} instances to join. * @return Resulting {@link Query} object. @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getBooleanQuery	TokenNameIdentifier	 get Boolean Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
BooleanClause	TokenNameIdentifier	 Boolean Clause
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
getBooleanQuery	TokenNameIdentifier	 get Boolean Query
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory method for generating query, given a set of clauses. * By default creates a boolean query composed of clauses passed in. * * Can be overridden by extending classes, to modify query being * returned. * * @param clauses List that contains {@link BooleanClause} instances * to join. * @param disableCoord true if coord scoring should be disabled. * * @return Resulting {@link Query} object. * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Factory method for generating query, given a set of clauses. By default creates a boolean query composed of clauses passed in. * Can be overridden by extending classes, to modify query being returned. * @param clauses List that contains {@link BooleanClause} instances to join. @param disableCoord true if coord scoring should be disabled. * @return Resulting {@link Query} object. @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getBooleanQuery	TokenNameIdentifier	 get Boolean Query
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
BooleanClause	TokenNameIdentifier	 Boolean Clause
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
,	TokenNameCOMMA	
boolean	TokenNameboolean	
disableCoord	TokenNameIdentifier	 disable Coord
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// all clause words were filtered away by the analyzer. 	TokenNameCOMMENT_LINE	all clause words were filtered away by the analyzer. 
}	TokenNameRBRACE	
BooleanQuery	TokenNameIdentifier	 Boolean Query
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
newBooleanQuery	TokenNameIdentifier	 new Boolean Query
(	TokenNameLPAREN	
disableCoord	TokenNameIdentifier	 disable Coord
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
BooleanClause	TokenNameIdentifier	 Boolean Clause
clause	TokenNameIdentifier	 clause
:	TokenNameCOLON	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
{	TokenNameLBRACE	
query	TokenNameIdentifier	 query
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
clause	TokenNameIdentifier	 clause
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
query	TokenNameIdentifier	 query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory method for generating a query. Called when parser * parses an input term token that contains one or more wildcard * characters (? and *), but is not a prefix term token (one * that has just a single * character at the end) *<p> * Depending on settings, prefix term may be lower-cased * automatically. It will not go through the default Analyzer, * however, since normal Analyzers are unlikely to work properly * with wildcard templates. *<p> * Can be overridden by extending classes, to provide custom handling for * wildcard queries, which may be necessary due to missing analyzer calls. * * @param field Name of the field query will use. * @param termStr Term token that contains one or more wild card * characters (? or *), but is not simple prefix term * * @return Resulting {@link Query} built for the term * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Factory method for generating a query. Called when parser parses an input term token that contains one or more wildcard characters (? and *), but is not a prefix term token (one that has just a single character at the end) *<p> Depending on settings, prefix term may be lower-cased automatically. It will not go through the default Analyzer, however, since normal Analyzers are unlikely to work properly with wildcard templates. *<p> Can be overridden by extending classes, to provide custom handling for wildcard queries, which may be necessary due to missing analyzer calls. * @param field Name of the field query will use. @param termStr Term token that contains one or more wild card characters (? or *), but is not simple prefix term * @return Resulting {@link Query} built for the term @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getWildcardQuery	TokenNameIdentifier	 get Wildcard Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
newMatchAllDocsQuery	TokenNameIdentifier	 new Match All Docs Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
)	TokenNameRPAREN	
||	TokenNameOR_OR	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"?"	TokenNameStringLiteral	?
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"'*' or '?' not allowed as first character in WildcardQuery"	TokenNameStringLiteral	'*' or '?' not allowed as first character in WildcardQuery
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termStr	TokenNameIdentifier	 term Str
=	TokenNameEQUAL	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newWildcardQuery	TokenNameIdentifier	 new Wildcard Query
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory method for generating a query (similar to * {@link #getWildcardQuery}). Called when parser parses an input term * token that uses prefix notation; that is, contains a single '*' wildcard * character as its last character. Since this is a special case * of generic wildcard term, and such a query can be optimized easily, * this usually results in a different query object. *<p> * Depending on settings, a prefix term may be lower-cased * automatically. It will not go through the default Analyzer, * however, since normal Analyzers are unlikely to work properly * with wildcard templates. *<p> * Can be overridden by extending classes, to provide custom handling for * wild card queries, which may be necessary due to missing analyzer calls. * * @param field Name of the field query will use. * @param termStr Term token to use for building term for the query * (<b>without</b> trailing '*' character!) * * @return Resulting {@link Query} built for the term * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Factory method for generating a query (similar to {@link #getWildcardQuery}). Called when parser parses an input term token that uses prefix notation; that is, contains a single '*' wildcard character as its last character. Since this is a special case of generic wildcard term, and such a query can be optimized easily, this usually results in a different query object. *<p> Depending on settings, a prefix term may be lower-cased automatically. It will not go through the default Analyzer, however, since normal Analyzers are unlikely to work properly with wildcard templates. *<p> Can be overridden by extending classes, to provide custom handling for wild card queries, which may be necessary due to missing analyzer calls. * @param field Name of the field query will use. @param termStr Term token to use for building term for the query (<b>without</b> trailing '*' character!) * @return Resulting {@link Query} built for the term @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getPrefixQuery	TokenNameIdentifier	 get Prefix Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
allowLeadingWildcard	TokenNameIdentifier	 allow Leading Wildcard
&&	TokenNameAND_AND	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"'*' not allowed as first character in PrefixQuery"	TokenNameStringLiteral	'*' not allowed as first character in PrefixQuery
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termStr	TokenNameIdentifier	 term Str
=	TokenNameEQUAL	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newPrefixQuery	TokenNameIdentifier	 new Prefix Query
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Factory method for generating a query (similar to * {@link #getWildcardQuery}). Called when parser parses * an input term token that has the fuzzy suffix (~) appended. * * @param field Name of the field query will use. * @param termStr Term token to use for building term for the query * * @return Resulting {@link Query} built for the term * @exception ParseException throw in overridden method to disallow */	TokenNameCOMMENT_JAVADOC	 Factory method for generating a query (similar to {@link #getWildcardQuery}). Called when parser parses an input term token that has the fuzzy suffix (~) appended. * @param field Name of the field query will use. @param termStr Term token to use for building term for the query * @return Resulting {@link Query} built for the term @exception ParseException throw in overridden method to disallow 
protected	TokenNameprotected	
Query	TokenNameIdentifier	 Query
getFuzzyQuery	TokenNameIdentifier	 get Fuzzy Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
termStr	TokenNameIdentifier	 term Str
,	TokenNameCOMMA	
float	TokenNamefloat	
minSimilarity	TokenNameIdentifier	 min Similarity
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lowercaseExpandedTerms	TokenNameIdentifier	 lowercase Expanded Terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
termStr	TokenNameIdentifier	 term Str
=	TokenNameEQUAL	
termStr	TokenNameIdentifier	 term Str
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termStr	TokenNameIdentifier	 term Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newFuzzyQuery	TokenNameIdentifier	 new Fuzzy Query
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
minSimilarity	TokenNameIdentifier	 min Similarity
,	TokenNameCOMMA	
fuzzyPrefixLength	TokenNameIdentifier	 fuzzy Prefix Length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a String where the escape char has been * removed, or kept only once if there was a double escape. * * Supports escaped unicode characters, e. g. translates * <code>\\u0041</code> to <code>A</code>. * */	TokenNameCOMMENT_JAVADOC	 Returns a String where the escape char has been removed, or kept only once if there was a double escape. * Supports escaped unicode characters, e. g. translates <code>\\u0041</code> to <code>A</code>. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
// Create char array to hold unescaped char sequence 	TokenNameCOMMENT_LINE	Create char array to hold unescaped char sequence 
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The length of the output can be less than the input 	TokenNameCOMMENT_LINE	The length of the output can be less than the input 
// due to discarded escape chars. This variable holds 	TokenNameCOMMENT_LINE	due to discarded escape chars. This variable holds 
// the actual length of the output 	TokenNameCOMMENT_LINE	the actual length of the output 
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// We remember whether the last processed character was 	TokenNameCOMMENT_LINE	We remember whether the last processed character was 
// an escape character 	TokenNameCOMMENT_LINE	an escape character 
boolean	TokenNameboolean	
lastCharWasEscapeChar	TokenNameIdentifier	 last Char Was Escape Char
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The multiplier the current unicode digit must be multiplied with. 	TokenNameCOMMENT_LINE	The multiplier the current unicode digit must be multiplied with. 
// E. g. the first digit must be multiplied with 16^3, the second with 16^2... 	TokenNameCOMMENT_LINE	E. g. the first digit must be multiplied with 16^3, the second with 16^2... 
int	TokenNameint	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Used to calculate the codepoint of the escaped unicode character 	TokenNameCOMMENT_LINE	Used to calculate the codepoint of the escaped unicode character 
int	TokenNameint	
codePoint	TokenNameIdentifier	 code Point
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
codePoint	TokenNameIdentifier	 code Point
+=	TokenNamePLUS_EQUAL	
hexToInt	TokenNameIdentifier	 hex To Int
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
;	TokenNameSEMICOLON	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
>>>=	TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
codePoint	TokenNameIdentifier	 code Point
;	TokenNameSEMICOLON	
codePoint	TokenNameIdentifier	 code Point
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
lastCharWasEscapeChar	TokenNameIdentifier	 last Char Was Escape Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'u'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// found an escaped unicode character 	TokenNameCOMMENT_LINE	found an escaped unicode character 
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
16	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
16	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// this character was escaped 	TokenNameCOMMENT_LINE	this character was escaped 
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastCharWasEscapeChar	TokenNameIdentifier	 last Char Was Escape Char
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\\'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastCharWasEscapeChar	TokenNameIdentifier	 last Char Was Escape Char
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
codePointMultiplier	TokenNameIdentifier	 code Point Multiplier
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Truncated unicode escape sequence."	TokenNameStringLiteral	Truncated unicode escape sequence.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lastCharWasEscapeChar	TokenNameIdentifier	 last Char Was Escape Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Term can not end with escape character."	TokenNameStringLiteral	Term can not end with escape character.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns the numeric value of the hexadecimal character */	TokenNameCOMMENT_JAVADOC	 Returns the numeric value of the hexadecimal character 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
hexToInt	TokenNameIdentifier	 hex To Int
(	TokenNameLPAREN	
char	TokenNamechar	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
'0'	TokenNameCharacterLiteral	
<=	TokenNameLESS_EQUAL	
c	TokenNameIdentifier	 c
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
<=	TokenNameLESS_EQUAL	
'9'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
-	TokenNameMINUS	
'0'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
'a'	TokenNameCharacterLiteral	
<=	TokenNameLESS_EQUAL	
c	TokenNameIdentifier	 c
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
<=	TokenNameLESS_EQUAL	
'f'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
-	TokenNameMINUS	
'a'	TokenNameCharacterLiteral	
+	TokenNamePLUS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
'A'	TokenNameCharacterLiteral	
<=	TokenNameLESS_EQUAL	
c	TokenNameIdentifier	 c
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
<=	TokenNameLESS_EQUAL	
'F'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
-	TokenNameMINUS	
'A'	TokenNameCharacterLiteral	
+	TokenNamePLUS	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"None-hex character in unicode escape sequence: "	TokenNameStringLiteral	None-hex character in unicode escape sequence: 
+	TokenNamePLUS	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns a String where those characters that QueryParser * expects to be escaped are escaped by a preceding <code>\</code>. */	TokenNameCOMMENT_JAVADOC	 Returns a String where those characters that QueryParser expects to be escaped are escaped by a preceding <code>\</code>. 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
escape	TokenNameIdentifier	 escape
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// These characters are part of the query syntax and must be escaped 	TokenNameCOMMENT_LINE	These characters are part of the query syntax and must be escaped 
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'\\'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'+'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'-'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'!'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'('	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
')'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
':'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'^'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'['	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
']'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'\"'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'{'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'}'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'~'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'*'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'?'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'|'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
'&'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'\\'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Command line tool to test QueryParser, using {@link org.apache.lucene.analysis.SimpleAnalyzer}. * Usage:<br> * <code>java org.apache.lucene.queryParser.QueryParser &lt;input&gt;</code> */	TokenNameCOMMENT_JAVADOC	 Command line tool to test QueryParser, using {@link org.apache.lucene.analysis.SimpleAnalyzer}. Usage:<br> <code>java org.apache.lucene.queryParser.QueryParser &lt;input&gt;</code> 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
main	TokenNameIdentifier	 main
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Usage: java org.apache.lucene.queryParser.QueryParser <input>"	TokenNameStringLiteral	Usage: java org.apache.lucene.queryParser.QueryParser <input>
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
QueryParser	TokenNameIdentifier	 Query Parser
qp	TokenNameIdentifier	 qp
=	TokenNameEQUAL	
new	TokenNamenew	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_CURRENT	TokenNameIdentifier	 LUCENE  CURRENT
,	TokenNameCOMMA	
"field"	TokenNameStringLiteral	field
,	TokenNameCOMMA	
new	TokenNamenew	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
SimpleAnalyzer	TokenNameIdentifier	 Simple Analyzer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
qp	TokenNameIdentifier	 qp
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
args	TokenNameIdentifier	 args
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
"field"	TokenNameStringLiteral	field
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// * Query ::= ( Clause )* 	TokenNameCOMMENT_LINE	* Query ::= ( Clause )* 
// * Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" ) 	TokenNameCOMMENT_LINE	* Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" ) 
final	TokenNamefinal	
public	TokenNamepublic	
int	TokenNameint	
Conjunction	TokenNameIdentifier	 Conjunction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_NONE	TokenNameIdentifier	 CONJ  NONE
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
AND	TokenNameIdentifier	 AND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_AND	TokenNameIdentifier	 CONJ  AND
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
OR	TokenNameIdentifier	 OR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
CONJ_OR	TokenNameIdentifier	 CONJ  OR
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
int	TokenNameint	
Modifiers	TokenNameIdentifier	 Modifiers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
MOD_NONE	TokenNameIdentifier	 MOD  NONE
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
PLUS	TokenNameIdentifier	 PLUS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
MOD_REQ	TokenNameIdentifier	 MOD  REQ
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
MINUS	TokenNameIdentifier	 MINUS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NOT	TokenNameIdentifier	 NOT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
MOD_NOT	TokenNameIdentifier	 MOD  NOT
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This makes sure that there is no garbage after the query string 	TokenNameCOMMENT_LINE	This makes sure that there is no garbage after the query string 
final	TokenNamefinal	
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
TopLevelQuery	TokenNameIdentifier	 Top Level Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
BooleanClause	TokenNameIdentifier	 Boolean Clause
>	TokenNameGREATER	
clauses	TokenNameIdentifier	 clauses
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
BooleanClause	TokenNameIdentifier	 Boolean Clause
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
,	TokenNameCOMMA	
firstQuery	TokenNameIdentifier	 first Query
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
conj	TokenNameIdentifier	 conj
,	TokenNameCOMMA	
mods	TokenNameIdentifier	 mods
;	TokenNameSEMICOLON	
mods	TokenNameIdentifier	 mods
=	TokenNameEQUAL	
Modifiers	TokenNameIdentifier	 Modifiers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Clause	TokenNameIdentifier	 Clause
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addClause	TokenNameIdentifier	 add Clause
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
,	TokenNameCOMMA	
CONJ_NONE	TokenNameIdentifier	 CONJ  NONE
,	TokenNameCOMMA	
mods	TokenNameIdentifier	 mods
,	TokenNameCOMMA	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mods	TokenNameIdentifier	 mods
==	TokenNameEQUAL_EQUAL	
MOD_NONE	TokenNameIdentifier	 MOD  NONE
)	TokenNameRPAREN	
firstQuery	TokenNameIdentifier	 first Query
=	TokenNameEQUAL	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
label_1	TokenNameIdentifier	 label 1
:	TokenNameCOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
AND	TokenNameIdentifier	 AND
:	TokenNameCOLON	
case	TokenNamecase	
OR	TokenNameIdentifier	 OR
:	TokenNameCOLON	
case	TokenNamecase	
NOT	TokenNameIdentifier	 NOT
:	TokenNameCOLON	
case	TokenNamecase	
PLUS	TokenNameIdentifier	 PLUS
:	TokenNameCOLON	
case	TokenNamecase	
MINUS	TokenNameIdentifier	 MINUS
:	TokenNameCOLON	
case	TokenNamecase	
BAREOPER	TokenNameIdentifier	 BAREOPER
:	TokenNameCOLON	
case	TokenNamecase	
LPAREN	TokenNameIdentifier	 LPAREN
:	TokenNameCOLON	
case	TokenNamecase	
STAR	TokenNameIdentifier	 STAR
:	TokenNameCOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
PREFIXTERM	TokenNameIdentifier	 PREFIXTERM
:	TokenNameCOLON	
case	TokenNamecase	
WILDTERM	TokenNameIdentifier	 WILDTERM
:	TokenNameCOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
break	TokenNamebreak	
label_1	TokenNameIdentifier	 label 1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
conj	TokenNameIdentifier	 conj
=	TokenNameEQUAL	
Conjunction	TokenNameIdentifier	 Conjunction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
mods	TokenNameIdentifier	 mods
=	TokenNameEQUAL	
Modifiers	TokenNameIdentifier	 Modifiers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Clause	TokenNameIdentifier	 Clause
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addClause	TokenNameIdentifier	 add Clause
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
,	TokenNameCOMMA	
conj	TokenNameIdentifier	 conj
,	TokenNameCOMMA	
mods	TokenNameIdentifier	 mods
,	TokenNameCOMMA	
q	TokenNameIdentifier	 q
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
firstQuery	TokenNameIdentifier	 first Query
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
firstQuery	TokenNameIdentifier	 first Query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
getBooleanQuery	TokenNameIdentifier	 get Boolean Query
(	TokenNameLPAREN	
clauses	TokenNameIdentifier	 clauses
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
Clause	TokenNameIdentifier	 Clause
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
fieldToken	TokenNameIdentifier	 field Token
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
fieldToken	TokenNameIdentifier	 field Token
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
fieldToken	TokenNameIdentifier	 field Token
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
STAR	TokenNameIdentifier	 STAR
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
STAR	TokenNameIdentifier	 STAR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
"*"	TokenNameStringLiteral	*
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
BAREOPER	TokenNameIdentifier	 BAREOPER
:	TokenNameCOLON	
case	TokenNamecase	
STAR	TokenNameIdentifier	 STAR
:	TokenNameCOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
PREFIXTERM	TokenNameIdentifier	 PREFIXTERM
:	TokenNameCOLON	
case	TokenNamecase	
WILDTERM	TokenNameIdentifier	 WILDTERM
:	TokenNameCOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LPAREN	TokenNameIdentifier	 LPAREN
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
LPAREN	TokenNameIdentifier	 LPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
Query	TokenNameIdentifier	 Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RPAREN	TokenNameIdentifier	 RPAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
7	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
Term	TokenNameIdentifier	 Term
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Query	TokenNameIdentifier	 Query
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
BAREOPER	TokenNameIdentifier	 BAREOPER
:	TokenNameCOLON	
case	TokenNamecase	
STAR	TokenNameIdentifier	 STAR
:	TokenNameCOLON	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
case	TokenNamecase	
PREFIXTERM	TokenNameIdentifier	 PREFIXTERM
:	TokenNameCOLON	
case	TokenNamecase	
WILDTERM	TokenNameIdentifier	 WILDTERM
:	TokenNameCOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TERM	TokenNameIdentifier	 TERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
STAR	TokenNameIdentifier	 STAR
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
STAR	TokenNameIdentifier	 STAR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
PREFIXTERM	TokenNameIdentifier	 PREFIXTERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
PREFIXTERM	TokenNameIdentifier	 PREFIXTERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
WILDTERM	TokenNameIdentifier	 WILDTERM
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
WILDTERM	TokenNameIdentifier	 WILDTERM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
NUMBER	TokenNameIdentifier	 NUMBER
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
BAREOPER	TokenNameIdentifier	 BAREOPER
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
BAREOPER	TokenNameIdentifier	 BAREOPER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
9	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fuzzy	TokenNameIdentifier	 fuzzy
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
11	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
termImage	TokenNameIdentifier	 term Image
=	TokenNameEQUAL	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getWildcardQuery	TokenNameIdentifier	 get Wildcard Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termImage	TokenNameIdentifier	 term Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getPrefixQuery	TokenNameIdentifier	 get Prefix Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fuzzy	TokenNameIdentifier	 fuzzy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
fms	TokenNameIdentifier	 fms
=	TokenNameEQUAL	
fuzzyMinSim	TokenNameIdentifier	 fuzzy Min Sim
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fms	TokenNameIdentifier	 fms
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fms	TokenNameIdentifier	 fms
<	TokenNameLESS	
0.0f	TokenNameFloatingPointLiteral	
||	TokenNameOR_OR	
fms	TokenNameIdentifier	 fms
>	TokenNameGREATER	
1.0f	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
"Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"	TokenNameStringLiteral	Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getFuzzyQuery	TokenNameIdentifier	 get Fuzzy Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termImage	TokenNameIdentifier	 term Image
,	TokenNameCOMMA	
fms	TokenNameIdentifier	 fms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
hasNewAPI	TokenNameIdentifier	 has New API
?	TokenNameQUESTION	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termImage	TokenNameIdentifier	 term Image
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
:	TokenNameCOLON	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
termImage	TokenNameIdentifier	 term Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_START	TokenNameIdentifier	 RANGEIN  START
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
12	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_TO	TokenNameIdentifier	 RANGEIN  TO
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_TO	TokenNameIdentifier	 RANGEIN  TO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
13	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_GOOP	TokenNameIdentifier	 RANGEIN  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
14	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEIN_END	TokenNameIdentifier	 RANGEIN  END
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
15	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
startOpen	TokenNameIdentifier	 start Open
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
endOpen	TokenNameIdentifier	 end Open
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startOpen	TokenNameIdentifier	 start Open
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEIN_QUOTED	TokenNameIdentifier	 RANGEIN  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
endOpen	TokenNameIdentifier	 end Open
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getRangeQuery	TokenNameIdentifier	 get Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
startOpen	TokenNameIdentifier	 start Open
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endOpen	TokenNameIdentifier	 end Open
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_START	TokenNameIdentifier	 RANGEEX  START
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
:	TokenNameCOLON	
goop1	TokenNameIdentifier	 goop1
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
16	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_TO	TokenNameIdentifier	 RANGEEX  TO
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_TO	TokenNameIdentifier	 RANGEEX  TO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
17	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_GOOP	TokenNameIdentifier	 RANGEEX  GOOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
:	TokenNameCOLON	
goop2	TokenNameIdentifier	 goop2
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
18	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
RANGEEX_END	TokenNameIdentifier	 RANGEEX  END
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
19	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
startOpen	TokenNameIdentifier	 start Open
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
endOpen	TokenNameIdentifier	 end Open
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startOpen	TokenNameIdentifier	 start Open
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
RANGEEX_QUOTED	TokenNameIdentifier	 RANGEEX  QUOTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
=	TokenNameEQUAL	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
"*"	TokenNameStringLiteral	*
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
endOpen	TokenNameIdentifier	 end Open
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getRangeQuery	TokenNameIdentifier	 get Range Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
startOpen	TokenNameIdentifier	 start Open
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop1	TokenNameIdentifier	 goop1
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
endOpen	TokenNameIdentifier	 end Open
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
goop2	TokenNameIdentifier	 goop2
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
QUOTED	TokenNameIdentifier	 QUOTED
:	TokenNameCOLON	
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
QUOTED	TokenNameIdentifier	 QUOTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
:	TokenNameCOLON	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
FUZZY_SLOP	TokenNameIdentifier	 FUZZY  SLOP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
20	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CARAT	TokenNameIdentifier	 CARAT
:	TokenNameCOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
CARAT	TokenNameIdentifier	 CARAT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boost	TokenNameIdentifier	 boost
=	TokenNameEQUAL	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
NUMBER	TokenNameIdentifier	 NUMBER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
21	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
phraseSlop	TokenNameIdentifier	 phrase Slop
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
fuzzySlop	TokenNameIdentifier	 fuzzy Slop
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
q	TokenNameIdentifier	 q
=	TokenNameEQUAL	
getFieldQuery	TokenNameIdentifier	 get Field Query
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
discardEscapeChar	TokenNameIdentifier	 discard Escape Char
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
22	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
boost	TokenNameIdentifier	 boost
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
.	TokenNameDOT	
floatValue	TokenNameIdentifier	 float Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ignored	TokenNameIdentifier	 ignored
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* Should this be handled somehow? (defaults to "no boost", if * boost number is invalid) */	TokenNameCOMMENT_BLOCK	 Should this be handled somehow? (defaults to "no boost", if boost number is invalid) 
}	TokenNameRBRACE	
// avoid boosting null queries, such as those caused by stop words 	TokenNameCOMMENT_LINE	avoid boosting null queries, such as those caused by stop words 
if	TokenNameif	
(	TokenNameLPAREN	
q	TokenNameIdentifier	 q
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
q	TokenNameIdentifier	 q
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
return	TokenNamereturn	
q	TokenNameIdentifier	 q
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"Missing return statement in function"	TokenNameStringLiteral	Missing return statement in function
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_2_1	TokenNameIdentifier	 jj 2 1
(	TokenNameLPAREN	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
xsp	TokenNameIdentifier	 xsp
;	TokenNameSEMICOLON	
xsp	TokenNameIdentifier	 xsp
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_3R_2	TokenNameIdentifier	 jj 3 R 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
xsp	TokenNameIdentifier	 xsp
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_3R_3	TokenNameIdentifier	 jj 3 R 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_3R_3	TokenNameIdentifier	 jj 3 R 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
STAR	TokenNameIdentifier	 STAR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_3R_2	TokenNameIdentifier	 jj 3 R 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
TERM	TokenNameIdentifier	 TERM
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
COLON	TokenNameIdentifier	 COLON
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Generated Token Manager. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
token_source	TokenNameIdentifier	 token source
;	TokenNameSEMICOLON	
/** Current token. */	TokenNameCOMMENT_JAVADOC	 Current token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
/** Next token. */	TokenNameCOMMENT_JAVADOC	 Next token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
jj_nt	TokenNameIdentifier	 jj nt
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_scanpos	TokenNameIdentifier	 jj scanpos
,	TokenNameCOMMA	
jj_lastpos	TokenNameIdentifier	 jj lastpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gen	TokenNameIdentifier	 jj gen
;	TokenNameSEMICOLON	
final	TokenNamefinal	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1	TokenNameIdentifier	 jj la1
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
23	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1_0	TokenNameIdentifier	 jj la1 0
;	TokenNameSEMICOLON	
static	TokenNamestatic	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_la1_1	TokenNameIdentifier	 jj la1 1
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_la1_init_1	TokenNameIdentifier	 jj la1 init 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
jj_la1_init_0	TokenNameIdentifier	 jj la1 init 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la1_0	TokenNameIdentifier	 jj la1 0
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
0x300	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x300	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1c00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x1c00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x7da7f00	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x120000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x40000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x7da6000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x4d22000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x200000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x200000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x40000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x60000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x8000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x60000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x40000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x80000000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x40000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x200000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x40000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x7da2000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
jj_la1_init_1	TokenNameIdentifier	 jj la1 init 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la1_1	TokenNameIdentifier	 jj la1 1
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0x0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** Constructor with user supplied CharStream. */	TokenNameCOMMENT_JAVADOC	 Constructor with user supplied CharStream. 
protected	TokenNameprotected	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
new	TokenNamenew	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor with generated Token Manager. */	TokenNameCOMMENT_JAVADOC	 Constructor with generated Token Manager. 
protected	TokenNameprotected	
QueryParser	TokenNameIdentifier	 Query Parser
(	TokenNameLPAREN	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise. */	TokenNameCOMMENT_JAVADOC	 Reinitialise. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
tm	TokenNameIdentifier	 tm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token_source	TokenNameIdentifier	 token source
=	TokenNameEQUAL	
tm	TokenNameIdentifier	 tm
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
jj_consume_token	TokenNameIdentifier	 jj consume token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
throws	TokenNamethrows	
ParseException	TokenNameIdentifier	 Parse Exception
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
oldToken	TokenNameIdentifier	 old Token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jj_gc	TokenNameIdentifier	 jj gc
>	TokenNameGREATER	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_gc	TokenNameIdentifier	 jj gc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
<	TokenNameLESS	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
oldToken	TokenNameIdentifier	 old Token
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
extends	TokenNameextends	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
Error	TokenNameIdentifier	 Error
{	TokenNameLBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
private	TokenNameprivate	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
jj_ls	TokenNameIdentifier	 jj ls
=	TokenNameEQUAL	
new	TokenNamenew	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
jj_scan_token	TokenNameIdentifier	 jj scan token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_rescan	TokenNameIdentifier	 jj rescan
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_scanpos	TokenNameIdentifier	 jj scanpos
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la	TokenNameIdentifier	 jj la
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
jj_scanpos	TokenNameIdentifier	 jj scanpos
==	TokenNameEQUAL_EQUAL	
jj_lastpos	TokenNameIdentifier	 jj lastpos
)	TokenNameRPAREN	
throw	TokenNamethrow	
jj_ls	TokenNameIdentifier	 jj ls
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_gen	TokenNameIdentifier	 jj gen
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get the specific Token. */	TokenNameCOMMENT_JAVADOC	 Get the specific Token. 
final	TokenNamefinal	
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
else	TokenNameelse	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jj_ntk	TokenNameIdentifier	 jj ntk
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_nt	TokenNameIdentifier	 jj nt
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
token_source	TokenNameIdentifier	 token source
.	TokenNameDOT	
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
jj_ntk	TokenNameIdentifier	 jj ntk
=	TokenNameEQUAL	
jj_nt	TokenNameIdentifier	 jj nt
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
jj_expentries	TokenNameIdentifier	 jj expentries
=	TokenNameEQUAL	
new	TokenNamenew	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_expentry	TokenNameIdentifier	 jj expentry
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
100	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>=	TokenNameGREATER_EQUAL	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
jj_endpos	TokenNameIdentifier	 jj endpos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_endpos	TokenNameIdentifier	 jj endpos
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_endpos	TokenNameIdentifier	 jj endpos
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
it	TokenNameIdentifier	 it
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
oldentry	TokenNameIdentifier	 oldentry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
it	TokenNameIdentifier	 it
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentry	TokenNameIdentifier	 jj expentry
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldentry	TokenNameIdentifier	 oldentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
jj_entries_loop	TokenNameIdentifier	 jj entries loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jj_lasttokens	TokenNameIdentifier	 jj lasttokens
[	TokenNameLBRACKET	
(	TokenNameLPAREN	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Generate ParseException. */	TokenNameCOMMENT_JAVADOC	 Generate ParseException. 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
generateParseException	TokenNameIdentifier	 generate Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
la1tokens	TokenNameIdentifier	 la1tokens
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
35	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jj_kind	TokenNameIdentifier	 jj kind
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
jj_kind	TokenNameIdentifier	 jj kind
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
jj_kind	TokenNameIdentifier	 jj kind
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jj_la1	TokenNameIdentifier	 jj la1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_la1_0	TokenNameIdentifier	 jj la1 0
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jj_la1_1	TokenNameIdentifier	 jj la1 1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
32	TokenNameIntegerLiteral	
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
35	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
la1tokens	TokenNameIdentifier	 la1tokens
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_expentry	TokenNameIdentifier	 jj expentry
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
jj_expentry	TokenNameIdentifier	 jj expentry
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
jj_expentry	TokenNameIdentifier	 jj expentry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_endpos	TokenNameIdentifier	 jj endpos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jj_add_error_token	TokenNameIdentifier	 jj add error token
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
exptokseq	TokenNameIdentifier	 exptokseq
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
exptokseq	TokenNameIdentifier	 exptokseq
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jj_expentries	TokenNameIdentifier	 jj expentries
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
exptokseq	TokenNameIdentifier	 exptokseq
,	TokenNameCOMMA	
tokenImage	TokenNameIdentifier	 token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Enable tracing. */	TokenNameCOMMENT_JAVADOC	 Enable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
enable_tracing	TokenNameIdentifier	 enable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** Disable tracing. */	TokenNameCOMMENT_JAVADOC	 Disable tracing. 
final	TokenNamefinal	
public	TokenNamepublic	
void	TokenNamevoid	
disable_tracing	TokenNameIdentifier	 disable tracing
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_rescan_token	TokenNameIdentifier	 jj rescan token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jj_la	TokenNameIdentifier	 jj la
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
jj_lastpos	TokenNameIdentifier	 jj lastpos
=	TokenNameEQUAL	
jj_scanpos	TokenNameIdentifier	 jj scanpos
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jj_3_1	TokenNameIdentifier	 jj 3 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
LookaheadSuccess	TokenNameIdentifier	 Lookahead Success
ls	TokenNameIdentifier	 ls
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
jj_rescan	TokenNameIdentifier	 jj rescan
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jj_save	TokenNameIdentifier	 jj save
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
int	TokenNameint	
xla	TokenNameIdentifier	 xla
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JJCalls	TokenNameIdentifier	 JJ Calls
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
jj_2_rtns	TokenNameIdentifier	 jj 2 rtns
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
>	TokenNameGREATER	
jj_gen	TokenNameIdentifier	 jj gen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
new	TokenNamenew	
JJCalls	TokenNameIdentifier	 JJ Calls
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
=	TokenNameEQUAL	
jj_gen	TokenNameIdentifier	 jj gen
+	TokenNamePLUS	
xla	TokenNameIdentifier	 xla
-	TokenNameMINUS	
jj_la	TokenNameIdentifier	 jj la
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
arg	TokenNameIdentifier	 arg
=	TokenNameEQUAL	
xla	TokenNameIdentifier	 xla
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
JJCalls	TokenNameIdentifier	 JJ Calls
{	TokenNameLBRACE	
int	TokenNameint	
gen	TokenNameIdentifier	 gen
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
first	TokenNameIdentifier	 first
;	TokenNameSEMICOLON	
int	TokenNameint	
arg	TokenNameIdentifier	 arg
;	TokenNameSEMICOLON	
JJCalls	TokenNameIdentifier	 JJ Calls
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
