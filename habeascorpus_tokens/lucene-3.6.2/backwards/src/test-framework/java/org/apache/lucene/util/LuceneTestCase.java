package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
Documented	TokenNameIdentifier	 Documented
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
Inherited	TokenNameIdentifier	 Inherited
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
Retention	TokenNameIdentifier	 Retention
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
annotation	TokenNameIdentifier	 annotation
.	TokenNameDOT	
RetentionPolicy	TokenNameIdentifier	 Retention Policy
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
reflect	TokenNameIdentifier	 reflect
.	TokenNameDOT	
Constructor	TokenNameIdentifier	 Constructor
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutorService	TokenNameIdentifier	 Executor Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Executors	TokenNameIdentifier	 Executors
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
TimeUnit	TokenNameIdentifier	 Time Unit
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Index	TokenNameIdentifier	 Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
Store	TokenNameIdentifier	 Store
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
.	TokenNameDOT	
TermVector	TokenNameIdentifier	 Term Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
AssertingIndexSearcher	TokenNameIdentifier	 Asserting Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FieldCache	TokenNameIdentifier	 Field Cache
.	TokenNameDOT	
CacheEntry	TokenNameIdentifier	 Cache Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FieldCache	TokenNameIdentifier	 Field Cache
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
IndexSearcher	TokenNameIdentifier	 Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
FSDirectory	TokenNameIdentifier	 FS Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
LockFactory	TokenNameIdentifier	 Lock Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FieldCacheSanityChecker	TokenNameIdentifier	 Field Cache Sanity Checker
.	TokenNameDOT	
Insanity	TokenNameIdentifier	 Insanity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
After	TokenNameIdentifier	 After
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
AfterClass	TokenNameIdentifier	 After Class
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Assert	TokenNameIdentifier	 Assert
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Assume	TokenNameIdentifier	 Assume
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Before	TokenNameIdentifier	 Before
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
BeforeClass	TokenNameIdentifier	 Before Class
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Ignore	TokenNameIdentifier	 Ignore
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
Rule	TokenNameIdentifier	 Rule
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
rules	TokenNameIdentifier	 rules
.	TokenNameDOT	
MethodRule	TokenNameIdentifier	 Method Rule
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
rules	TokenNameIdentifier	 rules
.	TokenNameDOT	
TestWatchman	TokenNameIdentifier	 Test Watchman
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
runner	TokenNameIdentifier	 runner
.	TokenNameDOT	
RunWith	TokenNameIdentifier	 Run With
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
runners	TokenNameIdentifier	 runners
.	TokenNameDOT	
model	TokenNameIdentifier	 model
.	TokenNameDOT	
FrameworkMethod	TokenNameIdentifier	 Framework Method
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
junit	TokenNameIdentifier	 junit
.	TokenNameDOT	
runners	TokenNameIdentifier	 runners
.	TokenNameDOT	
model	TokenNameIdentifier	 model
.	TokenNameDOT	
Statement	TokenNameIdentifier	 Statement
;	TokenNameSEMICOLON	
/** * Base class for all Lucene unit tests, Junit3 or Junit4 variant. * <p> * </p> * <p> * If you * override either <code>setUp()</code> or * <code>tearDown()</code> in your unit test, make sure you * call <code>super.setUp()</code> and * <code>super.tearDown()</code> * </p> * * <code>@After</code> - replaces setup * <code>@Before</code> - replaces teardown * <code>@Test</code> - any public method with this annotation is a test case, regardless * of its name * <p> * <p> * See Junit4 <a href="http://junit.org/junit/javadoc/4.7/">documentation</a> for a complete list of features. * <p> * Import from org.junit rather than junit.framework. * <p> * You should be able to use this class anywhere you used LuceneTestCase * if you annotate your derived class correctly with the annotations above * @see #assertSaneFieldCaches(String) */	TokenNameCOMMENT_JAVADOC	 Base class for all Lucene unit tests, Junit3 or Junit4 variant. <p> </p> <p> If you override either <code>setUp()</code> or <code>tearDown()</code> in your unit test, make sure you call <code>super.setUp()</code> and <code>super.tearDown()</code> </p> * <code>@After</code> - replaces setup <code>@Before</code> - replaces teardown <code>@Test</code> - any public method with this annotation is a test case, regardless of its name <p> <p> See Junit4 <a href="http://junit.org/junit/javadoc/4.7/">documentation</a> for a complete list of features. <p> Import from org.junit rather than junit.framework. <p> You should be able to use this class anywhere you used LuceneTestCase if you annotate your derived class correctly with the annotations above @see #assertSaneFieldCaches(String) 
@	TokenNameAT	
RunWith	TokenNameIdentifier	 Run With
(	TokenNameLPAREN	
LuceneTestCaseRunner	TokenNameIdentifier	 Lucene Test Case Runner
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
public	TokenNamepublic	
abstract	TokenNameabstract	
class	TokenNameclass	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
extends	TokenNameextends	
Assert	TokenNameIdentifier	 Assert
{	TokenNameLBRACE	
/** * true iff tests are run in verbose mode. Note: if it is false, tests are not * expected to print any messages. */	TokenNameCOMMENT_JAVADOC	 true iff tests are run in verbose mode. Note: if it is false, tests are not expected to print any messages. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
VERBOSE	TokenNameIdentifier	 VERBOSE
=	TokenNameEQUAL	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
getBoolean	TokenNameIdentifier	 get Boolean
(	TokenNameLPAREN	
"tests.verbose"	TokenNameStringLiteral	tests.verbose
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Use this constant when creating Analyzers and any other version-dependent stuff. * <p><b>NOTE:</b> Change this when development starts for new Lucene version: */	TokenNameCOMMENT_JAVADOC	 Use this constant when creating Analyzers and any other version-dependent stuff. <p><b>NOTE:</b> Change this when development starts for new Lucene version: 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Version	TokenNameIdentifier	 Version
TEST_VERSION_CURRENT	TokenNameIdentifier	 TEST  VERSION  CURRENT
=	TokenNameEQUAL	
Version	TokenNameIdentifier	 Version
.	TokenNameDOT	
LUCENE_35	TokenNameIdentifier	 LUCENE 35
;	TokenNameSEMICOLON	
/** * If this is set, it is the only method that should run. */	TokenNameCOMMENT_JAVADOC	 If this is set, it is the only method that should run. 
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_METHOD	TokenNameIdentifier	 TEST  METHOD
;	TokenNameSEMICOLON	
/** Create indexes in this directory, optimally use a subdir, named after the test */	TokenNameCOMMENT_JAVADOC	 Create indexes in this directory, optimally use a subdir, named after the test 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
TEMP_DIR	TokenNameIdentifier	 TEMP  DIR
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
method	TokenNameIdentifier	 method
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"testmethod"	TokenNameStringLiteral	testmethod
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TEST_METHOD	TokenNameIdentifier	 TEST  METHOD
=	TokenNameEQUAL	
method	TokenNameIdentifier	 method
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
method	TokenNameIdentifier	 method
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tempDir"	TokenNameStringLiteral	tempDir
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"java.io.tmpdir"	TokenNameStringLiteral	java.io.tmpdir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'."	TokenNameStringLiteral	To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TEMP_DIR	TokenNameIdentifier	 TEMP  DIR
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TEMP_DIR	TokenNameIdentifier	 TEMP  DIR
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** set of directories we created, in afterclass we try to clean these up */	TokenNameCOMMENT_JAVADOC	 set of directories we created, in afterclass we try to clean these up 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
File	TokenNameIdentifier	 File
,	TokenNameCOMMA	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
tempDirs	TokenNameIdentifier	 temp Dirs
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
synchronizedMap	TokenNameIdentifier	 synchronized Map
(	TokenNameLPAREN	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
File	TokenNameIdentifier	 File
,	TokenNameCOMMA	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// by default we randomly pick a different codec for 	TokenNameCOMMENT_LINE	by default we randomly pick a different codec for 
// each test case (non-J4 tests) and each test class (J4 	TokenNameCOMMENT_LINE	each test case (non-J4 tests) and each test class (J4 
// tests) 	TokenNameCOMMENT_LINE	tests) 
/** Gets the locale to run tests with */	TokenNameCOMMENT_JAVADOC	 Gets the locale to run tests with 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_LOCALE	TokenNameIdentifier	 TEST  LOCALE
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.locale"	TokenNameStringLiteral	tests.locale
,	TokenNameCOMMA	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Gets the timezone to run tests with */	TokenNameCOMMENT_JAVADOC	 Gets the timezone to run tests with 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_TIMEZONE	TokenNameIdentifier	 TEST  TIMEZONE
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.timezone"	TokenNameStringLiteral	tests.timezone
,	TokenNameCOMMA	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Gets the directory to run tests with */	TokenNameCOMMENT_JAVADOC	 Gets the directory to run tests with 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.directory"	TokenNameStringLiteral	tests.directory
,	TokenNameCOMMA	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Get the number of times to run tests */	TokenNameCOMMENT_JAVADOC	 Get the number of times to run tests 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TEST_ITER	TokenNameIdentifier	 TEST  ITER
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.iter"	TokenNameStringLiteral	tests.iter
,	TokenNameCOMMA	
"1"	TokenNameStringLiteral	1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Get the minimum number of times to run tests until a failure happens */	TokenNameCOMMENT_JAVADOC	 Get the minimum number of times to run tests until a failure happens 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TEST_ITER_MIN	TokenNameIdentifier	 TEST  ITER  MIN
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.iter.min"	TokenNameStringLiteral	tests.iter.min
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
TEST_ITER	TokenNameIdentifier	 TEST  ITER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Get the random seed for tests */	TokenNameCOMMENT_JAVADOC	 Get the random seed for tests 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_SEED	TokenNameIdentifier	 TEST  SEED
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.seed"	TokenNameStringLiteral	tests.seed
,	TokenNameCOMMA	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** whether or not nightly tests should run */	TokenNameCOMMENT_JAVADOC	 whether or not nightly tests should run 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
TEST_NIGHTLY	TokenNameIdentifier	 TEST  NIGHTLY
=	TokenNameEQUAL	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.nightly"	TokenNameStringLiteral	tests.nightly
,	TokenNameCOMMA	
"false"	TokenNameStringLiteral	false
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** the line file used by LineFileDocs */	TokenNameCOMMENT_JAVADOC	 the line file used by LineFileDocs 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_LINE_DOCS_FILE	TokenNameIdentifier	 TEST  LINE  DOCS  FILE
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.linedocsfile"	TokenNameStringLiteral	tests.linedocsfile
,	TokenNameCOMMA	
"europarl.lines.txt.gz"	TokenNameStringLiteral	europarl.lines.txt.gz
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** whether or not to clean threads between test invocations: "false", "perMethod", "perClass" */	TokenNameCOMMENT_JAVADOC	 whether or not to clean threads between test invocations: "false", "perMethod", "perClass" 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TEST_CLEAN_THREADS	TokenNameIdentifier	 TEST  CLEAN  THREADS
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.cleanthreads"	TokenNameStringLiteral	tests.cleanthreads
,	TokenNameCOMMA	
"perClass"	TokenNameStringLiteral	perClass
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * A random multiplier which you should use when writing random tests: * multiply it by the number of iterations */	TokenNameCOMMENT_JAVADOC	 A random multiplier which you should use when writing random tests: multiply it by the number of iterations 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.multiplier"	TokenNameStringLiteral	tests.multiplier
,	TokenNameCOMMA	
"1"	TokenNameStringLiteral	1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
savedBoolMaxClauseCount	TokenNameIdentifier	 saved Bool Max Clause Count
=	TokenNameEQUAL	
BooleanQuery	TokenNameIdentifier	 Boolean Query
.	TokenNameDOT	
getMaxClauseCount	TokenNameIdentifier	 get Max Clause Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
volatile	TokenNamevolatile	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
UncaughtExceptionHandler	TokenNameIdentifier	 Uncaught Exception Handler
savedUncaughtExceptionHandler	TokenNameIdentifier	 saved Uncaught Exception Handler
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
{	TokenNameLBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
Thread	TokenNameIdentifier	 Thread
thread	TokenNameIdentifier	 thread
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
Throwable	TokenNameIdentifier	 Throwable
exception	TokenNameIdentifier	 exception
;	TokenNameSEMICOLON	
public	TokenNamepublic	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
(	TokenNameLPAREN	
Thread	TokenNameIdentifier	 Thread
thread	TokenNameIdentifier	 thread
,	TokenNameCOMMA	
Throwable	TokenNameIdentifier	 Throwable
exception	TokenNameIdentifier	 exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
thread	TokenNameIdentifier	 thread
=	TokenNameEQUAL	
thread	TokenNameIdentifier	 thread
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
exception	TokenNameIdentifier	 exception
=	TokenNameEQUAL	
exception	TokenNameIdentifier	 exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
>	TokenNameGREATER	
uncaughtExceptions	TokenNameIdentifier	 uncaught Exceptions
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
synchronizedList	TokenNameIdentifier	 synchronized List
(	TokenNameLPAREN	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
Locale	TokenNameIdentifier	 Locale
savedLocale	TokenNameIdentifier	 saved Locale
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
TimeZone	TokenNameIdentifier	 Time Zone
timeZone	TokenNameIdentifier	 time Zone
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
TimeZone	TokenNameIdentifier	 Time Zone
savedTimeZone	TokenNameIdentifier	 saved Time Zone
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
,	TokenNameCOMMA	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
stores	TokenNameIdentifier	 stores
;	TokenNameSEMICOLON	
/** @deprecated: until we fix no-fork problems in solr tests */	TokenNameCOMMENT_JAVADOC	 @deprecated: until we fix no-fork problems in solr tests 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
testClassesRun	TokenNameIdentifier	 test Classes Run
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
initRandom	TokenNameIdentifier	 init Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
initialized	TokenNameIdentifier	 initialized
;	TokenNameSEMICOLON	
staticSeed	TokenNameIdentifier	 static Seed
=	TokenNameEQUAL	
"random"	TokenNameStringLiteral	random
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
TEST_SEED	TokenNameIdentifier	 TEST  SEED
)	TokenNameRPAREN	
?	TokenNameQUESTION	
seedRand	TokenNameIdentifier	 seed Rand
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
ThreeLongs	TokenNameIdentifier	 Three Longs
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
TEST_SEED	TokenNameIdentifier	 TEST  SEED
)	TokenNameRPAREN	
.	TokenNameDOT	
l1	TokenNameIdentifier	 l1
;	TokenNameSEMICOLON	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
setSeed	TokenNameIdentifier	 set Seed
(	TokenNameLPAREN	
staticSeed	TokenNameIdentifier	 static Seed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
icuTested	TokenNameIdentifier	 icu Tested
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
@	TokenNameAT	
BeforeClass	TokenNameIdentifier	 Before Class
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
beforeClassLuceneTestCaseJ4	TokenNameIdentifier	 before Class Lucene Test Case J4
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
initRandom	TokenNameIdentifier	 init Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempDirs	TokenNameIdentifier	 temp Dirs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stores	TokenNameIdentifier	 stores
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
synchronizedMap	TokenNameIdentifier	 synchronized Map
(	TokenNameLPAREN	
new	TokenNamenew	
IdentityHashMap	TokenNameIdentifier	 Identity Hash Map
<	TokenNameLESS	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
,	TokenNameCOMMA	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// enable this by default, for IDE consistency with ant tests (as its the default from ant) 	TokenNameCOMMENT_LINE	enable this by default, for IDE consistency with ant tests (as its the default from ant) 
// TODO: really should be in solr base classes, but some extend LTC directly. 	TokenNameCOMMENT_LINE	TODO: really should be in solr base classes, but some extend LTC directly. 
// we do this in beforeClass, because some tests currently disable it 	TokenNameCOMMENT_LINE	we do this in beforeClass, because some tests currently disable it 
if	TokenNameif	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"solr.directoryFactory"	TokenNameStringLiteral	solr.directoryFactory
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
"solr.directoryFactory"	TokenNameStringLiteral	solr.directoryFactory
,	TokenNameCOMMA	
"org.apache.solr.core.MockDirectoryFactory"	TokenNameStringLiteral	org.apache.solr.core.MockDirectoryFactory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this code consumes randoms where 4.0's lucenetestcase would: to make seeds work across both branches. 	TokenNameCOMMENT_LINE	this code consumes randoms where 4.0's lucenetestcase would: to make seeds work across both branches. 
// TODO: doesn't completely work, because what if we get mockrandom codec?! 	TokenNameCOMMENT_LINE	TODO: doesn't completely work, because what if we get mockrandom codec?! 
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// consume RandomCodecProvider's seed. 	TokenNameCOMMENT_LINE	consume RandomCodecProvider's seed. 
}	TokenNameRBRACE	
// end compatibility random-consumption 	TokenNameCOMMENT_LINE	end compatibility random-consumption 
savedLocale	TokenNameIdentifier	 saved Locale
=	TokenNameEQUAL	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// START hack to init ICU safely before we randomize locales. 	TokenNameCOMMENT_LINE	START hack to init ICU safely before we randomize locales. 
// ICU fails during classloading when a special Java7-only locale is the default 	TokenNameCOMMENT_LINE	ICU fails during classloading when a special Java7-only locale is the default 
// see: http://bugs.icu-project.org/trac/ticket/8734 	TokenNameCOMMENT_LINE	see: http://bugs.icu-project.org/trac/ticket/8734 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
icuTested	TokenNameIdentifier	 icu Tested
)	TokenNameRPAREN	
{	TokenNameLBRACE	
icuTested	TokenNameIdentifier	 icu Tested
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
setDefault	TokenNameIdentifier	 set Default
(	TokenNameLPAREN	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
US	TokenNameIdentifier	 US
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
"com.ibm.icu.util.ULocale"	TokenNameStringLiteral	com.ibm.icu.util.ULocale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
cnfe	TokenNameIdentifier	 cnfe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ignore if no ICU is in classpath 	TokenNameCOMMENT_LINE	ignore if no ICU is in classpath 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// END hack 	TokenNameCOMMENT_LINE	END hack 
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
TEST_LOCALE	TokenNameIdentifier	 TEST  LOCALE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
?	TokenNameQUESTION	
randomLocale	TokenNameIdentifier	 random Locale
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
:	TokenNameCOLON	
localeForName	TokenNameIdentifier	 locale For Name
(	TokenNameLPAREN	
TEST_LOCALE	TokenNameIdentifier	 TEST  LOCALE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
setDefault	TokenNameIdentifier	 set Default
(	TokenNameLPAREN	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
savedTimeZone	TokenNameIdentifier	 saved Time Zone
=	TokenNameEQUAL	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
timeZone	TokenNameIdentifier	 time Zone
=	TokenNameEQUAL	
TEST_TIMEZONE	TokenNameIdentifier	 TEST  TIMEZONE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
?	TokenNameQUESTION	
randomTimeZone	TokenNameIdentifier	 random Time Zone
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
:	TokenNameCOLON	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
getTimeZone	TokenNameIdentifier	 get Time Zone
(	TokenNameLPAREN	
TEST_TIMEZONE	TokenNameIdentifier	 TEST  TIMEZONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
setDefault	TokenNameIdentifier	 set Default
(	TokenNameLPAREN	
timeZone	TokenNameIdentifier	 time Zone
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
testsFailed	TokenNameIdentifier	 tests Failed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// verify assertions are enabled (do last, for smooth cleanup) 	TokenNameCOMMENT_LINE	verify assertions are enabled (do last, for smooth cleanup) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"tests.asserts.gracious"	TokenNameStringLiteral	tests.asserts.gracious
,	TokenNameCOMMA	
"false"	TokenNameStringLiteral	false
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertTrue	TokenNameIdentifier	 assert True
(	TokenNameLPAREN	
"assertions are not enabled!"	TokenNameStringLiteral	assertions are not enabled!
,	TokenNameCOMMA	
assertionsEnabled	TokenNameIdentifier	 assertions Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
AfterClass	TokenNameIdentifier	 After Class
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
afterClassLuceneTestCaseJ4	TokenNameIdentifier	 after Class Lucene Test Case J4
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Throwable	TokenNameIdentifier	 Throwable
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
"false"	TokenNameStringLiteral	false
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
TEST_CLEAN_THREADS	TokenNameIdentifier	 TEST  CLEAN  THREADS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
rogueThreads	TokenNameIdentifier	 rogue Threads
=	TokenNameEQUAL	
threadCleanup	TokenNameIdentifier	 thread Cleanup
(	TokenNameLPAREN	
"test class"	TokenNameStringLiteral	test class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rogueThreads	TokenNameIdentifier	 rogue Threads
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: fail here once the leaks are fixed. 	TokenNameCOMMENT_LINE	TODO: fail here once the leaks are fixed. 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"RESOURCE LEAK: test class left "	TokenNameStringLiteral	RESOURCE LEAK: test class left 
+	TokenNamePLUS	
rogueThreads	TokenNameIdentifier	 rogue Threads
+	TokenNamePLUS	
" thread(s) running"	TokenNameStringLiteral	 thread(s) running
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
setDefault	TokenNameIdentifier	 set Default
(	TokenNameLPAREN	
savedLocale	TokenNameIdentifier	 saved Locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
setDefault	TokenNameIdentifier	 set Default
(	TokenNameLPAREN	
savedTimeZone	TokenNameIdentifier	 saved Time Zone
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
clearProperty	TokenNameIdentifier	 clear Property
(	TokenNameLPAREN	
"solr.solr.home"	TokenNameStringLiteral	solr.solr.home
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
clearProperty	TokenNameIdentifier	 clear Property
(	TokenNameLPAREN	
"solr.data.dir"	TokenNameStringLiteral	solr.data.dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// now look for unclosed resources 	TokenNameCOMMENT_LINE	now look for unclosed resources 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
testsFailed	TokenNameIdentifier	 tests Failed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkResourcesAfterClass	TokenNameIdentifier	 check Resources After Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stores	TokenNameIdentifier	 stores
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// clear out any temp directories if we can 	TokenNameCOMMENT_LINE	clear out any temp directories if we can 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
testsFailed	TokenNameIdentifier	 tests Failed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
clearTempDirectoriesAfterClass	TokenNameIdentifier	 clear Temp Directories After Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we had afterClass failures, get some debugging information 	TokenNameCOMMENT_LINE	if we had afterClass failures, get some debugging information 
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportPartialFailureInfo	TokenNameIdentifier	 report Partial Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if verbose or tests failed, report some information back 	TokenNameCOMMENT_LINE	if verbose or tests failed, report some information back 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
||	TokenNameOR_OR	
testsFailed	TokenNameIdentifier	 tests Failed
||	TokenNameOR_OR	
problem	TokenNameIdentifier	 problem
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
printDebuggingInformation	TokenNameIdentifier	 print Debugging Information
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset seed 	TokenNameCOMMENT_LINE	reset seed 
random	TokenNameIdentifier	 random
.	TokenNameDOT	
setSeed	TokenNameIdentifier	 set Seed
(	TokenNameLPAREN	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
initialized	TokenNameIdentifier	 initialized
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** print some useful debugging information about the environment */	TokenNameCOMMENT_JAVADOC	 print some useful debugging information about the environment 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
printDebuggingInformation	TokenNameIdentifier	 print Debugging Information
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: test params are: "	TokenNameStringLiteral	NOTE: test params are: 
+	TokenNamePLUS	
"locale="	TokenNameStringLiteral	locale=
+	TokenNamePLUS	
locale	TokenNameIdentifier	 locale
+	TokenNamePLUS	
", timezone="	TokenNameStringLiteral	, timezone=
+	TokenNamePLUS	
(	TokenNameLPAREN	
timeZone	TokenNameIdentifier	 time Zone
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"(null)"	TokenNameStringLiteral	(null)
:	TokenNameCOLON	
timeZone	TokenNameIdentifier	 time Zone
.	TokenNameDOT	
getID	TokenNameIdentifier	 get ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: all tests run in this JVM:"	TokenNameStringLiteral	NOTE: all tests run in this JVM:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
testClassesRun	TokenNameIdentifier	 test Classes Run
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: "	TokenNameStringLiteral	NOTE: 
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"os.name"	TokenNameStringLiteral	os.name
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"os.version"	TokenNameStringLiteral	os.version
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"os.arch"	TokenNameStringLiteral	os.arch
)	TokenNameRPAREN	
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"java.vendor"	TokenNameStringLiteral	java.vendor
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"java.version"	TokenNameStringLiteral	java.version
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JRE_IS_64BIT	TokenNameIdentifier	 JRE  IS 64 BIT
?	TokenNameQUESTION	
"(64-bit)"	TokenNameStringLiteral	(64-bit)
:	TokenNameCOLON	
"(32-bit)"	TokenNameStringLiteral	(32-bit)
)	TokenNameRPAREN	
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
"cpus="	TokenNameStringLiteral	cpus=
+	TokenNamePLUS	
Runtime	TokenNameIdentifier	 Runtime
.	TokenNameDOT	
getRuntime	TokenNameIdentifier	 get Runtime
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
availableProcessors	TokenNameIdentifier	 available Processors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
"threads="	TokenNameStringLiteral	threads=
+	TokenNamePLUS	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
activeCount	TokenNameIdentifier	 active Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
"free="	TokenNameStringLiteral	free=
+	TokenNamePLUS	
Runtime	TokenNameIdentifier	 Runtime
.	TokenNameDOT	
getRuntime	TokenNameIdentifier	 get Runtime
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
freeMemory	TokenNameIdentifier	 free Memory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
"total="	TokenNameStringLiteral	total=
+	TokenNamePLUS	
Runtime	TokenNameIdentifier	 Runtime
.	TokenNameDOT	
getRuntime	TokenNameIdentifier	 get Runtime
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
totalMemory	TokenNameIdentifier	 total Memory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** check that directories and their resources were closed */	TokenNameCOMMENT_JAVADOC	 check that directories and their resources were closed 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
checkResourcesAfterClass	TokenNameIdentifier	 check Resources After Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
d	TokenNameIdentifier	 d
:	TokenNameCOLON	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
isOpen	TokenNameIdentifier	 is Open
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Look for the first class that is not LuceneTestCase that requested 	TokenNameCOMMENT_LINE	Look for the first class that is not LuceneTestCase that requested 
// a Directory. The first two items are of Thread's, so skipping over 	TokenNameCOMMENT_LINE	a Directory. The first two items are of Thread's, so skipping over 
// them. 	TokenNameCOMMENT_LINE	them. 
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
elements	TokenNameIdentifier	 elements
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
ste	TokenNameIdentifier	 ste
=	TokenNameEQUAL	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ste	TokenNameIdentifier	 ste
.	TokenNameDOT	
getClassName	TokenNameIdentifier	 get Class Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"LuceneTestCase"	TokenNameStringLiteral	LuceneTestCase
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
ste	TokenNameIdentifier	 ste
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"directory of test was not closed, opened from: "	TokenNameStringLiteral	directory of test was not closed, opened from: 
+	TokenNamePLUS	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** clear temp directories: this will fail if its not successful */	TokenNameCOMMENT_JAVADOC	 clear temp directories: this will fail if its not successful 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
clearTempDirectoriesAfterClass	TokenNameIdentifier	 clear Temp Directories After Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
File	TokenNameIdentifier	 File
,	TokenNameCOMMA	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
tempDirs	TokenNameIdentifier	 temp Dirs
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
rmDir	TokenNameIdentifier	 rm Dir
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"path "	TokenNameStringLiteral	path 
+	TokenNamePLUS	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" allocated from"	TokenNameStringLiteral	 allocated from
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// first two STE's are Java's 	TokenNameCOMMENT_LINE	first two STE's are Java's 
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
elements	TokenNameIdentifier	 elements
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
elements	TokenNameIdentifier	 elements
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StackTraceElement	TokenNameIdentifier	 Stack Trace Element
ste	TokenNameIdentifier	 ste
=	TokenNameEQUAL	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// print only our code's stack information 	TokenNameCOMMENT_LINE	print only our code's stack information 
if	TokenNameif	
(	TokenNameLPAREN	
ste	TokenNameIdentifier	 ste
.	TokenNameDOT	
getClassName	TokenNameIdentifier	 get Class Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"org.apache.lucene"	TokenNameStringLiteral	org.apache.lucene
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
ste	TokenNameIdentifier	 ste
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"could not remove temp dir: "	TokenNameStringLiteral	could not remove temp dir: 
+	TokenNamePLUS	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
static	TokenNamestatic	
boolean	TokenNameboolean	
testsFailed	TokenNameIdentifier	 tests Failed
;	TokenNameSEMICOLON	
/* true if any tests failed */	TokenNameCOMMENT_BLOCK	 true if any tests failed 
// This is how we get control when errors occur. 	TokenNameCOMMENT_LINE	This is how we get control when errors occur. 
// Think of this as start/end/success/failed 	TokenNameCOMMENT_LINE	Think of this as start/end/success/failed 
// events. 	TokenNameCOMMENT_LINE	events. 
@	TokenNameAT	
Rule	TokenNameIdentifier	 Rule
public	TokenNamepublic	
final	TokenNamefinal	
TestWatchman	TokenNameIdentifier	 Test Watchman
intercept	TokenNameIdentifier	 intercept
=	TokenNameEQUAL	
new	TokenNamenew	
TestWatchman	TokenNameIdentifier	 Test Watchman
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
failed	TokenNameIdentifier	 failed
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
FrameworkMethod	TokenNameIdentifier	 Framework Method
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// org.junit.internal.AssumptionViolatedException in older releases 	TokenNameCOMMENT_LINE	org.junit.internal.AssumptionViolatedException in older releases 
// org.junit.Assume.AssumptionViolatedException in recent ones 	TokenNameCOMMENT_LINE	org.junit.Assume.AssumptionViolatedException in recent ones 
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
"AssumptionViolatedException"	TokenNameStringLiteral	AssumptionViolatedException
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getCause	TokenNameIdentifier	 get Cause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
_TestIgnoredException	TokenNameIdentifier	 Test Ignored Exception
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getCause	TokenNameIdentifier	 get Cause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"NOTE: Assume failed in '"	TokenNameStringLiteral	NOTE: Assume failed in '
+	TokenNamePLUS	
method	TokenNameIdentifier	 method
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' (ignored):"	TokenNameStringLiteral	' (ignored):
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
testsFailed	TokenNameIdentifier	 tests Failed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
reportAdditionalFailureInfo	TokenNameIdentifier	 report Additional Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
failed	TokenNameIdentifier	 failed
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
starting	TokenNameIdentifier	 starting
(	TokenNameLPAREN	
FrameworkMethod	TokenNameIdentifier	 Framework Method
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set current method name for logging 	TokenNameCOMMENT_LINE	set current method name for logging 
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
method	TokenNameIdentifier	 method
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
starting	TokenNameIdentifier	 starting
(	TokenNameLPAREN	
method	TokenNameIdentifier	 method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * The thread executing the current test case. * @see #isTestThread() */	TokenNameCOMMENT_JAVADOC	 The thread executing the current test case. @see #isTestThread() 
volatile	TokenNamevolatile	
Thread	TokenNameIdentifier	 Thread
testCaseThread	TokenNameIdentifier	 test Case Thread
;	TokenNameSEMICOLON	
/** @see #testCaseThread */	TokenNameCOMMENT_JAVADOC	 @see #testCaseThread 
@	TokenNameAT	
Rule	TokenNameIdentifier	 Rule
public	TokenNamepublic	
final	TokenNamefinal	
MethodRule	TokenNameIdentifier	 Method Rule
setTestThread	TokenNameIdentifier	 set Test Thread
=	TokenNameEQUAL	
new	TokenNamenew	
MethodRule	TokenNameIdentifier	 Method Rule
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Statement	TokenNameIdentifier	 Statement
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
final	TokenNamefinal	
Statement	TokenNameIdentifier	 Statement
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
FrameworkMethod	TokenNameIdentifier	 Framework Method
fm	TokenNameIdentifier	 fm
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Statement	TokenNameIdentifier	 Statement
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Throwable	TokenNameIdentifier	 Throwable
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
testCaseThread	TokenNameIdentifier	 test Case Thread
=	TokenNameEQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
LuceneTestCase	TokenNameIdentifier	 Lucene Test Case
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
testCaseThread	TokenNameIdentifier	 test Case Thread
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
@	TokenNameAT	
Before	TokenNameIdentifier	 Before
public	TokenNamepublic	
void	TokenNamevoid	
setUp	TokenNameIdentifier	 set Up
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
seed	TokenNameIdentifier	 seed
=	TokenNameEQUAL	
"random"	TokenNameStringLiteral	random
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
TEST_SEED	TokenNameIdentifier	 TEST  SEED
)	TokenNameRPAREN	
?	TokenNameQUESTION	
seedRand	TokenNameIdentifier	 seed Rand
.	TokenNameDOT	
nextLong	TokenNameIdentifier	 next Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
ThreeLongs	TokenNameIdentifier	 Three Longs
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
TEST_SEED	TokenNameIdentifier	 TEST  SEED
)	TokenNameRPAREN	
.	TokenNameDOT	
l2	TokenNameIdentifier	 l2
;	TokenNameSEMICOLON	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
setSeed	TokenNameIdentifier	 set Seed
(	TokenNameLPAREN	
seed	TokenNameIdentifier	 seed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
savedUncaughtExceptionHandler	TokenNameIdentifier	 saved Uncaught Exception Handler
=	TokenNameEQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
getDefaultUncaughtExceptionHandler	TokenNameIdentifier	 get Default Uncaught Exception Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
setDefaultUncaughtExceptionHandler	TokenNameIdentifier	 set Default Uncaught Exception Handler
(	TokenNameLPAREN	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
UncaughtExceptionHandler	TokenNameIdentifier	 Uncaught Exception Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
uncaughtException	TokenNameIdentifier	 uncaught Exception
(	TokenNameLPAREN	
Thread	TokenNameIdentifier	 Thread
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
testsFailed	TokenNameIdentifier	 tests Failed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
uncaughtExceptions	TokenNameIdentifier	 uncaught Exceptions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
savedUncaughtExceptionHandler	TokenNameIdentifier	 saved Uncaught Exception Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
savedUncaughtExceptionHandler	TokenNameIdentifier	 saved Uncaught Exception Handler
.	TokenNameDOT	
uncaughtException	TokenNameIdentifier	 uncaught Exception
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
savedBoolMaxClauseCount	TokenNameIdentifier	 saved Bool Max Clause Count
=	TokenNameEQUAL	
BooleanQuery	TokenNameIdentifier	 Boolean Query
.	TokenNameDOT	
getMaxClauseCount	TokenNameIdentifier	 get Max Clause Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Forcible purges all cache entries from the FieldCache. * <p> * This method will be called by tearDown to clean up FieldCache.DEFAULT. * If a (poorly written) test has some expectation that the FieldCache * will persist across test methods (ie: a static IndexReader) this * method can be overridden to do nothing. * </p> * * @see FieldCache#purgeAllCaches() */	TokenNameCOMMENT_JAVADOC	 Forcible purges all cache entries from the FieldCache. <p> This method will be called by tearDown to clean up FieldCache.DEFAULT. If a (poorly written) test has some expectation that the FieldCache will persist across test methods (ie: a static IndexReader) this method can be overridden to do nothing. </p> * @see FieldCache#purgeAllCaches() 
protected	TokenNameprotected	
void	TokenNamevoid	
purgeFieldCache	TokenNameIdentifier	 purge Field Cache
(	TokenNameLPAREN	
final	TokenNamefinal	
FieldCache	TokenNameIdentifier	 Field Cache
fc	TokenNameIdentifier	 fc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fc	TokenNameIdentifier	 fc
.	TokenNameDOT	
purgeAllCaches	TokenNameIdentifier	 purge All Caches
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
getTestLabel	TokenNameIdentifier	 get Test Label
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"."	TokenNameStringLiteral	.
+	TokenNamePLUS	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
MergePolicy	TokenNameIdentifier	 Merge Policy
mp	TokenNameIdentifier	 mp
,	TokenNameCOMMA	
boolean	TokenNameboolean	
useCompound	TokenNameIdentifier	 use Compound
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mp	TokenNameIdentifier	 mp
instanceof	TokenNameinstanceof	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
)	TokenNameRPAREN	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
useCompound	TokenNameIdentifier	 use Compound
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
mp	TokenNameIdentifier	 mp
instanceof	TokenNameinstanceof	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
)	TokenNameRPAREN	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
useCompound	TokenNameIdentifier	 use Compound
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"MergePolicy (compound-file) not supported "	TokenNameStringLiteral	MergePolicy (compound-file) not supported 
+	TokenNamePLUS	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
MergePolicy	TokenNameIdentifier	 Merge Policy
mp	TokenNameIdentifier	 mp
,	TokenNameCOMMA	
int	TokenNameint	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mp	TokenNameIdentifier	 mp
instanceof	TokenNameinstanceof	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
)	TokenNameRPAREN	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
.	TokenNameDOT	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
mp	TokenNameIdentifier	 mp
instanceof	TokenNameinstanceof	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
)	TokenNameRPAREN	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
.	TokenNameDOT	
setMaxMergeAtOnce	TokenNameIdentifier	 set Max Merge At Once
(	TokenNameLPAREN	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
)	TokenNameRPAREN	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
.	TokenNameDOT	
setMaxMergeAtOnceExplicit	TokenNameIdentifier	 set Max Merge At Once Explicit
(	TokenNameLPAREN	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"MergePolicy not supported "	TokenNameStringLiteral	MergePolicy not supported 
+	TokenNamePLUS	
mp	TokenNameIdentifier	 mp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns true if and only if the calling thread is the primary thread * executing the test case. */	TokenNameCOMMENT_JAVADOC	 Returns true if and only if the calling thread is the primary thread executing the test case. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
isTestThread	TokenNameIdentifier	 is Test Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertNotNull	TokenNameIdentifier	 assert Not Null
(	TokenNameLPAREN	
"Test case thread not set?"	TokenNameStringLiteral	Test case thread not set?
,	TokenNameCOMMA	
testCaseThread	TokenNameIdentifier	 test Case Thread
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
testCaseThread	TokenNameIdentifier	 test Case Thread
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
After	TokenNameIdentifier	 After
public	TokenNamepublic	
void	TokenNamevoid	
tearDown	TokenNameIdentifier	 tear Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman 	TokenNameCOMMENT_LINE	NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman 
// does not know if something fails in tearDown. so we ensure this happens ourselves for now. 	TokenNameCOMMENT_LINE	does not know if something fails in tearDown. so we ensure this happens ourselves for now. 
// we can remove this if we upgrade to 4.8 	TokenNameCOMMENT_LINE	we can remove this if we upgrade to 4.8 
Throwable	TokenNameIdentifier	 Throwable
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
BooleanQuery	TokenNameIdentifier	 Boolean Query
.	TokenNameDOT	
setMaxClauseCount	TokenNameIdentifier	 set Max Clause Count
(	TokenNameLPAREN	
savedBoolMaxClauseCount	TokenNameIdentifier	 saved Bool Max Clause Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this won't throw any exceptions or fail the test 	TokenNameCOMMENT_LINE	this won't throw any exceptions or fail the test 
// if we change this, then change this logic 	TokenNameCOMMENT_LINE	if we change this, then change this logic 
checkRogueThreadsAfter	TokenNameIdentifier	 check Rogue Threads After
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// restore the default uncaught exception handler 	TokenNameCOMMENT_LINE	restore the default uncaught exception handler 
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
setDefaultUncaughtExceptionHandler	TokenNameIdentifier	 set Default Uncaught Exception Handler
(	TokenNameLPAREN	
savedUncaughtExceptionHandler	TokenNameIdentifier	 saved Uncaught Exception Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
checkUncaughtExceptionsAfter	TokenNameIdentifier	 check Uncaught Exceptions After
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// calling assertSaneFieldCaches here isn't as useful as having test 	TokenNameCOMMENT_LINE	calling assertSaneFieldCaches here isn't as useful as having test 
// classes call it directly from the scope where the index readers 	TokenNameCOMMENT_LINE	classes call it directly from the scope where the index readers 
// are used, because they could be gc'ed just before this tearDown 	TokenNameCOMMENT_LINE	are used, because they could be gc'ed just before this tearDown 
// method is called. 	TokenNameCOMMENT_LINE	method is called. 
// 	TokenNameCOMMENT_LINE	 
// But it's better then nothing. 	TokenNameCOMMENT_LINE	But it's better then nothing. 
// 	TokenNameCOMMENT_LINE	 
// If you are testing functionality that you know for a fact 	TokenNameCOMMENT_LINE	If you are testing functionality that you know for a fact 
// "violates" FieldCache sanity, then you should either explicitly 	TokenNameCOMMENT_LINE	"violates" FieldCache sanity, then you should either explicitly 
// call purgeFieldCache at the end of your test method, or refactor 	TokenNameCOMMENT_LINE	call purgeFieldCache at the end of your test method, or refactor 
// your Test class so that the inconsistant FieldCache usages are 	TokenNameCOMMENT_LINE	your Test class so that the inconsistant FieldCache usages are 
// isolated in distinct test methods 	TokenNameCOMMENT_LINE	isolated in distinct test methods 
assertSaneFieldCaches	TokenNameIdentifier	 assert Sane Field Caches
(	TokenNameLPAREN	
getTestLabel	TokenNameIdentifier	 get Test Label
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
problem	TokenNameIdentifier	 problem
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
purgeFieldCache	TokenNameIdentifier	 purge Field Cache
(	TokenNameLPAREN	
FieldCache	TokenNameIdentifier	 Field Cache
.	TokenNameDOT	
DEFAULT	TokenNameIdentifier	 DEFAULT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
testsFailed	TokenNameIdentifier	 tests Failed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
reportAdditionalFailureInfo	TokenNameIdentifier	 report Additional Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
problem	TokenNameIdentifier	 problem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** check if the test still has threads running, we don't want them to * fail in a subsequent test and pass the blame to the wrong test */	TokenNameCOMMENT_JAVADOC	 check if the test still has threads running, we don't want them to fail in a subsequent test and pass the blame to the wrong test 
private	TokenNameprivate	
void	TokenNamevoid	
checkRogueThreadsAfter	TokenNameIdentifier	 check Rogue Threads After
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
"perMethod"	TokenNameStringLiteral	perMethod
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
TEST_CLEAN_THREADS	TokenNameIdentifier	 TEST  CLEAN  THREADS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
rogueThreads	TokenNameIdentifier	 rogue Threads
=	TokenNameEQUAL	
threadCleanup	TokenNameIdentifier	 thread Cleanup
(	TokenNameLPAREN	
"test method: '"	TokenNameStringLiteral	test method: '
+	TokenNamePLUS	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
testsFailed	TokenNameIdentifier	 tests Failed
&&	TokenNameAND_AND	
rogueThreads	TokenNameIdentifier	 rogue Threads
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"RESOURCE LEAK: test method: '"	TokenNameStringLiteral	RESOURCE LEAK: test method: '
+	TokenNamePLUS	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"' left "	TokenNameStringLiteral	' left 
+	TokenNamePLUS	
rogueThreads	TokenNameIdentifier	 rogue Threads
+	TokenNamePLUS	
" thread(s) running"	TokenNameStringLiteral	 thread(s) running
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: fail, but print seed for now 	TokenNameCOMMENT_LINE	TODO: fail, but print seed for now 
if	TokenNameif	
(	TokenNameLPAREN	
uncaughtExceptions	TokenNameIdentifier	 uncaught Exceptions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportAdditionalFailureInfo	TokenNameIdentifier	 report Additional Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** see if any other threads threw uncaught exceptions, and fail the test if so */	TokenNameCOMMENT_JAVADOC	 see if any other threads threw uncaught exceptions, and fail the test if so 
private	TokenNameprivate	
void	TokenNamevoid	
checkUncaughtExceptionsAfter	TokenNameIdentifier	 check Uncaught Exceptions After
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
uncaughtExceptions	TokenNameIdentifier	 uncaught Exceptions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"The following exceptions were thrown by threads:"	TokenNameStringLiteral	The following exceptions were thrown by threads:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
UncaughtExceptionEntry	TokenNameIdentifier	 Uncaught Exception Entry
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
uncaughtExceptions	TokenNameIdentifier	 uncaught Exceptions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"*** Thread: "	TokenNameStringLiteral	*** Thread: 
+	TokenNamePLUS	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
thread	TokenNameIdentifier	 thread
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" ***"	TokenNameStringLiteral	 ***
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
exception	TokenNameIdentifier	 exception
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fail	TokenNameIdentifier	 fail
(	TokenNameLPAREN	
"Some threads threw uncaught exceptions!"	TokenNameStringLiteral	Some threads threw uncaught exceptions!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
THREAD_STOP_GRACE_MSEC	TokenNameIdentifier	 THREAD  STOP  GRACE  MSEC
=	TokenNameEQUAL	
50	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// jvm-wide list of 'rogue threads' we found, so they only get reported once. 	TokenNameCOMMENT_LINE	jvm-wide list of 'rogue threads' we found, so they only get reported once. 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
IdentityHashMap	TokenNameIdentifier	 Identity Hash Map
<	TokenNameLESS	
Thread	TokenNameIdentifier	 Thread
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
rogueThreads	TokenNameIdentifier	 rogue Threads
=	TokenNameEQUAL	
new	TokenNamenew	
IdentityHashMap	TokenNameIdentifier	 Identity Hash Map
<	TokenNameLESS	
Thread	TokenNameIdentifier	 Thread
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
// just a hack for things like eclipse test-runner threads 	TokenNameCOMMENT_LINE	just a hack for things like eclipse test-runner threads 
for	TokenNamefor	
(	TokenNameLPAREN	
Thread	TokenNameIdentifier	 Thread
t	TokenNameIdentifier	 t
:	TokenNameCOLON	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
getAllStackTraces	TokenNameIdentifier	 get All Stack Traces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rogueThreads	TokenNameIdentifier	 rogue Threads
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
TEST_ITER	TokenNameIdentifier	 TEST  ITER
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"WARNING: you are using -Dtests.iter=n where n > 1, not all tests support this option."	TokenNameStringLiteral	WARNING: you are using -Dtests.iter=n where n > 1, not all tests support this option.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Some may crash or fail: this is not a bug."	TokenNameStringLiteral	Some may crash or fail: this is not a bug.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Looks for leftover running threads, trying to kill them off, * so they don't fail future tests. * returns the number of rogue threads that it found. */	TokenNameCOMMENT_JAVADOC	 Looks for leftover running threads, trying to kill them off, so they don't fail future tests. returns the number of rogue threads that it found. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
threadCleanup	TokenNameIdentifier	 thread Cleanup
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// educated guess 	TokenNameCOMMENT_LINE	educated guess 
Thread	TokenNameIdentifier	 Thread
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stillRunning	TokenNameIdentifier	 still Running
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
[	TokenNameLBRACKET	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
activeCount	TokenNameIdentifier	 active Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
threadCount	TokenNameIdentifier	 thread Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
rogueCount	TokenNameIdentifier	 rogue Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
threadCount	TokenNameIdentifier	 thread Count
=	TokenNameEQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
enumerate	TokenNameIdentifier	 enumerate
(	TokenNameLPAREN	
stillRunning	TokenNameIdentifier	 still Running
)	TokenNameRPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
threadCount	TokenNameIdentifier	 thread Count
==	TokenNameEQUAL_EQUAL	
stillRunning	TokenNameIdentifier	 still Running
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// truncated response 	TokenNameCOMMENT_LINE	truncated response 
stillRunning	TokenNameIdentifier	 still Running
=	TokenNameEQUAL	
new	TokenNamenew	
Thread	TokenNameIdentifier	 Thread
[	TokenNameLBRACKET	
stillRunning	TokenNameIdentifier	 still Running
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
threadCount	TokenNameIdentifier	 thread Count
=	TokenNameEQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
enumerate	TokenNameIdentifier	 enumerate
(	TokenNameLPAREN	
stillRunning	TokenNameIdentifier	 still Running
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadCount	TokenNameIdentifier	 thread Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
stillRunning	TokenNameIdentifier	 still Running
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
isAlive	TokenNameIdentifier	 is Alive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
rogueThreads	TokenNameIdentifier	 rogue Threads
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
t	TokenNameIdentifier	 t
!=	TokenNameNOT_EQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
// TODO: TimeLimitingCollector starts a thread statically.... WTF?! 	TokenNameCOMMENT_LINE	TODO: TimeLimitingCollector starts a thread statically.... WTF?! 
!	TokenNameNOT	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"TimeLimitedCollector timer thread"	TokenNameStringLiteral	TimeLimitedCollector timer thread
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
/* its ok to keep your searcher across test cases */	TokenNameCOMMENT_BLOCK	 its ok to keep your searcher across test cases 
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"LuceneTestCase"	TokenNameStringLiteral	LuceneTestCase
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"test method"	TokenNameStringLiteral	test method
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
false	TokenNamefalse	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"WARNING: "	TokenNameStringLiteral	WARNING: 
+	TokenNamePLUS	
context	TokenNameIdentifier	 context
+	TokenNamePLUS	
" left thread running: "	TokenNameStringLiteral	 left thread running: 
+	TokenNamePLUS	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rogueThreads	TokenNameIdentifier	 rogue Threads
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rogueCount	TokenNameIdentifier	 rogue Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"LuceneTestCase"	TokenNameStringLiteral	LuceneTestCase
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"PLEASE CLOSE YOUR INDEXSEARCHERS IN YOUR TEST!!!!"	TokenNameStringLiteral	PLEASE CLOSE YOUR INDEXSEARCHERS IN YOUR TEST!!!!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// wait on the thread to die of natural causes 	TokenNameCOMMENT_LINE	wait on the thread to die of natural causes 
try	TokenNametry	
{	TokenNameLBRACE	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
THREAD_STOP_GRACE_MSEC	TokenNameIdentifier	 THREAD  STOP  GRACE  MSEC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// try to stop the thread: 	TokenNameCOMMENT_LINE	try to stop the thread: 
t	TokenNameIdentifier	 t
.	TokenNameDOT	
setUncaughtExceptionHandler	TokenNameIdentifier	 set Uncaught Exception Handler
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
setDefaultUncaughtExceptionHandler	TokenNameIdentifier	 set Default Uncaught Exception Handler
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
interrupt	TokenNameIdentifier	 interrupt
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
rogueCount	TokenNameIdentifier	 rogue Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Asserts that FieldCacheSanityChecker does not detect any * problems with FieldCache.DEFAULT. * <p> * If any problems are found, they are logged to System.err * (allong with the msg) when the Assertion is thrown. * </p> * <p> * This method is called by tearDown after every test method, * however IndexReaders scoped inside test methods may be garbage * collected prior to this method being called, causing errors to * be overlooked. Tests are encouraged to keep their IndexReaders * scoped at the class level, or to explicitly call this method * directly in the same scope as the IndexReader. * </p> * * @see org.apache.lucene.util.FieldCacheSanityChecker */	TokenNameCOMMENT_JAVADOC	 Asserts that FieldCacheSanityChecker does not detect any problems with FieldCache.DEFAULT. <p> If any problems are found, they are logged to System.err (allong with the msg) when the Assertion is thrown. </p> <p> This method is called by tearDown after every test method, however IndexReaders scoped inside test methods may be garbage collected prior to this method being called, causing errors to be overlooked. Tests are encouraged to keep their IndexReaders scoped at the class level, or to explicitly call this method directly in the same scope as the IndexReader. </p> * @see org.apache.lucene.util.FieldCacheSanityChecker 
protected	TokenNameprotected	
void	TokenNamevoid	
assertSaneFieldCaches	TokenNameIdentifier	 assert Sane Field Caches
(	TokenNameLPAREN	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
CacheEntry	TokenNameIdentifier	 Cache Entry
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
FieldCache	TokenNameIdentifier	 Field Cache
.	TokenNameDOT	
DEFAULT	TokenNameIdentifier	 DEFAULT
.	TokenNameDOT	
getCacheEntries	TokenNameIdentifier	 get Cache Entries
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Insanity	TokenNameIdentifier	 Insanity
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
insanity	TokenNameIdentifier	 insanity
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
insanity	TokenNameIdentifier	 insanity
=	TokenNameEQUAL	
FieldCacheSanityChecker	TokenNameIdentifier	 Field Cache Sanity Checker
.	TokenNameDOT	
checkSanity	TokenNameIdentifier	 check Sanity
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RuntimeException	TokenNameIdentifier	 Runtime Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dumpArray	TokenNameIdentifier	 dump Array
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
+	TokenNamePLUS	
": FieldCache"	TokenNameStringLiteral	: FieldCache
,	TokenNameCOMMA	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
+	TokenNamePLUS	
": Insane FieldCache usage(s) found"	TokenNameStringLiteral	: Insane FieldCache usage(s) found
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
insanity	TokenNameIdentifier	 insanity
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
insanity	TokenNameIdentifier	 insanity
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// report this in the event of any exception/failure 	TokenNameCOMMENT_LINE	report this in the event of any exception/failure 
// if no failure, then insanity will be null anyway 	TokenNameCOMMENT_LINE	if no failure, then insanity will be null anyway 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
insanity	TokenNameIdentifier	 insanity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dumpArray	TokenNameIdentifier	 dump Array
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
+	TokenNamePLUS	
": Insane FieldCache usage(s)"	TokenNameStringLiteral	: Insane FieldCache usage(s)
,	TokenNameCOMMA	
insanity	TokenNameIdentifier	 insanity
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns a number of at least <code>i</code> * <p> * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY} * is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge. */	TokenNameCOMMENT_JAVADOC	 Returns a number of at least <code>i</code> <p> The actual number returned will be influenced by whether {@link #TEST_NIGHTLY} is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge. 
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TEST_NIGHTLY	TokenNameIdentifier	 TEST  NIGHTLY
?	TokenNameQUESTION	
3	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
i	TokenNameIdentifier	 i
:	TokenNameCOLON	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
;	TokenNameSEMICOLON	
int	TokenNameint	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
min	TokenNameIdentifier	 min
+	TokenNamePLUS	
(	TokenNameLPAREN	
min	TokenNameIdentifier	 min
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
min	TokenNameIdentifier	 min
,	TokenNameCOMMA	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
int	TokenNameint	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
atLeast	TokenNameIdentifier	 at Least
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if something should happen rarely, * <p> * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY} * is active and {@link #RANDOM_MULTIPLIER}. */	TokenNameCOMMENT_JAVADOC	 Returns true if something should happen rarely, <p> The actual number returned will be influenced by whether {@link #TEST_NIGHTLY} is active and {@link #RANDOM_MULTIPLIER}. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
TEST_NIGHTLY	TokenNameIdentifier	 TEST  NIGHTLY
?	TokenNameQUESTION	
10	TokenNameIntegerLiteral	
:	TokenNameCOLON	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
*	TokenNameMULTIPLY	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
100	TokenNameIntegerLiteral	
-	TokenNameMINUS	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
,	TokenNameCOMMA	
50	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// never more than 50 	TokenNameCOMMENT_LINE	never more than 50 
return	TokenNamereturn	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
min	TokenNameIdentifier	 min
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
usually	TokenNameIdentifier	 usually
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
!	TokenNameNOT	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
usually	TokenNameIdentifier	 usually
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
usually	TokenNameIdentifier	 usually
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// These deprecated methods should be removed soon, when all tests using no Epsilon are fixed: 	TokenNameCOMMENT_LINE	These deprecated methods should be removed soon, when all tests using no Epsilon are fixed: 
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
static	TokenNamestatic	
public	TokenNamepublic	
void	TokenNamevoid	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
double	TokenNamedouble	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
double	TokenNamedouble	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
static	TokenNamestatic	
public	TokenNamepublic	
void	TokenNamevoid	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
double	TokenNamedouble	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
double	TokenNamedouble	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
static	TokenNamestatic	
public	TokenNamepublic	
void	TokenNamevoid	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
float	TokenNamefloat	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
float	TokenNamefloat	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Deprecated	TokenNameIdentifier	 Deprecated
static	TokenNamestatic	
public	TokenNamepublic	
void	TokenNamevoid	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
float	TokenNamefloat	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
float	TokenNamefloat	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assertEquals	TokenNameIdentifier	 assert Equals
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
actual	TokenNameIdentifier	 actual
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
assumeTrue	TokenNameIdentifier	 assume True
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Assume	TokenNameIdentifier	 Assume
.	TokenNameDOT	
assumeNoException	TokenNameIdentifier	 assume No Exception
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
_TestIgnoredException	TokenNameIdentifier	 Test Ignored Exception
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
assumeFalse	TokenNameIdentifier	 assume False
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assumeTrue	TokenNameIdentifier	 assume True
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
!	TokenNameNOT	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
assumeNoException	TokenNameIdentifier	 assume No Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Assume	TokenNameIdentifier	 Assume
.	TokenNameDOT	
assumeNoException	TokenNameIdentifier	 assume No Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
_TestIgnoredException	TokenNameIdentifier	 Test Ignored Exception
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method for logging an iterator. * * @param label String logged before/after the items in the iterator * @param iter Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator. * @param stream Stream to log messages to. */	TokenNameCOMMENT_JAVADOC	 Convenience method for logging an iterator. * @param label String logged before/after the items in the iterator @param iter Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator. @param stream Stream to log messages to. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
dumpIterator	TokenNameIdentifier	 dump Iterator
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
,	TokenNameCOMMA	
PrintStream	TokenNameIdentifier	 Print Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"*** BEGIN "	TokenNameStringLiteral	*** BEGIN 
+	TokenNamePLUS	
label	TokenNameIdentifier	 label
+	TokenNamePLUS	
" ***"	TokenNameStringLiteral	 ***
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" ... NULL ..."	TokenNameStringLiteral	 ... NULL ...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
stream	TokenNameIdentifier	 stream
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"*** END "	TokenNameStringLiteral	*** END 
+	TokenNamePLUS	
label	TokenNameIdentifier	 label
+	TokenNamePLUS	
" ***"	TokenNameStringLiteral	 ***
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convenience method for logging an array. Wraps the array in an iterator and delegates * * @see #dumpIterator(String,Iterator,PrintStream) */	TokenNameCOMMENT_JAVADOC	 Convenience method for logging an array. Wraps the array in an iterator and delegates * @see #dumpIterator(String,Iterator,PrintStream) 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
dumpArray	TokenNameIdentifier	 dump Array
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
objs	TokenNameIdentifier	 objs
,	TokenNameCOMMA	
PrintStream	TokenNameIdentifier	 Print Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
objs	TokenNameIdentifier	 objs
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
objs	TokenNameIdentifier	 objs
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dumpIterator	TokenNameIdentifier	 dump Iterator
(	TokenNameLPAREN	
label	TokenNameIdentifier	 label
,	TokenNameCOMMA	
iter	TokenNameIdentifier	 iter
,	TokenNameCOMMA	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** create a new index writer config with random defaults */	TokenNameCOMMENT_JAVADOC	 create a new index writer config with random defaults 
public	TokenNamepublic	
static	TokenNamestatic	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
Version	TokenNameIdentifier	 Version
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** create a new index writer config with random defaults using the specified random */	TokenNameCOMMENT_JAVADOC	 create a new index writer config with random defaults using the specified random 
public	TokenNamepublic	
static	TokenNamestatic	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
newIndexWriterConfig	TokenNameIdentifier	 new Index Writer Config
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
Version	TokenNameIdentifier	 Version
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
new	TokenNamenew	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
newTieredMergePolicy	TokenNameIdentifier	 new Tiered Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
new	TokenNamenew	
MockRandomMergePolicy	TokenNameIdentifier	 Mock Random Merge Policy
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergeScheduler	TokenNameIdentifier	 set Merge Scheduler
(	TokenNameLPAREN	
new	TokenNamenew	
SerialMergeScheduler	TokenNameIdentifier	 Serial Merge Scheduler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// crazy value 	TokenNameCOMMENT_LINE	crazy value 
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMaxBufferedDocs	TokenNameIdentifier	 set Max Buffered Docs
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// reasonable value 	TokenNameCOMMENT_LINE	reasonable value 
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMaxBufferedDocs	TokenNameIdentifier	 set Max Buffered Docs
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// crazy value 	TokenNameCOMMENT_LINE	crazy value 
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setTermIndexInterval	TokenNameIdentifier	 set Term Index Interval
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
31	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
129	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// reasonable value 	TokenNameCOMMENT_LINE	reasonable value 
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setTermIndexInterval	TokenNameIdentifier	 set Term Index Interval
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMaxThreadStates	TokenNameIdentifier	 set Max Thread States
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
new	TokenNamenew	
MockRandomMergePolicy	TokenNameIdentifier	 Mock Random Merge Policy
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setMergePolicy	TokenNameIdentifier	 set Merge Policy
(	TokenNameLPAREN	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setReaderPooling	TokenNameIdentifier	 set Reader Pooling
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
setReaderTermsIndexDivisor	TokenNameIdentifier	 set Reader Terms Index Divisor
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
newTieredMergePolicy	TokenNameIdentifier	 new Tiered Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newTieredMergePolicy	TokenNameIdentifier	 new Tiered Merge Policy
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
logmp	TokenNameIdentifier	 logmp
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
LogDocMergePolicy	TokenNameIdentifier	 Log Doc Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
LogByteSizeMergePolicy	TokenNameIdentifier	 Log Byte Size Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setCalibrateSizeByDeletes	TokenNameIdentifier	 set Calibrate Size By Deletes
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
50	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
logmp	TokenNameIdentifier	 logmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
newTieredMergePolicy	TokenNameIdentifier	 new Tiered Merge Policy
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
new	TokenNamenew	
TieredMergePolicy	TokenNameIdentifier	 Tiered Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setMaxMergeAtOnce	TokenNameIdentifier	 set Max Merge At Once
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setMaxMergeAtOnceExplicit	TokenNameIdentifier	 set Max Merge At Once Explicit
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setMaxMergeAtOnce	TokenNameIdentifier	 set Max Merge At Once
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
50	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setMaxMergeAtOnceExplicit	TokenNameIdentifier	 set Max Merge At Once Explicit
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
50	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setMaxMergedSegmentMB	TokenNameIdentifier	 set Max Merged Segment MB
(	TokenNameLPAREN	
0.2	TokenNameDoubleLiteral	
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setFloorSegmentMB	TokenNameIdentifier	 set Floor Segment MB
(	TokenNameLPAREN	
0.2	TokenNameDoubleLiteral	
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setForceMergeDeletesPctAllowed	TokenNameIdentifier	 set Force Merge Deletes Pct Allowed
(	TokenNameLPAREN	
0.0	TokenNameDoubleLiteral	
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
30.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setSegmentsPerTier	TokenNameIdentifier	 set Segments Per Tier
(	TokenNameLPAREN	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setNoCFSRatio	TokenNameIdentifier	 set No CFS Ratio
(	TokenNameLPAREN	
0.1	TokenNameDoubleLiteral	
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
0.8	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
setReclaimDeletesWeight	TokenNameIdentifier	 set Reclaim Deletes Weight
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
nextDouble	TokenNameIdentifier	 next Double
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
boolean	TokenNameboolean	
useCFS	TokenNameIdentifier	 use CFS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
logmp	TokenNameIdentifier	 logmp
=	TokenNameEQUAL	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
useCFS	TokenNameIdentifier	 use CFS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
logmp	TokenNameIdentifier	 logmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
boolean	TokenNameboolean	
useCFS	TokenNameIdentifier	 use CFS
,	TokenNameCOMMA	
int	TokenNameint	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
logmp	TokenNameIdentifier	 logmp
=	TokenNameEQUAL	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
useCFS	TokenNameIdentifier	 use CFS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
logmp	TokenNameIdentifier	 logmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
int	TokenNameint	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LogMergePolicy	TokenNameIdentifier	 Log Merge Policy
logmp	TokenNameIdentifier	 logmp
=	TokenNameEQUAL	
newLogMergePolicy	TokenNameIdentifier	 new Log Merge Policy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logmp	TokenNameIdentifier	 logmp
.	TokenNameDOT	
setMergeFactor	TokenNameIdentifier	 set Merge Factor
(	TokenNameLPAREN	
mergeFactor	TokenNameIdentifier	 merge Factor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
logmp	TokenNameIdentifier	 logmp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new Directory instance. Use this when the test does not * care about the specific Directory implementation (most tests). * <p> * The Directory is wrapped with {@link MockDirectoryWrapper}. * By default this means it will be picky, such as ensuring that you * properly close it and all open files in your test. It will emulate * some features of Windows, such as not allowing open files to be * overwritten. */	TokenNameCOMMENT_JAVADOC	 Returns a new Directory instance. Use this when the test does not care about the specific Directory implementation (most tests). <p> The Directory is wrapped with {@link MockDirectoryWrapper}. By default this means it will be picky, such as ensuring that you properly close it and all open files in your test. It will emulate some features of Windows, such as not allowing open files to be overwritten. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new Directory instance, using the specified random. * See {@link #newDirectory()} for more information. */	TokenNameCOMMENT_JAVADOC	 Returns a new Directory instance, using the specified random. See {@link #newDirectory()} for more information. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
impl	TokenNameIdentifier	 impl
=	TokenNameEQUAL	
newDirectoryImpl	TokenNameIdentifier	 new Directory Impl
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
impl	TokenNameIdentifier	 impl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getStackTrace	TokenNameIdentifier	 get Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new Directory instance, with contents copied from the * provided directory. See {@link #newDirectory()} for more * information. */	TokenNameCOMMENT_JAVADOC	 Returns a new Directory instance, with contents copied from the provided directory. See {@link #newDirectory()} for more information. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new FSDirectory instance over the given file, which must be a folder. */	TokenNameCOMMENT_JAVADOC	 Returns a new FSDirectory instance over the given file, which must be a folder. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newFSDirectory	TokenNameIdentifier	 new FS Directory
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
newFSDirectory	TokenNameIdentifier	 new FS Directory
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new FSDirectory instance over the given file, which must be a folder. */	TokenNameCOMMENT_JAVADOC	 Returns a new FSDirectory instance over the given file, which must be a folder. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newFSDirectory	TokenNameIdentifier	 new FS Directory
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
LockFactory	TokenNameIdentifier	 Lock Factory
lf	TokenNameIdentifier	 lf
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fsdirClass	TokenNameIdentifier	 fsdir Class
=	TokenNameEQUAL	
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fsdirClass	TokenNameIdentifier	 fsdir Class
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fsdirClass	TokenNameIdentifier	 fsdir Class
=	TokenNameEQUAL	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fsdirClass	TokenNameIdentifier	 fsdir Class
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"."	TokenNameStringLiteral	.
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if not fully qualified, assume .store 	TokenNameCOMMENT_LINE	if not fully qualified, assume .store 
fsdirClass	TokenNameIdentifier	 fsdir Class
=	TokenNameEQUAL	
"org.apache.lucene.store."	TokenNameStringLiteral	org.apache.lucene.store.
+	TokenNamePLUS	
fsdirClass	TokenNameIdentifier	 fsdir Class
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Class	TokenNameIdentifier	 Class
<	TokenNameLESS	
?	TokenNameQUESTION	
extends	TokenNameextends	
FSDirectory	TokenNameIdentifier	 FS Directory
>	TokenNameGREATER	
clazz	TokenNameIdentifier	 clazz
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
clazz	TokenNameIdentifier	 clazz
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
fsdirClass	TokenNameIdentifier	 fsdir Class
)	TokenNameRPAREN	
.	TokenNameDOT	
asSubclass	TokenNameIdentifier	 as Subclass
(	TokenNameLPAREN	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ClassCastException	TokenNameIdentifier	 Class Cast Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random 	TokenNameCOMMENT_LINE	TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random 
fsdirClass	TokenNameIdentifier	 fsdir Class
=	TokenNameEQUAL	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fsdirClass	TokenNameIdentifier	 fsdir Class
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"."	TokenNameStringLiteral	.
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if not fully qualified, assume .store 	TokenNameCOMMENT_LINE	if not fully qualified, assume .store 
fsdirClass	TokenNameIdentifier	 fsdir Class
=	TokenNameEQUAL	
"org.apache.lucene.store."	TokenNameStringLiteral	org.apache.lucene.store.
+	TokenNamePLUS	
fsdirClass	TokenNameIdentifier	 fsdir Class
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clazz	TokenNameIdentifier	 clazz
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
fsdirClass	TokenNameIdentifier	 fsdir Class
)	TokenNameRPAREN	
.	TokenNameDOT	
asSubclass	TokenNameIdentifier	 as Subclass
(	TokenNameLPAREN	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
newFSDirectoryImpl	TokenNameIdentifier	 new FS Directory Impl
(	TokenNameLPAREN	
clazz	TokenNameIdentifier	 clazz
,	TokenNameCOMMA	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lf	TokenNameIdentifier	 lf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
setLockFactory	TokenNameIdentifier	 set Lock Factory
(	TokenNameLPAREN	
lf	TokenNameIdentifier	 lf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getStackTrace	TokenNameIdentifier	 get Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns a new Directory instance, using the specified random * with contents copied from the provided directory. See * {@link #newDirectory()} for more information. */	TokenNameCOMMENT_JAVADOC	 Returns a new Directory instance, using the specified random with contents copied from the provided directory. See {@link #newDirectory()} for more information. 
public	TokenNamepublic	
static	TokenNamestatic	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
newDirectory	TokenNameIdentifier	 new Directory
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
Directory	TokenNameIdentifier	 Directory
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Directory	TokenNameIdentifier	 Directory
impl	TokenNameIdentifier	 impl
=	TokenNameEQUAL	
newDirectoryImpl	TokenNameIdentifier	 new Directory Impl
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
file	TokenNameIdentifier	 file
:	TokenNameCOLON	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
listAll	TokenNameIdentifier	 list All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
impl	TokenNameIdentifier	 impl
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
new	TokenNamenew	
MockDirectoryWrapper	TokenNameIdentifier	 Mock Directory Wrapper
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
impl	TokenNameIdentifier	 impl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stores	TokenNameIdentifier	 stores
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getStackTrace	TokenNameIdentifier	 get Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new field instance. * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */	TokenNameCOMMENT_JAVADOC	 Returns a new field instance. See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new field instance. * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */	TokenNameCOMMENT_JAVADOC	 Returns a new field instance. See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a new Field instance. Use this when the test does not * care about some specific field settings (most tests) * <ul> * <li>If the store value is set to Store.NO, sometimes the field will be randomly stored. * <li>More term vector data than you ask for might be indexed, for example if you choose YES * it might index term vectors with offsets too. * </ul> */	TokenNameCOMMENT_JAVADOC	 Returns a new Field instance. Use this when the test does not care about some specific field settings (most tests) <ul> <li>If the store value is set to Store.NO, sometimes the field will be randomly stored. <li>More term vector data than you ask for might be indexed, for example if you choose YES it might index term vectors with offsets too. </ul> 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new field instance, using the specified random. * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */	TokenNameCOMMENT_JAVADOC	 Returns a new field instance, using the specified random. See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new field instance, using the specified random. * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */	TokenNameCOMMENT_JAVADOC	 Returns a new field instance, using the specified random. See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a new field instance, using the specified random. * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */	TokenNameCOMMENT_JAVADOC	 Returns a new field instance, using the specified random. See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information 
public	TokenNamepublic	
static	TokenNamestatic	
Field	TokenNameIdentifier	 Field
newField	TokenNameIdentifier	 new Field
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
Store	TokenNameIdentifier	 Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Index	TokenNameIdentifier	 Index
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
usually	TokenNameIdentifier	 usually
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// most of the time, don't modify the params 	TokenNameCOMMENT_LINE	most of the time, don't modify the params 
return	TokenNamereturn	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
isIndexed	TokenNameIdentifier	 is Indexed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
isStored	TokenNameIdentifier	 is Stored
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
store	TokenNameIdentifier	 store
=	TokenNameEQUAL	
Store	TokenNameIdentifier	 Store
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
;	TokenNameSEMICOLON	
// randomly store it 	TokenNameCOMMENT_LINE	randomly store it 
tv	TokenNameIdentifier	 tv
=	TokenNameEQUAL	
randomTVSetting	TokenNameIdentifier	 random TV Setting
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
tv	TokenNameIdentifier	 tv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
TermVector	TokenNameIdentifier	 Term Vector
tvSettings	TokenNameIdentifier	 tv Settings
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
NO	TokenNameIdentifier	 NO
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
YES	TokenNameIdentifier	 YES
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_OFFSETS	TokenNameIdentifier	 WITH  OFFSETS
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS	TokenNameIdentifier	 WITH  POSITIONS
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS_OFFSETS	TokenNameIdentifier	 WITH  POSITIONS  OFFSETS
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
TermVector	TokenNameIdentifier	 Term Vector
randomTVSetting	TokenNameIdentifier	 random TV Setting
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
TermVector	TokenNameIdentifier	 Term Vector
minimum	TokenNameIdentifier	 minimum
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
minimum	TokenNameIdentifier	 minimum
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
NO	TokenNameIdentifier	 NO
:	TokenNameCOLON	
return	TokenNamereturn	
tvSettings	TokenNameIdentifier	 tv Settings
[	TokenNameLBRACKET	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tvSettings	TokenNameIdentifier	 tv Settings
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
case	TokenNamecase	
YES	TokenNameIdentifier	 YES
:	TokenNameCOLON	
return	TokenNamereturn	
tvSettings	TokenNameIdentifier	 tv Settings
[	TokenNameLBRACKET	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
tvSettings	TokenNameIdentifier	 tv Settings
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
case	TokenNamecase	
WITH_OFFSETS	TokenNameIdentifier	 WITH  OFFSETS
:	TokenNameCOLON	
return	TokenNamereturn	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_OFFSETS	TokenNameIdentifier	 WITH  OFFSETS
:	TokenNameCOLON	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS_OFFSETS	TokenNameIdentifier	 WITH  POSITIONS  OFFSETS
;	TokenNameSEMICOLON	
case	TokenNamecase	
WITH_POSITIONS	TokenNameIdentifier	 WITH  POSITIONS
:	TokenNameCOLON	
return	TokenNamereturn	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS	TokenNameIdentifier	 WITH  POSITIONS
:	TokenNameCOLON	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS_OFFSETS	TokenNameIdentifier	 WITH  POSITIONS  OFFSETS
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
TermVector	TokenNameIdentifier	 Term Vector
.	TokenNameDOT	
WITH_POSITIONS_OFFSETS	TokenNameIdentifier	 WITH  POSITIONS  OFFSETS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** return a random Locale from the available locales on the system */	TokenNameCOMMENT_JAVADOC	 return a random Locale from the available locales on the system 
public	TokenNamepublic	
static	TokenNamestatic	
Locale	TokenNameIdentifier	 Locale
randomLocale	TokenNameIdentifier	 random Locale
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Locale	TokenNameIdentifier	 Locale
locales	TokenNameIdentifier	 locales
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getAvailableLocales	TokenNameIdentifier	 get Available Locales
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
locales	TokenNameIdentifier	 locales
[	TokenNameLBRACKET	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
locales	TokenNameIdentifier	 locales
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** return a random TimeZone from the available timezones on the system */	TokenNameCOMMENT_JAVADOC	 return a random TimeZone from the available timezones on the system 
public	TokenNamepublic	
static	TokenNamestatic	
TimeZone	TokenNameIdentifier	 Time Zone
randomTimeZone	TokenNameIdentifier	 random Time Zone
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
tzIds	TokenNameIdentifier	 tz Ids
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
getAvailableIDs	TokenNameIdentifier	 get Available I Ds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
TimeZone	TokenNameIdentifier	 Time Zone
.	TokenNameDOT	
getTimeZone	TokenNameIdentifier	 get Time Zone
(	TokenNameLPAREN	
tzIds	TokenNameIdentifier	 tz Ids
[	TokenNameLBRACKET	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
tzIds	TokenNameIdentifier	 tz Ids
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** return a Locale object equivalent to its programmatic name */	TokenNameCOMMENT_JAVADOC	 return a Locale object equivalent to its programmatic name 
public	TokenNamepublic	
static	TokenNamestatic	
Locale	TokenNameIdentifier	 Locale
localeForName	TokenNameIdentifier	 locale For Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
localeName	TokenNameIdentifier	 locale Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
localeName	TokenNameIdentifier	 locale Name
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
"\_"	TokenNameStringLiteral	\_
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
elements	TokenNameIdentifier	 elements
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
elements	TokenNameIdentifier	 elements
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Invalid Locale: "	TokenNameStringLiteral	Invalid Locale: 
+	TokenNamePLUS	
localeName	TokenNameIdentifier	 locale Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"SimpleFSDirectory"	TokenNameStringLiteral	SimpleFSDirectory
,	TokenNameCOMMA	
"NIOFSDirectory"	TokenNameStringLiteral	NIOFSDirectory
,	TokenNameCOMMA	
"MMapDirectory"	TokenNameStringLiteral	MMapDirectory
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
CORE_DIRECTORIES	TokenNameIdentifier	 CORE  DIRECTORIES
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"RAMDirectory"	TokenNameStringLiteral	RAMDirectory
,	TokenNameCOMMA	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
FS_DIRECTORIES	TokenNameIdentifier	 FS  DIRECTORIES
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
randomDirectory	TokenNameIdentifier	 random Directory
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
CORE_DIRECTORIES	TokenNameIdentifier	 CORE  DIRECTORIES
[	TokenNameLBRACKET	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
CORE_DIRECTORIES	TokenNameIdentifier	 CORE  DIRECTORIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
"RAMDirectory"	TokenNameStringLiteral	RAMDirectory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
Directory	TokenNameIdentifier	 Directory
newFSDirectoryImpl	TokenNameIdentifier	 new FS Directory Impl
(	TokenNameLPAREN	
Class	TokenNameIdentifier	 Class
<	TokenNameLESS	
?	TokenNameQUESTION	
extends	TokenNameextends	
FSDirectory	TokenNameIdentifier	 FS Directory
>	TokenNameGREATER	
clazz	TokenNameIdentifier	 clazz
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
FSDirectory	TokenNameIdentifier	 FS Directory
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Assuming every FSDirectory has a ctor(File), but not all may take a 	TokenNameCOMMENT_LINE	Assuming every FSDirectory has a ctor(File), but not all may take a 
// LockFactory too, so setting it afterwards. 	TokenNameCOMMENT_LINE	LockFactory too, so setting it afterwards. 
Constructor	TokenNameIdentifier	 Constructor
<	TokenNameLESS	
?	TokenNameQUESTION	
extends	TokenNameextends	
FSDirectory	TokenNameIdentifier	 FS Directory
>	TokenNameGREATER	
ctor	TokenNameIdentifier	 ctor
=	TokenNameEQUAL	
clazz	TokenNameIdentifier	 clazz
.	TokenNameDOT	
getConstructor	TokenNameIdentifier	 get Constructor
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
ctor	TokenNameIdentifier	 ctor
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
d	TokenNameIdentifier	 d
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Registers a temp directory that will be deleted when tests are done. This * is used by {@link _TestUtil#getTempDir(String)} and * {@link _TestUtil#unzip(File, File)}, so you should call these methods when * possible. */	TokenNameCOMMENT_JAVADOC	 Registers a temp directory that will be deleted when tests are done. This is used by {@link _TestUtil#getTempDir(String)} and {@link _TestUtil#unzip(File, File)}, so you should call these methods when possible. 
static	TokenNamestatic	
void	TokenNamevoid	
registerTempDir	TokenNameIdentifier	 register Temp Dir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
tmpFile	TokenNameIdentifier	 tmp File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempDirs	TokenNameIdentifier	 temp Dirs
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
tmpFile	TokenNameIdentifier	 tmp File
.	TokenNameDOT	
getAbsoluteFile	TokenNameIdentifier	 get Absolute File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getStackTrace	TokenNameIdentifier	 get Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
Directory	TokenNameIdentifier	 Directory
newDirectoryImpl	TokenNameIdentifier	 new Directory Impl
(	TokenNameLPAREN	
Random	TokenNameIdentifier	 Random
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
clazzName	TokenNameIdentifier	 clazz Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
clazzName	TokenNameIdentifier	 clazz Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
clazzName	TokenNameIdentifier	 clazz Name
=	TokenNameEQUAL	
randomDirectory	TokenNameIdentifier	 random Directory
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clazzName	TokenNameIdentifier	 clazz Name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"."	TokenNameStringLiteral	.
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// if not fully qualified, assume .store 	TokenNameCOMMENT_LINE	if not fully qualified, assume .store 
clazzName	TokenNameIdentifier	 clazz Name
=	TokenNameEQUAL	
"org.apache.lucene.store."	TokenNameStringLiteral	org.apache.lucene.store.
+	TokenNamePLUS	
clazzName	TokenNameIdentifier	 clazz Name
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
Class	TokenNameIdentifier	 Class
<	TokenNameLESS	
?	TokenNameQUESTION	
extends	TokenNameextends	
Directory	TokenNameIdentifier	 Directory
>	TokenNameGREATER	
clazz	TokenNameIdentifier	 clazz
=	TokenNameEQUAL	
Class	TokenNameIdentifier	 Class
.	TokenNameDOT	
forName	TokenNameIdentifier	 for Name
(	TokenNameLPAREN	
clazzName	TokenNameIdentifier	 clazz Name
)	TokenNameRPAREN	
.	TokenNameDOT	
asSubclass	TokenNameIdentifier	 as Subclass
(	TokenNameLPAREN	
Directory	TokenNameIdentifier	 Directory
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If it is a FSDirectory type, try its ctor(File) 	TokenNameCOMMENT_LINE	If it is a FSDirectory type, try its ctor(File) 
if	TokenNameif	
(	TokenNameLPAREN	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
isAssignableFrom	TokenNameIdentifier	 is Assignable From
(	TokenNameLPAREN	
clazz	TokenNameIdentifier	 clazz
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
getTempDir	TokenNameIdentifier	 get Temp Dir
(	TokenNameLPAREN	
"index"	TokenNameStringLiteral	index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ensure it's created so we 'have' it. 	TokenNameCOMMENT_LINE	ensure it's created so we 'have' it. 
return	TokenNamereturn	
newFSDirectoryImpl	TokenNameIdentifier	 new FS Directory Impl
(	TokenNameLPAREN	
clazz	TokenNameIdentifier	 clazz
.	TokenNameDOT	
asSubclass	TokenNameIdentifier	 as Subclass
(	TokenNameLPAREN	
FSDirectory	TokenNameIdentifier	 FS Directory
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// try empty ctor 	TokenNameCOMMENT_LINE	try empty ctor 
return	TokenNamereturn	
clazz	TokenNameIdentifier	 clazz
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** create a new searcher over the reader. * This searcher might randomly use threads. */	TokenNameCOMMENT_JAVADOC	 create a new searcher over the reader. This searcher might randomly use threads. 
public	TokenNamepublic	
static	TokenNamestatic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
newSearcher	TokenNameIdentifier	 new Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
newSearcher	TokenNameIdentifier	 new Searcher
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** create a new searcher over the reader. * This searcher might randomly use threads. * if <code>maybeWrap</code> is true, this searcher might wrap the reader * with one that returns null for getSequentialSubReaders. */	TokenNameCOMMENT_JAVADOC	 create a new searcher over the reader. This searcher might randomly use threads. if <code>maybeWrap</code> is true, this searcher might wrap the reader with one that returns null for getSequentialSubReaders. 
public	TokenNamepublic	
static	TokenNamestatic	
IndexSearcher	TokenNameIdentifier	 Index Searcher
newSearcher	TokenNameIdentifier	 new Searcher
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
boolean	TokenNameboolean	
maybeWrap	TokenNameIdentifier	 maybe Wrap
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maybeWrap	TokenNameIdentifier	 maybe Wrap
&&	TokenNameAND_AND	
rarely	TokenNameIdentifier	 rarely
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
SlowMultiReaderWrapper	TokenNameIdentifier	 Slow Multi Reader Wrapper
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
AssertingIndexSearcher	TokenNameIdentifier	 Asserting Index Searcher
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
threads	TokenNameIdentifier	 threads
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ExecutorService	TokenNameIdentifier	 Executor Service
ex	TokenNameIdentifier	 ex
=	TokenNameEQUAL	
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
.	TokenNameDOT	
nextBoolean	TokenNameIdentifier	 next Boolean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
Executors	TokenNameIdentifier	 Executors
.	TokenNameDOT	
newFixedThreadPool	TokenNameIdentifier	 new Fixed Thread Pool
(	TokenNameLPAREN	
threads	TokenNameIdentifier	 threads
=	TokenNameEQUAL	
_TestUtil	TokenNameIdentifier	 Test Util
.	TokenNameDOT	
nextInt	TokenNameIdentifier	 next Int
(	TokenNameLPAREN	
random	TokenNameIdentifier	 random
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
(	TokenNameLPAREN	
"LuceneTestCase"	TokenNameStringLiteral	LuceneTestCase
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: newSearcher using ExecutorService with "	TokenNameStringLiteral	NOTE: newSearcher using ExecutorService with 
+	TokenNamePLUS	
threads	TokenNameIdentifier	 threads
+	TokenNamePLUS	
" threads"	TokenNameStringLiteral	 threads
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
AssertingIndexSearcher	TokenNameIdentifier	 Asserting Index Searcher
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shutdownExecutorService	TokenNameIdentifier	 shutdown Executor Service
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
void	TokenNamevoid	
shutdownExecutorService	TokenNameIdentifier	 shutdown Executor Service
(	TokenNameLPAREN	
ExecutorService	TokenNameIdentifier	 Executor Service
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Gets a resource from the classpath as {@link File}. This method should only be used, * if a real file is needed. To get a stream, code should prefer * {@link Class#getResourceAsStream} using {@code this.getClass()}. */	TokenNameCOMMENT_JAVADOC	 Gets a resource from the classpath as {@link File}. This method should only be used, if a real file is needed. To get a stream, code should prefer {@link Class#getResourceAsStream} using {@code this.getClass()}. 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
getDataFile	TokenNameIdentifier	 get Data File
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
.	TokenNameDOT	
toURI	TokenNameIdentifier	 to URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Cannot find resource: "	TokenNameStringLiteral	Cannot find resource: 
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// We get here from InterceptTestCaseEvents on the 'failed' event.... 	TokenNameCOMMENT_LINE	We get here from InterceptTestCaseEvents on the 'failed' event.... 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
reportPartialFailureInfo	TokenNameIdentifier	 report Partial Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: reproduce with (hopefully): ant test -Dtestcase="	TokenNameStringLiteral	NOTE: reproduce with (hopefully): ant test -Dtestcase=
+	TokenNamePLUS	
testClassesRun	TokenNameIdentifier	 test Classes Run
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
testClassesRun	TokenNameIdentifier	 test Classes Run
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" -Dtests.seed="	TokenNameStringLiteral	 -Dtests.seed=
+	TokenNamePLUS	
new	TokenNamenew	
ThreeLongs	TokenNameIdentifier	 Three Longs
(	TokenNameLPAREN	
staticSeed	TokenNameIdentifier	 static Seed
,	TokenNameCOMMA	
0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
LuceneTestCaseRunner	TokenNameIdentifier	 Lucene Test Case Runner
.	TokenNameDOT	
runnerSeed	TokenNameIdentifier	 runner Seed
)	TokenNameRPAREN	
+	TokenNamePLUS	
reproduceWithExtraParams	TokenNameIdentifier	 reproduce With Extra Params
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We get here from InterceptTestCaseEvents on the 'failed' event.... 	TokenNameCOMMENT_LINE	We get here from InterceptTestCaseEvents on the 'failed' event.... 
public	TokenNamepublic	
void	TokenNamevoid	
reportAdditionalFailureInfo	TokenNameIdentifier	 report Additional Failure Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"NOTE: reproduce with: ant test -Dtestcase="	TokenNameStringLiteral	NOTE: reproduce with: ant test -Dtestcase=
+	TokenNamePLUS	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getSimpleName	TokenNameIdentifier	 get Simple Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" -Dtestmethod="	TokenNameStringLiteral	 -Dtestmethod=
+	TokenNamePLUS	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" -Dtests.seed="	TokenNameStringLiteral	 -Dtests.seed=
+	TokenNamePLUS	
new	TokenNamenew	
ThreeLongs	TokenNameIdentifier	 Three Longs
(	TokenNameLPAREN	
staticSeed	TokenNameIdentifier	 static Seed
,	TokenNameCOMMA	
seed	TokenNameIdentifier	 seed
,	TokenNameCOMMA	
LuceneTestCaseRunner	TokenNameIdentifier	 Lucene Test Case Runner
.	TokenNameDOT	
runnerSeed	TokenNameIdentifier	 runner Seed
)	TokenNameRPAREN	
+	TokenNamePLUS	
reproduceWithExtraParams	TokenNameIdentifier	 reproduce With Extra Params
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// extra params that were overridden needed to reproduce the command 	TokenNameCOMMENT_LINE	extra params that were overridden needed to reproduce the command 
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
reproduceWithExtraParams	TokenNameIdentifier	 reproduce With Extra Params
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
sb	TokenNameIdentifier	 sb
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
TEST_LOCALE	TokenNameIdentifier	 TEST  LOCALE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dtests.locale="	TokenNameStringLiteral	 -Dtests.locale=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TEST_LOCALE	TokenNameIdentifier	 TEST  LOCALE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
TEST_TIMEZONE	TokenNameIdentifier	 TEST  TIMEZONE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dtests.timezone="	TokenNameStringLiteral	 -Dtests.timezone=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TEST_TIMEZONE	TokenNameIdentifier	 TEST  TIMEZONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"random"	TokenNameStringLiteral	random
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dtests.directory="	TokenNameStringLiteral	 -Dtests.directory=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TEST_DIRECTORY	TokenNameIdentifier	 TEST  DIRECTORY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dtests.multiplier="	TokenNameStringLiteral	 -Dtests.multiplier=
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
RANDOM_MULTIPLIER	TokenNameIdentifier	 RANDOM  MULTIPLIER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
TEST_NIGHTLY	TokenNameIdentifier	 TEST  NIGHTLY
)	TokenNameRPAREN	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dtests.nightly=true"	TokenNameStringLiteral	 -Dtests.nightly=true
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO we can't randomize this yet (it drives ant crazy) but this makes tests reproduceable 	TokenNameCOMMENT_LINE	TODO we can't randomize this yet (it drives ant crazy) but this makes tests reproduceable 
// in case machines have different default charsets... 	TokenNameCOMMENT_LINE	in case machines have different default charsets... 
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" -Dargs="-Dfile.encoding="	TokenNameStringLiteral	 -Dargs="-Dfile.encoding=
+	TokenNamePLUS	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"file.encoding"	TokenNameStringLiteral	file.encoding
)	TokenNameRPAREN	
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sb	TokenNameIdentifier	 sb
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// recorded seed: for beforeClass 	TokenNameCOMMENT_LINE	recorded seed: for beforeClass 
private	TokenNameprivate	
static	TokenNamestatic	
long	TokenNamelong	
staticSeed	TokenNameIdentifier	 static Seed
;	TokenNameSEMICOLON	
// seed for individual test methods, changed in @before 	TokenNameCOMMENT_LINE	seed for individual test methods, changed in @before 
private	TokenNameprivate	
long	TokenNamelong	
seed	TokenNameIdentifier	 seed
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
Random	TokenNameIdentifier	 Random
seedRand	TokenNameIdentifier	 seed Rand
=	TokenNameEQUAL	
new	TokenNamenew	
Random	TokenNameIdentifier	 Random
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
SmartRandom	TokenNameIdentifier	 Smart Random
random	TokenNameIdentifier	 random
=	TokenNameEQUAL	
new	TokenNamenew	
SmartRandom	TokenNameIdentifier	 Smart Random
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
"<unknown>"	TokenNameStringLiteral	<unknown>
;	TokenNameSEMICOLON	
/** * Annotation for tests that should only be run during nightly builds. */	TokenNameCOMMENT_JAVADOC	 Annotation for tests that should only be run during nightly builds. 
@	TokenNameAT	
Documented	TokenNameIdentifier	 Documented
@	TokenNameAT	
Inherited	TokenNameIdentifier	 Inherited
@	TokenNameAT	
Retention	TokenNameIdentifier	 Retention
(	TokenNameLPAREN	
RetentionPolicy	TokenNameIdentifier	 Retention Policy
.	TokenNameDOT	
RUNTIME	TokenNameIdentifier	 RUNTIME
)	TokenNameRPAREN	
public	TokenNamepublic	
@	TokenNameAT	
interface	TokenNameinterface	
Nightly	TokenNameIdentifier	 Nightly
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Ignore	TokenNameIdentifier	 Ignore
(	TokenNameLPAREN	
"just a hack"	TokenNameStringLiteral	just a hack
)	TokenNameRPAREN	
public	TokenNamepublic	
final	TokenNamefinal	
void	TokenNamevoid	
alwaysIgnoredTestMethod	TokenNameIdentifier	 always Ignored Test Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
/** check if assertions are enabled */	TokenNameCOMMENT_JAVADOC	 check if assertions are enabled 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
assertionsEnabled	TokenNameIdentifier	 assertions Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
assert	TokenNameassert	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
FALSE	TokenNameIdentifier	 FALSE
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// should never get here 	TokenNameCOMMENT_LINE	should never get here 
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
AssertionError	TokenNameIdentifier	 Assertion Error
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
