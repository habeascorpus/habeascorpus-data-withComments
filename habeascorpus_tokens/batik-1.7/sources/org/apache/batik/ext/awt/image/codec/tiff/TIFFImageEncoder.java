/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
tiff	TokenNameIdentifier	 tiff
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
color	TokenNameIdentifier	 color
.	TokenNameDOT	
ColorSpace	TokenNameIdentifier	 Color Space
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
BufferedImage	TokenNameIdentifier	 Buffered Image
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ColorModel	TokenNameIdentifier	 Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBuffer	TokenNameIdentifier	 Data Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferByte	TokenNameIdentifier	 Data Buffer Byte
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
IndexColorModel	TokenNameIdentifier	 Index Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
Raster	TokenNameIdentifier	 Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
RenderedImage	TokenNameIdentifier	 Rendered Image
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SampleModel	TokenNameIdentifier	 Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
WritableRaster	TokenNameIdentifier	 Writable Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileInputStream	TokenNameIdentifier	 File Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
OutputStream	TokenNameIdentifier	 Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
RandomAccessFile	TokenNameIdentifier	 Random Access File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SortedSet	TokenNameIdentifier	 Sorted Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
TreeSet	TokenNameIdentifier	 Tree Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
zip	TokenNameIdentifier	 zip
.	TokenNameDOT	
Deflater	TokenNameIdentifier	 Deflater
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ImageEncodeParam	TokenNameIdentifier	 Image Encode Param
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ImageEncoderImpl	TokenNameIdentifier	 Image Encoder Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGEncodeParam	TokenNameIdentifier	 JPEG Encode Param
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGQTable	TokenNameIdentifier	 JPEGQ Table
;	TokenNameSEMICOLON	
/** * A baseline TIFF writer. The writer outputs TIFF images in either Bilevel, * Greyscale, Palette color or Full Color modes. * * @version $Id: TIFFImageEncoder.java 498740 2007-01-22 18:35:57Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 A baseline TIFF writer. The writer outputs TIFF images in either Bilevel, Greyscale, Palette color or Full Color modes. * @version $Id: TIFFImageEncoder.java 498740 2007-01-22 18:35:57Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
TIFFImageEncoder	TokenNameIdentifier	 TIFF Image Encoder
extends	TokenNameextends	
ImageEncoderImpl	TokenNameIdentifier	 Image Encoder Impl
{	TokenNameLBRACE	
// Image Types 	TokenNameCOMMENT_LINE	Image Types 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_UNSUPPORTED	TokenNameIdentifier	 TIFF  UNSUPPORTED
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_BILEVEL_WHITE_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  WHITE  IS  ZERO
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_BILEVEL_BLACK_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  BLACK  IS  ZERO
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_GRAY	TokenNameIdentifier	 TIFF  GRAY
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_RGB	TokenNameIdentifier	 TIFF  RGB
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_CMYK	TokenNameIdentifier	 TIFF  CMYK
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_CIELAB	TokenNameIdentifier	 TIFF  CIELAB
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_GENERIC	TokenNameIdentifier	 TIFF  GENERIC
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Compression types 	TokenNameCOMMENT_LINE	Compression types 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
=	TokenNameEQUAL	
32773	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
=	TokenNameEQUAL	
32946	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Incidental tags 	TokenNameCOMMENT_LINE	Incidental tags 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_JPEG_TABLES	TokenNameIdentifier	 TIFF  JPEG  TABLES
=	TokenNameEQUAL	
347	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_YCBCR_SUBSAMPLING	TokenNameIdentifier	 TIFF  YCBCR  SUBSAMPLING
=	TokenNameEQUAL	
530	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_YCBCR_POSITIONING	TokenNameIdentifier	 TIFF  YCBCR  POSITIONING
=	TokenNameEQUAL	
531	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
TIFF_REF_BLACK_WHITE	TokenNameIdentifier	 TIFF  REF  BLACK  WHITE
=	TokenNameEQUAL	
532	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// ExtraSamples types 	TokenNameCOMMENT_LINE	ExtraSamples types 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
EXTRA_SAMPLE_UNSPECIFIED	TokenNameIdentifier	 EXTRA  SAMPLE  UNSPECIFIED
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
EXTRA_SAMPLE_ASSOCIATED_ALPHA	TokenNameIdentifier	 EXTRA  SAMPLE  ASSOCIATED  ALPHA
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
EXTRA_SAMPLE_UNASSOCIATED_ALPHA	TokenNameIdentifier	 EXTRA  SAMPLE  UNASSOCIATED  ALPHA
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Default values 	TokenNameCOMMENT_LINE	Default values 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_ROWS_PER_STRIP	TokenNameIdentifier	 DEFAULT  ROWS  PER  STRIP
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
TIFFImageEncoder	TokenNameIdentifier	 TIFF Image Encoder
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
ImageEncodeParam	TokenNameIdentifier	 Image Encode Param
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
param	TokenNameIdentifier	 param
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
param	TokenNameIdentifier	 param
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
param	TokenNameIdentifier	 param
=	TokenNameEQUAL	
new	TokenNamenew	
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Encodes a RenderedImage and writes the output to the * OutputStream associated with this ImageEncoder. */	TokenNameCOMMENT_JAVADOC	 Encodes a RenderedImage and writes the output to the OutputStream associated with this ImageEncoder. 
public	TokenNamepublic	
void	TokenNamevoid	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
RenderedImage	TokenNameIdentifier	 Rendered Image
im	TokenNameIdentifier	 im
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Write the file header (8 bytes). 	TokenNameCOMMENT_LINE	Write the file header (8 bytes). 
writeFileHeader	TokenNameIdentifier	 write File Header
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get the encoding parameters. 	TokenNameCOMMENT_LINE	Get the encoding parameters. 
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
encodeParam	TokenNameIdentifier	 encode Param
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
)	TokenNameRPAREN	
param	TokenNameIdentifier	 param
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getExtraImages	TokenNameIdentifier	 get Extra Images
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ifdOffset	TokenNameIdentifier	 ifd Offset
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
RenderedImage	TokenNameIdentifier	 Rendered Image
nextImage	TokenNameIdentifier	 next Image
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
;	TokenNameSEMICOLON	
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
nextParam	TokenNameIdentifier	 next Param
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
hasNext	TokenNameIdentifier	 has Next
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ifdOffset	TokenNameIdentifier	 ifd Offset
=	TokenNameEQUAL	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
nextImage	TokenNameIdentifier	 next Image
,	TokenNameCOMMA	
nextParam	TokenNameIdentifier	 next Param
,	TokenNameCOMMA	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
!	TokenNameNOT	
hasNext	TokenNameIdentifier	 has Next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hasNext	TokenNameIdentifier	 has Next
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
obj	TokenNameIdentifier	 obj
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
RenderedImage	TokenNameIdentifier	 Rendered Image
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextImage	TokenNameIdentifier	 next Image
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RenderedImage	TokenNameIdentifier	 Rendered Image
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
nextParam	TokenNameIdentifier	 next Param
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
obj	TokenNameIdentifier	 obj
instanceof	TokenNameinstanceof	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
obj	TokenNameIdentifier	 obj
;	TokenNameSEMICOLON	
nextImage	TokenNameIdentifier	 next Image
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RenderedImage	TokenNameIdentifier	 Rendered Image
)	TokenNameRPAREN	
o	TokenNameIdentifier	 o
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
nextParam	TokenNameIdentifier	 next Param
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
)	TokenNameRPAREN	
o	TokenNameIdentifier	 o
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
hasNext	TokenNameIdentifier	 has Next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
im	TokenNameIdentifier	 im
,	TokenNameCOMMA	
encodeParam	TokenNameIdentifier	 encode Param
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
RenderedImage	TokenNameIdentifier	 Rendered Image
im	TokenNameIdentifier	 im
,	TokenNameCOMMA	
TIFFEncodeParam	TokenNameIdentifier	 TIFF Encode Param
encodeParam	TokenNameIdentifier	 encode Param
,	TokenNameCOMMA	
int	TokenNameint	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isLast	TokenNameIdentifier	 is Last
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Currently all images are stored uncompressed. 	TokenNameCOMMENT_LINE	Currently all images are stored uncompressed. 
int	TokenNameint	
compression	TokenNameIdentifier	 compression
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getCompression	TokenNameIdentifier	 get Compression
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get tiled output preference. 	TokenNameCOMMENT_LINE	Get tiled output preference. 
boolean	TokenNameboolean	
isTiled	TokenNameIdentifier	 is Tiled
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getWriteTiled	TokenNameIdentifier	 get Write Tiled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Set bounds. 	TokenNameCOMMENT_LINE	Set bounds. 
int	TokenNameint	
minX	TokenNameIdentifier	 min X
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
minY	TokenNameIdentifier	 min Y
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
width	TokenNameIdentifier	 width
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
height	TokenNameIdentifier	 height
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Get SampleModel. 	TokenNameCOMMENT_LINE	Get SampleModel. 
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Retrieve and verify sample size. 	TokenNameCOMMENT_LINE	Retrieve and verify sample size. 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sampleSize	TokenNameIdentifier	 sample Size
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getSampleSize	TokenNameIdentifier	 get Sample Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
sampleSize	TokenNameIdentifier	 sample Size
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder0"	TokenNameStringLiteral	TIFFImageEncoder0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Check low bit limits. 	TokenNameCOMMENT_LINE	Check low bit limits. 
int	TokenNameint	
numBands	TokenNameIdentifier	 num Bands
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
numBands	TokenNameIdentifier	 num Bands
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder1"	TokenNameStringLiteral	TIFFImageEncoder1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Retrieve and verify data type. 	TokenNameCOMMENT_LINE	Retrieve and verify data type. 
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getDataType	TokenNameIdentifier	 get Data Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
// todo does this make sense?? 	TokenNameCOMMENT_LINE	todo does this make sense?? 
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we get error only for 4 	TokenNameCOMMENT_LINE	we get error only for 4 
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder2"	TokenNameStringLiteral	TIFFImageEncoder2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
:	TokenNameCOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder3"	TokenNameStringLiteral	TIFFImageEncoder3
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
:	TokenNameCOLON	
case	TokenNamecase	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_FLOAT	TokenNameIdentifier	 TYPE  FLOAT
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder4"	TokenNameStringLiteral	TIFFImageEncoder4
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder5"	TokenNameStringLiteral	TIFFImageEncoder5
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
dataTypeIsShort	TokenNameIdentifier	 data Type Is Short
=	TokenNameEQUAL	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_SHORT	TokenNameIdentifier	 TYPE  SHORT
||	TokenNameOR_OR	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
;	TokenNameSEMICOLON	
ColorModel	TokenNameIdentifier	 Color Model
colorModel	TokenNameIdentifier	 color Model
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
colorModel	TokenNameIdentifier	 color Model
instanceof	TokenNameinstanceof	
IndexColorModel	TokenNameIdentifier	 Index Color Model
&&	TokenNameAND_AND	
dataType	TokenNameIdentifier	 data Type
!=	TokenNameNOT_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Don't support (unsigned) short palette-color images. 	TokenNameCOMMENT_LINE	Don't support (unsigned) short palette-color images. 
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder6"	TokenNameStringLiteral	TIFFImageEncoder6
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexColorModel	TokenNameIdentifier	 Index Color Model
icm	TokenNameIdentifier	 icm
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
colormap	TokenNameIdentifier	 colormap
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Set image type. 	TokenNameCOMMENT_LINE	Set image type. 
int	TokenNameint	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_UNSUPPORTED	TokenNameIdentifier	 TIFF  UNSUPPORTED
;	TokenNameSEMICOLON	
int	TokenNameint	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
extraSampleType	TokenNameIdentifier	 extra Sample Type
=	TokenNameEQUAL	
EXTRA_SAMPLE_UNSPECIFIED	TokenNameIdentifier	 EXTRA  SAMPLE  UNSPECIFIED
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
instanceof	TokenNameinstanceof	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Bilevel or palette 	TokenNameCOMMENT_LINE	Bilevel or palette 
icm	TokenNameIdentifier	 icm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
colorModel	TokenNameIdentifier	 color Model
;	TokenNameSEMICOLON	
int	TokenNameint	
mapSize	TokenNameIdentifier	 map Size
=	TokenNameEQUAL	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getMapSize	TokenNameIdentifier	 get Map Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Bilevel image 	TokenNameCOMMENT_LINE	Bilevel image 
if	TokenNameif	
(	TokenNameLPAREN	
mapSize	TokenNameIdentifier	 map Size
!=	TokenNameNOT_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"TIFFImageEncoder7"	TokenNameStringLiteral	TIFFImageEncoder7
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
mapSize	TokenNameIdentifier	 map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getReds	TokenNameIdentifier	 get Reds
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
mapSize	TokenNameIdentifier	 map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getGreens	TokenNameIdentifier	 get Greens
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
mapSize	TokenNameIdentifier	 map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getBlues	TokenNameIdentifier	 get Blues
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_BILEVEL_BLACK_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  BLACK  IS  ZERO
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
255	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_BILEVEL_WHITE_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  WHITE  IS  ZERO
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Non-bilevel image. 	TokenNameCOMMENT_LINE	Non-bilevel image. 
// Palette color image. 	TokenNameCOMMENT_LINE	Palette color image. 
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
numBands	TokenNameIdentifier	 num Bands
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// bilevel 	TokenNameCOMMENT_LINE	bilevel 
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_BILEVEL_BLACK_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  BLACK  IS  ZERO
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// generic image 	TokenNameCOMMENT_LINE	generic image 
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_GENERIC	TokenNameIdentifier	 TIFF  GENERIC
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
=	TokenNameEQUAL	
numBands	TokenNameIdentifier	 num Bands
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// colorModel is non-null but not an IndexColorModel 	TokenNameCOMMENT_LINE	colorModel is non-null but not an IndexColorModel 
ColorSpace	TokenNameIdentifier	 Color Space
colorSpace	TokenNameIdentifier	 color Space
=	TokenNameEQUAL	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
colorSpace	TokenNameIdentifier	 color Space
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_CMYK	TokenNameIdentifier	 TYPE  CMYK
:	TokenNameCOLON	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_CMYK	TokenNameIdentifier	 TIFF  CMYK
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_GRAY	TokenNameIdentifier	 TYPE  GRAY
:	TokenNameCOLON	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_GRAY	TokenNameIdentifier	 TIFF  GRAY
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_Lab	TokenNameIdentifier	 TYPE  Lab
:	TokenNameCOLON	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_CIELAB	TokenNameIdentifier	 TIFF  CIELAB
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
&&	TokenNameAND_AND	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getJPEGCompressRGBToYCbCr	TokenNameIdentifier	 get JPEG Compress RGB To Y Cb Cr
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_RGB	TokenNameIdentifier	 TIFF  RGB
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_YCbCr	TokenNameIdentifier	 TYPE  Y Cb Cr
:	TokenNameCOLON	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
imageType	TokenNameIdentifier	 image Type
=	TokenNameEQUAL	
TIFF_GENERIC	TokenNameIdentifier	 TIFF  GENERIC
;	TokenNameSEMICOLON	
// generic 	TokenNameCOMMENT_LINE	generic 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_GENERIC	TokenNameIdentifier	 TIFF  GENERIC
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
=	TokenNameEQUAL	
numBands	TokenNameIdentifier	 num Bands
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numBands	TokenNameIdentifier	 num Bands
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
=	TokenNameEQUAL	
numBands	TokenNameIdentifier	 num Bands
-	TokenNameMINUS	
colorSpace	TokenNameIdentifier	 color Space
.	TokenNameDOT	
getNumComponents	TokenNameIdentifier	 get Num Components
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
hasAlpha	TokenNameIdentifier	 has Alpha
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
extraSampleType	TokenNameIdentifier	 extra Sample Type
=	TokenNameEQUAL	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
EXTRA_SAMPLE_ASSOCIATED_ALPHA	TokenNameIdentifier	 EXTRA  SAMPLE  ASSOCIATED  ALPHA
:	TokenNameCOLON	
EXTRA_SAMPLE_UNASSOCIATED_ALPHA	TokenNameIdentifier	 EXTRA  SAMPLE  UNASSOCIATED  ALPHA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_UNSUPPORTED	TokenNameIdentifier	 TIFF  UNSUPPORTED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder8"	TokenNameStringLiteral	TIFFImageEncoder8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check JPEG compatibility. 	TokenNameCOMMENT_LINE	Check JPEG compatibility. 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder11"	TokenNameStringLiteral	TIFFImageEncoder11
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_GRAY	TokenNameIdentifier	 TIFF  GRAY
||	TokenNameOR_OR	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_RGB	TokenNameIdentifier	 TIFF  RGB
||	TokenNameOR_OR	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder9"	TokenNameStringLiteral	TIFFImageEncoder9
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TIFF_BILEVEL_WHITE_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  WHITE  IS  ZERO
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_BILEVEL_BLACK_IS_ZERO	TokenNameIdentifier	 TIFF  BILEVEL  BLACK  IS  ZERO
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_GRAY	TokenNameIdentifier	 TIFF  GRAY
:	TokenNameCOLON	
case	TokenNamecase	
TIFF_GENERIC	TokenNameIdentifier	 TIFF  GENERIC
:	TokenNameCOLON	
// Since the CS_GRAY colorspace is always of type black_is_zero 	TokenNameCOMMENT_LINE	Since the CS_GRAY colorspace is always of type black_is_zero 
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IndexColorModel	TokenNameIdentifier	 Index Color Model
)	TokenNameRPAREN	
colorModel	TokenNameIdentifier	 color Model
;	TokenNameSEMICOLON	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
=	TokenNameEQUAL	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getMapSize	TokenNameIdentifier	 get Map Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getReds	TokenNameIdentifier	 get Reds
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getGreens	TokenNameIdentifier	 get Greens
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
icm	TokenNameIdentifier	 icm
.	TokenNameDOT	
getBlues	TokenNameIdentifier	 get Blues
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
redIndex	TokenNameIdentifier	 red Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
greenIndex	TokenNameIdentifier	 green Index
=	TokenNameEQUAL	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
;	TokenNameSEMICOLON	
int	TokenNameint	
blueIndex	TokenNameIdentifier	 blue Index
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
;	TokenNameSEMICOLON	
colormap	TokenNameIdentifier	 colormap
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
*	TokenNameMULTIPLY	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
0xff	TokenNameIntegerLiteral	
&	TokenNameAND	
r	TokenNameIdentifier	 r
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// beware of sign extended bytes 	TokenNameCOMMENT_LINE	beware of sign extended bytes 
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
redIndex	TokenNameIdentifier	 red Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
tmp	TokenNameIdentifier	 tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
0xff	TokenNameIntegerLiteral	
&	TokenNameAND	
g	TokenNameIdentifier	 g
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
greenIndex	TokenNameIdentifier	 green Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
tmp	TokenNameIdentifier	 tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
0xff	TokenNameIntegerLiteral	
&	TokenNameAND	
b	TokenNameIdentifier	 b
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
colormap	TokenNameIdentifier	 colormap
[	TokenNameLBRACKET	
blueIndex	TokenNameIdentifier	 blue Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
tmp	TokenNameIdentifier	 tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
*=	TokenNameMULTIPLY_EQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_RGB	TokenNameIdentifier	 TIFF  RGB
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_CMYK	TokenNameIdentifier	 TIFF  CMYK
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_CIELAB	TokenNameIdentifier	 TIFF  CIELAB
:	TokenNameCOLON	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder8"	TokenNameStringLiteral	TIFFImageEncoder8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Initialize tile dimensions. 	TokenNameCOMMENT_LINE	Initialize tile dimensions. 
int	TokenNameint	
tileWidth	TokenNameIdentifier	 tile Width
;	TokenNameSEMICOLON	
int	TokenNameint	
tileHeight	TokenNameIdentifier	 tile Height
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileWidth	TokenNameIdentifier	 get Tile Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileWidth	TokenNameIdentifier	 get Tile Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getTileWidth	TokenNameIdentifier	 get Tile Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileHeight	TokenNameIdentifier	 get Tile Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileHeight	TokenNameIdentifier	 get Tile Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getTileHeight	TokenNameIdentifier	 get Tile Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
width	TokenNameIdentifier	 width
;	TokenNameSEMICOLON	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileHeight	TokenNameIdentifier	 get Tile Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getTileHeight	TokenNameIdentifier	 get Tile Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
DEFAULT_ROWS_PER_STRIP	TokenNameIdentifier	 DEFAULT  ROWS  PER  STRIP
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Re-tile for JPEG conformance if needed. 	TokenNameCOMMENT_LINE	Re-tile for JPEG conformance if needed. 
JPEGEncodeParam	TokenNameIdentifier	 JPEG Encode Param
jep	TokenNameIdentifier	 jep
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get JPEGEncodeParam from encodeParam. 	TokenNameCOMMENT_LINE	Get JPEGEncodeParam from encodeParam. 
jep	TokenNameIdentifier	 jep
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getJPEGEncodeParam	TokenNameIdentifier	 get JPEG Encode Param
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Determine maximum subsampling. 	TokenNameCOMMENT_LINE	Determine maximum subsampling. 
int	TokenNameint	
maxSubH	TokenNameIdentifier	 max Sub H
=	TokenNameEQUAL	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getHorizontalSubsampling	TokenNameIdentifier	 get Horizontal Subsampling
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
maxSubV	TokenNameIdentifier	 max Sub V
=	TokenNameEQUAL	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getVerticalSubsampling	TokenNameIdentifier	 get Vertical Subsampling
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
subH	TokenNameIdentifier	 sub H
=	TokenNameEQUAL	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getHorizontalSubsampling	TokenNameIdentifier	 get Horizontal Subsampling
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subH	TokenNameIdentifier	 sub H
>	TokenNameGREATER	
maxSubH	TokenNameIdentifier	 max Sub H
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxSubH	TokenNameIdentifier	 max Sub H
=	TokenNameEQUAL	
subH	TokenNameIdentifier	 sub H
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
subV	TokenNameIdentifier	 sub V
=	TokenNameEQUAL	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getVerticalSubsampling	TokenNameIdentifier	 get Vertical Subsampling
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subV	TokenNameIdentifier	 sub V
>	TokenNameGREATER	
maxSubV	TokenNameIdentifier	 max Sub V
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxSubV	TokenNameIdentifier	 max Sub V
=	TokenNameEQUAL	
subV	TokenNameIdentifier	 sub V
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
factorV	TokenNameIdentifier	 factor V
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
maxSubV	TokenNameIdentifier	 max Sub V
;	TokenNameSEMICOLON	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
tileHeight	TokenNameIdentifier	 tile Height
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
factorV	TokenNameIdentifier	 factor V
+	TokenNamePLUS	
0.5F	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
factorV	TokenNameIdentifier	 factor V
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tileHeight	TokenNameIdentifier	 tile Height
<	TokenNameLESS	
factorV	TokenNameIdentifier	 factor V
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tileHeight	TokenNameIdentifier	 tile Height
=	TokenNameEQUAL	
factorV	TokenNameIdentifier	 factor V
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
factorH	TokenNameIdentifier	 factor H
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
maxSubH	TokenNameIdentifier	 max Sub H
;	TokenNameSEMICOLON	
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
tileWidth	TokenNameIdentifier	 tile Width
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
factorH	TokenNameIdentifier	 factor H
+	TokenNamePLUS	
0.5F	TokenNameFloatingPointLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
factorH	TokenNameIdentifier	 factor H
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
<	TokenNameLESS	
factorH	TokenNameIdentifier	 factor H
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tileWidth	TokenNameIdentifier	 tile Width
=	TokenNameEQUAL	
factorH	TokenNameIdentifier	 factor H
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
numTiles	TokenNameIdentifier	 num Tiles
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// NB: Parentheses are used in this statement for correct rounding. 	TokenNameCOMMENT_LINE	NB: Parentheses are used in this statement for correct rounding. 
numTiles	TokenNameIdentifier	 num Tiles
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
width	TokenNameIdentifier	 width
+	TokenNamePLUS	
tileWidth	TokenNameIdentifier	 tile Width
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
tileWidth	TokenNameIdentifier	 tile Width
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
height	TokenNameIdentifier	 height
+	TokenNamePLUS	
tileHeight	TokenNameIdentifier	 tile Height
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
numTiles	TokenNameIdentifier	 num Tiles
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
ceil	TokenNameIdentifier	 ceil
(	TokenNameLPAREN	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
height	TokenNameIdentifier	 height
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
numTiles	TokenNameIdentifier	 num Tiles
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
long	TokenNamelong	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
ceil	TokenNameIdentifier	 ceil
(	TokenNameLPAREN	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
/	TokenNameDIVIDE	
8.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
bytesPerTile	TokenNameIdentifier	 bytes Per Tile
=	TokenNameEQUAL	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
*	TokenNameMULTIPLY	
tileHeight	TokenNameIdentifier	 tile Height
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTiles	TokenNameIdentifier	 num Tiles
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bytesPerTile	TokenNameIdentifier	 bytes Per Tile
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Last strip may have lesser rows 	TokenNameCOMMENT_LINE	Last strip may have lesser rows 
long	TokenNamelong	
lastStripRows	TokenNameIdentifier	 last Strip Rows
=	TokenNameEQUAL	
height	TokenNameIdentifier	 height
-	TokenNameMINUS	
(	TokenNameLPAREN	
tileHeight	TokenNameIdentifier	 tile Height
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
numTiles	TokenNameIdentifier	 num Tiles
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
numTiles	TokenNameIdentifier	 num Tiles
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
lastStripRows	TokenNameIdentifier	 last Strip Rows
*	TokenNameMULTIPLY	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
totalBytesOfData	TokenNameIdentifier	 total Bytes Of Data
=	TokenNameEQUAL	
bytesPerTile	TokenNameIdentifier	 bytes Per Tile
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
numTiles	TokenNameIdentifier	 num Tiles
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
numTiles	TokenNameIdentifier	 num Tiles
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The data will be written after the IFD: create the array here 	TokenNameCOMMENT_LINE	The data will be written after the IFD: create the array here 
// but fill it in later. 	TokenNameCOMMENT_LINE	but fill it in later. 
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tileOffsets	TokenNameIdentifier	 tile Offsets
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
numTiles	TokenNameIdentifier	 num Tiles
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Basic fields - have to be in increasing numerical order. 	TokenNameCOMMENT_LINE	Basic fields - have to be in increasing numerical order. 
// ImageWidth 256 	TokenNameCOMMENT_LINE	ImageWidth 256 
// ImageLength 257 	TokenNameCOMMENT_LINE	ImageLength 257 
// BitsPerSample 258 	TokenNameCOMMENT_LINE	BitsPerSample 258 
// Compression 259 	TokenNameCOMMENT_LINE	Compression 259 
// PhotoMetricInterpretation 262 	TokenNameCOMMENT_LINE	PhotoMetricInterpretation 262 
// StripOffsets 273 	TokenNameCOMMENT_LINE	StripOffsets 273 
// RowsPerStrip 278 	TokenNameCOMMENT_LINE	RowsPerStrip 278 
// StripByteCounts 279 	TokenNameCOMMENT_LINE	StripByteCounts 279 
// XResolution 282 	TokenNameCOMMENT_LINE	XResolution 282 
// YResolution 283 	TokenNameCOMMENT_LINE	YResolution 283 
// ResolutionUnit 296 	TokenNameCOMMENT_LINE	ResolutionUnit 296 
// Create Directory 	TokenNameCOMMENT_LINE	Create Directory 
SortedSet	TokenNameIdentifier	 Sorted Set
fields	TokenNameIdentifier	 fields
=	TokenNameEQUAL	
new	TokenNamenew	
TreeSet	TokenNameIdentifier	 Tree Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Image Width 	TokenNameCOMMENT_LINE	Image Width 
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_IMAGE_WIDTH	TokenNameIdentifier	 TIFF  IMAGE  WIDTH
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
width	TokenNameIdentifier	 width
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Image Length 	TokenNameCOMMENT_LINE	Image Length 
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_IMAGE_LENGTH	TokenNameIdentifier	 TIFF  IMAGE  LENGTH
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
height	TokenNameIdentifier	 height
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shortSampleSize	TokenNameIdentifier	 short Sample Size
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
shortSampleSize	TokenNameIdentifier	 short Sample Size
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_BITS_PER_SAMPLE	TokenNameIdentifier	 TIFF  BITS  PER  SAMPLE
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
shortSampleSize	TokenNameIdentifier	 short Sample Size
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_COMPRESSION	TokenNameIdentifier	 TIFF  COMPRESSION
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
compression	TokenNameIdentifier	 compression
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_PHOTOMETRIC_INTERPRETATION	TokenNameIdentifier	 TIFF  PHOTOMETRIC  INTERPRETATION
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
photometricInterpretation	TokenNameIdentifier	 photometric Interpretation
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_STRIP_OFFSETS	TokenNameIdentifier	 TIFF  STRIP  OFFSETS
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
numTiles	TokenNameIdentifier	 num Tiles
,	TokenNameCOMMA	
tileOffsets	TokenNameIdentifier	 tile Offsets
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_SAMPLES_PER_PIXEL	TokenNameIdentifier	 TIFF  SAMPLES  PER  PIXEL
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
numBands	TokenNameIdentifier	 num Bands
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_ROWS_PER_STRIP	TokenNameIdentifier	 TIFF  ROWS  PER  STRIP
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
tileHeight	TokenNameIdentifier	 tile Height
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_STRIP_BYTE_COUNTS	TokenNameIdentifier	 TIFF  STRIP  BYTE  COUNTS
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
numTiles	TokenNameIdentifier	 num Tiles
,	TokenNameCOMMA	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
colormap	TokenNameIdentifier	 colormap
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_COLORMAP	TokenNameIdentifier	 TIFF  COLORMAP
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
sizeOfColormap	TokenNameIdentifier	 size Of Colormap
,	TokenNameCOMMA	
colormap	TokenNameIdentifier	 colormap
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isTiled	TokenNameIdentifier	 is Tiled
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_WIDTH	TokenNameIdentifier	 TIFF  TILE  WIDTH
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
tileWidth	TokenNameIdentifier	 tile Width
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_LENGTH	TokenNameIdentifier	 TIFF  TILE  LENGTH
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
tileHeight	TokenNameIdentifier	 tile Height
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_OFFSETS	TokenNameIdentifier	 TIFF  TILE  OFFSETS
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
numTiles	TokenNameIdentifier	 num Tiles
,	TokenNameCOMMA	
tileOffsets	TokenNameIdentifier	 tile Offsets
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_TILE_BYTE_COUNTS	TokenNameIdentifier	 TIFF  TILE  BYTE  COUNTS
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
,	TokenNameCOMMA	
numTiles	TokenNameIdentifier	 num Tiles
,	TokenNameCOMMA	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extraSamples	TokenNameIdentifier	 extra Samples
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
extraSamples	TokenNameIdentifier	 extra Samples
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
extraSampleType	TokenNameIdentifier	 extra Sample Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_EXTRA_SAMPLES	TokenNameIdentifier	 TIFF  EXTRA  SAMPLES
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
numExtraSamples	TokenNameIdentifier	 num Extra Samples
,	TokenNameCOMMA	
extraSamples	TokenNameIdentifier	 extra Samples
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Data Sample Format Extension fields. 	TokenNameCOMMENT_LINE	Data Sample Format Extension fields. 
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
!=	TokenNameNOT_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// SampleFormat 	TokenNameCOMMENT_LINE	SampleFormat 
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sampleFormat	TokenNameIdentifier	 sample Format
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_FLOAT	TokenNameIdentifier	 TYPE  FLOAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_USHORT	TokenNameIdentifier	 TYPE  USHORT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
sampleFormat	TokenNameIdentifier	 sample Format
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFFImageDecoder	TokenNameIdentifier	 TIFF Image Decoder
.	TokenNameDOT	
TIFF_SAMPLE_FORMAT	TokenNameIdentifier	 TIFF  SAMPLE  FORMAT
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
,	TokenNameCOMMA	
sampleFormat	TokenNameIdentifier	 sample Format
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: We don't bother setting the SMinSampleValue and 	TokenNameCOMMENT_LINE	NOTE: We don't bother setting the SMinSampleValue and 
// SMaxSampleValue fields as these both default to the 	TokenNameCOMMENT_LINE	SMaxSampleValue fields as these both default to the 
// extrema of the respective data types. Probably we should 	TokenNameCOMMENT_LINE	extrema of the respective data types. Probably we should 
// check for the presence of the "extrema" property and 	TokenNameCOMMENT_LINE	check for the presence of the "extrema" property and 
// use it if available. 	TokenNameCOMMENT_LINE	use it if available. 
}	TokenNameRBRACE	
// Initialize some JPEG variables. 	TokenNameCOMMENT_LINE	Initialize some JPEG variables. 
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGEncodeParam	TokenNameIdentifier	 JPEG Encode Param
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGImageEncoder	TokenNameIdentifier	 JPEG Image Encoder
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Initialize JPEG color ID. 	TokenNameCOMMENT_LINE	Initialize JPEG color ID. 
jpegColorID	TokenNameIdentifier	 jpeg Color ID
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
.	TokenNameDOT	
COLOR_ID_UNKNOWN	TokenNameIdentifier	 COLOR  ID  UNKNOWN
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
TIFF_GRAY	TokenNameIdentifier	 TIFF  GRAY
:	TokenNameCOLON	
case	TokenNamecase	
TIFF_PALETTE	TokenNameIdentifier	 TIFF  PALETTE
:	TokenNameCOLON	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
.	TokenNameDOT	
COLOR_ID_GRAY	TokenNameIdentifier	 COLOR  ID  GRAY
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_RGB	TokenNameIdentifier	 TIFF  RGB
:	TokenNameCOLON	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
.	TokenNameDOT	
COLOR_ID_RGB	TokenNameIdentifier	 COLOR  ID  RGB
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
:	TokenNameCOLON	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGDecodeParam	TokenNameIdentifier	 JPEG Decode Param
.	TokenNameDOT	
COLOR_ID_YCbCr	TokenNameIdentifier	 COLOR  ID  Y Cb Cr
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Get the JDK encoding parameters. 	TokenNameCOMMENT_LINE	Get the JDK encoding parameters. 
Raster	TokenNameIdentifier	 Raster
tile00	TokenNameIdentifier	 tile00
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getTile	TokenNameIdentifier	 get Tile
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
getDefaultJPEGEncodeParam	TokenNameIdentifier	 get Default JPEG Encode Param
(	TokenNameLPAREN	
tile00	TokenNameIdentifier	 tile00
,	TokenNameCOMMA	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
modifyEncodeParam	TokenNameIdentifier	 modify Encode Param
(	TokenNameLPAREN	
jep	TokenNameIdentifier	 jep
,	TokenNameCOMMA	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write an abbreviated tables-only stream to JPEGTables field. 	TokenNameCOMMENT_LINE	Write an abbreviated tables-only stream to JPEGTables field. 
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
.	TokenNameDOT	
setImageInfoValid	TokenNameIdentifier	 set Image Info Valid
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
.	TokenNameDOT	
setTableInfoValid	TokenNameIdentifier	 set Table Info Valid
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
tableStream	TokenNameIdentifier	 table Stream
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
createJPEGEncoder	TokenNameIdentifier	 create JPEG Encoder
(	TokenNameLPAREN	
tableStream	TokenNameIdentifier	 table Stream
,	TokenNameCOMMA	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
.	TokenNameDOT	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
tile00	TokenNameIdentifier	 tile00
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tableData	TokenNameIdentifier	 table Data
=	TokenNameEQUAL	
tableStream	TokenNameIdentifier	 table Stream
.	TokenNameDOT	
toByteArray	TokenNameIdentifier	 to Byte Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFF_JPEG_TABLES	TokenNameIdentifier	 TIFF  JPEG  TABLES
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_UNDEFINED	TokenNameIdentifier	 TIFF  UNDEFINED
,	TokenNameCOMMA	
tableData	TokenNameIdentifier	 table Data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
tableData	TokenNameIdentifier	 table Data
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reset encoder so it's recreated below. 	TokenNameCOMMENT_LINE	Reset encoder so it's recreated below. 
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// YCbCrSubSampling: 2 is the default so we must write 1 as 	TokenNameCOMMENT_LINE	YCbCrSubSampling: 2 is the default so we must write 1 as 
// we do not (yet) do any subsampling. 	TokenNameCOMMENT_LINE	we do not (yet) do any subsampling. 
char	TokenNamechar	
subsampleH	TokenNameIdentifier	 subsample H
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
char	TokenNamechar	
subsampleV	TokenNameIdentifier	 subsample V
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// If JPEG, update values. 	TokenNameCOMMENT_LINE	If JPEG, update values. 
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Determine maximum subsampling. 	TokenNameCOMMENT_LINE	Determine maximum subsampling. 
subsampleH	TokenNameIdentifier	 subsample H
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getHorizontalSubsampling	TokenNameIdentifier	 get Horizontal Subsampling
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
subsampleV	TokenNameIdentifier	 subsample V
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getVerticalSubsampling	TokenNameIdentifier	 get Vertical Subsampling
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
char	TokenNamechar	
subH	TokenNameIdentifier	 sub H
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getHorizontalSubsampling	TokenNameIdentifier	 get Horizontal Subsampling
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subH	TokenNameIdentifier	 sub H
>	TokenNameGREATER	
subsampleH	TokenNameIdentifier	 subsample H
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subsampleH	TokenNameIdentifier	 subsample H
=	TokenNameEQUAL	
subH	TokenNameIdentifier	 sub H
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
char	TokenNamechar	
subV	TokenNameIdentifier	 sub V
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
jep	TokenNameIdentifier	 jep
.	TokenNameDOT	
getVerticalSubsampling	TokenNameIdentifier	 get Vertical Subsampling
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
subV	TokenNameIdentifier	 sub V
>	TokenNameGREATER	
subsampleV	TokenNameIdentifier	 subsample V
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subsampleV	TokenNameIdentifier	 subsample V
=	TokenNameEQUAL	
subV	TokenNameIdentifier	 sub V
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFF_YCBCR_SUBSAMPLING	TokenNameIdentifier	 TIFF  YCBCR  SUBSAMPLING
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
subsampleH	TokenNameIdentifier	 subsample H
,	TokenNameCOMMA	
subsampleV	TokenNameIdentifier	 subsample V
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// YCbCr positioning. 	TokenNameCOMMENT_LINE	YCbCr positioning. 
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFF_YCBCR_POSITIONING	TokenNameIdentifier	 TIFF  YCBCR  POSITIONING
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reference black/white. 	TokenNameCOMMENT_LINE	Reference black/white. 
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
refbw	TokenNameIdentifier	 refbw
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
refbw	TokenNameIdentifier	 refbw
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
// no headroon/footroom 	TokenNameCOMMENT_LINE	no headroon/footroom 
{	TokenNameLBRACE	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
255	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
128	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
255	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
128	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
255	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
refbw	TokenNameIdentifier	 refbw
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
// CCIR 601.1 headroom/footroom (presumptive) 	TokenNameCOMMENT_LINE	CCIR 601.1 headroom/footroom (presumptive) 
{	TokenNameLBRACE	
15	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
235	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
128	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
240	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
128	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
{	TokenNameLBRACE	
240	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
TIFFField	TokenNameIdentifier	 TIFF Field
(	TokenNameLPAREN	
TIFF_REF_BLACK_WHITE	TokenNameIdentifier	 TIFF  REF  BLACK  WHITE
,	TokenNameCOMMA	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_RATIONAL	TokenNameIdentifier	 TIFF  RATIONAL
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
refbw	TokenNameIdentifier	 refbw
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ---- No more automatically generated fields should be added 	TokenNameCOMMENT_LINE	---- No more automatically generated fields should be added 
// after this point. ---- 	TokenNameCOMMENT_LINE	after this point. ---- 
// Add extra fields specified via the encoding parameters. 	TokenNameCOMMENT_LINE	Add extra fields specified via the encoding parameters. 
TIFFField	TokenNameIdentifier	 TIFF Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
extraFields	TokenNameIdentifier	 extra Fields
=	TokenNameEQUAL	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getExtraFields	TokenNameIdentifier	 get Extra Fields
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
extraFields	TokenNameIdentifier	 extra Fields
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
extantTags	TokenNameIdentifier	 extant Tags
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
fieldIter	TokenNameIdentifier	 field Iter
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
fieldIter	TokenNameIdentifier	 field Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
fld	TokenNameIdentifier	 fld
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
)	TokenNameRPAREN	
fieldIter	TokenNameIdentifier	 field Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
extantTags	TokenNameIdentifier	 extant Tags
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
fld	TokenNameIdentifier	 fld
.	TokenNameDOT	
getTag	TokenNameIdentifier	 get Tag
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
numExtraFields	TokenNameIdentifier	 num Extra Fields
=	TokenNameEQUAL	
extraFields	TokenNameIdentifier	 extra Fields
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numExtraFields	TokenNameIdentifier	 num Extra Fields
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
TIFFField	TokenNameIdentifier	 TIFF Field
fld	TokenNameIdentifier	 fld
=	TokenNameEQUAL	
extraFields	TokenNameIdentifier	 extra Fields
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Integer	TokenNameIdentifier	 Integer
tagValue	TokenNameIdentifier	 tag Value
=	TokenNameEQUAL	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
fld	TokenNameIdentifier	 fld
.	TokenNameDOT	
getTag	TokenNameIdentifier	 get Tag
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
extantTags	TokenNameIdentifier	 extant Tags
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
tagValue	TokenNameIdentifier	 tag Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fld	TokenNameIdentifier	 fld
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
extantTags	TokenNameIdentifier	 extant Tags
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
tagValue	TokenNameIdentifier	 tag Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ---- No more fields of any type should be added after this. ---- 	TokenNameCOMMENT_LINE	---- No more fields of any type should be added after this. ---- 
// Determine the size of the IFD which is written after the header 	TokenNameCOMMENT_LINE	Determine the size of the IFD which is written after the header 
// of the stream or after the data of the previous image in a 	TokenNameCOMMENT_LINE	of the stream or after the data of the previous image in a 
// multi-page stream. 	TokenNameCOMMENT_LINE	multi-page stream. 
int	TokenNameint	
dirSize	TokenNameIdentifier	 dir Size
=	TokenNameEQUAL	
getDirectorySize	TokenNameIdentifier	 get Directory Size
(	TokenNameLPAREN	
fields	TokenNameIdentifier	 fields
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The first data segment is written after the field overflow 	TokenNameCOMMENT_LINE	The first data segment is written after the field overflow 
// following the IFD so initialize the first offset accordingly. 	TokenNameCOMMENT_LINE	following the IFD so initialize the first offset accordingly. 
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ifdOffset	TokenNameIdentifier	 ifd Offset
+	TokenNamePLUS	
dirSize	TokenNameIdentifier	 dir Size
;	TokenNameSEMICOLON	
// Branch here depending on whether data are being comrpressed. 	TokenNameCOMMENT_LINE	Branch here depending on whether data are being comrpressed. 
// If not, then the IFD is written immediately. 	TokenNameCOMMENT_LINE	If not, then the IFD is written immediately. 
// If so then there are three possibilities: 	TokenNameCOMMENT_LINE	If so then there are three possibilities: 
// A) the OutputStream is a SeekableOutputStream (outCache null); 	TokenNameCOMMENT_LINE	A) the OutputStream is a SeekableOutputStream (outCache null); 
// B) the OutputStream is not a SeekableOutputStream and a file cache 	TokenNameCOMMENT_LINE	B) the OutputStream is not a SeekableOutputStream and a file cache 
// is used (outCache non-null, tempFile non-null); 	TokenNameCOMMENT_LINE	is used (outCache non-null, tempFile non-null); 
// C) the OutputStream is not a SeekableOutputStream and a memory cache 	TokenNameCOMMENT_LINE	C) the OutputStream is not a SeekableOutputStream and a memory cache 
// is used (outCache non-null, tempFile null). 	TokenNameCOMMENT_LINE	is used (outCache non-null, tempFile null). 
OutputStream	TokenNameIdentifier	 Output Stream
outCache	TokenNameIdentifier	 out Cache
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
compressBuf	TokenNameIdentifier	 compress Buf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
tempFile	TokenNameIdentifier	 temp File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
skipByte	TokenNameIdentifier	 skip Byte
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Deflater	TokenNameIdentifier	 Deflater
deflater	TokenNameIdentifier	 deflater
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
jpegRGBToYCbCr	TokenNameIdentifier	 jpeg RGB To Y Cb Cr
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Determine the number of bytes of padding necessary between 	TokenNameCOMMENT_LINE	Determine the number of bytes of padding necessary between 
// the end of the IFD and the first data segment such that the 	TokenNameCOMMENT_LINE	the end of the IFD and the first data segment such that the 
// alignment of the data conforms to the specification (required 	TokenNameCOMMENT_LINE	alignment of the data conforms to the specification (required 
// for uncompressed data only). 	TokenNameCOMMENT_LINE	for uncompressed data only). 
int	TokenNameint	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
16	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
%	TokenNameREMAINDER	
2	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
32	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
%	TokenNameREMAINDER	
4	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
-	TokenNameMINUS	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
%	TokenNameREMAINDER	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+=	TokenNamePLUS_EQUAL	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Update the data offsets (which TIFFField stores by reference). 	TokenNameCOMMENT_LINE	Update the data offsets (which TIFFField stores by reference). 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTiles	TokenNameIdentifier	 num Tiles
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isLast	TokenNameIdentifier	 is Last
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Determine the offset of the next IFD. 	TokenNameCOMMENT_LINE	Determine the offset of the next IFD. 
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
totalBytesOfData	TokenNameIdentifier	 total Bytes Of Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// IFD offsets must be on a word boundary. 	TokenNameCOMMENT_LINE	IFD offsets must be on a word boundary. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
skipByte	TokenNameIdentifier	 skip Byte
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Write the IFD and field overflow before the image data. 	TokenNameCOMMENT_LINE	Write the IFD and field overflow before the image data. 
writeDirectory	TokenNameIdentifier	 write Directory
(	TokenNameLPAREN	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write any padding bytes needed between the end of the IFD 	TokenNameCOMMENT_LINE	Write any padding bytes needed between the end of the IFD 
// and the start of the actual image data. 	TokenNameCOMMENT_LINE	and the start of the actual image data. 
if	TokenNameif	
(	TokenNameLPAREN	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
padding	TokenNameIdentifier	 padding
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
padding	TokenNameIdentifier	 padding
<	TokenNameLESS	
numBytesPadding	TokenNameIdentifier	 num Bytes Padding
;	TokenNameSEMICOLON	
padding	TokenNameIdentifier	 padding
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// If compressing, the cannot be written yet as the size of the 	TokenNameCOMMENT_LINE	If compressing, the cannot be written yet as the size of the 
// data segments is unknown. 	TokenNameCOMMENT_LINE	data segments is unknown. 
if	TokenNameif	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
instanceof	TokenNameinstanceof	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Simply seek to the first data segment position. 	TokenNameCOMMENT_LINE	Simply seek to the first data segment position. 
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Cache the original OutputStream. 	TokenNameCOMMENT_LINE	Cache the original OutputStream. 
outCache	TokenNameIdentifier	 out Cache
=	TokenNameEQUAL	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Attempt to create a temporary file. 	TokenNameCOMMENT_LINE	Attempt to create a temporary file. 
tempFile	TokenNameIdentifier	 temp File
=	TokenNameEQUAL	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
createTempFile	TokenNameIdentifier	 create Temp File
(	TokenNameLPAREN	
"jai-SOS-"	TokenNameStringLiteral	jai-SOS-
,	TokenNameCOMMA	
".tmp"	TokenNameStringLiteral	.tmp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempFile	TokenNameIdentifier	 temp File
.	TokenNameDOT	
deleteOnExit	TokenNameIdentifier	 delete On Exit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RandomAccessFile	TokenNameIdentifier	 Random Access File
raFile	TokenNameIdentifier	 ra File
=	TokenNameEQUAL	
new	TokenNamenew	
RandomAccessFile	TokenNameIdentifier	 Random Access File
(	TokenNameLPAREN	
tempFile	TokenNameIdentifier	 temp File
,	TokenNameCOMMA	
"rw"	TokenNameStringLiteral	rw
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
(	TokenNameLPAREN	
raFile	TokenNameIdentifier	 ra File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this method is exited! 	TokenNameCOMMENT_LINE	this method is exited! 
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Allocate memory for the entire image data (!). 	TokenNameCOMMENT_LINE	Allocate memory for the entire image data (!). 
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
new	TokenNamenew	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
totalBytesOfData	TokenNameIdentifier	 total Bytes Of Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
bufSize	TokenNameIdentifier	 buf Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
:	TokenNameCOLON	
bufSize	TokenNameIdentifier	 buf Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
bytesPerTile	TokenNameIdentifier	 bytes Per Tile
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
+	TokenNamePLUS	
127	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
:	TokenNameCOLON	
bufSize	TokenNameIdentifier	 buf Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Set color conversion flag. 	TokenNameCOMMENT_LINE	Set color conversion flag. 
if	TokenNameif	
(	TokenNameLPAREN	
imageType	TokenNameIdentifier	 image Type
==	TokenNameEQUAL_EQUAL	
TIFF_YCBCR	TokenNameIdentifier	 TIFF  YCBCR
&&	TokenNameAND_AND	
colorModel	TokenNameIdentifier	 color Model
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
TYPE_RGB	TokenNameIdentifier	 TYPE  RGB
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jpegRGBToYCbCr	TokenNameIdentifier	 jpeg RGB To Y Cb Cr
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
:	TokenNameCOLON	
bufSize	TokenNameIdentifier	 buf Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerTile	TokenNameIdentifier	 bytes Per Tile
;	TokenNameSEMICOLON	
deflater	TokenNameIdentifier	 deflater
=	TokenNameEQUAL	
new	TokenNamenew	
Deflater	TokenNameIdentifier	 Deflater
(	TokenNameLPAREN	
encodeParam	TokenNameIdentifier	 encode Param
.	TokenNameDOT	
getDeflateLevel	TokenNameIdentifier	 get Deflate Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
bufSize	TokenNameIdentifier	 buf Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bufSize	TokenNameIdentifier	 buf Size
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compressBuf	TokenNameIdentifier	 compress Buf
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
bufSize	TokenNameIdentifier	 buf Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ---- Writing of actual image data ---- 	TokenNameCOMMENT_LINE	---- Writing of actual image data ---- 
// Buffer for up to tileHeight rows of pixels 	TokenNameCOMMENT_LINE	Buffer for up to tileHeight rows of pixels 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pixels	TokenNameIdentifier	 pixels
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fpixels	TokenNameIdentifier	 fpixels
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Whether to test for contiguous data. 	TokenNameCOMMENT_LINE	Whether to test for contiguous data. 
boolean	TokenNameboolean	
checkContiguous	TokenNameIdentifier	 check Contiguous
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
sampleModel	TokenNameIdentifier	 sample Model
instanceof	TokenNameinstanceof	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
&&	TokenNameAND_AND	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
sampleModel	TokenNameIdentifier	 sample Model
instanceof	TokenNameinstanceof	
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Also create a buffer to hold tileHeight lines of the 	TokenNameCOMMENT_LINE	Also create a buffer to hold tileHeight lines of the 
// data to be written to the file, so we can use array writes. 	TokenNameCOMMENT_LINE	data to be written to the file, so we can use array writes. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bpixels	TokenNameIdentifier	 bpixels
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
!=	TokenNameNOT_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_BYTE	TokenNameIdentifier	 TYPE  BYTE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bpixels	TokenNameIdentifier	 bpixels
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
tileHeight	TokenNameIdentifier	 tile Height
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataTypeIsShort	TokenNameIdentifier	 data Type Is Short
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bpixels	TokenNameIdentifier	 bpixels
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
tileHeight	TokenNameIdentifier	 tile Height
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
||	TokenNameOR_OR	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_FLOAT	TokenNameIdentifier	 TYPE  FLOAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bpixels	TokenNameIdentifier	 bpixels
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
tileHeight	TokenNameIdentifier	 tile Height
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Process tileHeight rows at a time 	TokenNameCOMMENT_LINE	Process tileHeight rows at a time 
int	TokenNameint	
lastRow	TokenNameIdentifier	 last Row
=	TokenNameEQUAL	
minY	TokenNameIdentifier	 min Y
+	TokenNamePLUS	
height	TokenNameIdentifier	 height
;	TokenNameSEMICOLON	
int	TokenNameint	
lastCol	TokenNameIdentifier	 last Col
=	TokenNameEQUAL	
minX	TokenNameIdentifier	 min X
+	TokenNamePLUS	
width	TokenNameIdentifier	 width
;	TokenNameSEMICOLON	
int	TokenNameint	
tileNum	TokenNameIdentifier	 tile Num
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
minY	TokenNameIdentifier	 min Y
;	TokenNameSEMICOLON	
row	TokenNameIdentifier	 row
<	TokenNameLESS	
lastRow	TokenNameIdentifier	 last Row
;	TokenNameSEMICOLON	
row	TokenNameIdentifier	 row
+=	TokenNamePLUS_EQUAL	
tileHeight	TokenNameIdentifier	 tile Height
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
isTiled	TokenNameIdentifier	 is Tiled
?	TokenNameQUESTION	
tileHeight	TokenNameIdentifier	 tile Height
:	TokenNameCOLON	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
tileHeight	TokenNameIdentifier	 tile Height
,	TokenNameCOMMA	
lastRow	TokenNameIdentifier	 last Row
-	TokenNameMINUS	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
rows	TokenNameIdentifier	 rows
*	TokenNameMULTIPLY	
tileWidth	TokenNameIdentifier	 tile Width
*	TokenNameMULTIPLY	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
col	TokenNameIdentifier	 col
=	TokenNameEQUAL	
minX	TokenNameIdentifier	 min X
;	TokenNameSEMICOLON	
col	TokenNameIdentifier	 col
<	TokenNameLESS	
lastCol	TokenNameIdentifier	 last Col
;	TokenNameSEMICOLON	
col	TokenNameIdentifier	 col
+=	TokenNamePLUS_EQUAL	
tileWidth	TokenNameIdentifier	 tile Width
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Grab the pixels 	TokenNameCOMMENT_LINE	Grab the pixels 
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
im	TokenNameIdentifier	 im
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
!=	TokenNameNOT_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// JPEG access Raster 	TokenNameCOMMENT_LINE	JPEG access Raster 
if	TokenNameif	
(	TokenNameLPAREN	
checkContiguous	TokenNameIdentifier	 check Contiguous
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 8-bit 	TokenNameCOMMENT_LINE	8-bit 
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
csm	TokenNameIdentifier	 csm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bankIndices	TokenNameIdentifier	 bank Indices
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getBankIndices	TokenNameIdentifier	 get Bank Indices
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bandOffsets	TokenNameIdentifier	 band Offsets
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getBandOffsets	TokenNameIdentifier	 get Band Offsets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
pixelStride	TokenNameIdentifier	 pixel Stride
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getPixelStride	TokenNameIdentifier	 get Pixel Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lineStride	TokenNameIdentifier	 line Stride
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pixelStride	TokenNameIdentifier	 pixel Stride
!=	TokenNameNOT_EQUAL	
numBands	TokenNameIdentifier	 num Bands
||	TokenNameOR_OR	
lineStride	TokenNameIdentifier	 line Stride
!=	TokenNameNOT_EQUAL	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBands	TokenNameIdentifier	 num Bands
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bankIndices	TokenNameIdentifier	 bank Indices
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
bandOffsets	TokenNameIdentifier	 band Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 1-bit 	TokenNameCOMMENT_LINE	1-bit 
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
mpp	TokenNameIdentifier	 mpp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mpp	TokenNameIdentifier	 mpp
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
mpp	TokenNameIdentifier	 mpp
.	TokenNameDOT	
getDataBitOffset	TokenNameIdentifier	 get Data Bit Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
mpp	TokenNameIdentifier	 mpp
.	TokenNameDOT	
getPixelBitStride	TokenNameIdentifier	 get Pixel Bit Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_FLOAT	TokenNameIdentifier	 TYPE  FLOAT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fpixels	TokenNameIdentifier	 fpixels
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getPixels	TokenNameIdentifier	 get Pixels
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
fpixels	TokenNameIdentifier	 fpixels
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
pixels	TokenNameIdentifier	 pixels
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getPixels	TokenNameIdentifier	 get Pixels
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
,	TokenNameCOMMA	
tileWidth	TokenNameIdentifier	 tile Width
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
pixels	TokenNameIdentifier	 pixels
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
int	TokenNameint	
pixel	TokenNameIdentifier	 pixel
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
sampleSize	TokenNameIdentifier	 sample Size
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
btmp	TokenNameIdentifier	 btmp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferByte	TokenNameIdentifier	 Data Buffer Byte
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
mpp	TokenNameIdentifier	 mpp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
MultiPixelPackedSampleModel	TokenNameIdentifier	 Multi Pixel Packed Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lineStride	TokenNameIdentifier	 line Stride
=	TokenNameEQUAL	
mpp	TokenNameIdentifier	 mpp
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
inOffset	TokenNameIdentifier	 in Offset
=	TokenNameEQUAL	
mpp	TokenNameIdentifier	 mpp
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateX	TokenNameIdentifier	 get Sample Model Translate X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateY	TokenNameIdentifier	 get Sample Model Translate Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lineStride	TokenNameIdentifier	 line Stride
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
btmp	TokenNameIdentifier	 btmp
,	TokenNameCOMMA	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
*	TokenNameMULTIPLY	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
outOffset	TokenNameIdentifier	 out Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
btmp	TokenNameIdentifier	 btmp
,	TokenNameCOMMA	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
outOffset	TokenNameIdentifier	 out Offset
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inOffset	TokenNameIdentifier	 in Offset
+=	TokenNamePLUS_EQUAL	
lineStride	TokenNameIdentifier	 line Stride
;	TokenNameSEMICOLON	
outOffset	TokenNameIdentifier	 out Offset
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// For each of the rows in a strip 	TokenNameCOMMENT_LINE	For each of the rows in a strip 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Write number of pixels exactly divisible by 8 	TokenNameCOMMENT_LINE	Write number of pixels exactly divisible by 8 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
tileWidth	TokenNameIdentifier	 tile Width
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixel	TokenNameIdentifier	 pixel
=	TokenNameEQUAL	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
pixel	TokenNameIdentifier	 pixel
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Write the pixels remaining after division by 8 	TokenNameCOMMENT_LINE	Write the pixels remaining after division by 8 
if	TokenNameif	
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixel	TokenNameIdentifier	 pixel
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
tileWidth	TokenNameIdentifier	 tile Width
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixel	TokenNameIdentifier	 pixel
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
7	TokenNameIntegerLiteral	
-	TokenNameMINUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
pixel	TokenNameIdentifier	 pixel
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
+	TokenNamePLUS	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// For each of the rows in a strip 	TokenNameCOMMENT_LINE	For each of the rows in a strip 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Write the number of pixels that will fit into an 	TokenNameCOMMENT_LINE	Write the number of pixels that will fit into an 
// even number of nibbles. 	TokenNameCOMMENT_LINE	even number of nibbles. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
tileWidth	TokenNameIdentifier	 tile Width
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixel	TokenNameIdentifier	 pixel
=	TokenNameEQUAL	
(	TokenNameLPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
pixel	TokenNameIdentifier	 pixel
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Last pixel for odd-length lines 	TokenNameCOMMENT_LINE	Last pixel for odd-length lines 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
&	TokenNameAND	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pixel	TokenNameIdentifier	 pixel
=	TokenNameEQUAL	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
<<	TokenNameLEFT_SHIFT	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
pixel	TokenNameIdentifier	 pixel
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tileWidth	TokenNameIdentifier	 tile Width
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
!=	TokenNameNOT_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
useDataBuffer	TokenNameIdentifier	 use Data Buffer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
btmp	TokenNameIdentifier	 btmp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DataBufferByte	TokenNameIdentifier	 Data Buffer Byte
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getData	TokenNameIdentifier	 get Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
csm	TokenNameIdentifier	 csm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ComponentSampleModel	TokenNameIdentifier	 Component Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
inOffset	TokenNameIdentifier	 in Offset
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateX	TokenNameIdentifier	 get Sample Model Translate X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateY	TokenNameIdentifier	 get Sample Model Translate Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lineStride	TokenNameIdentifier	 line Stride
=	TokenNameEQUAL	
csm	TokenNameIdentifier	 csm
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lineStride	TokenNameIdentifier	 line Stride
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
btmp	TokenNameIdentifier	 btmp
,	TokenNameCOMMA	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
*	TokenNameMULTIPLY	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
outOffset	TokenNameIdentifier	 out Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
btmp	TokenNameIdentifier	 btmp
,	TokenNameCOMMA	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
outOffset	TokenNameIdentifier	 out Offset
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inOffset	TokenNameIdentifier	 in Offset
+=	TokenNamePLUS_EQUAL	
lineStride	TokenNameIdentifier	 line Stride
;	TokenNameSEMICOLON	
outOffset	TokenNameIdentifier	 out Offset
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_JPEG_TTN2	TokenNameIdentifier	 COMP  JPEG  TT N2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
startPos	TokenNameIdentifier	 start Pos
=	TokenNameEQUAL	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Recreate encoder and parameters if the encoder 	TokenNameCOMMENT_LINE	Recreate encoder and parameters if the encoder 
// is null (first data segment) or if its size 	TokenNameCOMMENT_LINE	is null (first data segment) or if its size 
// doesn't match the current data segment. 	TokenNameCOMMENT_LINE	doesn't match the current data segment. 
if	TokenNameif	
(	TokenNameLPAREN	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
getDefaultJPEGEncodeParam	TokenNameIdentifier	 get Default JPEG Encode Param
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
jpegColorID	TokenNameIdentifier	 jpeg Color ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
modifyEncodeParam	TokenNameIdentifier	 modify Encode Param
(	TokenNameLPAREN	
jep	TokenNameIdentifier	 jep
,	TokenNameCOMMA	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
,	TokenNameCOMMA	
numBands	TokenNameIdentifier	 num Bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
=	TokenNameEQUAL	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
sun	TokenNameIdentifier	 sun
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
codec	TokenNameIdentifier	 codec
.	TokenNameDOT	
jpeg	TokenNameIdentifier	 jpeg
.	TokenNameDOT	
JPEGCodec	TokenNameIdentifier	 JPEG Codec
.	TokenNameDOT	
createJPEGEncoder	TokenNameIdentifier	 create JPEG Encoder
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
jpegEncodeParam	TokenNameIdentifier	 jpeg Encode Param
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jpegRGBToYCbCr	TokenNameIdentifier	 jpeg RGB To Y Cb Cr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
WritableRaster	TokenNameIdentifier	 Writable Raster
wRas	TokenNameIdentifier	 w Ras
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
instanceof	TokenNameinstanceof	
WritableRaster	TokenNameIdentifier	 Writable Raster
)	TokenNameRPAREN	
{	TokenNameLBRACE	
wRas	TokenNameIdentifier	 w Ras
=	TokenNameEQUAL	
(	TokenNameLPAREN	
WritableRaster	TokenNameIdentifier	 Writable Raster
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
wRas	TokenNameIdentifier	 w Ras
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
createCompatibleWritableRaster	TokenNameIdentifier	 create Compatible Writable Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
wRas	TokenNameIdentifier	 w Ras
.	TokenNameDOT	
setRect	TokenNameIdentifier	 set Rect
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wRas	TokenNameIdentifier	 w Ras
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
wRas	TokenNameIdentifier	 w Ras
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
wRas	TokenNameIdentifier	 w Ras
=	TokenNameEQUAL	
wRas	TokenNameIdentifier	 w Ras
.	TokenNameDOT	
createWritableTranslatedChild	TokenNameIdentifier	 create Writable Translated Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
BufferedImage	TokenNameIdentifier	 Buffered Image
bi	TokenNameIdentifier	 bi
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedImage	TokenNameIdentifier	 Buffered Image
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
,	TokenNameCOMMA	
wRas	TokenNameIdentifier	 w Ras
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
.	TokenNameDOT	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
bi	TokenNameIdentifier	 bi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
jpegEncoder	TokenNameIdentifier	 jpeg Encoder
.	TokenNameDOT	
encode	TokenNameIdentifier	 encode
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
createTranslatedChild	TokenNameIdentifier	 create Translated Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
endPos	TokenNameIdentifier	 end Pos
=	TokenNameEQUAL	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
endPos	TokenNameIdentifier	 end Pos
-	TokenNameMINUS	
startPos	TokenNameIdentifier	 start Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
int	TokenNameint	
ls	TokenNameIdentifier	 ls
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
ls	TokenNameIdentifier	 ls
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
ls	TokenNameIdentifier	 ls
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x00ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
==	TokenNameEQUAL_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
li	TokenNameIdentifier	 li
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
pixels	TokenNameIdentifier	 pixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
li	TokenNameIdentifier	 li
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0xff000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
li	TokenNameIdentifier	 li
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x00ff0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
li	TokenNameIdentifier	 li
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x0000ff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
li	TokenNameIdentifier	 li
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x000000ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// DataBuffer.TYPE_FLOAT 	TokenNameCOMMENT_LINE	DataBuffer.TYPE_FLOAT 
int	TokenNameint	
lf	TokenNameIdentifier	 lf
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
floatToIntBits	TokenNameIdentifier	 float To Int Bits
(	TokenNameLPAREN	
fpixels	TokenNameIdentifier	 fpixels
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
lf	TokenNameIdentifier	 lf
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0xff000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
lf	TokenNameIdentifier	 lf
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x00ff0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
lf	TokenNameIdentifier	 lf
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x0000ff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bpixels	TokenNameIdentifier	 bpixels
[	TokenNameLBRACKET	
lf	TokenNameIdentifier	 lf
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
&	TokenNameAND	
0x000000ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_PACKBITS	TokenNameIdentifier	 COMP  PACKBITS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_DEFLATE	TokenNameIdentifier	 COMP  DEFLATE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
bpixels	TokenNameIdentifier	 bpixels
,	TokenNameCOMMA	
compressBuf	TokenNameIdentifier	 compress Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
tileNum	TokenNameIdentifier	 tile Num
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
compressBuf	TokenNameIdentifier	 compress Buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
compression	TokenNameIdentifier	 compression
==	TokenNameEQUAL_EQUAL	
COMP_NONE	TokenNameIdentifier	 COMP  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Write an extra byte for IFD word alignment if needed. 	TokenNameCOMMENT_LINE	Write an extra byte for IFD word alignment if needed. 
if	TokenNameif	
(	TokenNameLPAREN	
skipByte	TokenNameIdentifier	 skip Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Recompute the tile offsets the size of the compressed tiles. 	TokenNameCOMMENT_LINE	Recompute the tile offsets the size of the compressed tiles. 
int	TokenNameint	
totalBytes	TokenNameIdentifier	 total Bytes
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numTiles	TokenNameIdentifier	 num Tiles
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numBytes	TokenNameIdentifier	 num Bytes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
totalBytes	TokenNameIdentifier	 total Bytes
+=	TokenNamePLUS_EQUAL	
numBytes	TokenNameIdentifier	 num Bytes
;	TokenNameSEMICOLON	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tileOffsets	TokenNameIdentifier	 tile Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
+	TokenNamePLUS	
numBytes	TokenNameIdentifier	 num Bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
totalBytes	TokenNameIdentifier	 total Bytes
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
tileByteCounts	TokenNameIdentifier	 tile Byte Counts
[	TokenNameLBRACKET	
numTiles	TokenNameIdentifier	 num Tiles
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
=	TokenNameEQUAL	
isLast	TokenNameIdentifier	 is Last
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
ifdOffset	TokenNameIdentifier	 ifd Offset
+	TokenNamePLUS	
dirSize	TokenNameIdentifier	 dir Size
+	TokenNamePLUS	
totalBytes	TokenNameIdentifier	 total Bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
&	TokenNameAND	
0x01	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make it even 	TokenNameCOMMENT_LINE	make it even 
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
skipByte	TokenNameIdentifier	 skip Byte
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
outCache	TokenNameIdentifier	 out Cache
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Original OutputStream must be a SeekableOutputStream. 	TokenNameCOMMENT_LINE	Original OutputStream must be a SeekableOutputStream. 
// Write an extra byte for IFD word alignment if needed. 	TokenNameCOMMENT_LINE	Write an extra byte for IFD word alignment if needed. 
if	TokenNameif	
(	TokenNameLPAREN	
skipByte	TokenNameIdentifier	 skip Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
sos	TokenNameIdentifier	 sos
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
// Save current position. 	TokenNameCOMMENT_LINE	Save current position. 
long	TokenNamelong	
savePos	TokenNameIdentifier	 save Pos
=	TokenNameEQUAL	
sos	TokenNameIdentifier	 sos
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Seek backward to the IFD offset and write IFD. 	TokenNameCOMMENT_LINE	Seek backward to the IFD offset and write IFD. 
sos	TokenNameIdentifier	 sos
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
ifdOffset	TokenNameIdentifier	 ifd Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeDirectory	TokenNameIdentifier	 write Directory
(	TokenNameLPAREN	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Seek forward to position after data. 	TokenNameCOMMENT_LINE	Seek forward to position after data. 
sos	TokenNameIdentifier	 sos
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
savePos	TokenNameIdentifier	 save Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
tempFile	TokenNameIdentifier	 temp File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Using a file cache for the image data. 	TokenNameCOMMENT_LINE	Using a file cache for the image data. 
// Open a FileInputStream from which to copy the data. 	TokenNameCOMMENT_LINE	Open a FileInputStream from which to copy the data. 
FileInputStream	TokenNameIdentifier	 File Input Stream
fileStream	TokenNameIdentifier	 file Stream
=	TokenNameEQUAL	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
tempFile	TokenNameIdentifier	 temp File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Close the original SeekableOutputStream. 	TokenNameCOMMENT_LINE	Close the original SeekableOutputStream. 
output	TokenNameIdentifier	 output
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Reset variable to the original OutputStream. 	TokenNameCOMMENT_LINE	Reset variable to the original OutputStream. 
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outCache	TokenNameIdentifier	 out Cache
;	TokenNameSEMICOLON	
// Write the IFD. 	TokenNameCOMMENT_LINE	Write the IFD. 
writeDirectory	TokenNameIdentifier	 write Directory
(	TokenNameLPAREN	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write the image data. 	TokenNameCOMMENT_LINE	Write the image data. 
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
copyBuffer	TokenNameIdentifier	 copy Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
8192	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
bytesCopied	TokenNameIdentifier	 bytes Copied
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
bytesCopied	TokenNameIdentifier	 bytes Copied
<	TokenNameLESS	
totalBytes	TokenNameIdentifier	 total Bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
bytesRead	TokenNameIdentifier	 bytes Read
=	TokenNameEQUAL	
fileStream	TokenNameIdentifier	 file Stream
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
copyBuffer	TokenNameIdentifier	 copy Buffer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bytesRead	TokenNameIdentifier	 bytes Read
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
copyBuffer	TokenNameIdentifier	 copy Buffer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bytesRead	TokenNameIdentifier	 bytes Read
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesCopied	TokenNameIdentifier	 bytes Copied
+=	TokenNamePLUS_EQUAL	
bytesRead	TokenNameIdentifier	 bytes Read
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Delete the temporary file. 	TokenNameCOMMENT_LINE	Delete the temporary file. 
fileStream	TokenNameIdentifier	 file Stream
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tempFile	TokenNameIdentifier	 temp File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write an extra byte for IFD word alignment if needed. 	TokenNameCOMMENT_LINE	Write an extra byte for IFD word alignment if needed. 
if	TokenNameif	
(	TokenNameLPAREN	
skipByte	TokenNameIdentifier	 skip Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
instanceof	TokenNameinstanceof	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Using a memory cache for the image data. 	TokenNameCOMMENT_LINE	Using a memory cache for the image data. 
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
memoryStream	TokenNameIdentifier	 memory Stream
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
;	TokenNameSEMICOLON	
// Reset variable to the original OutputStream. 	TokenNameCOMMENT_LINE	Reset variable to the original OutputStream. 
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
outCache	TokenNameIdentifier	 out Cache
;	TokenNameSEMICOLON	
// Write the IFD. 	TokenNameCOMMENT_LINE	Write the IFD. 
writeDirectory	TokenNameIdentifier	 write Directory
(	TokenNameLPAREN	
ifdOffset	TokenNameIdentifier	 ifd Offset
,	TokenNameCOMMA	
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write the image data. 	TokenNameCOMMENT_LINE	Write the image data. 
memoryStream	TokenNameIdentifier	 memory Stream
.	TokenNameDOT	
writeTo	TokenNameIdentifier	 write To
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write an extra byte for IFD word alignment if needed. 	TokenNameCOMMENT_LINE	Write an extra byte for IFD word alignment if needed. 
if	TokenNameif	
(	TokenNameLPAREN	
skipByte	TokenNameIdentifier	 skip Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This should never happen. 	TokenNameCOMMENT_LINE	This should never happen. 
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates the size of the IFD. */	TokenNameCOMMENT_JAVADOC	 Calculates the size of the IFD. 
private	TokenNameprivate	
int	TokenNameint	
getDirectorySize	TokenNameIdentifier	 get Directory Size
(	TokenNameLPAREN	
SortedSet	TokenNameIdentifier	 Sorted Set
fields	TokenNameIdentifier	 fields
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the number of entries. 	TokenNameCOMMENT_LINE	Get the number of entries. 
int	TokenNameint	
numEntries	TokenNameIdentifier	 num Entries
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Initialize the size excluding that of any values > 4 bytes. 	TokenNameCOMMENT_LINE	Initialize the size excluding that of any values > 4 bytes. 
int	TokenNameint	
dirSize	TokenNameIdentifier	 dir Size
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
numEntries	TokenNameIdentifier	 num Entries
*	TokenNameMULTIPLY	
12	TokenNameIntegerLiteral	
+	TokenNamePLUS	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Loop over fields adding the size of all values > 4 bytes. 	TokenNameCOMMENT_LINE	Loop over fields adding the size of all values > 4 bytes. 
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the field. 	TokenNameCOMMENT_LINE	Get the field. 
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Determine the size of the field value. 	TokenNameCOMMENT_LINE	Determine the size of the field value. 
int	TokenNameint	
valueSize	TokenNameIdentifier	 value Size
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
sizeOfType	TokenNameIdentifier	 size Of Type
[	TokenNameLBRACKET	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Add any excess size. 	TokenNameCOMMENT_LINE	Add any excess size. 
if	TokenNameif	
(	TokenNameLPAREN	
valueSize	TokenNameIdentifier	 value Size
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dirSize	TokenNameIdentifier	 dir Size
+=	TokenNamePLUS_EQUAL	
valueSize	TokenNameIdentifier	 value Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
dirSize	TokenNameIdentifier	 dir Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeFileHeader	TokenNameIdentifier	 write File Header
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// 8 byte image file header 	TokenNameCOMMENT_LINE	8 byte image file header 
// Byte order used within the file - Big Endian 	TokenNameCOMMENT_LINE	Byte order used within the file - Big Endian 
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
'M'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
'M'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Magic value 	TokenNameCOMMENT_LINE	Magic value 
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
42	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Offset in bytes of the first IFD. 	TokenNameCOMMENT_LINE	Offset in bytes of the first IFD. 
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeDirectory	TokenNameIdentifier	 write Directory
(	TokenNameLPAREN	
int	TokenNameint	
thisIFDOffset	TokenNameIdentifier	 this IFD Offset
,	TokenNameCOMMA	
SortedSet	TokenNameIdentifier	 Sorted Set
fields	TokenNameIdentifier	 fields
,	TokenNameCOMMA	
int	TokenNameint	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// 2 byte count of number of directory entries (fields) 	TokenNameCOMMENT_LINE	2 byte count of number of directory entries (fields) 
int	TokenNameint	
numEntries	TokenNameIdentifier	 num Entries
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
offsetBeyondIFD	TokenNameIdentifier	 offset Beyond IFD
=	TokenNameEQUAL	
thisIFDOffset	TokenNameIdentifier	 this IFD Offset
+	TokenNamePLUS	
12	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
numEntries	TokenNameIdentifier	 num Entries
+	TokenNamePLUS	
4	TokenNameIntegerLiteral	
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
tooBig	TokenNameIdentifier	 too Big
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write number of fields in the IFD 	TokenNameCOMMENT_LINE	Write number of fields in the IFD 
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
numEntries	TokenNameIdentifier	 num Entries
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
fields	TokenNameIdentifier	 fields
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 12 byte field entry TIFFField 	TokenNameCOMMENT_LINE	12 byte field entry TIFFField 
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
=	TokenNameEQUAL	
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// byte 0-1 Tag that identifies a field 	TokenNameCOMMENT_LINE	byte 0-1 Tag that identifies a field 
int	TokenNameint	
tag	TokenNameIdentifier	 tag
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getTag	TokenNameIdentifier	 get Tag
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// byte 2-3 The field type 	TokenNameCOMMENT_LINE	byte 2-3 The field type 
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// bytes 4-7 the number of values of the indicated type except 	TokenNameCOMMENT_LINE	bytes 4-7 the number of values of the indicated type except 
// ASCII-valued fields which require the total number of bytes. 	TokenNameCOMMENT_LINE	ASCII-valued fields which require the total number of bytes. 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
valueSize	TokenNameIdentifier	 value Size
=	TokenNameEQUAL	
getValueSize	TokenNameIdentifier	 get Value Size
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_ASCII	TokenNameIdentifier	 TIFF  ASCII
?	TokenNameQUESTION	
valueSize	TokenNameIdentifier	 value Size
:	TokenNameCOLON	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// bytes 8 - 11 the value or value offset 	TokenNameCOMMENT_LINE	bytes 8 - 11 the value or value offset 
if	TokenNameif	
(	TokenNameLPAREN	
valueSize	TokenNameIdentifier	 value Size
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We need an offset as data won't fit into 4 bytes 	TokenNameCOMMENT_LINE	We need an offset as data won't fit into 4 bytes 
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
offsetBeyondIFD	TokenNameIdentifier	 offset Beyond IFD
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetBeyondIFD	TokenNameIdentifier	 offset Beyond IFD
+=	TokenNamePLUS_EQUAL	
valueSize	TokenNameIdentifier	 value Size
;	TokenNameSEMICOLON	
tooBig	TokenNameIdentifier	 too Big
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
writeValuesAsFourBytes	TokenNameIdentifier	 write Values As Four Bytes
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Address of next IFD 	TokenNameCOMMENT_LINE	Address of next IFD 
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
nextIFDOffset	TokenNameIdentifier	 next IFD Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Write the tag values that did not fit into 4 bytes 	TokenNameCOMMENT_LINE	Write the tag values that did not fit into 4 bytes 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tooBig	TokenNameIdentifier	 too Big
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeValues	TokenNameIdentifier	 write Values
(	TokenNameLPAREN	
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
)	TokenNameRPAREN	
tooBig	TokenNameIdentifier	 too Big
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Determine the number of bytes in the value portion of the field. */	TokenNameCOMMENT_JAVADOC	 Determine the number of bytes in the value portion of the field. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
getValueSize	TokenNameIdentifier	 get Value Size
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
valueSize	TokenNameIdentifier	 value Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_ASCII	TokenNameIdentifier	 TIFF  ASCII
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stringBytes	TokenNameIdentifier	 string Bytes
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsString	TokenNameIdentifier	 get As String
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// note: default encoding @work here! 	TokenNameCOMMENT_LINE	note: default encoding @work here! 
valueSize	TokenNameIdentifier	 value Size
+=	TokenNamePLUS_EQUAL	
stringBytes	TokenNameIdentifier	 string Bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stringBytes	TokenNameIdentifier	 string Bytes
[	TokenNameLBRACKET	
stringBytes	TokenNameIdentifier	 string Bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
valueSize	TokenNameIdentifier	 value Size
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
valueSize	TokenNameIdentifier	 value Size
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
*	TokenNameMULTIPLY	
sizeOfType	TokenNameIdentifier	 size Of Type
[	TokenNameLBRACKET	
type	TokenNameIdentifier	 type
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
valueSize	TokenNameIdentifier	 value Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sizeOfType	TokenNameIdentifier	 size Of Type
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 0 = n/a 	TokenNameCOMMENT_LINE	0 = n/a 
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 1 = byte 	TokenNameCOMMENT_LINE	1 = byte 
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 2 = ascii 	TokenNameCOMMENT_LINE	2 = ascii 
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 3 = short 	TokenNameCOMMENT_LINE	3 = short 
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 4 = long 	TokenNameCOMMENT_LINE	4 = long 
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 5 = rational 	TokenNameCOMMENT_LINE	5 = rational 
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 6 = sbyte 	TokenNameCOMMENT_LINE	6 = sbyte 
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 7 = undefined 	TokenNameCOMMENT_LINE	7 = undefined 
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 8 = sshort 	TokenNameCOMMENT_LINE	8 = sshort 
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 9 = slong 	TokenNameCOMMENT_LINE	9 = slong 
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 10 = srational 	TokenNameCOMMENT_LINE	10 = srational 
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 11 = float 	TokenNameCOMMENT_LINE	11 = float 
8	TokenNameIntegerLiteral	
// 12 = double 	TokenNameCOMMENT_LINE	12 = double 
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
writeValuesAsFourBytes	TokenNameIdentifier	 write Values As Four Bytes
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// unsigned 8 bits 	TokenNameCOMMENT_LINE	unsigned 8 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_BYTE	TokenNameIdentifier	 TIFF  BYTE
:	TokenNameCOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsBytes	TokenNameIdentifier	 get As Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// unsigned 16 bits 	TokenNameCOMMENT_LINE	unsigned 16 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
:	TokenNameCOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chars	TokenNameIdentifier	 chars
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// unsigned 32 bits 	TokenNameCOMMENT_LINE	unsigned 32 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
:	TokenNameCOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
longs	TokenNameIdentifier	 longs
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsLongs	TokenNameIdentifier	 get As Longs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
longs	TokenNameIdentifier	 longs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeValues	TokenNameIdentifier	 write Values
(	TokenNameLPAREN	
TIFFField	TokenNameIdentifier	 TIFF Field
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
int	TokenNameint	
dataType	TokenNameIdentifier	 data Type
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
dataType	TokenNameIdentifier	 data Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// unsigned 8 bits 	TokenNameCOMMENT_LINE	unsigned 8 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_BYTE	TokenNameIdentifier	 TIFF  BYTE
:	TokenNameCOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SBYTE	TokenNameIdentifier	 TIFF  SBYTE
:	TokenNameCOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_UNDEFINED	TokenNameIdentifier	 TIFF  UNDEFINED
:	TokenNameCOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bytes	TokenNameIdentifier	 bytes
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsBytes	TokenNameIdentifier	 get As Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// unsigned 16 bits 	TokenNameCOMMENT_LINE	unsigned 16 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SHORT	TokenNameIdentifier	 TIFF  SHORT
:	TokenNameCOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
chars	TokenNameIdentifier	 chars
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsChars	TokenNameIdentifier	 get As Chars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
chars	TokenNameIdentifier	 chars
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SSHORT	TokenNameIdentifier	 TIFF  SSHORT
:	TokenNameCOLON	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
shorts	TokenNameIdentifier	 shorts
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsShorts	TokenNameIdentifier	 get As Shorts
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
shorts	TokenNameIdentifier	 shorts
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// unsigned 32 bits 	TokenNameCOMMENT_LINE	unsigned 32 bits 
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_LONG	TokenNameIdentifier	 TIFF  LONG
:	TokenNameCOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SLONG	TokenNameIdentifier	 TIFF  SLONG
:	TokenNameCOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
longs	TokenNameIdentifier	 longs
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsLongs	TokenNameIdentifier	 get As Longs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
longs	TokenNameIdentifier	 longs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_FLOAT	TokenNameIdentifier	 TIFF  FLOAT
:	TokenNameCOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
floats	TokenNameIdentifier	 floats
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsFloats	TokenNameIdentifier	 get As Floats
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
intBits	TokenNameIdentifier	 int Bits
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
floatToIntBits	TokenNameIdentifier	 float To Int Bits
(	TokenNameLPAREN	
floats	TokenNameIdentifier	 floats
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
intBits	TokenNameIdentifier	 int Bits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_DOUBLE	TokenNameIdentifier	 TIFF  DOUBLE
:	TokenNameCOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
doubles	TokenNameIdentifier	 doubles
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsDoubles	TokenNameIdentifier	 get As Doubles
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
longBits	TokenNameIdentifier	 long Bits
=	TokenNameEQUAL	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
doubleToLongBits	TokenNameIdentifier	 double To Long Bits
(	TokenNameLPAREN	
doubles	TokenNameIdentifier	 doubles
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
longBits	TokenNameIdentifier	 long Bits
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write upper 32 bits 	TokenNameCOMMENT_LINE	write upper 32 bits 
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
longBits	TokenNameIdentifier	 long Bits
&	TokenNameAND	
0xffffffffL	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// write lower 32 bits 	TokenNameCOMMENT_LINE	write lower 32 bits 
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_RATIONAL	TokenNameIdentifier	 TIFF  RATIONAL
:	TokenNameCOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_SRATIONAL	TokenNameIdentifier	 TIFF  SRATIONAL
:	TokenNameCOLON	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rationals	TokenNameIdentifier	 rationals
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsRationals	TokenNameIdentifier	 get As Rationals
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
rationals	TokenNameIdentifier	 rationals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
rationals	TokenNameIdentifier	 rationals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TIFFField	TokenNameIdentifier	 TIFF Field
.	TokenNameDOT	
TIFF_ASCII	TokenNameIdentifier	 TIFF  ASCII
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
stringBytes	TokenNameIdentifier	 string Bytes
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getAsString	TokenNameIdentifier	 get As String
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getBytes	TokenNameIdentifier	 get Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
stringBytes	TokenNameIdentifier	 string Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stringBytes	TokenNameIdentifier	 string Bytes
[	TokenNameLBRACKET	
stringBytes	TokenNameIdentifier	 string Bytes
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
Error	TokenNameIdentifier	 Error
(	TokenNameLPAREN	
"TIFFImageEncoder10"	TokenNameStringLiteral	TIFFImageEncoder10
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Here s is never expected to have value greater than what can be 	TokenNameCOMMENT_LINE	Here s is never expected to have value greater than what can be 
// stored in 2 bytes. 	TokenNameCOMMENT_LINE	stored in 2 bytes. 
private	TokenNameprivate	
void	TokenNamevoid	
writeUnsignedShort	TokenNameIdentifier	 write Unsigned Short
(	TokenNameLPAREN	
int	TokenNameint	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
&	TokenNameAND	
0x00ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * despite its name, this method writes only 4 bytes to output. * @param l 32bits of this are written as 4 bytes * @throws IOException */	TokenNameCOMMENT_JAVADOC	 despite its name, this method writes only 4 bytes to output. @param l 32bits of this are written as 4 bytes @throws IOException 
private	TokenNameprivate	
void	TokenNamevoid	
writeLong	TokenNameIdentifier	 write Long
(	TokenNameLPAREN	
long	TokenNamelong	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
&	TokenNameAND	
0xff000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
&	TokenNameAND	
0x00ff0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
&	TokenNameAND	
0x0000ff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
&	TokenNameAND	
0x000000ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the current offset in the supplied OutputStream. * This method should only be used if compressing data. */	TokenNameCOMMENT_JAVADOC	 Returns the current offset in the supplied OutputStream. This method should only be used if compressing data. 
private	TokenNameprivate	
long	TokenNamelong	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
OutputStream	TokenNameIdentifier	 Output Stream
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
instanceof	TokenNameinstanceof	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ByteArrayOutputStream	TokenNameIdentifier	 Byte Array Output Stream
)	TokenNameRPAREN	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
out	TokenNameIdentifier	 out
instanceof	TokenNameinstanceof	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SeekableOutputStream	TokenNameIdentifier	 Seekable Output Stream
)	TokenNameRPAREN	
out	TokenNameIdentifier	 out
)	TokenNameRPAREN	
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Shouldn't happen. 	TokenNameCOMMENT_LINE	Shouldn't happen. 
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Performs PackBits compression on a tile of data. */	TokenNameCOMMENT_JAVADOC	 Performs PackBits compression on a tile of data. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
compressPackBits	TokenNameIdentifier	 compress Pack Bits
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
int	TokenNameint	
numRows	TokenNameIdentifier	 num Rows
,	TokenNameCOMMA	
int	TokenNameint	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
compData	TokenNameIdentifier	 comp Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
inOffset	TokenNameIdentifier	 in Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
outOffset	TokenNameIdentifier	 out Offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numRows	TokenNameIdentifier	 num Rows
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outOffset	TokenNameIdentifier	 out Offset
=	TokenNameEQUAL	
packBits	TokenNameIdentifier	 pack Bits
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
,	TokenNameCOMMA	
compData	TokenNameIdentifier	 comp Data
,	TokenNameCOMMA	
outOffset	TokenNameIdentifier	 out Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inOffset	TokenNameIdentifier	 in Offset
+=	TokenNamePLUS_EQUAL	
bytesPerRow	TokenNameIdentifier	 bytes Per Row
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
outOffset	TokenNameIdentifier	 out Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Performs PackBits compression for a single buffer of data. * This should be called for each row of each tile. The returned * value is the offset into the output buffer after compression. */	TokenNameCOMMENT_JAVADOC	 Performs PackBits compression for a single buffer of data. This should be called for each row of each tile. The returned value is the offset into the output buffer after compression. 
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
packBits	TokenNameIdentifier	 pack Bits
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
int	TokenNameint	
inOffset	TokenNameIdentifier	 in Offset
,	TokenNameCOMMA	
int	TokenNameint	
inCount	TokenNameIdentifier	 in Count
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
int	TokenNameint	
outOffset	TokenNameIdentifier	 out Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
inMax	TokenNameIdentifier	 in Max
=	TokenNameEQUAL	
inOffset	TokenNameIdentifier	 in Offset
+	TokenNamePLUS	
inCount	TokenNameIdentifier	 in Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
inMaxMinus1	TokenNameIdentifier	 in Max Minus1
=	TokenNameEQUAL	
inMax	TokenNameIdentifier	 in Max
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
inOffset	TokenNameIdentifier	 in Offset
<=	TokenNameLESS_EQUAL	
inMax	TokenNameIdentifier	 in Max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
run	TokenNameIdentifier	 run
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
replicate	TokenNameIdentifier	 replicate
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
<	TokenNameLESS	
127	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
inOffset	TokenNameIdentifier	 in Offset
<	TokenNameLESS	
inMax	TokenNameIdentifier	 in Max
&&	TokenNameAND_AND	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
run	TokenNameIdentifier	 run
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
inOffset	TokenNameIdentifier	 in Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inOffset	TokenNameIdentifier	 in Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
replicate	TokenNameIdentifier	 replicate
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
run	TokenNameIdentifier	 run
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
saveOffset	TokenNameIdentifier	 save Offset
=	TokenNameEQUAL	
outOffset	TokenNameIdentifier	 out Offset
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
inOffset	TokenNameIdentifier	 in Offset
<	TokenNameLESS	
inMax	TokenNameIdentifier	 in Max
&&	TokenNameAND_AND	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
inOffset	TokenNameIdentifier	 in Offset
<	TokenNameLESS	
inMaxMinus1	TokenNameIdentifier	 in Max Minus1
&&	TokenNameAND_AND	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
run	TokenNameIdentifier	 run
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
outOffset	TokenNameIdentifier	 out Offset
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
saveOffset	TokenNameIdentifier	 save Offset
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
inOffset	TokenNameIdentifier	 in Offset
==	TokenNameEQUAL_EQUAL	
inMax	TokenNameIdentifier	 in Max
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
run	TokenNameIdentifier	 run
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
run	TokenNameIdentifier	 run
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
saveOffset	TokenNameIdentifier	 save Offset
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
[	TokenNameLBRACKET	
outOffset	TokenNameIdentifier	 out Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
[	TokenNameLBRACKET	
inOffset	TokenNameIdentifier	 in Offset
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
outOffset	TokenNameIdentifier	 out Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
int	TokenNameint	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
Deflater	TokenNameIdentifier	 Deflater
deflater	TokenNameIdentifier	 deflater
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
inflated	TokenNameIdentifier	 inflated
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
deflated	TokenNameIdentifier	 deflated
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deflater	TokenNameIdentifier	 deflater
.	TokenNameDOT	
setInput	TokenNameIdentifier	 set Input
(	TokenNameLPAREN	
inflated	TokenNameIdentifier	 inflated
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
deflater	TokenNameIdentifier	 deflater
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
=	TokenNameEQUAL	
deflater	TokenNameIdentifier	 deflater
.	TokenNameDOT	
deflate	TokenNameIdentifier	 deflate
(	TokenNameLPAREN	
deflated	TokenNameIdentifier	 deflated
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
deflater	TokenNameIdentifier	 deflater
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
numCompressedBytes	TokenNameIdentifier	 num Compressed Bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
modifyEncodeParam	TokenNameIdentifier	 modify Encode Param
(	TokenNameLPAREN	
JPEGEncodeParam	TokenNameIdentifier	 JPEG Encode Param
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
JPEGEncodeParam	TokenNameIdentifier	 JPEG Encode Param
dst	TokenNameIdentifier	 dst
,	TokenNameCOMMA	
int	TokenNameint	
nbands	TokenNameIdentifier	 nbands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dst	TokenNameIdentifier	 dst
.	TokenNameDOT	
setDensityUnit	TokenNameIdentifier	 set Density Unit
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getDensityUnit	TokenNameIdentifier	 get Density Unit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dst	TokenNameIdentifier	 dst
.	TokenNameDOT	
setXDensity	TokenNameIdentifier	 set X Density
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getXDensity	TokenNameIdentifier	 get X Density
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dst	TokenNameIdentifier	 dst
.	TokenNameDOT	
setYDensity	TokenNameIdentifier	 set Y Density
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getYDensity	TokenNameIdentifier	 get Y Density
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dst	TokenNameIdentifier	 dst
.	TokenNameDOT	
setRestartInterval	TokenNameIdentifier	 set Restart Interval
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getRestartInterval	TokenNameIdentifier	 get Restart Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
JPEGQTable	TokenNameIdentifier	 JPEGQ Table
tbl	TokenNameIdentifier	 tbl
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getQTable	TokenNameIdentifier	 get Q Table
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tbl	TokenNameIdentifier	 tbl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
dst	TokenNameIdentifier	 dst
.	TokenNameDOT	
setQTable	TokenNameIdentifier	 set Q Table
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
tbl	TokenNameIdentifier	 tbl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
