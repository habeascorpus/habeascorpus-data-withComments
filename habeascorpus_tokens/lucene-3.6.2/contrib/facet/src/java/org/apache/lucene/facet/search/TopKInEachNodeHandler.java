package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
PriorityQueue	TokenNameIdentifier	 Priority Queue
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
params	TokenNameIdentifier	 params
.	TokenNameDOT	
FacetRequest	TokenNameIdentifier	 Facet Request
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
params	TokenNameIdentifier	 params
.	TokenNameDOT	
FacetRequest	TokenNameIdentifier	 Facet Request
.	TokenNameDOT	
SortOrder	TokenNameIdentifier	 Sort Order
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
FacetResult	TokenNameIdentifier	 Facet Result
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
ChildrenArrays	TokenNameIdentifier	 Children Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
collections	TokenNameIdentifier	 collections
.	TokenNameDOT	
IntIterator	TokenNameIdentifier	 Int Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
collections	TokenNameIdentifier	 collections
.	TokenNameDOT	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/** * Generates {@link FacetResult} from the count arrays aggregated for a particular * {@link FacetRequest}. * The generated {@link FacetResult} is a subtree of the taxonomy tree. * Its root node, {@link FacetResult#getFacetResultNode()}, * is the facet specified by {@link FacetRequest#getCategoryPath()}, * and the enumerated children, {@link FacetResultNode#getSubResults()}, of each node in that * {@link FacetResult} are the top K ( = {@link FacetRequest#getNumResults()}) among its children * in the taxonomy. * Top in the sense {@link FacetRequest#getSortBy()}, * which can be by the values aggregated in the count arrays, or by ordinal numbers; * also specified is the sort order, {@link FacetRequest#getSortOrder()}, * ascending or descending, of these values or ordinals before their top K are selected. * The depth (number of levels excluding the root) of the * {@link FacetResult} tree is specified by {@link FacetRequest#getDepth()}. * <p> * Because the number of selected children of each node is restricted, * and not the overall number of nodes in the {@link FacetResult}, facets not selected * into {@link FacetResult} might have better values, or ordinals, (typically, * higher counts), than facets that are selected into the {@link FacetResult}. * <p> * The generated {@link FacetResult} also provides with * {@link FacetResult#getNumValidDescendants()}, which returns the total number of facets * that are descendants of the root node, no deeper than {@link FacetRequest#getDepth()}, and * which have valid value. The rootnode itself is not counted here. * Valid value is determined by the {@link FacetResultsHandler}. * {@link TopKInEachNodeHandler} defines valid as != 0. * <p> * <b>NOTE:</b> this code relies on the assumption that {@link TaxonomyReader#INVALID_ORDINAL} == -1, a smaller * value than any valid ordinal. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Generates {@link FacetResult} from the count arrays aggregated for a particular {@link FacetRequest}. The generated {@link FacetResult} is a subtree of the taxonomy tree. Its root node, {@link FacetResult#getFacetResultNode()}, is the facet specified by {@link FacetRequest#getCategoryPath()}, and the enumerated children, {@link FacetResultNode#getSubResults()}, of each node in that {@link FacetResult} are the top K ( = {@link FacetRequest#getNumResults()}) among its children in the taxonomy. Top in the sense {@link FacetRequest#getSortBy()}, which can be by the values aggregated in the count arrays, or by ordinal numbers; also specified is the sort order, {@link FacetRequest#getSortOrder()}, ascending or descending, of these values or ordinals before their top K are selected. The depth (number of levels excluding the root) of the {@link FacetResult} tree is specified by {@link FacetRequest#getDepth()}. <p> Because the number of selected children of each node is restricted, and not the overall number of nodes in the {@link FacetResult}, facets not selected into {@link FacetResult} might have better values, or ordinals, (typically, higher counts), than facets that are selected into the {@link FacetResult}. <p> The generated {@link FacetResult} also provides with {@link FacetResult#getNumValidDescendants()}, which returns the total number of facets that are descendants of the root node, no deeper than {@link FacetRequest#getDepth()}, and which have valid value. The rootnode itself is not counted here. Valid value is determined by the {@link FacetResultsHandler}. {@link TopKInEachNodeHandler} defines valid as != 0. <p> <b>NOTE:</b> this code relies on the assumption that {@link TaxonomyReader#INVALID_ORDINAL} == -1, a smaller value than any valid ordinal. * @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
TopKInEachNodeHandler	TokenNameIdentifier	 Top K In Each Node Handler
extends	TokenNameextends	
FacetResultsHandler	TokenNameIdentifier	 Facet Results Handler
{	TokenNameLBRACE	
public	TokenNamepublic	
TopKInEachNodeHandler	TokenNameIdentifier	 Top K In Each Node Handler
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
,	TokenNameCOMMA	
FacetRequest	TokenNameIdentifier	 Facet Request
facetRequest	TokenNameIdentifier	 facet Request
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
,	TokenNameCOMMA	
facetRequest	TokenNameIdentifier	 facet Request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursively explore all facets that can be potentially included in the * {@link FacetResult} to be generated, and that belong to the given * partition, so that values can be examined and collected. For each such * node, gather its top K ({@link FacetRequest#getNumResults()}) children * among its children that are encountered in the given particular partition * (aka current counting list). * * @return {@link IntermediateFacetResult} consisting of * {@link IntToObjectMap} that maps potential * {@link FacetResult} nodes to their top K children encountered in * the current partition. Note that the mapped potential tree nodes * need not belong to the given partition, only the top K children * mapped to. The aim is to identify nodes that are certainly excluded * from the {@link FacetResult} to be eventually (after going through * all the partitions) returned by this handler, because they have K * better siblings, already identified in this partition. For the * identified excluded nodes, we only count number of their * descendants in the subtree (to be included in * {@link FacetResult#getNumValidDescendants()}), but not bother with * selecting top K in these generations, which, by definition, are, * too, excluded from the FacetResult tree. * @param arrays the already filled in count array, potentially only covering * one partition: the ordinals ranging from * @param offset to <code>offset</code> + the length of the count arrays * within <code>arrays</code> (exclusive) * @throws IOException in case * {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)} * does. * @see FacetResultsHandler#fetchPartitionResult(FacetArrays, int) */	TokenNameCOMMENT_JAVADOC	 Recursively explore all facets that can be potentially included in the {@link FacetResult} to be generated, and that belong to the given partition, so that values can be examined and collected. For each such node, gather its top K ({@link FacetRequest#getNumResults()}) children among its children that are encountered in the given particular partition (aka current counting list). * @return {@link IntermediateFacetResult} consisting of {@link IntToObjectMap} that maps potential {@link FacetResult} nodes to their top K children encountered in the current partition. Note that the mapped potential tree nodes need not belong to the given partition, only the top K children mapped to. The aim is to identify nodes that are certainly excluded from the {@link FacetResult} to be eventually (after going through all the partitions) returned by this handler, because they have K better siblings, already identified in this partition. For the identified excluded nodes, we only count number of their descendants in the subtree (to be included in {@link FacetResult#getNumValidDescendants()}), but not bother with selecting top K in these generations, which, by definition, are, too, excluded from the FacetResult tree. @param arrays the already filled in count array, potentially only covering one partition: the ordinals ranging from @param offset to <code>offset</code> + the length of the count arrays within <code>arrays</code> (exclusive) @throws IOException in case {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)} does. @see FacetResultsHandler#fetchPartitionResult(FacetArrays, int) 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
fetchPartitionResult	TokenNameIdentifier	 fetch Partition Result
(	TokenNameLPAREN	
FacetArrays	TokenNameIdentifier	 Facet Arrays
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// get the root of the result tree to be returned, and the depth of that result tree 	TokenNameCOMMENT_LINE	get the root of the result tree to be returned, and the depth of that result tree 
// (depth means number of node levels excluding the root). 	TokenNameCOMMENT_LINE	(depth means number of node levels excluding the root). 
int	TokenNameint	
rootNode	TokenNameIdentifier	 root Node
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getCategoryPath	TokenNameIdentifier	 get Category Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
==	TokenNameEQUAL_EQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
K	TokenNameIdentifier	 K
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getNumResults	TokenNameIdentifier	 get Num Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
.	TokenNameDOT	
getSize	TokenNameIdentifier	 get Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// number of best results in each node 	TokenNameCOMMENT_LINE	number of best results in each node 
// this will grow into the returned IntermediateFacetResult 	TokenNameCOMMENT_LINE	this will grow into the returned IntermediateFacetResult 
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
AACOsOfOnePartition	TokenNameIdentifier	 AAC Os Of One Partition
=	TokenNameEQUAL	
new	TokenNamenew	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
partitionSize	TokenNameIdentifier	 partition Size
=	TokenNameEQUAL	
arrays	TokenNameIdentifier	 arrays
.	TokenNameDOT	
getArraysLength	TokenNameIdentifier	 get Arrays Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// all partitions, except, possibly, the last, 	TokenNameCOMMENT_LINE	all partitions, except, possibly, the last, 
// have the same length. Hence modulo is OK. 	TokenNameCOMMENT_LINE	have the same length. Hence modulo is OK. 
int	TokenNameint	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getDepth	TokenNameIdentifier	 get Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Need to only have root node. 	TokenNameCOMMENT_LINE	Need to only have root node. 
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
tempFRWH	TokenNameIdentifier	 temp FRWH
=	TokenNameEQUAL	
new	TokenNamenew	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
,	TokenNameCOMMA	
AACOsOfOnePartition	TokenNameIdentifier	 AAC Os Of One Partition
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSelfPartition	TokenNameIdentifier	 is Self Partition
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
,	TokenNameCOMMA	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempFRWH	TokenNameIdentifier	 temp FRWH
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
tempFRWH	TokenNameIdentifier	 temp FRWH
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getValueOf	TokenNameIdentifier	 get Value Of
(	TokenNameLPAREN	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
rootNode	TokenNameIdentifier	 root Node
%	TokenNameREMAINDER	
partitionSize	TokenNameIdentifier	 partition Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
tempFRWH	TokenNameIdentifier	 temp FRWH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
depth	TokenNameIdentifier	 depth
>	TokenNameGREATER	
Short	TokenNameIdentifier	 Short
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
Short	TokenNameIdentifier	 Short
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
partitionSize	TokenNameIdentifier	 partition Size
;	TokenNameSEMICOLON	
// one past the largest ordinal in the partition 	TokenNameCOMMENT_LINE	one past the largest ordinal in the partition 
ChildrenArrays	TokenNameIdentifier	 Children Arrays
childrenArray	TokenNameIdentifier	 children Array
=	TokenNameEQUAL	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
.	TokenNameDOT	
getChildrenArrays	TokenNameIdentifier	 get Children Arrays
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChild	TokenNameIdentifier	 youngest Child
=	TokenNameEQUAL	
childrenArray	TokenNameIdentifier	 children Array
.	TokenNameDOT	
getYoungestChildArray	TokenNameIdentifier	 get Youngest Child Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
olderSibling	TokenNameIdentifier	 older Sibling
=	TokenNameEQUAL	
childrenArray	TokenNameIdentifier	 children Array
.	TokenNameDOT	
getOlderSiblingArray	TokenNameIdentifier	 get Older Sibling Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
totalNumOfDescendantsConsidered	TokenNameIdentifier	 total Num Of Descendants Considered
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// total number of facets with value != 0, 	TokenNameCOMMENT_LINE	total number of facets with value != 0, 
// in the tree. These include those selected as top K in each node, and all the others that 	TokenNameCOMMENT_LINE	in the tree. These include those selected as top K in each node, and all the others that 
// were not. Not including rootNode 	TokenNameCOMMENT_LINE	were not. Not including rootNode 
// the following priority queue will be used again and again for each node recursed into 	TokenNameCOMMENT_LINE	the following priority queue will be used again and again for each node recursed into 
// to select its best K children among its children encountered in the given partition 	TokenNameCOMMENT_LINE	to select its best K children among its children encountered in the given partition 
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
>	TokenNameGREATER	
pq	TokenNameIdentifier	 pq
=	TokenNameEQUAL	
new	TokenNamenew	
AggregatedCategoryHeap	TokenNameIdentifier	 Aggregated Category Heap
(	TokenNameLPAREN	
K	TokenNameIdentifier	 K
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getSuitableACComparator	TokenNameIdentifier	 get Suitable AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// reusables will feed the priority queue in each use 	TokenNameCOMMENT_LINE	reusables will feed the priority queue in each use 
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
reusables	TokenNameIdentifier	 reusables
=	TokenNameEQUAL	
new	TokenNamenew	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
K	TokenNameIdentifier	 K
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
reusables	TokenNameIdentifier	 reusables
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reusables	TokenNameIdentifier	 reusables
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * The returned map is built by a recursive visit of potential tree nodes. Nodes * determined to be excluded from the FacetResult are not recursively explored as others, * they are only recursed in order to count the number of their descendants. * Also, nodes that they and any of their descendants can not be mapped into facets encountered * in this partition, are, too, explored no further. These are facets whose ordinal * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy * maintains that a parent ordinal is smaller than any of its descendants' ordinals). * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number * greater than those in the given partition are skipped over, (2) among the children of n residing * in this partition, the best K children are selected (using pq) for usual further recursion * and the rest (those rejected out from the pq) are only recursed for counting total number * of descendants, and (3) all the children of ordinal numbers smaller than the given partition * are further explored in the usual way, since these may lead to descendants residing in this partition. * * ordinalStack drives the recursive descent. * Top of stack holds the current node which we recurse from. * ordinalStack[0] holds the root of the facetRequest, and * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. * localDepth points to the current top of ordinalStack. * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if * the element below it explored all its relevant children. */	TokenNameCOMMENT_BLOCK	 The returned map is built by a recursive visit of potential tree nodes. Nodes determined to be excluded from the FacetResult are not recursively explored as others, they are only recursed in order to count the number of their descendants. Also, nodes that they and any of their descendants can not be mapped into facets encountered in this partition, are, too, explored no further. These are facets whose ordinal numbers are greater than the ordinals of the given partition. (recall that the Taxonomy maintains that a parent ordinal is smaller than any of its descendants' ordinals). So, when scanning over all children of a potential tree node n: (1) all children with ordinal number greater than those in the given partition are skipped over, (2) among the children of n residing in this partition, the best K children are selected (using pq) for usual further recursion and the rest (those rejected out from the pq) are only recursed for counting total number of descendants, and (3) all the children of ordinal numbers smaller than the given partition are further explored in the usual way, since these may lead to descendants residing in this partition. * ordinalStack drives the recursive descent. Top of stack holds the current node which we recurse from. ordinalStack[0] holds the root of the facetRequest, and it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. localDepth points to the current top of ordinalStack. Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if the element below it explored all its relevant children. 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ordinalStack	TokenNameIdentifier	 ordinal Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// for 0 and for invalid on top 	TokenNameCOMMENT_LINE	for 0 and for invalid on top 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rootNode	TokenNameIdentifier	 root Node
;	TokenNameSEMICOLON	
int	TokenNameint	
localDepth	TokenNameIdentifier	 local Depth
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely, * the best K siblings of ordinalStack[i], best K among those residing in the given partition. * Note that the residents of ordinalStack need not belong * to the current partition, only the residents of bestSignlingsStack. * When exploring the children of ordianlStack[i-1] that reside in the current partition * (after the top K of them have been determined and stored into bestSignlingsStack[i]), * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of * a sibling smaller than the ordinals in the partition. * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings * that reside in this partition have not been determined yet. * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition * (i.e. of a smaller ordinal than the current partition) * (step (3) above is executed for the children of ordianlStack[i-1]) */	TokenNameCOMMENT_BLOCK	 bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely, the best K siblings of ordinalStack[i], best K among those residing in the given partition. Note that the residents of ordinalStack need not belong to the current partition, only the residents of bestSignlingsStack. When exploring the children of ordianlStack[i-1] that reside in the current partition (after the top K of them have been determined and stored into bestSignlingsStack[i]), siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of a sibling smaller than the ordinals in the partition. When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings that reside in this partition have not been determined yet. if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition (i.e. of a smaller ordinal than the current partition) (step (3) above is executed for the children of ordianlStack[i-1]) 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bestSignlingsStack	TokenNameIdentifier	 best Signlings Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
siblingExplored	TokenNameIdentifier	 sibling Explored
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
firstToTheLeftOfPartition	TokenNameIdentifier	 first To The Left Of Partition
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
depth	TokenNameIdentifier	 depth
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
;	TokenNameSEMICOLON	
// top of stack element, the ordinal at the top of stack 	TokenNameCOMMENT_LINE	top of stack element, the ordinal at the top of stack 
/* * to start the loop, complete the datastructures for root node: * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children * of rootNode, which reside in the current partition have not been read yet to select the top * K of them. Also, make rootNode as if, related to its parent, rootNode belongs to the children * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that * it went that down) */	TokenNameCOMMENT_BLOCK	 to start the loop, complete the datastructures for root node: push its youngest child to ordinalStack; make a note in siblingExplored[] that the children of rootNode, which reside in the current partition have not been read yet to select the top K of them. Also, make rootNode as if, related to its parent, rootNode belongs to the children of ordinal numbers smaller than those of the current partition (this will ease on end condition -- we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that it went that down) 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
youngestChild	TokenNameIdentifier	 youngest Child
[	TokenNameLBRACKET	
rootNode	TokenNameIdentifier	 root Node
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
// we have not verified position wrt current partition 	TokenNameCOMMENT_LINE	we have not verified position wrt current partition 
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// as if rootNode resides to the left of current position 	TokenNameCOMMENT_LINE	as if rootNode resides to the left of current position 
/* * now the whole recursion: loop as long as stack is not empty of elements descendants of * facetRequest's root. */	TokenNameCOMMENT_BLOCK	 now the whole recursion: loop as long as stack is not empty of elements descendants of facetRequest's root. 
while	TokenNamewhile	
(	TokenNameLPAREN	
localDepth	TokenNameIdentifier	 local Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
=	TokenNameEQUAL	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
==	TokenNameEQUAL_EQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the brotherhood that has been occupying the top of stack is all exhausted. 	TokenNameCOMMENT_LINE	the brotherhood that has been occupying the top of stack is all exhausted. 
// Hence, element below tos, namely, father of tos, has all its children, 	TokenNameCOMMENT_LINE	Hence, element below tos, namely, father of tos, has all its children, 
// and itself, all explored. 	TokenNameCOMMENT_LINE	and itself, all explored. 
localDepth	TokenNameIdentifier	 local Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// replace this father, now on top of stack, by this father's sibling: 	TokenNameCOMMENT_LINE	replace this father, now on top of stack, by this father's sibling: 
// this parent's ordinal can not be greater than current partition, as otherwise 	TokenNameCOMMENT_LINE	this parent's ordinal can not be greater than current partition, as otherwise 
// its child, now just removed, would not have been pushed on it. 	TokenNameCOMMENT_LINE	its child, now just removed, would not have been pushed on it. 
// so the father is either inside the partition, or smaller ordinal 	TokenNameCOMMENT_LINE	so the father is either inside the partition, or smaller ordinal 
if	TokenNameif	
(	TokenNameLPAREN	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
olderSibling	TokenNameIdentifier	 older Sibling
[	TokenNameLBRACKET	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// in this point, siblingExplored[localDepth] between 0 and number of bestSiblings 	TokenNameCOMMENT_LINE	in this point, siblingExplored[localDepth] between 0 and number of bestSiblings 
// it can not be max int 	TokenNameCOMMENT_LINE	it can not be max int 
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//siblings residing in the partition have been all processed, we now move 	TokenNameCOMMENT_LINE	siblings residing in the partition have been all processed, we now move 
// to those of ordinal numbers smaller than the partition 	TokenNameCOMMENT_LINE	to those of ordinal numbers smaller than the partition 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
firstToTheLeftOfPartition	TokenNameIdentifier	 first To The Left Of Partition
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// still explore siblings residing in the partition 	TokenNameCOMMENT_LINE	still explore siblings residing in the partition 
// just move to the next one 	TokenNameCOMMENT_LINE	just move to the next one 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
bestSignlingsStack	TokenNameIdentifier	 best Signlings Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this 	TokenNameCOMMENT_LINE	endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this 
// parent's sibling 	TokenNameCOMMENT_LINE	parent's sibling 
// now try to push a kid, but first look at tos whether it 'deserves' its kids explored: 	TokenNameCOMMENT_LINE	now try to push a kid, but first look at tos whether it 'deserves' its kids explored: 
// it is not to the right of current partition, and we know whether to only count or to 	TokenNameCOMMENT_LINE	it is not to the right of current partition, and we know whether to only count or to 
// select best K siblings. 	TokenNameCOMMENT_LINE	select best K siblings. 
if	TokenNameif	
(	TokenNameLPAREN	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//tosOrdinal was not examined yet for its position relative to current partition 	TokenNameCOMMENT_LINE	tosOrdinal was not examined yet for its position relative to current partition 
// and the best K of current partition, among its siblings, have not been determined yet 	TokenNameCOMMENT_LINE	and the best K of current partition, among its siblings, have not been determined yet 
while	TokenNamewhile	
(	TokenNameLPAREN	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
>=	TokenNameGREATER_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
=	TokenNameEQUAL	
olderSibling	TokenNameIdentifier	 older Sibling
[	TokenNameLBRACKET	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now it is inside. Run it and all its siblings inside the partition through a heap 	TokenNameCOMMENT_LINE	now it is inside. Run it and all its siblings inside the partition through a heap 
// and in doing so, count them, find best K, and sum into residue 	TokenNameCOMMENT_LINE	and in doing so, count them, find best K, and sum into residue 
double	TokenNamedouble	
residue	TokenNameIdentifier	 residue
=	TokenNameEQUAL	
0f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
// the sum of all the siblings from this partition that do not make 	TokenNameCOMMENT_LINE	the sum of all the siblings from this partition that do not make 
// it to top K 	TokenNameCOMMENT_LINE	it to top K 
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//reusables are consumed as from a stack. The stack starts full and returns full. 	TokenNameCOMMENT_LINE	reusables are consumed as from a stack. The stack starts full and returns full. 
int	TokenNameint	
tosReuslables	TokenNameIdentifier	 tos Reuslables
=	TokenNameEQUAL	
reusables	TokenNameIdentifier	 reusables
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
>=	TokenNameGREATER_EQUAL	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// while tosOrdinal belongs to the given partition; here, too, we use the fact 	TokenNameCOMMENT_LINE	while tosOrdinal belongs to the given partition; here, too, we use the fact 
// that TaxonomyReader.INVALID_ORDINAL == -1 < offset 	TokenNameCOMMENT_LINE	that TaxonomyReader.INVALID_ORDINAL == -1 < offset 
double	TokenNamedouble	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getValueOf	TokenNameIdentifier	 get Value Of
(	TokenNameLPAREN	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
%	TokenNameREMAINDER	
partitionSize	TokenNameIdentifier	 partition Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the value of yc is not 0, it is to be considered. 	TokenNameCOMMENT_LINE	the value of yc is not 0, it is to be considered. 
totalNumOfDescendantsConsidered	TokenNameIdentifier	 total Num Of Descendants Considered
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// consume one reusable, and push to the priority queue 	TokenNameCOMMENT_LINE	consume one reusable, and push to the priority queue 
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
ac	TokenNameIdentifier	 ac
=	TokenNameEQUAL	
reusables	TokenNameIdentifier	 reusables
[	TokenNameLBRACKET	
tosReuslables	TokenNameIdentifier	 tos Reuslables
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
;	TokenNameSEMICOLON	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
ac	TokenNameIdentifier	 ac
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
insertWithOverflow	TokenNameIdentifier	 insert With Overflow
(	TokenNameLPAREN	
ac	TokenNameIdentifier	 ac
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
ac	TokenNameIdentifier	 ac
)	TokenNameRPAREN	
{	TokenNameLBRACE	
residue	TokenNameIdentifier	 residue
+=	TokenNamePLUS_EQUAL	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
// TODO (Facet): could it be that we need to do something 	TokenNameCOMMENT_LINE	TODO (Facet): could it be that we need to do something 
// else, not add, depending on the aggregator? 	TokenNameCOMMENT_LINE	else, not add, depending on the aggregator? 
/* when a facet is excluded from top K, because already in this partition it has * K better siblings, it is only recursed for count only. */	TokenNameCOMMENT_BLOCK	 when a facet is excluded from top K, because already in this partition it has K better siblings, it is only recursed for count only. 
// update totalNumOfDescendants by the now excluded node and all its descendants 	TokenNameCOMMENT_LINE	update totalNumOfDescendants by the now excluded node and all its descendants 
totalNumOfDescendantsConsidered	TokenNameIdentifier	 total Num Of Descendants Considered
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// reduce the 1 earned when the excluded node entered the heap 	TokenNameCOMMENT_LINE	reduce the 1 earned when the excluded node entered the heap 
// and now return it and all its descendants. These will never make it to FacetResult 	TokenNameCOMMENT_LINE	and now return it and all its descendants. These will never make it to FacetResult 
totalNumOfDescendantsConsidered	TokenNameIdentifier	 total Num Of Descendants Considered
+=	TokenNamePLUS_EQUAL	
countOnly	TokenNameIdentifier	 count Only
(	TokenNameLPAREN	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
youngestChild	TokenNameIdentifier	 youngest Child
,	TokenNameCOMMA	
olderSibling	TokenNameIdentifier	 older Sibling
,	TokenNameCOMMA	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
partitionSize	TokenNameIdentifier	 partition Size
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
localDepth	TokenNameIdentifier	 local Depth
,	TokenNameCOMMA	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reusables	TokenNameIdentifier	 reusables
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
tosReuslables	TokenNameIdentifier	 tos Reuslables
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ac	TokenNameIdentifier	 ac
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
=	TokenNameEQUAL	
olderSibling	TokenNameIdentifier	 older Sibling
[	TokenNameLBRACKET	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now pq has best K children of ordinals that belong to the given partition. 	TokenNameCOMMENT_LINE	now pq has best K children of ordinals that belong to the given partition. 
// Populate a new AACO with them. 	TokenNameCOMMENT_LINE	Populate a new AACO with them. 
// tosOrdinal is now first sibling smaller than partition, make a note of that 	TokenNameCOMMENT_LINE	tosOrdinal is now first sibling smaller than partition, make a note of that 
firstToTheLeftOfPartition	TokenNameIdentifier	 first To The Left Of Partition
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
;	TokenNameSEMICOLON	
int	TokenNameint	
aaci	TokenNameIdentifier	 aaci
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ords	TokenNameIdentifier	 ords
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
aaci	TokenNameIdentifier	 aaci
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
vals	TokenNameIdentifier	 vals
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
aaci	TokenNameIdentifier	 aaci
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
aaci	TokenNameIdentifier	 aaci
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
ac	TokenNameIdentifier	 ac
=	TokenNameEQUAL	
pq	TokenNameIdentifier	 pq
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ords	TokenNameIdentifier	 ords
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
aaci	TokenNameIdentifier	 aaci
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
;	TokenNameSEMICOLON	
vals	TokenNameIdentifier	 vals
[	TokenNameLBRACKET	
aaci	TokenNameIdentifier	 aaci
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ac	TokenNameIdentifier	 ac
.	TokenNameDOT	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
reusables	TokenNameIdentifier	 reusables
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
tosReuslables	TokenNameIdentifier	 tos Reuslables
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ac	TokenNameIdentifier	 ac
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if more than 0 ordinals, add this AACO to the map to be returned, 	TokenNameCOMMENT_LINE	if more than 0 ordinals, add this AACO to the map to be returned, 
// and add ords to sibling stack, and make a note in siblingExplored that these are to 	TokenNameCOMMENT_LINE	and add ords to sibling stack, and make a note in siblingExplored that these are to 
// be visited now 	TokenNameCOMMENT_LINE	be visited now 
if	TokenNameif	
(	TokenNameLPAREN	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AACOsOfOnePartition	TokenNameIdentifier	 AAC Os Of One Partition
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
AACO	TokenNameIdentifier	 AACO
(	TokenNameLPAREN	
ords	TokenNameIdentifier	 ords
,	TokenNameCOMMA	
vals	TokenNameIdentifier	 vals
,	TokenNameCOMMA	
residue	TokenNameIdentifier	 residue
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bestSignlingsStack	TokenNameIdentifier	 best Signlings Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ords	TokenNameIdentifier	 ords
;	TokenNameSEMICOLON	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ords	TokenNameIdentifier	 ords
[	TokenNameLBRACKET	
ords	TokenNameIdentifier	 ords
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// no ordinals siblings of tosOrdinal in current partition, move to the left of it 	TokenNameCOMMENT_LINE	no ordinals siblings of tosOrdinal in current partition, move to the left of it 
// tosOrdinal is already there (to the left of partition). 	TokenNameCOMMENT_LINE	tosOrdinal is already there (to the left of partition). 
// make a note of it in siblingExplored 	TokenNameCOMMENT_LINE	make a note of it in siblingExplored 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
;	TokenNameSEMICOLON	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endof we did not check the position of a valid ordinal wrt partition 	TokenNameCOMMENT_LINE	endof we did not check the position of a valid ordinal wrt partition 
// now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need 	TokenNameCOMMENT_LINE	now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need 
// to push its kids on top of it, if not too deep. 	TokenNameCOMMENT_LINE	to push its kids on top of it, if not too deep. 
// Make a note that we did not check them yet 	TokenNameCOMMENT_LINE	Make a note that we did not check them yet 
if	TokenNameif	
(	TokenNameLPAREN	
localDepth	TokenNameIdentifier	 local Depth
>=	TokenNameGREATER_EQUAL	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL 	TokenNameCOMMENT_LINE	localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL 
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ordinalStack	TokenNameIdentifier	 ordinal Stack
[	TokenNameLBRACKET	
++	TokenNamePLUS_PLUS	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
youngestChild	TokenNameIdentifier	 youngest Child
[	TokenNameLBRACKET	
tosOrdinal	TokenNameIdentifier	 tos Ordinal
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
siblingExplored	TokenNameIdentifier	 sibling Explored
[	TokenNameLBRACKET	
localDepth	TokenNameIdentifier	 local Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endof loop while stack is not empty 	TokenNameCOMMENT_LINE	endof loop while stack is not empty 
// now generate a TempFacetResult from AACOsOfOnePartition, and consider self. 	TokenNameCOMMENT_LINE	now generate a TempFacetResult from AACOsOfOnePartition, and consider self. 
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
tempFRWH	TokenNameIdentifier	 temp FRWH
=	TokenNameEQUAL	
new	TokenNamenew	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
,	TokenNameCOMMA	
AACOsOfOnePartition	TokenNameIdentifier	 AAC Os Of One Partition
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSelfPartition	TokenNameIdentifier	 is Self Partition
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
,	TokenNameCOMMA	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tempFRWH	TokenNameIdentifier	 temp FRWH
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
tempFRWH	TokenNameIdentifier	 temp FRWH
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getValueOf	TokenNameIdentifier	 get Value Of
(	TokenNameLPAREN	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
rootNode	TokenNameIdentifier	 root Node
%	TokenNameREMAINDER	
partitionSize	TokenNameIdentifier	 partition Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
tempFRWH	TokenNameIdentifier	 temp FRWH
.	TokenNameDOT	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
=	TokenNameEQUAL	
totalNumOfDescendantsConsidered	TokenNameIdentifier	 total Num Of Descendants Considered
;	TokenNameSEMICOLON	
return	TokenNamereturn	
tempFRWH	TokenNameIdentifier	 temp FRWH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursively count <code>ordinal</code>, whose depth is <code>currentDepth</code>, * and all its descendants down to <code>maxDepth</code> (including), * descendants whose value in the count arrays, <code>arrays</code>, is != 0. * The count arrays only includes the current partition, from <code>offset</code>, to (exclusive) * <code>endOffset</code>. * It is assumed that <code>ordinal</code> < <code>endOffset</code>, * otherwise, not <code>ordinal</code>, and none of its descendants, reside in * the current partition. <code>ordinal</code> < <code>offset</code> is allowed, * as ordinal's descendants might be >= <code>offeset</code>. * * @param ordinal a facet ordinal. * @param youngestChild mapping a given ordinal to its youngest child in the taxonomy (of largest ordinal number), * or to -1 if has no children. * @param olderSibling mapping a given ordinal to its older sibling, or to -1 * @param arrays values for the ordinals in the given partition * @param offset the first (smallest) ordinal in the given partition * @param partitionSize number of ordinals in the given partition * @param endOffset one larger than the largest ordinal that belong to this partition * @param currentDepth the depth or ordinal in the TaxonomyTree (relative to rootnode of the facetRequest) * @param maxDepth maximal depth of descendants to be considered here (measured relative to rootnode of the * facetRequest). * * @return the number of nodes, from ordinal down its descendants, of depth <= maxDepth, * which reside in the current partition, and whose value != 0 */	TokenNameCOMMENT_JAVADOC	 Recursively count <code>ordinal</code>, whose depth is <code>currentDepth</code>, and all its descendants down to <code>maxDepth</code> (including), descendants whose value in the count arrays, <code>arrays</code>, is != 0. The count arrays only includes the current partition, from <code>offset</code>, to (exclusive) <code>endOffset</code>. It is assumed that <code>ordinal</code> < <code>endOffset</code>, otherwise, not <code>ordinal</code>, and none of its descendants, reside in the current partition. <code>ordinal</code> < <code>offset</code> is allowed, as ordinal's descendants might be >= <code>offeset</code>. * @param ordinal a facet ordinal. @param youngestChild mapping a given ordinal to its youngest child in the taxonomy (of largest ordinal number), or to -1 if has no children. @param olderSibling mapping a given ordinal to its older sibling, or to -1 @param arrays values for the ordinals in the given partition @param offset the first (smallest) ordinal in the given partition @param partitionSize number of ordinals in the given partition @param endOffset one larger than the largest ordinal that belong to this partition @param currentDepth the depth or ordinal in the TaxonomyTree (relative to rootnode of the facetRequest) @param maxDepth maximal depth of descendants to be considered here (measured relative to rootnode of the facetRequest). * @return the number of nodes, from ordinal down its descendants, of depth <= maxDepth, which reside in the current partition, and whose value != 0 
private	TokenNameprivate	
int	TokenNameint	
countOnly	TokenNameIdentifier	 count Only
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
youngestChild	TokenNameIdentifier	 youngest Child
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
olderSibling	TokenNameIdentifier	 older Sibling
,	TokenNameCOMMA	
FacetArrays	TokenNameIdentifier	 Facet Arrays
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
int	TokenNameint	
partitionSize	TokenNameIdentifier	 partition Size
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
int	TokenNameint	
currentDepth	TokenNameIdentifier	 current Depth
,	TokenNameCOMMA	
int	TokenNameint	
maxDepth	TokenNameIdentifier	 max Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
<=	TokenNameLESS_EQUAL	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ordinal belongs to the current partition 	TokenNameCOMMENT_LINE	ordinal belongs to the current partition 
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getValueOf	TokenNameIdentifier	 get Value Of
(	TokenNameLPAREN	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
ordinal	TokenNameIdentifier	 ordinal
%	TokenNameREMAINDER	
partitionSize	TokenNameIdentifier	 partition Size
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ret	TokenNameIdentifier	 ret
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now consider children of ordinal, if not too deep 	TokenNameCOMMENT_LINE	now consider children of ordinal, if not too deep 
if	TokenNameif	
(	TokenNameLPAREN	
currentDepth	TokenNameIdentifier	 current Depth
>=	TokenNameGREATER_EQUAL	
maxDepth	TokenNameIdentifier	 max Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
yc	TokenNameIdentifier	 yc
=	TokenNameEQUAL	
youngestChild	TokenNameIdentifier	 youngest Child
[	TokenNameLBRACKET	
ordinal	TokenNameIdentifier	 ordinal
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
yc	TokenNameIdentifier	 yc
>=	TokenNameGREATER_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
yc	TokenNameIdentifier	 yc
=	TokenNameEQUAL	
olderSibling	TokenNameIdentifier	 older Sibling
[	TokenNameLBRACKET	
yc	TokenNameIdentifier	 yc
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
yc	TokenNameIdentifier	 yc
>	TokenNameGREATER	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// assuming this is -1, smaller than any legal ordinal 	TokenNameCOMMENT_LINE	assuming this is -1, smaller than any legal ordinal 
ret	TokenNameIdentifier	 ret
+=	TokenNamePLUS_EQUAL	
countOnly	TokenNameIdentifier	 count Only
(	TokenNameLPAREN	
yc	TokenNameIdentifier	 yc
,	TokenNameCOMMA	
youngestChild	TokenNameIdentifier	 youngest Child
,	TokenNameCOMMA	
olderSibling	TokenNameIdentifier	 older Sibling
,	TokenNameCOMMA	
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
partitionSize	TokenNameIdentifier	 partition Size
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
currentDepth	TokenNameIdentifier	 current Depth
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
maxDepth	TokenNameIdentifier	 max Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
yc	TokenNameIdentifier	 yc
=	TokenNameEQUAL	
olderSibling	TokenNameIdentifier	 older Sibling
[	TokenNameLBRACKET	
yc	TokenNameIdentifier	 yc
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Merge several partitions' {@link IntermediateFacetResult}-s into one of the * same format * * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...) */	TokenNameCOMMENT_JAVADOC	 Merge several partitions' {@link IntermediateFacetResult}-s into one of the same format * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...) 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
mergeResults	TokenNameIdentifier	 merge Results
(	TokenNameLPAREN	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
...	TokenNameELLIPSIS	
tmpResults	TokenNameIdentifier	 tmp Results
)	TokenNameRPAREN	
throws	TokenNamethrows	
ClassCastException	TokenNameIdentifier	 Class Cast Exception
,	TokenNameCOMMA	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tmpResults	TokenNameIdentifier	 tmp Results
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// skip over null tmpResults 	TokenNameCOMMENT_LINE	skip over null tmpResults 
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tmpResults	TokenNameIdentifier	 tmp Results
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
tmpResults	TokenNameIdentifier	 tmp Results
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
tmpResults	TokenNameIdentifier	 tmp Results
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// all inputs are null 	TokenNameCOMMENT_LINE	all inputs are null 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// i points to the first non-null input 	TokenNameCOMMENT_LINE	i points to the first non-null input 
int	TokenNameint	
K	TokenNameIdentifier	 K
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getNumResults	TokenNameIdentifier	 get Num Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// number of best result in each node 	TokenNameCOMMENT_LINE	number of best result in each node 
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
tmpToReturn	TokenNameIdentifier	 tmp To Return
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
)	TokenNameRPAREN	
tmpResults	TokenNameIdentifier	 tmp Results
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// now loop over the rest of tmpResults and merge each into tmpToReturn 	TokenNameCOMMENT_LINE	now loop over the rest of tmpResults and merge each into tmpToReturn 
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
tmpResults	TokenNameIdentifier	 tmp Results
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
tfr	TokenNameIdentifier	 tfr
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
)	TokenNameRPAREN	
tmpResults	TokenNameIdentifier	 tmp Results
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
tmpToReturn	TokenNameIdentifier	 tmp To Return
.	TokenNameDOT	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
+=	TokenNamePLUS_EQUAL	
tfr	TokenNameIdentifier	 tfr
.	TokenNameDOT	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tfr	TokenNameIdentifier	 tfr
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tmpToReturn	TokenNameIdentifier	 tmp To Return
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
tmpToReturn	TokenNameIdentifier	 tmp To Return
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
=	TokenNameEQUAL	
tfr	TokenNameIdentifier	 tfr
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now merge the HashMap of tfr into this of tmpToReturn 	TokenNameCOMMENT_LINE	now merge the HashMap of tfr into this of tmpToReturn 
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
tmpToReturnMapToACCOs	TokenNameIdentifier	 tmp To Return Map To ACC Os
=	TokenNameEQUAL	
tmpToReturn	TokenNameIdentifier	 tmp To Return
.	TokenNameDOT	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
;	TokenNameSEMICOLON	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
tfrMapToACCOs	TokenNameIdentifier	 tfr Map To ACC Os
=	TokenNameEQUAL	
tfr	TokenNameIdentifier	 tfr
.	TokenNameDOT	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
;	TokenNameSEMICOLON	
IntIterator	TokenNameIdentifier	 Int Iterator
tfrIntIterator	TokenNameIdentifier	 tfr Int Iterator
=	TokenNameEQUAL	
tfrMapToACCOs	TokenNameIdentifier	 tfr Map To ACC Os
.	TokenNameDOT	
keyIterator	TokenNameIdentifier	 key Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//iterate over all ordinals in tfr that are maps to their children (and the residue over 	TokenNameCOMMENT_LINE	iterate over all ordinals in tfr that are maps to their children (and the residue over 
// non included chilren) 	TokenNameCOMMENT_LINE	non included chilren) 
while	TokenNamewhile	
(	TokenNameLPAREN	
tfrIntIterator	TokenNameIdentifier	 tfr Int Iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
tfrkey	TokenNameIdentifier	 tfrkey
=	TokenNameEQUAL	
tfrIntIterator	TokenNameIdentifier	 tfr Int Iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AACO	TokenNameIdentifier	 AACO
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
=	TokenNameEQUAL	
tmpToReturnMapToACCOs	TokenNameIdentifier	 tmp To Return Map To ACC Os
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tfrkey	TokenNameIdentifier	 tfrkey
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if tmpToReturn does not have any kids of tfrkey, map all the kids 	TokenNameCOMMENT_LINE	if tmpToReturn does not have any kids of tfrkey, map all the kids 
// from tfr to it as one package, along with their redisude 	TokenNameCOMMENT_LINE	from tfr to it as one package, along with their redisude 
tmpToReturnMapToACCOs	TokenNameIdentifier	 tmp To Return Map To ACC Os
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
tfrkey	TokenNameIdentifier	 tfrkey
,	TokenNameCOMMA	
tfrMapToACCOs	TokenNameIdentifier	 tfr Map To ACC Os
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tfrkey	TokenNameIdentifier	 tfrkey
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// merge the best K children of tfrkey as appear in tmpToReturn and in tfr 	TokenNameCOMMENT_LINE	merge the best K children of tfrkey as appear in tmpToReturn and in tfr 
AACO	TokenNameIdentifier	 AACO
tfrAACO	TokenNameIdentifier	 tfr AACO
=	TokenNameEQUAL	
tfrMapToACCOs	TokenNameIdentifier	 tfr Map To ACC Os
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tfrkey	TokenNameIdentifier	 tfrkey
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
resLength	TokenNameIdentifier	 res Length
=	TokenNameEQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
K	TokenNameIdentifier	 K
<	TokenNameLESS	
resLength	TokenNameIdentifier	 res Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resLength	TokenNameIdentifier	 res Length
=	TokenNameEQUAL	
K	TokenNameIdentifier	 K
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resOrds	TokenNameIdentifier	 res Ords
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
resLength	TokenNameIdentifier	 res Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
resVals	TokenNameIdentifier	 res Vals
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
resLength	TokenNameIdentifier	 res Length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
resResidue	TokenNameIdentifier	 res Residue
=	TokenNameEQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
residue	TokenNameIdentifier	 residue
+	TokenNamePLUS	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
residue	TokenNameIdentifier	 residue
;	TokenNameSEMICOLON	
int	TokenNameint	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ACComparator	TokenNameIdentifier	 AC Comparator
merger	TokenNameIdentifier	 merger
=	TokenNameEQUAL	
getSuitableACComparator	TokenNameIdentifier	 get Suitable AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// by facet Request 	TokenNameCOMMENT_LINE	by facet Request 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
indexIntoRes	TokenNameIdentifier	 index Into Res
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
indexIntoRes	TokenNameIdentifier	 index Into Res
<	TokenNameLESS	
resLength	TokenNameIdentifier	 res Length
;	TokenNameSEMICOLON	
indexIntoRes	TokenNameIdentifier	 index Into Res
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
>=	TokenNameGREATER_EQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//tmpToReturnAACO (former result to return) ran out of indices 	TokenNameCOMMENT_LINE	tmpToReturnAACO (former result to return) ran out of indices 
// it is all merged into resOrds and resVal 	TokenNameCOMMENT_LINE	it is all merged into resOrds and resVal 
resOrds	TokenNameIdentifier	 res Ords
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
resVals	TokenNameIdentifier	 res Vals
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
>=	TokenNameGREATER_EQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// tfr ran out of indices 	TokenNameCOMMENT_LINE	tfr ran out of indices 
resOrds	TokenNameIdentifier	 res Ords
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
resVals	TokenNameIdentifier	 res Vals
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// select which goes now to res: next (ord, value) from tmpToReturn or from tfr: 	TokenNameCOMMENT_LINE	select which goes now to res: next (ord, value) from tmpToReturn or from tfr: 
if	TokenNameif	
(	TokenNameLPAREN	
merger	TokenNameIdentifier	 merger
.	TokenNameDOT	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resOrds	TokenNameIdentifier	 res Ords
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
resVals	TokenNameIdentifier	 res Vals
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
resOrds	TokenNameIdentifier	 res Ords
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
resVals	TokenNameIdentifier	 res Vals
[	TokenNameLBRACKET	
indexIntoRes	TokenNameIdentifier	 index Into Res
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr 	TokenNameCOMMENT_LINE	end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr 
// altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of 	TokenNameCOMMENT_LINE	altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of 
// tmpToReturn 	TokenNameCOMMENT_LINE	tmpToReturn 
while	TokenNamewhile	
(	TokenNameLPAREN	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
<	TokenNameLESS	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resResidue	TokenNameIdentifier	 res Residue
+=	TokenNamePLUS_EQUAL	
tmpToReturnAACO	TokenNameIdentifier	 tmp To Return AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTmpToReturn	TokenNameIdentifier	 index Into Tmp To Return
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
<	TokenNameLESS	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resResidue	TokenNameIdentifier	 res Residue
+=	TokenNamePLUS_EQUAL	
tfrAACO	TokenNameIdentifier	 tfr AACO
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
indexIntoTFR	TokenNameIdentifier	 index Into TFR
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//update the list of best kids of tfrkey as appear in tmpToReturn 	TokenNameCOMMENT_LINE	update the list of best kids of tfrkey as appear in tmpToReturn 
tmpToReturnMapToACCOs	TokenNameIdentifier	 tmp To Return Map To ACC Os
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
tfrkey	TokenNameIdentifier	 tfrkey
,	TokenNameCOMMA	
new	TokenNamenew	
AACO	TokenNameIdentifier	 AACO
(	TokenNameLPAREN	
resOrds	TokenNameIdentifier	 res Ords
,	TokenNameCOMMA	
resVals	TokenNameIdentifier	 res Vals
,	TokenNameCOMMA	
resResidue	TokenNameIdentifier	 res Residue
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endof need to merge both AACO -- children and residue for same ordinal 	TokenNameCOMMENT_LINE	endof need to merge both AACO -- children and residue for same ordinal 
}	TokenNameRBRACE	
// endof loop over all ordinals in tfr 	TokenNameCOMMENT_LINE	endof loop over all ordinals in tfr 
}	TokenNameRBRACE	
// endof loop over all temporary facet results to merge 	TokenNameCOMMENT_LINE	endof loop over all temporary facet results to merge 
return	TokenNamereturn	
tmpToReturn	TokenNameIdentifier	 tmp To Return
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
AggregatedCategoryHeap	TokenNameIdentifier	 Aggregated Category Heap
extends	TokenNameextends	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
ACComparator	TokenNameIdentifier	 AC Comparator
merger	TokenNameIdentifier	 merger
;	TokenNameSEMICOLON	
public	TokenNamepublic	
AggregatedCategoryHeap	TokenNameIdentifier	 Aggregated Category Heap
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
,	TokenNameCOMMA	
ACComparator	TokenNameIdentifier	 AC Comparator
merger	TokenNameIdentifier	 merger
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
merger	TokenNameIdentifier	 merger
=	TokenNameEQUAL	
merger	TokenNameIdentifier	 merger
;	TokenNameSEMICOLON	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
arg1	TokenNameIdentifier	 arg1
,	TokenNameCOMMA	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
arg2	TokenNameIdentifier	 arg2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
merger	TokenNameIdentifier	 merger
.	TokenNameDOT	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
arg2	TokenNameIdentifier	 arg2
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
arg2	TokenNameIdentifier	 arg2
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
arg1	TokenNameIdentifier	 arg1
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
arg1	TokenNameIdentifier	 arg1
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ResultNodeHeap	TokenNameIdentifier	 Result Node Heap
extends	TokenNameextends	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
{	TokenNameLBRACE	
private	TokenNameprivate	
ACComparator	TokenNameIdentifier	 AC Comparator
merger	TokenNameIdentifier	 merger
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ResultNodeHeap	TokenNameIdentifier	 Result Node Heap
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
,	TokenNameCOMMA	
ACComparator	TokenNameIdentifier	 AC Comparator
merger	TokenNameIdentifier	 merger
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
merger	TokenNameIdentifier	 merger
=	TokenNameEQUAL	
merger	TokenNameIdentifier	 merger
;	TokenNameSEMICOLON	
initialize	TokenNameIdentifier	 initialize
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
lessThan	TokenNameIdentifier	 less Than
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
arg1	TokenNameIdentifier	 arg1
,	TokenNameCOMMA	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
arg2	TokenNameIdentifier	 arg2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
merger	TokenNameIdentifier	 merger
.	TokenNameDOT	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
arg2	TokenNameIdentifier	 arg2
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
arg2	TokenNameIdentifier	 arg2
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
arg1	TokenNameIdentifier	 arg1
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
arg1	TokenNameIdentifier	 arg1
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return the {@link ACComparator} that reflects the order, * expressed in the {@link FacetRequest}, of * facets in the {@link FacetResult}. */	TokenNameCOMMENT_JAVADOC	 @return the {@link ACComparator} that reflects the order, expressed in the {@link FacetRequest}, of facets in the {@link FacetResult}. 
private	TokenNameprivate	
ACComparator	TokenNameIdentifier	 AC Comparator
getSuitableACComparator	TokenNameIdentifier	 get Suitable AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getSortOrder	TokenNameIdentifier	 get Sort Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
SortOrder	TokenNameIdentifier	 Sort Order
.	TokenNameDOT	
ASCENDING	TokenNameIdentifier	 ASCENDING
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getSortBy	TokenNameIdentifier	 get Sort By
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
VALUE	TokenNameIdentifier	 VALUE
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
AscValueACComparator	TokenNameIdentifier	 Asc Value AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ORDINAL	TokenNameIdentifier	 ORDINAL
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
AscOrdACComparator	TokenNameIdentifier	 Asc Ord AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getSortBy	TokenNameIdentifier	 get Sort By
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
VALUE	TokenNameIdentifier	 VALUE
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
DescValueACComparator	TokenNameIdentifier	 Desc Value AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ORDINAL	TokenNameIdentifier	 ORDINAL
:	TokenNameCOLON	
return	TokenNamereturn	
new	TokenNamenew	
DescOrdACComparator	TokenNameIdentifier	 Desc Ord AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A comparator of two Aggregated Categories according to the order * (ascending / descending) and item (ordinal or value) specified in the * FacetRequest for the FacetResult to be generated */	TokenNameCOMMENT_JAVADOC	 A comparator of two Aggregated Categories according to the order (ascending / descending) and item (ordinal or value) specified in the FacetRequest for the FacetResult to be generated 
private	TokenNameprivate	
static	TokenNamestatic	
abstract	TokenNameabstract	
class	TokenNameclass	
ACComparator	TokenNameIdentifier	 AC Comparator
{	TokenNameLBRACE	
ACComparator	TokenNameIdentifier	 AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
abstract	TokenNameabstract	
boolean	TokenNameboolean	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
int	TokenNameint	
ord1	TokenNameIdentifier	 ord1
,	TokenNameCOMMA	
double	TokenNamedouble	
val1	TokenNameIdentifier	 val1
,	TokenNameCOMMA	
int	TokenNameint	
ord2	TokenNameIdentifier	 ord2
,	TokenNameCOMMA	
double	TokenNamedouble	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
AscValueACComparator	TokenNameIdentifier	 Asc Value AC Comparator
extends	TokenNameextends	
ACComparator	TokenNameIdentifier	 AC Comparator
{	TokenNameLBRACE	
AscValueACComparator	TokenNameIdentifier	 Asc Value AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
int	TokenNameint	
ord1	TokenNameIdentifier	 ord1
,	TokenNameCOMMA	
double	TokenNamedouble	
val1	TokenNameIdentifier	 val1
,	TokenNameCOMMA	
int	TokenNameint	
ord2	TokenNameIdentifier	 ord2
,	TokenNameCOMMA	
double	TokenNamedouble	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
val1	TokenNameIdentifier	 val1
<	TokenNameLESS	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
DescValueACComparator	TokenNameIdentifier	 Desc Value AC Comparator
extends	TokenNameextends	
ACComparator	TokenNameIdentifier	 AC Comparator
{	TokenNameLBRACE	
DescValueACComparator	TokenNameIdentifier	 Desc Value AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
int	TokenNameint	
ord1	TokenNameIdentifier	 ord1
,	TokenNameCOMMA	
double	TokenNamedouble	
val1	TokenNameIdentifier	 val1
,	TokenNameCOMMA	
int	TokenNameint	
ord2	TokenNameIdentifier	 ord2
,	TokenNameCOMMA	
double	TokenNamedouble	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
val1	TokenNameIdentifier	 val1
>	TokenNameGREATER	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
AscOrdACComparator	TokenNameIdentifier	 Asc Ord AC Comparator
extends	TokenNameextends	
ACComparator	TokenNameIdentifier	 AC Comparator
{	TokenNameLBRACE	
AscOrdACComparator	TokenNameIdentifier	 Asc Ord AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
int	TokenNameint	
ord1	TokenNameIdentifier	 ord1
,	TokenNameCOMMA	
double	TokenNamedouble	
val1	TokenNameIdentifier	 val1
,	TokenNameCOMMA	
int	TokenNameint	
ord2	TokenNameIdentifier	 ord2
,	TokenNameCOMMA	
double	TokenNamedouble	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ord1	TokenNameIdentifier	 ord1
<	TokenNameLESS	
ord2	TokenNameIdentifier	 ord2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
DescOrdACComparator	TokenNameIdentifier	 Desc Ord AC Comparator
extends	TokenNameextends	
ACComparator	TokenNameIdentifier	 AC Comparator
{	TokenNameLBRACE	
DescOrdACComparator	TokenNameIdentifier	 Desc Ord AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
boolean	TokenNameboolean	
leftGoesNow	TokenNameIdentifier	 left Goes Now
(	TokenNameLPAREN	
int	TokenNameint	
ord1	TokenNameIdentifier	 ord1
,	TokenNameCOMMA	
double	TokenNamedouble	
val1	TokenNameIdentifier	 val1
,	TokenNameCOMMA	
int	TokenNameint	
ord2	TokenNameIdentifier	 ord2
,	TokenNameCOMMA	
double	TokenNamedouble	
val2	TokenNameIdentifier	 val2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ord1	TokenNameIdentifier	 ord1
>	TokenNameGREATER	
ord2	TokenNameIdentifier	 ord2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Intermediate result to hold counts from one or more partitions processed * thus far. Its main field, constructor parameter <i>mapToAACOs</i>, is a map * from ordinals to AACOs. The AACOs mapped to contain ordinals and values * encountered in the count arrays of the partitions processed thus far. The * ordinals mapped from are their parents, and they may be not contained in * the partitions processed thus far. All nodes belong to the taxonomy subtree * defined at the facet request, constructor parameter <i>facetReq</i>, by its * root and depth. */	TokenNameCOMMENT_JAVADOC	 Intermediate result to hold counts from one or more partitions processed thus far. Its main field, constructor parameter <i>mapToAACOs</i>, is a map from ordinals to AACOs. The AACOs mapped to contain ordinals and values encountered in the count arrays of the partitions processed thus far. The ordinals mapped from are their parents, and they may be not contained in the partitions processed thus far. All nodes belong to the taxonomy subtree defined at the facet request, constructor parameter <i>facetReq</i>, by its root and depth. 
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
implements	TokenNameimplements	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
{	TokenNameLBRACE	
protected	TokenNameprotected	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
;	TokenNameSEMICOLON	
FacetRequest	TokenNameIdentifier	 Facet Request
facetRequest	TokenNameIdentifier	 facet Request
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
;	TokenNameSEMICOLON	
// among the ordinals in the partitions 	TokenNameCOMMENT_LINE	among the ordinals in the partitions 
// processed thus far 	TokenNameCOMMENT_LINE	processed thus far 
double	TokenNamedouble	
rootNodeValue	TokenNameIdentifier	 root Node Value
;	TokenNameSEMICOLON	
// the value of it, in case encountered. 	TokenNameCOMMENT_LINE	the value of it, in case encountered. 
int	TokenNameint	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
;	TokenNameSEMICOLON	
// total number of facets 	TokenNameCOMMENT_LINE	total number of facets 
// which belong to facetRequest subtree and have value != 0, 	TokenNameCOMMENT_LINE	which belong to facetRequest subtree and have value != 0, 
// and have been encountered thus far in the partitions processed. 	TokenNameCOMMENT_LINE	and have been encountered thus far in the partitions processed. 
// root node of result tree is not included in this count. 	TokenNameCOMMENT_LINE	root node of result tree is not included in this count. 
public	TokenNamepublic	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
(	TokenNameLPAREN	
FacetRequest	TokenNameIdentifier	 Facet Request
facetReq	TokenNameIdentifier	 facet Req
,	TokenNameCOMMA	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
=	TokenNameEQUAL	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
=	TokenNameEQUAL	
facetReq	TokenNameIdentifier	 facet Req
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
=	TokenNameEQUAL	
0.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
FacetRequest	TokenNameIdentifier	 Facet Request
getFacetRequest	TokenNameIdentifier	 get Facet Request
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endof FacetResultWithHash 	TokenNameCOMMENT_LINE	endof FacetResultWithHash 
/** * Maintains info of one entry in the filled up count array: * an ordinal number of a category and the value aggregated for it * (typically, that value is the count for that ordinal). */	TokenNameCOMMENT_JAVADOC	 Maintains info of one entry in the filled up count array: an ordinal number of a category and the value aggregated for it (typically, that value is the count for that ordinal). 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
{	TokenNameLBRACE	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
;	TokenNameSEMICOLON	
double	TokenNamedouble	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
AggregatedCategory	TokenNameIdentifier	 Aggregated Category
(	TokenNameLPAREN	
int	TokenNameint	
ord	TokenNameIdentifier	 ord
,	TokenNameCOMMA	
double	TokenNamedouble	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
ord	TokenNameIdentifier	 ord
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Maintains an array of {@link AggregatedCategory}. For space consideration, this is implemented as * a pair of arrays, <i>ordinals</i> and <i>values</i>, rather than one array of pairs. * Enumerated in <i>ordinals</i> are siblings, * potential nodes of the {@link FacetResult} tree * (i.e., the descendants of the root node, no deeper than the specified depth). * No more than K ( = {@link FacetRequest#getNumResults()}) * siblings are enumerated, and * <i>residue</i> holds the sum of values of the siblings rejected from the * enumerated top K. */	TokenNameCOMMENT_JAVADOC	 Maintains an array of {@link AggregatedCategory}. For space consideration, this is implemented as a pair of arrays, <i>ordinals</i> and <i>values</i>, rather than one array of pairs. Enumerated in <i>ordinals</i> are siblings, potential nodes of the {@link FacetResult} tree (i.e., the descendants of the root node, no deeper than the specified depth). No more than K ( = {@link FacetRequest#getNumResults()}) siblings are enumerated, and <i>residue</i> holds the sum of values of the siblings rejected from the enumerated top K. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
AACO	TokenNameIdentifier	 AACO
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ordinals	TokenNameIdentifier	 ordinals
;	TokenNameSEMICOLON	
// ordinals of the best K children, sorted from best to least 	TokenNameCOMMENT_LINE	ordinals of the best K children, sorted from best to least 
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
values	TokenNameIdentifier	 values
;	TokenNameSEMICOLON	
// the respective values for these children 	TokenNameCOMMENT_LINE	the respective values for these children 
double	TokenNamedouble	
residue	TokenNameIdentifier	 residue
;	TokenNameSEMICOLON	
// sum of values of all other children, that did not get into top K 	TokenNameCOMMENT_LINE	sum of values of all other children, that did not get into top K 
AACO	TokenNameIdentifier	 AACO
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ords	TokenNameIdentifier	 ords
,	TokenNameCOMMA	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
vals	TokenNameIdentifier	 vals
,	TokenNameCOMMA	
double	TokenNamedouble	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
=	TokenNameEQUAL	
ords	TokenNameIdentifier	 ords
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
values	TokenNameIdentifier	 values
=	TokenNameEQUAL	
vals	TokenNameIdentifier	 vals
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
residue	TokenNameIdentifier	 residue
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
/** * Recursively label the first facetRequest.getNumLabel() sub results * of the root of a given {@link FacetResult}, or of an already labeled node in it. * I.e., a node is labeled only if it is the root or all its ancestors are labeled. */	TokenNameCOMMENT_JAVADOC	 Recursively label the first facetRequest.getNumLabel() sub results of the root of a given {@link FacetResult}, or of an already labeled node in it. I.e., a node is labeled only if it is the root or all its ancestors are labeled. 
public	TokenNamepublic	
void	TokenNamevoid	
labelResult	TokenNameIdentifier	 label Result
(	TokenNameLPAREN	
FacetResult	TokenNameIdentifier	 Facet Result
facetResult	TokenNameIdentifier	 facet Result
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
facetResult	TokenNameIdentifier	 facet Result
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// any result to label? 	TokenNameCOMMENT_LINE	any result to label? 
}	TokenNameRBRACE	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
rootNode	TokenNameIdentifier	 root Node
=	TokenNameEQUAL	
facetResult	TokenNameIdentifier	 facet Result
.	TokenNameDOT	
getFacetResultNode	TokenNameIdentifier	 get Facet Result Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
recursivelyLabel	TokenNameIdentifier	 recursively Label
(	TokenNameLPAREN	
rootNode	TokenNameIdentifier	 root Node
,	TokenNameCOMMA	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getNumLabel	TokenNameIdentifier	 get Num Label
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
recursivelyLabel	TokenNameIdentifier	 recursively Label
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
numToLabel	TokenNameIdentifier	 num To Label
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getLabel	TokenNameIdentifier	 get Label
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// attach a label -- category path -- to the node 	TokenNameCOMMENT_LINE	attach a label -- category path -- to the node 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getSubResults	TokenNameIdentifier	 get Sub Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// if node has no children -- done 	TokenNameCOMMENT_LINE	if node has no children -- done 
}	TokenNameRBRACE	
// otherwise, label the first numToLabel of these children, and recursively -- their children. 	TokenNameCOMMENT_LINE	otherwise, label the first numToLabel of these children, and recursively -- their children. 
int	TokenNameint	
numLabeled	TokenNameIdentifier	 num Labeled
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
frn	TokenNameIdentifier	 frn
:	TokenNameCOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getSubResults	TokenNameIdentifier	 get Sub Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// go over the children of node from first to last, no more than numToLable of them 	TokenNameCOMMENT_LINE	go over the children of node from first to last, no more than numToLable of them 
recursivelyLabel	TokenNameIdentifier	 recursively Label
(	TokenNameLPAREN	
frn	TokenNameIdentifier	 frn
,	TokenNameCOMMA	
numToLabel	TokenNameIdentifier	 num To Label
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
numLabeled	TokenNameIdentifier	 num Labeled
>=	TokenNameGREATER_EQUAL	
numToLabel	TokenNameIdentifier	 num To Label
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
// verifies that the children of each node are sorted by the order 	TokenNameCOMMENT_LINE	verifies that the children of each node are sorted by the order 
// specified by the facetRequest. 	TokenNameCOMMENT_LINE	specified by the facetRequest. 
// the values in these nodes may have changed due to a re-count, for example 	TokenNameCOMMENT_LINE	the values in these nodes may have changed due to a re-count, for example 
// following the accumulation by Sampling. 	TokenNameCOMMENT_LINE	following the accumulation by Sampling. 
// so now we test and re-order if necessary. 	TokenNameCOMMENT_LINE	so now we test and re-order if necessary. 
public	TokenNamepublic	
FacetResult	TokenNameIdentifier	 Facet Result
rearrangeFacetResult	TokenNameIdentifier	 rearrange Facet Result
(	TokenNameLPAREN	
FacetResult	TokenNameIdentifier	 Facet Result
facetResult	TokenNameIdentifier	 facet Result
)	TokenNameRPAREN	
{	TokenNameLBRACE	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
nodesHeap	TokenNameIdentifier	 nodes Heap
=	TokenNameEQUAL	
new	TokenNamenew	
ResultNodeHeap	TokenNameIdentifier	 Result Node Heap
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getNumResults	TokenNameIdentifier	 get Num Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getSuitableACComparator	TokenNameIdentifier	 get Suitable AC Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
topFrn	TokenNameIdentifier	 top Frn
=	TokenNameEQUAL	
(	TokenNameLPAREN	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
)	TokenNameRPAREN	
facetResult	TokenNameIdentifier	 facet Result
.	TokenNameDOT	
getFacetResultNode	TokenNameIdentifier	 get Facet Result Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// safe cast 	TokenNameCOMMENT_LINE	safe cast 
rearrangeChilrenOfNode	TokenNameIdentifier	 rearrange Chilren Of Node
(	TokenNameLPAREN	
topFrn	TokenNameIdentifier	 top Frn
,	TokenNameCOMMA	
nodesHeap	TokenNameIdentifier	 nodes Heap
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
facetResult	TokenNameIdentifier	 facet Result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
rearrangeChilrenOfNode	TokenNameIdentifier	 rearrange Chilren Of Node
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
PriorityQueue	TokenNameIdentifier	 Priority Queue
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
nodesHeap	TokenNameIdentifier	 nodes Heap
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodesHeap	TokenNameIdentifier	 nodes Heap
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// just to be safe 	TokenNameCOMMENT_LINE	just to be safe 
for	TokenNamefor	
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
frn	TokenNameIdentifier	 frn
:	TokenNameCOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getSubResults	TokenNameIdentifier	 get Sub Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodesHeap	TokenNameIdentifier	 nodes Heap
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
frn	TokenNameIdentifier	 frn
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
nodesHeap	TokenNameIdentifier	 nodes Heap
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
subResults	TokenNameIdentifier	 sub Results
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
nodesHeap	TokenNameIdentifier	 nodes Heap
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
subResults	TokenNameIdentifier	 sub Results
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
nodesHeap	TokenNameIdentifier	 nodes Heap
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
.	TokenNameDOT	
setSubResults	TokenNameIdentifier	 set Sub Results
(	TokenNameLPAREN	
subResults	TokenNameIdentifier	 sub Results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
frn	TokenNameIdentifier	 frn
:	TokenNameCOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getSubResults	TokenNameIdentifier	 get Sub Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rearrangeChilrenOfNode	TokenNameIdentifier	 rearrange Chilren Of Node
(	TokenNameLPAREN	
frn	TokenNameIdentifier	 frn
,	TokenNameCOMMA	
nodesHeap	TokenNameIdentifier	 nodes Heap
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
FacetResult	TokenNameIdentifier	 Facet Result
renderFacetResult	TokenNameIdentifier	 render Facet Result
(	TokenNameLPAREN	
IntermediateFacetResult	TokenNameIdentifier	 Intermediate Facet Result
tmpResult	TokenNameIdentifier	 tmp Result
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IntermediateFacetResultWithHash	TokenNameIdentifier	 Intermediate Facet Result With Hash
)	TokenNameRPAREN	
tmpResult	TokenNameIdentifier	 tmp Result
;	TokenNameSEMICOLON	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
.	TokenNameDOT	
getOrdinal	TokenNameIdentifier	 get Ordinal
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
.	TokenNameDOT	
getCategoryPath	TokenNameIdentifier	 get Category Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
==	TokenNameEQUAL_EQUAL	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
.	TokenNameDOT	
INVALID_ORDINAL	TokenNameIdentifier	 INVALID  ORDINAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
double	TokenNamedouble	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
isRootNodeIncluded	TokenNameIdentifier	 is Root Node Included
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
rootNodeValue	TokenNameIdentifier	 root Node Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
generateNode	TokenNameIdentifier	 generate Node
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
FacetResult	TokenNameIdentifier	 Facet Result
(	TokenNameLPAREN	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
facetRequest	TokenNameIdentifier	 facet Request
,	TokenNameCOMMA	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
tmp	TokenNameIdentifier	 tmp
.	TokenNameDOT	
totalNumOfFacetsConsidered	TokenNameIdentifier	 total Num Of Facets Considered
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
generateNode	TokenNameIdentifier	 generate Node
(	TokenNameLPAREN	
int	TokenNameint	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
double	TokenNamedouble	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
IntToObjectMap	TokenNameIdentifier	 Int To Object Map
<	TokenNameLESS	
AACO	TokenNameIdentifier	 AACO
>	TokenNameGREATER	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
new	TokenNamenew	
MutableFacetResultNode	TokenNameIdentifier	 Mutable Facet Result Node
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
,	TokenNameCOMMA	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AACO	TokenNameIdentifier	 AACO
aaco	TokenNameIdentifier	 aaco
=	TokenNameEQUAL	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
ordinal	TokenNameIdentifier	 ordinal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
aaco	TokenNameIdentifier	 aaco
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
FacetResultNode	TokenNameIdentifier	 Facet Result Node
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
aaco	TokenNameIdentifier	 aaco
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
generateNode	TokenNameIdentifier	 generate Node
(	TokenNameLPAREN	
aaco	TokenNameIdentifier	 aaco
.	TokenNameDOT	
ordinals	TokenNameIdentifier	 ordinals
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
aaco	TokenNameIdentifier	 aaco
.	TokenNameDOT	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
mapToAACOs	TokenNameIdentifier	 map To AAC Os
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
setSubResults	TokenNameIdentifier	 set Sub Results
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
setResidue	TokenNameIdentifier	 set Residue
(	TokenNameLPAREN	
aaco	TokenNameIdentifier	 aaco
.	TokenNameDOT	
residue	TokenNameIdentifier	 residue
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
