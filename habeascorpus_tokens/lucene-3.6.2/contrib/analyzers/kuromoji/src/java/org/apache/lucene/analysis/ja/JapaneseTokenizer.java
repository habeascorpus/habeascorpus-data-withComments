package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Reader	TokenNameIdentifier	 Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collections	TokenNameIdentifier	 Collections
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
EnumMap	TokenNameIdentifier	 Enum Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Tokenizer	TokenNameIdentifier	 Tokenizer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
CharacterDefinition	TokenNameIdentifier	 Character Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
ConnectionCosts	TokenNameIdentifier	 Connection Costs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
Dictionary	TokenNameIdentifier	 Dictionary
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
TokenInfoDictionary	TokenNameIdentifier	 Token Info Dictionary
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
TokenInfoFST	TokenNameIdentifier	 Token Info FST
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
UnknownDictionary	TokenNameIdentifier	 Unknown Dictionary
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
UserDictionary	TokenNameIdentifier	 User Dictionary
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
ja	TokenNameIdentifier	 ja
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntsRef	TokenNameIdentifier	 Ints Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RollingCharBuffer	TokenNameIdentifier	 Rolling Char Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
FST	TokenNameIdentifier	 FST
;	TokenNameSEMICOLON	
// TODO: somehow factor out a reusable viterbi search here, 	TokenNameCOMMENT_LINE	TODO: somehow factor out a reusable viterbi search here, 
// so other decompounders/tokenizers can reuse... 	TokenNameCOMMENT_LINE	so other decompounders/tokenizers can reuse... 
/** * Tokenizer for Japanese that uses morphological analysis. * <p> * This tokenizer sets a number of additional attributes: * <ul> * <li>{@link BaseFormAttribute} containing base form for inflected * adjectives and verbs. * <li>{@link PartOfSpeechAttribute} containing part-of-speech. * <li>{@link ReadingAttribute} containing reading and pronunciation. * <li>{@link InflectionAttribute} containing additional part-of-speech * information for inflected forms. * </ul> * <p> * This tokenizer uses a rolling Viterbi search to find the * least cost segmentation (path) of the incoming characters. * For tokens that appear to be compound (> length 2 for all * Kanji, or > length 7 for non-Kanji), we see if there is a * 2nd best segmentation of that token after applying * penalties to the long tokens. If so, and the Mode is * {@link Mode#SEARCH}, we output the alternate segmentation * as well. */	TokenNameCOMMENT_JAVADOC	 Tokenizer for Japanese that uses morphological analysis. <p> This tokenizer sets a number of additional attributes: <ul> <li>{@link BaseFormAttribute} containing base form for inflected adjectives and verbs. <li>{@link PartOfSpeechAttribute} containing part-of-speech. <li>{@link ReadingAttribute} containing reading and pronunciation. <li>{@link InflectionAttribute} containing additional part-of-speech information for inflected forms. </ul> <p> This tokenizer uses a rolling Viterbi search to find the least cost segmentation (path) of the incoming characters. For tokens that appear to be compound (> length 2 for all Kanji, or > length 7 for non-Kanji), we see if there is a 2nd best segmentation of that token after applying penalties to the long tokens. If so, and the Mode is {@link Mode#SEARCH}, we output the alternate segmentation as well. 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
JapaneseTokenizer	TokenNameIdentifier	 Japanese Tokenizer
extends	TokenNameextends	
Tokenizer	TokenNameIdentifier	 Tokenizer
{	TokenNameLBRACE	
/** * Tokenization mode: this determines how the tokenizer handles * compound and unknown words. */	TokenNameCOMMENT_JAVADOC	 Tokenization mode: this determines how the tokenizer handles compound and unknown words. 
public	TokenNamepublic	
static	TokenNamestatic	
enum	TokenNameenum	
Mode	TokenNameIdentifier	 Mode
{	TokenNameLBRACE	
/** * Ordinary segmentation: no decomposition for compounds, */	TokenNameCOMMENT_JAVADOC	 Ordinary segmentation: no decomposition for compounds, 
NORMAL	TokenNameIdentifier	 NORMAL
,	TokenNameCOMMA	
/** * Segmentation geared towards search: this includes a * decompounding process for long nouns, also including * the full compound token as a synonym. */	TokenNameCOMMENT_JAVADOC	 Segmentation geared towards search: this includes a decompounding process for long nouns, also including the full compound token as a synonym. 
SEARCH	TokenNameIdentifier	 SEARCH
,	TokenNameCOMMA	
/** * Extended mode outputs unigrams for unknown words. * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Extended mode outputs unigrams for unknown words. @lucene.experimental 
EXTENDED	TokenNameIdentifier	 EXTENDED
}	TokenNameRBRACE	
/** * Default tokenization mode. Currently this is {@link Mode#SEARCH}. */	TokenNameCOMMENT_JAVADOC	 Default tokenization mode. Currently this is {@link Mode#SEARCH}. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Mode	TokenNameIdentifier	 Mode
DEFAULT_MODE	TokenNameIdentifier	 DEFAULT  MODE
=	TokenNameEQUAL	
Mode	TokenNameIdentifier	 Mode
.	TokenNameDOT	
SEARCH	TokenNameIdentifier	 SEARCH
;	TokenNameSEMICOLON	
enum	TokenNameenum	
Type	TokenNameIdentifier	 Type
{	TokenNameLBRACE	
KNOWN	TokenNameIdentifier	 KNOWN
,	TokenNameCOMMA	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
,	TokenNameCOMMA	
USER	TokenNameIdentifier	 USER
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
VERBOSE	TokenNameIdentifier	 VERBOSE
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SEARCH_MODE_KANJI_LENGTH	TokenNameIdentifier	 SEARCH  MODE  KANJI  LENGTH
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SEARCH_MODE_OTHER_LENGTH	TokenNameIdentifier	 SEARCH  MODE  OTHER  LENGTH
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Must be >= SEARCH_MODE_KANJI_LENGTH 	TokenNameCOMMENT_LINE	Must be >= SEARCH_MODE_KANJI_LENGTH 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SEARCH_MODE_KANJI_PENALTY	TokenNameIdentifier	 SEARCH  MODE  KANJI  PENALTY
=	TokenNameEQUAL	
3000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
SEARCH_MODE_OTHER_PENALTY	TokenNameIdentifier	 SEARCH  MODE  OTHER  PENALTY
=	TokenNameEQUAL	
1700	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// For safety: 	TokenNameCOMMENT_LINE	For safety: 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_UNKNOWN_WORD_LENGTH	TokenNameIdentifier	 MAX  UNKNOWN  WORD  LENGTH
=	TokenNameEQUAL	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
MAX_BACKTRACE_GAP	TokenNameIdentifier	 MAX  BACKTRACE  GAP
=	TokenNameEQUAL	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
EnumMap	TokenNameIdentifier	 Enum Map
<	TokenNameLESS	
Type	TokenNameIdentifier	 Type
,	TokenNameCOMMA	
Dictionary	TokenNameIdentifier	 Dictionary
>	TokenNameGREATER	
dictionaryMap	TokenNameIdentifier	 dictionary Map
=	TokenNameEQUAL	
new	TokenNamenew	
EnumMap	TokenNameIdentifier	 Enum Map
<	TokenNameLESS	
Type	TokenNameIdentifier	 Type
,	TokenNameCOMMA	
Dictionary	TokenNameIdentifier	 Dictionary
>	TokenNameGREATER	
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
TokenInfoFST	TokenNameIdentifier	 Token Info FST
fst	TokenNameIdentifier	 fst
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
TokenInfoDictionary	TokenNameIdentifier	 Token Info Dictionary
dictionary	TokenNameIdentifier	 dictionary
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
UnknownDictionary	TokenNameIdentifier	 Unknown Dictionary
unkDictionary	TokenNameIdentifier	 unk Dictionary
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ConnectionCosts	TokenNameIdentifier	 Connection Costs
costs	TokenNameIdentifier	 costs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
UserDictionary	TokenNameIdentifier	 User Dictionary
userDictionary	TokenNameIdentifier	 user Dictionary
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CharacterDefinition	TokenNameIdentifier	 Character Definition
characterDefinition	TokenNameIdentifier	 character Definition
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
arc	TokenNameIdentifier	 arc
=	TokenNameEQUAL	
new	TokenNamenew	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
Arc	TokenNameIdentifier	 Arc
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
fstReader	TokenNameIdentifier	 fst Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IntsRef	TokenNameIdentifier	 Ints Ref
wordIdRef	TokenNameIdentifier	 word Id Ref
=	TokenNameEQUAL	
new	TokenNamenew	
IntsRef	TokenNameIdentifier	 Ints Ref
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FST	TokenNameIdentifier	 FST
.	TokenNameDOT	
BytesReader	TokenNameIdentifier	 Bytes Reader
userFSTReader	TokenNameIdentifier	 user FST Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
TokenInfoFST	TokenNameIdentifier	 Token Info FST
userFST	TokenNameIdentifier	 user FST
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
RollingCharBuffer	TokenNameIdentifier	 Rolling Char Buffer
buffer	TokenNameIdentifier	 buffer
=	TokenNameEQUAL	
new	TokenNamenew	
RollingCharBuffer	TokenNameIdentifier	 Rolling Char Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
WrappedPositionArray	TokenNameIdentifier	 Wrapped Position Array
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
new	TokenNamenew	
WrappedPositionArray	TokenNameIdentifier	 Wrapped Position Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
searchMode	TokenNameIdentifier	 search Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
extendedMode	TokenNameIdentifier	 extended Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
outputCompounds	TokenNameIdentifier	 output Compounds
;	TokenNameSEMICOLON	
// Index of the last character of unknown word: 	TokenNameCOMMENT_LINE	Index of the last character of unknown word: 
private	TokenNameprivate	
int	TokenNameint	
unknownWordEndIndex	TokenNameIdentifier	 unknown Word End Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// True once we've hit the EOF from the input reader: 	TokenNameCOMMENT_LINE	True once we've hit the EOF from the input reader: 
private	TokenNameprivate	
boolean	TokenNameboolean	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
// Last absolute position we backtraced from: 	TokenNameCOMMENT_LINE	Last absolute position we backtraced from: 
private	TokenNameprivate	
int	TokenNameint	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
;	TokenNameSEMICOLON	
// Position of last token we returned; we use this to 	TokenNameCOMMENT_LINE	Position of last token we returned; we use this to 
// figure out whether to set posIncr to 0 or 1: 	TokenNameCOMMENT_LINE	figure out whether to set posIncr to 0 or 1: 
private	TokenNameprivate	
int	TokenNameint	
lastTokenPos	TokenNameIdentifier	 last Token Pos
;	TokenNameSEMICOLON	
// Next absolute position to process: 	TokenNameCOMMENT_LINE	Next absolute position to process: 
private	TokenNameprivate	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
// Already parsed, but not yet passed to caller, tokens: 	TokenNameCOMMENT_LINE	Already parsed, but not yet passed to caller, tokens: 
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
pending	TokenNameIdentifier	 pending
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
termAtt	TokenNameIdentifier	 term Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
offsetAtt	TokenNameIdentifier	 offset Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
OffsetAttribute	TokenNameIdentifier	 Offset Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
posIncAtt	TokenNameIdentifier	 pos Inc Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
posLengthAtt	TokenNameIdentifier	 pos Length Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PositionLengthAttribute	TokenNameIdentifier	 Position Length Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BaseFormAttribute	TokenNameIdentifier	 Base Form Attribute
basicFormAtt	TokenNameIdentifier	 basic Form Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
BaseFormAttribute	TokenNameIdentifier	 Base Form Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
PartOfSpeechAttribute	TokenNameIdentifier	 Part Of Speech Attribute
posAtt	TokenNameIdentifier	 pos Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
PartOfSpeechAttribute	TokenNameIdentifier	 Part Of Speech Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ReadingAttribute	TokenNameIdentifier	 Reading Attribute
readingAtt	TokenNameIdentifier	 reading Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
ReadingAttribute	TokenNameIdentifier	 Reading Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
InflectionAttribute	TokenNameIdentifier	 Inflection Attribute
inflectionAtt	TokenNameIdentifier	 inflection Att
=	TokenNameEQUAL	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
InflectionAttribute	TokenNameIdentifier	 Inflection Attribute
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Create a new JapaneseTokenizer. * * @param input Reader containing text * @param userDictionary Optional: if non-null, user dictionary. * @param discardPunctuation true if punctuation tokens should be dropped from the output. * @param mode tokenization mode. */	TokenNameCOMMENT_JAVADOC	 Create a new JapaneseTokenizer. * @param input Reader containing text @param userDictionary Optional: if non-null, user dictionary. @param discardPunctuation true if punctuation tokens should be dropped from the output. @param mode tokenization mode. 
public	TokenNamepublic	
JapaneseTokenizer	TokenNameIdentifier	 Japanese Tokenizer
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
UserDictionary	TokenNameIdentifier	 User Dictionary
userDictionary	TokenNameIdentifier	 user Dictionary
,	TokenNameCOMMA	
boolean	TokenNameboolean	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
,	TokenNameCOMMA	
Mode	TokenNameIdentifier	 Mode
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dictionary	TokenNameIdentifier	 dictionary
=	TokenNameEQUAL	
TokenInfoDictionary	TokenNameIdentifier	 Token Info Dictionary
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fst	TokenNameIdentifier	 fst
=	TokenNameEQUAL	
dictionary	TokenNameIdentifier	 dictionary
.	TokenNameDOT	
getFST	TokenNameIdentifier	 get FST
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
unkDictionary	TokenNameIdentifier	 unk Dictionary
=	TokenNameEQUAL	
UnknownDictionary	TokenNameIdentifier	 Unknown Dictionary
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
characterDefinition	TokenNameIdentifier	 character Definition
=	TokenNameEQUAL	
unkDictionary	TokenNameIdentifier	 unk Dictionary
.	TokenNameDOT	
getCharacterDefinition	TokenNameIdentifier	 get Character Definition
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
userDictionary	TokenNameIdentifier	 user Dictionary
=	TokenNameEQUAL	
userDictionary	TokenNameIdentifier	 user Dictionary
;	TokenNameSEMICOLON	
costs	TokenNameIdentifier	 costs
=	TokenNameEQUAL	
ConnectionCosts	TokenNameIdentifier	 Connection Costs
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fstReader	TokenNameIdentifier	 fst Reader
=	TokenNameEQUAL	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
userDictionary	TokenNameIdentifier	 user Dictionary
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userFST	TokenNameIdentifier	 user FST
=	TokenNameEQUAL	
userDictionary	TokenNameIdentifier	 user Dictionary
.	TokenNameDOT	
getFST	TokenNameIdentifier	 get FST
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
userFSTReader	TokenNameIdentifier	 user FST Reader
=	TokenNameEQUAL	
userFST	TokenNameIdentifier	 user FST
.	TokenNameDOT	
getBytesReader	TokenNameIdentifier	 get Bytes Reader
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
userFST	TokenNameIdentifier	 user FST
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
userFSTReader	TokenNameIdentifier	 user FST Reader
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
=	TokenNameEQUAL	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
mode	TokenNameIdentifier	 mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
SEARCH	TokenNameIdentifier	 SEARCH
:	TokenNameCOLON	
searchMode	TokenNameIdentifier	 search Mode
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
extendedMode	TokenNameIdentifier	 extended Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
outputCompounds	TokenNameIdentifier	 output Compounds
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
EXTENDED	TokenNameIdentifier	 EXTENDED
:	TokenNameCOLON	
searchMode	TokenNameIdentifier	 search Mode
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
extendedMode	TokenNameIdentifier	 extended Mode
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
outputCompounds	TokenNameIdentifier	 output Compounds
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
searchMode	TokenNameIdentifier	 search Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
extendedMode	TokenNameIdentifier	 extended Mode
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
outputCompounds	TokenNameIdentifier	 output Compounds
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resetState	TokenNameIdentifier	 reset State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dictionaryMap	TokenNameIdentifier	 dictionary Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
KNOWN	TokenNameIdentifier	 KNOWN
,	TokenNameCOMMA	
dictionary	TokenNameIdentifier	 dictionary
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dictionaryMap	TokenNameIdentifier	 dictionary Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
,	TokenNameCOMMA	
unkDictionary	TokenNameIdentifier	 unk Dictionary
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dictionaryMap	TokenNameIdentifier	 dictionary Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
,	TokenNameCOMMA	
userDictionary	TokenNameIdentifier	 user Dictionary
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
GraphvizFormatter	TokenNameIdentifier	 Graphviz Formatter
dotOut	TokenNameIdentifier	 dot Out
;	TokenNameSEMICOLON	
/** Expert: set this to produce graphviz (dot) output of * the Viterbi lattice */	TokenNameCOMMENT_JAVADOC	 Expert: set this to produce graphviz (dot) output of the Viterbi lattice 
public	TokenNamepublic	
void	TokenNamevoid	
setGraphvizFormatter	TokenNameIdentifier	 set Graphviz Formatter
(	TokenNameLPAREN	
GraphvizFormatter	TokenNameIdentifier	 Graphviz Formatter
dotOut	TokenNameIdentifier	 dot Out
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dotOut	TokenNameIdentifier	 dot Out
=	TokenNameEQUAL	
dotOut	TokenNameIdentifier	 dot Out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
Reader	TokenNameIdentifier	 Reader
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
resetState	TokenNameIdentifier	 reset State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
resetState	TokenNameIdentifier	 reset State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
unknownWordEndIndex	TokenNameIdentifier	 unknown Word End Index
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
lastTokenPos	TokenNameIdentifier	 last Token Pos
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Add BOS: 	TokenNameCOMMENT_LINE	Add BOS: 
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
KNOWN	TokenNameIdentifier	 KNOWN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
end	TokenNameIdentifier	 end
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Set final offset 	TokenNameCOMMENT_LINE	Set final offset 
int	TokenNameint	
finalOffset	TokenNameIdentifier	 final Offset
=	TokenNameEQUAL	
correctOffset	TokenNameIdentifier	 correct Offset
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
finalOffset	TokenNameIdentifier	 final Offset
,	TokenNameCOMMA	
finalOffset	TokenNameIdentifier	 final Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Returns the added cost that a 2nd best segmentation is 	TokenNameCOMMENT_LINE	Returns the added cost that a 2nd best segmentation is 
// allowed to have. Ie, if we see path with cost X, 	TokenNameCOMMENT_LINE	allowed to have. Ie, if we see path with cost X, 
// ending in a compound word, and this method returns 	TokenNameCOMMENT_LINE	ending in a compound word, and this method returns 
// threshold > 0, then we will also find the 2nd best 	TokenNameCOMMENT_LINE	threshold > 0, then we will also find the 2nd best 
// segmentation and if its path score is within this 	TokenNameCOMMENT_LINE	segmentation and if its path score is within this 
// threshold of X, we'll include it in the output: 	TokenNameCOMMENT_LINE	threshold of X, we'll include it in the output: 
private	TokenNameprivate	
int	TokenNameint	
computeSecondBestThreshold	TokenNameIdentifier	 compute Second Best Threshold
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// TODO: maybe we do something else here, instead of just 	TokenNameCOMMENT_LINE	TODO: maybe we do something else here, instead of just 
// using the penalty...? EG we can be more aggressive on 	TokenNameCOMMENT_LINE	using the penalty...? EG we can be more aggressive on 
// when to also test for 2nd best path 	TokenNameCOMMENT_LINE	when to also test for 2nd best path 
return	TokenNamereturn	
computePenalty	TokenNameIdentifier	 compute Penalty
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
computePenalty	TokenNameIdentifier	 compute Penalty
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
SEARCH_MODE_KANJI_LENGTH	TokenNameIdentifier	 SEARCH  MODE  KANJI  LENGTH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
allKanji	TokenNameIdentifier	 all Kanji
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// check if node consists of only kanji 	TokenNameCOMMENT_LINE	check if node consists of only kanji 
final	TokenNamefinal	
int	TokenNameint	
endPos	TokenNameIdentifier	 end Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos2	TokenNameIdentifier	 pos2
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
<	TokenNameLESS	
endPos	TokenNameIdentifier	 end Pos
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
characterDefinition	TokenNameIdentifier	 character Definition
.	TokenNameDOT	
isKanji	TokenNameIdentifier	 is Kanji
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos2	TokenNameIdentifier	 pos2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allKanji	TokenNameIdentifier	 all Kanji
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
allKanji	TokenNameIdentifier	 all Kanji
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Process only Kanji keywords 	TokenNameCOMMENT_LINE	Process only Kanji keywords 
return	TokenNamereturn	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
SEARCH_MODE_KANJI_LENGTH	TokenNameIdentifier	 SEARCH  MODE  KANJI  LENGTH
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
SEARCH_MODE_KANJI_PENALTY	TokenNameIdentifier	 SEARCH  MODE  KANJI  PENALTY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
SEARCH_MODE_OTHER_LENGTH	TokenNameIdentifier	 SEARCH  MODE  OTHER  LENGTH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
SEARCH_MODE_OTHER_LENGTH	TokenNameIdentifier	 SEARCH  MODE  OTHER  LENGTH
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
SEARCH_MODE_OTHER_PENALTY	TokenNameIdentifier	 SEARCH  MODE  OTHER  PENALTY
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Holds all back pointers arriving to this position: 	TokenNameCOMMENT_LINE	Holds all back pointers arriving to this position: 
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
Position	TokenNameIdentifier	 Position
{	TokenNameLBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
// maybe single int array * 5? 	TokenNameCOMMENT_LINE	maybe single int array * 5? 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
costs	TokenNameIdentifier	 costs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lastRightID	TokenNameIdentifier	 last Right ID
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
backPos	TokenNameIdentifier	 back Pos
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
backIndex	TokenNameIdentifier	 back Index
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
backID	TokenNameIdentifier	 back ID
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
backType	TokenNameIdentifier	 back Type
=	TokenNameEQUAL	
new	TokenNamenew	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Only used when finding 2nd best segmentation under a 	TokenNameCOMMENT_LINE	Only used when finding 2nd best segmentation under a 
// too-long token: 	TokenNameCOMMENT_LINE	too-long token: 
int	TokenNameint	
forwardCount	TokenNameIdentifier	 forward Count
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
forwardPos	TokenNameIdentifier	 forward Pos
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
forwardID	TokenNameIdentifier	 forward ID
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
forwardIndex	TokenNameIdentifier	 forward Index
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
forwardType	TokenNameIdentifier	 forward Type
=	TokenNameEQUAL	
new	TokenNamenew	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
costs	TokenNameIdentifier	 costs
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
costs	TokenNameIdentifier	 costs
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastRightID	TokenNameIdentifier	 last Right ID
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
lastRightID	TokenNameIdentifier	 last Right ID
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
backPos	TokenNameIdentifier	 back Pos
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
backIndex	TokenNameIdentifier	 back Index
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
backIndex	TokenNameIdentifier	 back Index
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
backID	TokenNameIdentifier	 back ID
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: sneaky: grow separately because 	TokenNameCOMMENT_LINE	NOTE: sneaky: grow separately because 
// ArrayUtil.grow will otherwise pick a different 	TokenNameCOMMENT_LINE	ArrayUtil.grow will otherwise pick a different 
// length than the int[]s we just grew: 	TokenNameCOMMENT_LINE	length than the int[]s we just grew: 
final	TokenNamefinal	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newBackType	TokenNameIdentifier	 new Back Type
=	TokenNameEQUAL	
new	TokenNamenew	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
backID	TokenNameIdentifier	 back ID
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
backType	TokenNameIdentifier	 back Type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newBackType	TokenNameIdentifier	 new Back Type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
backType	TokenNameIdentifier	 back Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
backType	TokenNameIdentifier	 back Type
=	TokenNameEQUAL	
newBackType	TokenNameIdentifier	 new Back Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
growForward	TokenNameIdentifier	 grow Forward
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
forwardPos	TokenNameIdentifier	 forward Pos
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
forwardPos	TokenNameIdentifier	 forward Pos
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
forwardCount	TokenNameIdentifier	 forward Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
forwardID	TokenNameIdentifier	 forward ID
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
forwardID	TokenNameIdentifier	 forward ID
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
forwardCount	TokenNameIdentifier	 forward Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
forwardIndex	TokenNameIdentifier	 forward Index
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
forwardIndex	TokenNameIdentifier	 forward Index
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
forwardCount	TokenNameIdentifier	 forward Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: sneaky: grow separately because 	TokenNameCOMMENT_LINE	NOTE: sneaky: grow separately because 
// ArrayUtil.grow will otherwise pick a different 	TokenNameCOMMENT_LINE	ArrayUtil.grow will otherwise pick a different 
// length than the int[]s we just grew: 	TokenNameCOMMENT_LINE	length than the int[]s we just grew: 
final	TokenNamefinal	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newForwardType	TokenNameIdentifier	 new Forward Type
=	TokenNameEQUAL	
new	TokenNamenew	
Type	TokenNameIdentifier	 Type
[	TokenNameLBRACKET	
forwardPos	TokenNameIdentifier	 forward Pos
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
forwardType	TokenNameIdentifier	 forward Type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newForwardType	TokenNameIdentifier	 new Forward Type
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
forwardType	TokenNameIdentifier	 forward Type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
forwardType	TokenNameIdentifier	 forward Type
=	TokenNameEQUAL	
newForwardType	TokenNameIdentifier	 new Forward Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
int	TokenNameint	
cost	TokenNameIdentifier	 cost
,	TokenNameCOMMA	
int	TokenNameint	
lastRightID	TokenNameIdentifier	 last Right ID
,	TokenNameCOMMA	
int	TokenNameint	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
int	TokenNameint	
backIndex	TokenNameIdentifier	 back Index
,	TokenNameCOMMA	
int	TokenNameint	
backID	TokenNameIdentifier	 back ID
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
backType	TokenNameIdentifier	 back Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// NOTE: this isn't quite a true Viterbit search, 	TokenNameCOMMENT_LINE	NOTE: this isn't quite a true Viterbit search, 
// becase we should check if lastRightID is 	TokenNameCOMMENT_LINE	becase we should check if lastRightID is 
// already present here, and only update if the new 	TokenNameCOMMENT_LINE	already present here, and only update if the new 
// cost is less than the current cost, instead of 	TokenNameCOMMENT_LINE	cost is less than the current cost, instead of 
// simply appending. However, that will likely hurt 	TokenNameCOMMENT_LINE	simply appending. However, that will likely hurt 
// performance (usually we add a lastRightID only once), 	TokenNameCOMMENT_LINE	performance (usually we add a lastRightID only once), 
// and it means we actually create the full graph 	TokenNameCOMMENT_LINE	and it means we actually create the full graph 
// intersection instead of a "normal" Viterbi lattice: 	TokenNameCOMMENT_LINE	intersection instead of a "normal" Viterbi lattice: 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
cost	TokenNameIdentifier	 cost
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
lastRightID	TokenNameIdentifier	 last Right ID
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
backIndex	TokenNameIdentifier	 back Index
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
backID	TokenNameIdentifier	 back ID
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
backType	TokenNameIdentifier	 back Type
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addForward	TokenNameIdentifier	 add Forward
(	TokenNameLPAREN	
int	TokenNameint	
forwardPos	TokenNameIdentifier	 forward Pos
,	TokenNameCOMMA	
int	TokenNameint	
forwardIndex	TokenNameIdentifier	 forward Index
,	TokenNameCOMMA	
int	TokenNameint	
forwardID	TokenNameIdentifier	 forward ID
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
forwardType	TokenNameIdentifier	 forward Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
forwardCount	TokenNameIdentifier	 forward Count
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
forwardID	TokenNameIdentifier	 forward ID
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
growForward	TokenNameIdentifier	 grow Forward
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
forwardPos	TokenNameIdentifier	 forward Pos
[	TokenNameLBRACKET	
forwardCount	TokenNameIdentifier	 forward Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
forwardPos	TokenNameIdentifier	 forward Pos
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
forwardIndex	TokenNameIdentifier	 forward Index
[	TokenNameLBRACKET	
forwardCount	TokenNameIdentifier	 forward Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
forwardIndex	TokenNameIdentifier	 forward Index
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
forwardID	TokenNameIdentifier	 forward ID
[	TokenNameLBRACKET	
forwardCount	TokenNameIdentifier	 forward Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
forwardID	TokenNameIdentifier	 forward ID
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
forwardType	TokenNameIdentifier	 forward Type
[	TokenNameLBRACKET	
forwardCount	TokenNameIdentifier	 forward Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
forwardType	TokenNameIdentifier	 forward Type
;	TokenNameSEMICOLON	
forwardCount	TokenNameIdentifier	 forward Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// forwardCount naturally resets after it runs: 	TokenNameCOMMENT_LINE	forwardCount naturally resets after it runs: 
assert	TokenNameassert	
forwardCount	TokenNameIdentifier	 forward Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"pos="	TokenNameStringLiteral	pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" forwardCount="	TokenNameStringLiteral	 forwardCount=
+	TokenNamePLUS	
forwardCount	TokenNameIdentifier	 forward Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Dictionary	TokenNameIdentifier	 Dictionary
dict	TokenNameIdentifier	 dict
,	TokenNameCOMMA	
Position	TokenNameIdentifier	 Position
fromPosData	TokenNameIdentifier	 from Pos Data
,	TokenNameCOMMA	
int	TokenNameint	
endPos	TokenNameIdentifier	 end Pos
,	TokenNameCOMMA	
int	TokenNameint	
wordID	TokenNameIdentifier	 word ID
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
boolean	TokenNameboolean	
addPenalty	TokenNameIdentifier	 add Penalty
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
wordCost	TokenNameIdentifier	 word Cost
=	TokenNameEQUAL	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
getWordCost	TokenNameIdentifier	 get Word Cost
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
leftID	TokenNameIdentifier	 left ID
=	TokenNameEQUAL	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
getLeftId	TokenNameIdentifier	 get Left Id
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
int	TokenNameint	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Cost is path cost so far, plus word cost (added at 	TokenNameCOMMENT_LINE	Cost is path cost so far, plus word cost (added at 
// end of loop), plus bigram cost: 	TokenNameCOMMENT_LINE	end of loop), plus bigram cost: 
final	TokenNamefinal	
int	TokenNameint	
cost	TokenNameIdentifier	 cost
=	TokenNameEQUAL	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
+	TokenNamePLUS	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
leftID	TokenNameIdentifier	 left ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" fromIDX="	TokenNameStringLiteral	 fromIDX=
+	TokenNamePLUS	
idx	TokenNameIdentifier	 idx
+	TokenNamePLUS	
": cost="	TokenNameStringLiteral	: cost=
+	TokenNamePLUS	
cost	TokenNameIdentifier	 cost
+	TokenNamePLUS	
" (prevCost="	TokenNameStringLiteral	 (prevCost=
+	TokenNamePLUS	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
+	TokenNamePLUS	
" wordCost="	TokenNameStringLiteral	 wordCost=
+	TokenNamePLUS	
wordCost	TokenNameIdentifier	 word Cost
+	TokenNamePLUS	
" bgCost="	TokenNameStringLiteral	 bgCost=
+	TokenNamePLUS	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
leftID	TokenNameIdentifier	 left ID
)	TokenNameRPAREN	
+	TokenNamePLUS	
" leftID="	TokenNameStringLiteral	 leftID=
+	TokenNamePLUS	
leftID	TokenNameIdentifier	 left ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cost	TokenNameIdentifier	 cost
<	TokenNameLESS	
leastCost	TokenNameIdentifier	 least Cost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
cost	TokenNameIdentifier	 cost
;	TokenNameSEMICOLON	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" **"	TokenNameStringLiteral	 **
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
leastCost	TokenNameIdentifier	 least Cost
+=	TokenNamePLUS_EQUAL	
wordCost	TokenNameIdentifier	 word Cost
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" + cost="	TokenNameStringLiteral	 + cost=
+	TokenNamePLUS	
leastCost	TokenNameIdentifier	 least Cost
+	TokenNamePLUS	
" wordID="	TokenNameStringLiteral	 wordID=
+	TokenNamePLUS	
wordID	TokenNameIdentifier	 word ID
+	TokenNamePLUS	
" leftID="	TokenNameStringLiteral	 leftID=
+	TokenNamePLUS	
leftID	TokenNameIdentifier	 left ID
+	TokenNamePLUS	
" leastIDX="	TokenNameStringLiteral	 leastIDX=
+	TokenNamePLUS	
leastIDX	TokenNameIdentifier	 least IDX
+	TokenNamePLUS	
" toPos="	TokenNameStringLiteral	 toPos=
+	TokenNamePLUS	
endPos	TokenNameIdentifier	 end Pos
+	TokenNamePLUS	
" toPos.idx="	TokenNameStringLiteral	 toPos.idx=
+	TokenNamePLUS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endPos	TokenNameIdentifier	 end Pos
)	TokenNameRPAREN	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
addPenalty	TokenNameIdentifier	 add Penalty
||	TokenNameOR_OR	
(	TokenNameLPAREN	
!	TokenNameNOT	
outputCompounds	TokenNameIdentifier	 output Compounds
&&	TokenNameAND_AND	
searchMode	TokenNameIdentifier	 search Mode
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
penalty	TokenNameIdentifier	 penalty
=	TokenNameEQUAL	
computePenalty	TokenNameIdentifier	 compute Penalty
(	TokenNameLPAREN	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
endPos	TokenNameIdentifier	 end Pos
-	TokenNameMINUS	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
penalty	TokenNameIdentifier	 penalty
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" + penalty="	TokenNameStringLiteral	 + penalty=
+	TokenNamePLUS	
penalty	TokenNameIdentifier	 penalty
+	TokenNamePLUS	
" cost="	TokenNameStringLiteral	 cost=
+	TokenNamePLUS	
(	TokenNameLPAREN	
leastCost	TokenNameIdentifier	 least Cost
+	TokenNamePLUS	
penalty	TokenNameIdentifier	 penalty
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
leastCost	TokenNameIdentifier	 least Cost
+=	TokenNamePLUS_EQUAL	
penalty	TokenNameIdentifier	 penalty
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type); 	TokenNameCOMMENT_LINE	positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type); 
assert	TokenNameassert	
leftID	TokenNameIdentifier	 left ID
==	TokenNameEQUAL_EQUAL	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
getRightId	TokenNameIdentifier	 get Right Id
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endPos	TokenNameIdentifier	 end Pos
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
leastCost	TokenNameIdentifier	 least Cost
,	TokenNameCOMMA	
leftID	TokenNameIdentifier	 left ID
,	TokenNameCOMMA	
fromPosData	TokenNameIdentifier	 from Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
leastIDX	TokenNameIdentifier	 least IDX
,	TokenNameCOMMA	
wordID	TokenNameIdentifier	 word ID
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
incrementToken	TokenNameIdentifier	 increment Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// parse() is able to return w/o producing any new 	TokenNameCOMMENT_LINE	parse() is able to return w/o producing any new 
// tokens, when the tokens it had produced were entirely 	TokenNameCOMMENT_LINE	tokens, when the tokens it had produced were entirely 
// punctuation. So we loop here until we get a real 	TokenNameCOMMENT_LINE	punctuation. So we loop here until we get a real 
// token or we end: 	TokenNameCOMMENT_LINE	token or we end: 
while	TokenNamewhile	
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Push Viterbi forward some more: 	TokenNameCOMMENT_LINE	Push Viterbi forward some more: 
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
position	TokenNameIdentifier	 position
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
clearAttributes	TokenNameIdentifier	 clear Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println("off=" + token.getOffset() + " len=" + length + " vs " + token.getSurfaceForm().length); 	TokenNameCOMMENT_LINE	System.out.println("off=" + token.getOffset() + " len=" + length + " vs " + token.getSurfaceForm().length); 
termAtt	TokenNameIdentifier	 term Att
.	TokenNameDOT	
copyBuffer	TokenNameIdentifier	 copy Buffer
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getSurfaceForm	TokenNameIdentifier	 get Surface Form
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
offsetAtt	TokenNameIdentifier	 offset Att
.	TokenNameDOT	
setOffset	TokenNameIdentifier	 set Offset
(	TokenNameLPAREN	
correctOffset	TokenNameIdentifier	 correct Offset
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
,	TokenNameCOMMA	
correctOffset	TokenNameIdentifier	 correct Offset
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
+	TokenNamePLUS	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
basicFormAtt	TokenNameIdentifier	 basic Form Att
.	TokenNameDOT	
setToken	TokenNameIdentifier	 set Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posAtt	TokenNameIdentifier	 pos Att
.	TokenNameDOT	
setToken	TokenNameIdentifier	 set Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
readingAtt	TokenNameIdentifier	 reading Att
.	TokenNameDOT	
setToken	TokenNameIdentifier	 set Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
inflectionAtt	TokenNameIdentifier	 inflection Att
.	TokenNameDOT	
setToken	TokenNameIdentifier	 set Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
lastTokenPos	TokenNameIdentifier	 last Token Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posIncAtt	TokenNameIdentifier	 pos Inc Att
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posLengthAtt	TokenNameIdentifier	 pos Length Att
.	TokenNameDOT	
setPositionLength	TokenNameIdentifier	 set Position Length
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPositionLength	TokenNameIdentifier	 get Position Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
lastTokenPos	TokenNameIdentifier	 last Token Pos
;	TokenNameSEMICOLON	
posIncAtt	TokenNameIdentifier	 pos Inc Att
.	TokenNameDOT	
setPositionIncrement	TokenNameIdentifier	 set Position Increment
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
posLengthAtt	TokenNameIdentifier	 pos Length Att
.	TokenNameDOT	
setPositionLength	TokenNameIdentifier	 set Position Length
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
": incToken: return token="	TokenNameStringLiteral	: incToken: return token=
+	TokenNamePLUS	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastTokenPos	TokenNameIdentifier	 last Token Pos
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO: make generic'd version of this "circular array"? 	TokenNameCOMMENT_LINE	TODO: make generic'd version of this "circular array"? 
// It's a bit tricky because we do things to the Position 	TokenNameCOMMENT_LINE	It's a bit tricky because we do things to the Position 
// (eg, set .pos = N on reuse)... 	TokenNameCOMMENT_LINE	(eg, set .pos = N on reuse)... 
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
WrappedPositionArray	TokenNameIdentifier	 Wrapped Position Array
{	TokenNameLBRACE	
private	TokenNameprivate	
Position	TokenNameIdentifier	 Position
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
new	TokenNamenew	
Position	TokenNameIdentifier	 Position
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
WrappedPositionArray	TokenNameIdentifier	 Wrapped Position Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Position	TokenNameIdentifier	 Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Next array index to write to in positions: 	TokenNameCOMMENT_LINE	Next array index to write to in positions: 
private	TokenNameprivate	
int	TokenNameint	
nextWrite	TokenNameIdentifier	 next Write
;	TokenNameSEMICOLON	
// Next position to write: 	TokenNameCOMMENT_LINE	Next position to write: 
private	TokenNameprivate	
int	TokenNameint	
nextPos	TokenNameIdentifier	 next Pos
;	TokenNameSEMICOLON	
// How many valid Position instances are held in the 	TokenNameCOMMENT_LINE	How many valid Position instances are held in the 
// positions array: 	TokenNameCOMMENT_LINE	positions array: 
private	TokenNameprivate	
int	TokenNameint	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextWrite	TokenNameIdentifier	 next Write
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nextWrite	TokenNameIdentifier	 next Write
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextPos	TokenNameIdentifier	 next Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Get Position instance for this absolute position; * this is allowed to be arbitrarily far "in the * future" but cannot be before the last freeBefore. */	TokenNameCOMMENT_JAVADOC	 Get Position instance for this absolute position; this is allowed to be arbitrarily far "in the future" but cannot be before the last freeBefore. 
public	TokenNamepublic	
Position	TokenNameIdentifier	 Position
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>=	TokenNameGREATER_EQUAL	
nextPos	TokenNameIdentifier	 next Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("count=" + count + " vs len=" + positions.length); 	TokenNameCOMMENT_LINE	System.out.println("count=" + count + " vs len=" + positions.length); 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Position	TokenNameIdentifier	 Position
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newPositions	TokenNameIdentifier	 new Positions
=	TokenNameEQUAL	
new	TokenNamenew	
Position	TokenNameIdentifier	 Position
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_OBJECT_REF	TokenNameIdentifier	 NUM  BYTES  OBJECT  REF
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println("grow positions " + newPositions.length); 	TokenNameCOMMENT_LINE	System.out.println("grow positions " + newPositions.length); 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
positions	TokenNameIdentifier	 positions
,	TokenNameCOMMA	
nextWrite	TokenNameIdentifier	 next Write
,	TokenNameCOMMA	
newPositions	TokenNameIdentifier	 new Positions
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
positions	TokenNameIdentifier	 positions
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newPositions	TokenNameIdentifier	 new Positions
,	TokenNameCOMMA	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
nextWrite	TokenNameIdentifier	 next Write
,	TokenNameCOMMA	
nextWrite	TokenNameIdentifier	 next Write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newPositions	TokenNameIdentifier	 new Positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newPositions	TokenNameIdentifier	 new Positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Position	TokenNameIdentifier	 Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
newPositions	TokenNameIdentifier	 new Positions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nextWrite	TokenNameIdentifier	 next Write
==	TokenNameEQUAL_EQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextWrite	TokenNameIdentifier	 next Write
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Should have already been reset: 	TokenNameCOMMENT_LINE	Should have already been reset: 
assert	TokenNameassert	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
]	TokenNameRBRACKET	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
nextWrite	TokenNameIdentifier	 next Write
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
nextPos	TokenNameIdentifier	 next Pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
inBounds	TokenNameIdentifier	 in Bounds
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
return	TokenNamereturn	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getNextPos	TokenNameIdentifier	 get Next Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
nextPos	TokenNameIdentifier	 next Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// For assert: 	TokenNameCOMMENT_LINE	For assert: 
private	TokenNameprivate	
boolean	TokenNameboolean	
inBounds	TokenNameIdentifier	 in Bounds
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
nextPos	TokenNameIdentifier	 next Pos
&&	TokenNameAND_AND	
pos	TokenNameIdentifier	 pos
>=	TokenNameGREATER_EQUAL	
nextPos	TokenNameIdentifier	 next Pos
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
nextWrite	TokenNameIdentifier	 next Write
-	TokenNameMINUS	
(	TokenNameLPAREN	
nextPos	TokenNameIdentifier	 next Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
+=	TokenNamePLUS_EQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
freeBefore	TokenNameIdentifier	 free Before
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
toFree	TokenNameIdentifier	 to Free
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
(	TokenNameLPAREN	
nextPos	TokenNameIdentifier	 next Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
toFree	TokenNameIdentifier	 to Free
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
toFree	TokenNameIdentifier	 to Free
<=	TokenNameLESS_EQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
nextWrite	TokenNameIdentifier	 next Write
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
+=	TokenNamePLUS_EQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toFree	TokenNameIdentifier	 to Free
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" fb idx=" + index); 	TokenNameCOMMENT_LINE	System.out.println(" fb idx=" + index); 
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
count	TokenNameIdentifier	 count
-=	TokenNameMINUS_EQUAL	
toFree	TokenNameIdentifier	 to Free
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* Incrementally parse some more characters. This runs * the viterbi search forwards "enough" so that we * generate some more tokens. How much forward depends on * the chars coming in, since some chars could cause * longer-lasting ambiguity in the parsing. Once the * ambiguity is resolved, then we back trace, produce * the pending tokens, and return. */	TokenNameCOMMENT_BLOCK	 Incrementally parse some more characters. This runs the viterbi search forwards "enough" so that we generate some more tokens. How much forward depends on the chars coming in, since some chars could cause longer-lasting ambiguity in the parsing. Once the ambiguity is resolved, then we back trace, produce the pending tokens, and return. 
private	TokenNameprivate	
void	TokenNamevoid	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" PARSE"	TokenNameStringLiteral	 PARSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Advances over each position (character): 	TokenNameCOMMENT_LINE	Advances over each position (character): 
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// End 	TokenNameCOMMENT_LINE	End 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData	TokenNameIdentifier	 pos Data
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
isFrontier	TokenNameIdentifier	 is Frontier
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
getNextPos	TokenNameIdentifier	 get Next Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No arcs arrive here; move to next position: 	TokenNameCOMMENT_LINE	No arcs arrive here; move to next position: 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" no arcs in; skip pos="	TokenNameStringLiteral	 no arcs in; skip pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>	TokenNameGREATER	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
&&	TokenNameAND_AND	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
isFrontier	TokenNameIdentifier	 is Frontier
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if (pos > lastBackTracePos && posData.count == 1 && isFrontier) { 	TokenNameCOMMENT_LINE	if (pos > lastBackTracePos && posData.count == 1 && isFrontier) { 
// We are at a "frontier", and only one node is 	TokenNameCOMMENT_LINE	We are at a "frontier", and only one node is 
// alive, so whatever the eventual best path is must 	TokenNameCOMMENT_LINE	alive, so whatever the eventual best path is must 
// come through this node. So we can safely commit 	TokenNameCOMMENT_LINE	come through this node. So we can safely commit 
// to the prefix of the best path at this point: 	TokenNameCOMMENT_LINE	to the prefix of the best path at this point: 
backtrace	TokenNameIdentifier	 backtrace
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Re-base cost so we don't risk int overflow: 	TokenNameCOMMENT_LINE	Re-base cost so we don't risk int overflow: 
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This means the backtrace only produced 	TokenNameCOMMENT_LINE	This means the backtrace only produced 
// punctuation tokens, so we must keep parsing. 	TokenNameCOMMENT_LINE	punctuation tokens, so we must keep parsing. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
>=	TokenNameGREATER_EQUAL	
MAX_BACKTRACE_GAP	TokenNameIdentifier	 MAX  BACKTRACE  GAP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Safety: if we've buffered too much, force a 	TokenNameCOMMENT_LINE	Safety: if we've buffered too much, force a 
// backtrace now. We find the least-cost partial 	TokenNameCOMMENT_LINE	backtrace now. We find the least-cost partial 
// path, across all paths, backtrace from it, and 	TokenNameCOMMENT_LINE	path, across all paths, backtrace from it, and 
// then prune all others. Note that this, in 	TokenNameCOMMENT_LINE	then prune all others. Note that this, in 
// general, can produce the wrong result, if the 	TokenNameCOMMENT_LINE	general, can produce the wrong result, if the 
// total bast path did not in fact back trace 	TokenNameCOMMENT_LINE	total bast path did not in fact back trace 
// through this partial best path. But it's the 	TokenNameCOMMENT_LINE	through this partial best path. But it's the 
// best we can do... (short of not having a 	TokenNameCOMMENT_LINE	best we can do... (short of not having a 
// safety!). 	TokenNameCOMMENT_LINE	safety!). 
// First pass: find least cost parital path so far, 	TokenNameCOMMENT_LINE	First pass: find least cost parital path so far, 
// including ending at future positions: 	TokenNameCOMMENT_LINE	including ending at future positions: 
int	TokenNameint	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
Position	TokenNameIdentifier	 Position
leastPosData	TokenNameIdentifier	 least Pos Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos2	TokenNameIdentifier	 pos2
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
<	TokenNameLESS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
getNextPos	TokenNameIdentifier	 get Next Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData2	TokenNameIdentifier	 pos Data2
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos2	TokenNameIdentifier	 pos2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" idx=" + idx + " cost=" + cost); 	TokenNameCOMMENT_LINE	System.out.println(" idx=" + idx + " cost=" + cost); 
final	TokenNamefinal	
int	TokenNameint	
cost	TokenNameIdentifier	 cost
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cost	TokenNameIdentifier	 cost
<	TokenNameLESS	
leastCost	TokenNameIdentifier	 least Cost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
cost	TokenNameIdentifier	 cost
;	TokenNameSEMICOLON	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
leastPosData	TokenNameIdentifier	 least Pos Data
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// We will always have at least one live path: 	TokenNameCOMMENT_LINE	We will always have at least one live path: 
assert	TokenNameassert	
leastIDX	TokenNameIdentifier	 least IDX
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Second pass: prune all but the best path: 	TokenNameCOMMENT_LINE	Second pass: prune all but the best path: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos2	TokenNameIdentifier	 pos2
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
<	TokenNameLESS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
getNextPos	TokenNameIdentifier	 get Next Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pos2	TokenNameIdentifier	 pos2
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData2	TokenNameIdentifier	 pos Data2
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos2	TokenNameIdentifier	 pos2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
posData2	TokenNameIdentifier	 pos Data2
!=	TokenNameNOT_EQUAL	
leastPosData	TokenNameIdentifier	 least Pos Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
leastIDX	TokenNameIdentifier	 least IDX
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
posData2	TokenNameIdentifier	 pos Data2
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
backtrace	TokenNameIdentifier	 backtrace
(	TokenNameLPAREN	
leastPosData	TokenNameIdentifier	 least Pos Data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Re-base cost so we don't risk int overflow: 	TokenNameCOMMENT_LINE	Re-base cost so we don't risk int overflow: 
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
fill	TokenNameIdentifier	 fill
(	TokenNameLPAREN	
leastPosData	TokenNameIdentifier	 least Pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
leastPosData	TokenNameIdentifier	 least Pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
leastPosData	TokenNameIdentifier	 least Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We jumped into a future position: 	TokenNameCOMMENT_LINE	We jumped into a future position: 
assert	TokenNameassert	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
leastPosData	TokenNameIdentifier	 least Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
leastPosData	TokenNameIdentifier	 least Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This means the backtrace only produced 	TokenNameCOMMENT_LINE	This means the backtrace only produced 
// punctuation tokens, so we must keep parsing. 	TokenNameCOMMENT_LINE	punctuation tokens, so we must keep parsing. 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" extend @ pos="	TokenNameStringLiteral	 extend @ pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" char="	TokenNameStringLiteral	 char=
+	TokenNamePLUS	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
" arcs in"	TokenNameStringLiteral	 arcs in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
anyMatches	TokenNameIdentifier	 any Matches
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// First try user dict: 	TokenNameCOMMENT_LINE	First try user dict: 
if	TokenNameif	
(	TokenNameLPAREN	
userFST	TokenNameIdentifier	 user FST
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
userFST	TokenNameIdentifier	 user FST
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
posAhead	TokenNameIdentifier	 pos Ahead
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
posAhead	TokenNameIdentifier	 pos Ahead
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
posAhead	TokenNameIdentifier	 pos Ahead
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
userFST	TokenNameIdentifier	 user FST
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
==	TokenNameEQUAL_EQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
userFSTReader	TokenNameIdentifier	 user FST Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
+=	TokenNamePLUS_EQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" USER word "	TokenNameStringLiteral	 USER word 
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" toPos="	TokenNameStringLiteral	 toPos=
+	TokenNamePLUS	
(	TokenNameLPAREN	
posAhead	TokenNameIdentifier	 pos Ahead
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
userDictionary	TokenNameIdentifier	 user Dictionary
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
output	TokenNameIdentifier	 output
+	TokenNamePLUS	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
anyMatches	TokenNameIdentifier	 any Matches
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// TODO: we can be more aggressive about user 	TokenNameCOMMENT_LINE	TODO: we can be more aggressive about user 
// matches? if we are "under" a user match then don't 	TokenNameCOMMENT_LINE	matches? if we are "under" a user match then don't 
// extend KNOWN/UNKNOWN paths? 	TokenNameCOMMENT_LINE	extend KNOWN/UNKNOWN paths? 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
anyMatches	TokenNameIdentifier	 any Matches
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Next, try known dictionary matches 	TokenNameCOMMENT_LINE	Next, try known dictionary matches 
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
getFirstArc	TokenNameIdentifier	 get First Arc
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
output	TokenNameIdentifier	 output
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
posAhead	TokenNameIdentifier	 pos Ahead
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
posAhead	TokenNameIdentifier	 pos Ahead
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
posAhead	TokenNameIdentifier	 pos Ahead
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" match " + (char) ch + " posAhead=" + posAhead); 	TokenNameCOMMENT_LINE	System.out.println(" match " + (char) ch + " posAhead=" + posAhead); 
if	TokenNameif	
(	TokenNameLPAREN	
fst	TokenNameIdentifier	 fst
.	TokenNameDOT	
findTargetArc	TokenNameIdentifier	 find Target Arc
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
arc	TokenNameIdentifier	 arc
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
==	TokenNameEQUAL_EQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
fstReader	TokenNameIdentifier	 fst Reader
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
+=	TokenNamePLUS_EQUAL	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Optimization: for known words that are too-long 	TokenNameCOMMENT_LINE	Optimization: for known words that are too-long 
// (compound), we should pre-compute the 2nd 	TokenNameCOMMENT_LINE	(compound), we should pre-compute the 2nd 
// best segmentation and store it in the 	TokenNameCOMMENT_LINE	best segmentation and store it in the 
// dictionary instead of recomputing it each time a 	TokenNameCOMMENT_LINE	dictionary instead of recomputing it each time a 
// match is found. 	TokenNameCOMMENT_LINE	match is found. 
if	TokenNameif	
(	TokenNameLPAREN	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dictionary	TokenNameIdentifier	 dictionary
.	TokenNameDOT	
lookupWordIds	TokenNameIdentifier	 lookup Word Ids
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
+	TokenNamePLUS	
arc	TokenNameIdentifier	 arc
.	TokenNameDOT	
nextFinalOutput	TokenNameIdentifier	 next Final Output
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
wordIdRef	TokenNameIdentifier	 word Id Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" KNOWN word "	TokenNameStringLiteral	 KNOWN word 
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" toPos="	TokenNameStringLiteral	 toPos=
+	TokenNamePLUS	
(	TokenNameLPAREN	
posAhead	TokenNameIdentifier	 pos Ahead
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
" wordIDs"	TokenNameStringLiteral	 wordIDs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ofs	TokenNameIdentifier	 ofs
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ofs	TokenNameIdentifier	 ofs
<	TokenNameLESS	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
ofs	TokenNameIdentifier	 ofs
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
dictionary	TokenNameIdentifier	 dictionary
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
,	TokenNameCOMMA	
posAhead	TokenNameIdentifier	 pos Ahead
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
ofs	TokenNameIdentifier	 ofs
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
KNOWN	TokenNameIdentifier	 KNOWN
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
anyMatches	TokenNameIdentifier	 any Matches
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// In the case of normal mode, it doesn't process unknown word greedily. 	TokenNameCOMMENT_LINE	In the case of normal mode, it doesn't process unknown word greedily. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
searchMode	TokenNameIdentifier	 search Mode
&&	TokenNameAND_AND	
unknownWordEndIndex	TokenNameIdentifier	 unknown Word End Index
>	TokenNameGREATER	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
char	TokenNamechar	
firstCharacter	TokenNameIdentifier	 first Character
=	TokenNameEQUAL	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
anyMatches	TokenNameIdentifier	 any Matches
||	TokenNameOR_OR	
characterDefinition	TokenNameIdentifier	 character Definition
.	TokenNameDOT	
isInvoke	TokenNameIdentifier	 is Invoke
(	TokenNameLPAREN	
firstCharacter	TokenNameIdentifier	 first Character
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Find unknown match: 	TokenNameCOMMENT_LINE	Find unknown match: 
final	TokenNamefinal	
int	TokenNameint	
characterId	TokenNameIdentifier	 character Id
=	TokenNameEQUAL	
characterDefinition	TokenNameIdentifier	 character Definition
.	TokenNameDOT	
getCharacterClass	TokenNameIdentifier	 get Character Class
(	TokenNameLPAREN	
firstCharacter	TokenNameIdentifier	 first Character
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
isPunct	TokenNameIdentifier	 is Punct
=	TokenNameEQUAL	
isPunctuation	TokenNameIdentifier	 is Punctuation
(	TokenNameLPAREN	
firstCharacter	TokenNameIdentifier	 first Character
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: copied from UnknownDictionary.lookup: 	TokenNameCOMMENT_LINE	NOTE: copied from UnknownDictionary.lookup: 
int	TokenNameint	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
characterDefinition	TokenNameIdentifier	 character Definition
.	TokenNameDOT	
isGroup	TokenNameIdentifier	 is Group
(	TokenNameLPAREN	
firstCharacter	TokenNameIdentifier	 first Character
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Extract unknown word. Characters with the same character class are considered to be part of unknown word 	TokenNameCOMMENT_LINE	Extract unknown word. Characters with the same character class are considered to be part of unknown word 
unknownWordLength	TokenNameIdentifier	 unknown Word Length
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
posAhead	TokenNameIdentifier	 pos Ahead
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
<	TokenNameLESS	
MAX_UNKNOWN_WORD_LENGTH	TokenNameIdentifier	 MAX  UNKNOWN  WORD  LENGTH
;	TokenNameSEMICOLON	
posAhead	TokenNameIdentifier	 pos Ahead
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
posAhead	TokenNameIdentifier	 pos Ahead
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
characterId	TokenNameIdentifier	 character Id
==	TokenNameEQUAL_EQUAL	
characterDefinition	TokenNameIdentifier	 character Definition
.	TokenNameDOT	
getCharacterClass	TokenNameIdentifier	 get Character Class
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
isPunctuation	TokenNameIdentifier	 is Punctuation
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
isPunct	TokenNameIdentifier	 is Punct
)	TokenNameRPAREN	
{	TokenNameLBRACE	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
unkDictionary	TokenNameIdentifier	 unk Dictionary
.	TokenNameDOT	
lookupWordIds	TokenNameIdentifier	 lookup Word Ids
(	TokenNameLPAREN	
characterId	TokenNameIdentifier	 character Id
,	TokenNameCOMMA	
wordIdRef	TokenNameIdentifier	 word Id Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// characters in input text are supposed to be the same 	TokenNameCOMMENT_LINE	characters in input text are supposed to be the same 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" UNKNOWN word len="	TokenNameStringLiteral	 UNKNOWN word len=
+	TokenNamePLUS	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
" wordIDs"	TokenNameStringLiteral	 wordIDs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
ofs	TokenNameIdentifier	 ofs
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ofs	TokenNameIdentifier	 ofs
<	TokenNameLESS	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
ofs	TokenNameIdentifier	 ofs
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
unkDictionary	TokenNameIdentifier	 unk Dictionary
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
,	TokenNameCOMMA	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
ints	TokenNameIdentifier	 ints
[	TokenNameLBRACKET	
wordIdRef	TokenNameIdentifier	 word Id Ref
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
ofs	TokenNameIdentifier	 ofs
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
unknownWordEndIndex	TokenNameIdentifier	 unknown Word End Index
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
unknownWordLength	TokenNameIdentifier	 unknown Word Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
endPosData	TokenNameIdentifier	 end Pos Data
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
int	TokenNameint	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" end: "	TokenNameStringLiteral	 end: 
+	TokenNamePLUS	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
" nodes"	TokenNameStringLiteral	 nodes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Add EOS cost: 	TokenNameCOMMENT_LINE	Add EOS cost: 
final	TokenNamefinal	
int	TokenNameint	
cost	TokenNameIdentifier	 cost
=	TokenNameEQUAL	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
+	TokenNamePLUS	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
lastRightID	TokenNameIdentifier	 last Right ID
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" idx=" + idx + " cost=" + cost + " (pathCost=" + endPosData.costs[idx] + " bgCost=" + costs.get(endPosData.lastRightID[idx], 0) + ") backPos=" + endPosData.backPos[idx]); 	TokenNameCOMMENT_LINE	System.out.println(" idx=" + idx + " cost=" + cost + " (pathCost=" + endPosData.costs[idx] + " bgCost=" + costs.get(endPosData.lastRightID[idx], 0) + ") backPos=" + endPosData.backPos[idx]); 
if	TokenNameif	
(	TokenNameLPAREN	
cost	TokenNameIdentifier	 cost
<	TokenNameLESS	
leastCost	TokenNameIdentifier	 least Cost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
cost	TokenNameIdentifier	 cost
;	TokenNameSEMICOLON	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
backtrace	TokenNameIdentifier	 backtrace
(	TokenNameLPAREN	
endPosData	TokenNameIdentifier	 end Pos Data
,	TokenNameCOMMA	
leastIDX	TokenNameIdentifier	 least IDX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// No characters in the input string; return no tokens! 	TokenNameCOMMENT_LINE	No characters in the input string; return no tokens! 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Eliminates arcs from the lattice that are compound 	TokenNameCOMMENT_LINE	Eliminates arcs from the lattice that are compound 
// tokens (have a penalty) or are not congruent with the 	TokenNameCOMMENT_LINE	tokens (have a penalty) or are not congruent with the 
// compound token we've matched (ie, span across the 	TokenNameCOMMENT_LINE	compound token we've matched (ie, span across the 
// startPos). This should be fairly efficient, because we 	TokenNameCOMMENT_LINE	startPos). This should be fairly efficient, because we 
// just keep the already intersected structure of the 	TokenNameCOMMENT_LINE	just keep the already intersected structure of the 
// graph, eg we don't have to consult the FSTs again: 	TokenNameCOMMENT_LINE	graph, eg we don't have to consult the FSTs again: 
private	TokenNameprivate	
void	TokenNamevoid	
pruneAndRescore	TokenNameIdentifier	 prune And Rescore
(	TokenNameLPAREN	
int	TokenNameint	
startPos	TokenNameIdentifier	 start Pos
,	TokenNameCOMMA	
int	TokenNameint	
endPos	TokenNameIdentifier	 end Pos
,	TokenNameCOMMA	
int	TokenNameint	
bestStartIDX	TokenNameIdentifier	 best Start IDX
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" pruneAndRescore startPos="	TokenNameStringLiteral	 pruneAndRescore startPos=
+	TokenNamePLUS	
startPos	TokenNameIdentifier	 start Pos
+	TokenNamePLUS	
" endPos="	TokenNameStringLiteral	 endPos=
+	TokenNamePLUS	
endPos	TokenNameIdentifier	 end Pos
+	TokenNamePLUS	
" bestStartIDX="	TokenNameStringLiteral	 bestStartIDX=
+	TokenNamePLUS	
bestStartIDX	TokenNameIdentifier	 best Start IDX
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// First pass: walk backwards, building up the forward 	TokenNameCOMMENT_LINE	First pass: walk backwards, building up the forward 
// arcs and pruning inadmissible arcs: 	TokenNameCOMMENT_LINE	arcs and pruning inadmissible arcs: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
endPos	TokenNameIdentifier	 end Pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
>	TokenNameGREATER	
startPos	TokenNameIdentifier	 start Pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData	TokenNameIdentifier	 pos Data
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" back pos="	TokenNameStringLiteral	 back pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
arcIDX	TokenNameIdentifier	 arc IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
arcIDX	TokenNameIdentifier	 arc IDX
<	TokenNameLESS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
arcIDX	TokenNameIdentifier	 arc IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
backPos	TokenNameIdentifier	 back Pos
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
arcIDX	TokenNameIdentifier	 arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
>=	TokenNameGREATER_EQUAL	
startPos	TokenNameIdentifier	 start Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Keep this arc: 	TokenNameCOMMENT_LINE	Keep this arc: 
//System.out.println(" keep backPos=" + backPos); 	TokenNameCOMMENT_LINE	System.out.println(" keep backPos=" + backPos); 
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
)	TokenNameRPAREN	
.	TokenNameDOT	
addForward	TokenNameIdentifier	 add Forward
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
arcIDX	TokenNameIdentifier	 arc IDX
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
arcIDX	TokenNameIdentifier	 arc IDX
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
arcIDX	TokenNameIdentifier	 arc IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" prune"	TokenNameStringLiteral	 prune
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
!=	TokenNameNOT_EQUAL	
startPos	TokenNameIdentifier	 start Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Second pass: walk forward, re-scoring: 	TokenNameCOMMENT_LINE	Second pass: walk forward, re-scoring: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
startPos	TokenNameIdentifier	 start Pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
endPos	TokenNameIdentifier	 end Pos
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData	TokenNameIdentifier	 pos Data
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" forward pos="	TokenNameStringLiteral	 forward pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" count="	TokenNameStringLiteral	 count=
+	TokenNamePLUS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardCount	TokenNameIdentifier	 forward Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No arcs arrive here... 	TokenNameCOMMENT_LINE	No arcs arrive here... 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" skip"	TokenNameStringLiteral	 skip
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardCount	TokenNameIdentifier	 forward Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
==	TokenNameEQUAL_EQUAL	
startPos	TokenNameIdentifier	 start Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// On the initial position, only consider the best 	TokenNameCOMMENT_LINE	On the initial position, only consider the best 
// path so we "force congruence": the 	TokenNameCOMMENT_LINE	path so we "force congruence": the 
// sub-segmentation is "in context" of what the best 	TokenNameCOMMENT_LINE	sub-segmentation is "in context" of what the best 
// path (compound token) had matched: 	TokenNameCOMMENT_LINE	path (compound token) had matched: 
final	TokenNamefinal	
int	TokenNameint	
rightID	TokenNameIdentifier	 right ID
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
startPos	TokenNameIdentifier	 start Pos
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rightID	TokenNameIdentifier	 right ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
rightID	TokenNameIdentifier	 right ID
=	TokenNameEQUAL	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
bestStartIDX	TokenNameIdentifier	 best Start IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getRightId	TokenNameIdentifier	 get Right Id
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
bestStartIDX	TokenNameIdentifier	 best Start IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
pathCost	TokenNameIdentifier	 path Cost
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
bestStartIDX	TokenNameIdentifier	 best Start IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
<	TokenNameLESS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardCount	TokenNameIdentifier	 forward Count
;	TokenNameSEMICOLON	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Type	TokenNameIdentifier	 Type
forwardType	TokenNameIdentifier	 forward Type
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardType	TokenNameIdentifier	 forward Type
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Dictionary	TokenNameIdentifier	 Dictionary
dict2	TokenNameIdentifier	 dict2
=	TokenNameEQUAL	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
forwardType	TokenNameIdentifier	 forward Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
wordID	TokenNameIdentifier	 word ID
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardID	TokenNameIdentifier	 forward ID
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
toPos	TokenNameIdentifier	 to Pos
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardPos	TokenNameIdentifier	 forward Pos
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
newCost	TokenNameIdentifier	 new Cost
=	TokenNameEQUAL	
pathCost	TokenNameIdentifier	 path Cost
+	TokenNamePLUS	
dict2	TokenNameIdentifier	 dict2
.	TokenNameDOT	
getWordCost	TokenNameIdentifier	 get Word Cost
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
+	TokenNamePLUS	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
rightID	TokenNameIdentifier	 right ID
,	TokenNameCOMMA	
dict2	TokenNameIdentifier	 dict2
.	TokenNameDOT	
getLeftId	TokenNameIdentifier	 get Left Id
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
computePenalty	TokenNameIdentifier	 compute Penalty
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
toPos	TokenNameIdentifier	 to Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" + "	TokenNameStringLiteral	 + 
+	TokenNamePLUS	
forwardType	TokenNameIdentifier	 forward Type
+	TokenNamePLUS	
" word "	TokenNameStringLiteral	 word 
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
toPos	TokenNameIdentifier	 to Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" toPos="	TokenNameStringLiteral	 toPos=
+	TokenNamePLUS	
toPos	TokenNameIdentifier	 to Pos
+	TokenNamePLUS	
" cost="	TokenNameStringLiteral	 cost=
+	TokenNamePLUS	
newCost	TokenNameIdentifier	 new Cost
+	TokenNamePLUS	
" penalty="	TokenNameStringLiteral	 penalty=
+	TokenNamePLUS	
computePenalty	TokenNameIdentifier	 compute Penalty
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
toPos	TokenNameIdentifier	 to Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
+	TokenNamePLUS	
" toPos.idx="	TokenNameStringLiteral	 toPos.idx=
+	TokenNamePLUS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toPos	TokenNameIdentifier	 to Pos
)	TokenNameRPAREN	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toPos	TokenNameIdentifier	 to Pos
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newCost	TokenNameIdentifier	 new Cost
,	TokenNameCOMMA	
dict2	TokenNameIdentifier	 dict2
.	TokenNameDOT	
getRightId	TokenNameIdentifier	 get Right Id
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
bestStartIDX	TokenNameIdentifier	 best Start IDX
,	TokenNameCOMMA	
wordID	TokenNameIdentifier	 word ID
,	TokenNameCOMMA	
forwardType	TokenNameIdentifier	 forward Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// On non-initial positions, we maximize score 	TokenNameCOMMENT_LINE	On non-initial positions, we maximize score 
// across all arriving lastRightIDs: 	TokenNameCOMMENT_LINE	across all arriving lastRightIDs: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
<	TokenNameLESS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardCount	TokenNameIdentifier	 forward Count
;	TokenNameSEMICOLON	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Type	TokenNameIdentifier	 Type
forwardType	TokenNameIdentifier	 forward Type
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardType	TokenNameIdentifier	 forward Type
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
toPos	TokenNameIdentifier	 to Pos
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardPos	TokenNameIdentifier	 forward Pos
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" + "	TokenNameStringLiteral	 + 
+	TokenNamePLUS	
forwardType	TokenNameIdentifier	 forward Type
+	TokenNamePLUS	
" word "	TokenNameStringLiteral	 word 
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
toPos	TokenNameIdentifier	 to Pos
-	TokenNameMINUS	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" toPos="	TokenNameStringLiteral	 toPos=
+	TokenNamePLUS	
toPos	TokenNameIdentifier	 to Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
forwardType	TokenNameIdentifier	 forward Type
)	TokenNameRPAREN	
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
,	TokenNameCOMMA	
toPos	TokenNameIdentifier	 to Pos
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardID	TokenNameIdentifier	 forward ID
[	TokenNameLBRACKET	
forwardArcIDX	TokenNameIdentifier	 forward Arc IDX
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
forwardType	TokenNameIdentifier	 forward Type
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
forwardCount	TokenNameIdentifier	 forward Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Backtrace from the provided position, back to the last 	TokenNameCOMMENT_LINE	Backtrace from the provided position, back to the last 
// time we back-traced, accumulating the resulting tokens to 	TokenNameCOMMENT_LINE	time we back-traced, accumulating the resulting tokens to 
// the pending list. The pending list is then in-reverse 	TokenNameCOMMENT_LINE	the pending list. The pending list is then in-reverse 
// (last token should be returned first). 	TokenNameCOMMENT_LINE	(last token should be returned first). 
private	TokenNameprivate	
void	TokenNamevoid	
backtrace	TokenNameIdentifier	 backtrace
(	TokenNameLPAREN	
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
endPosData	TokenNameIdentifier	 end Pos Data
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
fromIDX	TokenNameIdentifier	 from IDX
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
endPos	TokenNameIdentifier	 end Pos
=	TokenNameEQUAL	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" backtrace: endPos="	TokenNameStringLiteral	 backtrace: endPos=
+	TokenNamePLUS	
endPos	TokenNameIdentifier	 end Pos
+	TokenNamePLUS	
" pos="	TokenNameStringLiteral	 pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
"; "	TokenNameStringLiteral	; 
+	TokenNamePLUS	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
)	TokenNameRPAREN	
+	TokenNamePLUS	
" characters; last="	TokenNameStringLiteral	 characters; last=
+	TokenNamePLUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
+	TokenNamePLUS	
" cost="	TokenNameStringLiteral	 cost=
+	TokenNamePLUS	
endPosData	TokenNameIdentifier	 end Pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
fromIDX	TokenNameIdentifier	 from IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fragment	TokenNameIdentifier	 fragment
=	TokenNameEQUAL	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
,	TokenNameCOMMA	
endPos	TokenNameIdentifier	 end Pos
-	TokenNameMINUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dotOut	TokenNameIdentifier	 dot Out
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dotOut	TokenNameIdentifier	 dot Out
.	TokenNameDOT	
onBacktrace	TokenNameIdentifier	 on Backtrace
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
positions	TokenNameIdentifier	 positions
,	TokenNameCOMMA	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
,	TokenNameCOMMA	
endPosData	TokenNameIdentifier	 end Pos Data
,	TokenNameCOMMA	
fromIDX	TokenNameIdentifier	 from IDX
,	TokenNameCOMMA	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
endPos	TokenNameIdentifier	 end Pos
;	TokenNameSEMICOLON	
int	TokenNameint	
bestIDX	TokenNameIdentifier	 best IDX
=	TokenNameEQUAL	
fromIDX	TokenNameIdentifier	 from IDX
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
altToken	TokenNameIdentifier	 alt Token
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// We trace backwards, so this will be the leftWordID of 	TokenNameCOMMENT_LINE	We trace backwards, so this will be the leftWordID of 
// the token after the one we are now on: 	TokenNameCOMMENT_LINE	the token after the one we are now on: 
int	TokenNameint	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
backCount	TokenNameIdentifier	 back Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// TODO: sort of silly to make Token instances here; the 	TokenNameCOMMENT_LINE	TODO: sort of silly to make Token instances here; the 
// back trace has all info needed to generate the 	TokenNameCOMMENT_LINE	back trace has all info needed to generate the 
// token. So, we could just directly set the attrs, 	TokenNameCOMMENT_LINE	token. So, we could just directly set the attrs, 
// from the backtrace, in incrementToken w/o ever 	TokenNameCOMMENT_LINE	from the backtrace, in incrementToken w/o ever 
// creating Token; we'd have to defer calling freeBefore 	TokenNameCOMMENT_LINE	creating Token; we'd have to defer calling freeBefore 
// until after the bactrace was fully "consumed" by 	TokenNameCOMMENT_LINE	until after the bactrace was fully "consumed" by 
// incrementToken. 	TokenNameCOMMENT_LINE	incrementToken. 
while	TokenNamewhile	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
>	TokenNameGREATER	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("BT: back pos=" + pos + " bestIDX=" + bestIDX); 	TokenNameCOMMENT_LINE	System.out.println("BT: back pos=" + pos + " bestIDX=" + bestIDX); 
final	TokenNamefinal	
Position	TokenNameIdentifier	 Position
posData	TokenNameIdentifier	 pos Data
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
bestIDX	TokenNameIdentifier	 best IDX
<	TokenNameLESS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
int	TokenNameint	
backPos	TokenNameIdentifier	 back Pos
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
backPos	TokenNameIdentifier	 back Pos
>=	TokenNameGREATER_EQUAL	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
:	TokenNameCOLON	
"backPos="	TokenNameStringLiteral	backPos=
+	TokenNamePLUS	
backPos	TokenNameIdentifier	 back Pos
+	TokenNamePLUS	
" vs lastBackTracePos="	TokenNameStringLiteral	 vs lastBackTracePos=
+	TokenNamePLUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
;	TokenNameSEMICOLON	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
Type	TokenNameIdentifier	 Type
backType	TokenNameIdentifier	 back Type
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
backID	TokenNameIdentifier	 back ID
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
nextBestIDX	TokenNameIdentifier	 next Best IDX
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputCompounds	TokenNameIdentifier	 output Compounds
&&	TokenNameAND_AND	
searchMode	TokenNameIdentifier	 search Mode
&&	TokenNameAND_AND	
altToken	TokenNameIdentifier	 alt Token
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
backType	TokenNameIdentifier	 back Type
!=	TokenNameNOT_EQUAL	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// In searchMode, if best path had picked a too-long 	TokenNameCOMMENT_LINE	In searchMode, if best path had picked a too-long 
// token, we use the "penalty" to compute the allowed 	TokenNameCOMMENT_LINE	token, we use the "penalty" to compute the allowed 
// max cost of an alternate back-trace. If we find an 	TokenNameCOMMENT_LINE	max cost of an alternate back-trace. If we find an 
// alternate back trace with cost below that 	TokenNameCOMMENT_LINE	alternate back trace with cost below that 
// threshold, we pursue it instead (but also output 	TokenNameCOMMENT_LINE	threshold, we pursue it instead (but also output 
// the long token). 	TokenNameCOMMENT_LINE	the long token). 
//System.out.println(" 2nd best backPos=" + backPos + " pos=" + pos); 	TokenNameCOMMENT_LINE	System.out.println(" 2nd best backPos=" + backPos + " pos=" + pos); 
final	TokenNamefinal	
int	TokenNameint	
penalty	TokenNameIdentifier	 penalty
=	TokenNameEQUAL	
computeSecondBestThreshold	TokenNameIdentifier	 compute Second Best Threshold
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
backPos	TokenNameIdentifier	 back Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
penalty	TokenNameIdentifier	 penalty
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" compound="	TokenNameStringLiteral	 compound=
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
backPos	TokenNameIdentifier	 back Pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" backPos="	TokenNameStringLiteral	 backPos=
+	TokenNamePLUS	
backPos	TokenNameIdentifier	 back Pos
+	TokenNamePLUS	
" pos="	TokenNameStringLiteral	 pos=
+	TokenNamePLUS	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
" penalty="	TokenNameStringLiteral	 penalty=
+	TokenNamePLUS	
penalty	TokenNameIdentifier	 penalty
+	TokenNamePLUS	
" cost="	TokenNameStringLiteral	 cost=
+	TokenNamePLUS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
+	TokenNamePLUS	
" bestIDX="	TokenNameStringLiteral	 bestIDX=
+	TokenNamePLUS	
bestIDX	TokenNameIdentifier	 best IDX
+	TokenNamePLUS	
" lastLeftID="	TokenNameStringLiteral	 lastLeftID=
+	TokenNamePLUS	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Use the penalty to set maxCost on the 2nd best 	TokenNameCOMMENT_LINE	Use the penalty to set maxCost on the 2nd best 
// segmentation: 	TokenNameCOMMENT_LINE	segmentation: 
int	TokenNameint	
maxCost	TokenNameIdentifier	 max Cost
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
+	TokenNamePLUS	
penalty	TokenNameIdentifier	 penalty
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxCost	TokenNameIdentifier	 max Cost
+=	TokenNamePLUS_EQUAL	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
backType	TokenNameIdentifier	 back Type
)	TokenNameRPAREN	
.	TokenNameDOT	
getRightId	TokenNameIdentifier	 get Right Id
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
)	TokenNameRPAREN	
,	TokenNameCOMMA	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now, prune all too-long tokens from the graph: 	TokenNameCOMMENT_LINE	Now, prune all too-long tokens from the graph: 
pruneAndRescore	TokenNameIdentifier	 prune And Rescore
(	TokenNameLPAREN	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Finally, find 2nd best back-trace and resume 	TokenNameCOMMENT_LINE	Finally, find 2nd best back-trace and resume 
// backtrace there: 	TokenNameCOMMENT_LINE	backtrace there: 
int	TokenNameint	
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
int	TokenNameint	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
cost	TokenNameIdentifier	 cost
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
costs	TokenNameIdentifier	 costs
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" idx=" + idx + " prevCost=" + cost); 	TokenNameCOMMENT_LINE	System.out.println(" idx=" + idx + " prevCost=" + cost); 
if	TokenNameif	
(	TokenNameLPAREN	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cost	TokenNameIdentifier	 cost
+=	TokenNamePLUS_EQUAL	
costs	TokenNameIdentifier	 costs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getRightId	TokenNameIdentifier	 get Right Id
(	TokenNameLPAREN	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" += bgCost=" + costs.get(getDict(posData.backType[idx]).getRightId(posData.backID[idx]), 	TokenNameCOMMENT_LINE	System.out.println(" += bgCost=" + costs.get(getDict(posData.backType[idx]).getRightId(posData.backID[idx]), 
//lastLeftWordID) + " -> " + cost); 	TokenNameCOMMENT_LINE	lastLeftWordID) + " -> " + cost); 
}	TokenNameRBRACE	
//System.out.println("penalty " + posData.backPos[idx] + " to " + pos); 	TokenNameCOMMENT_LINE	System.out.println("penalty " + posData.backPos[idx] + " to " + pos); 
//cost += computePenalty(posData.backPos[idx], pos - posData.backPos[idx]); 	TokenNameCOMMENT_LINE	cost += computePenalty(posData.backPos[idx], pos - posData.backPos[idx]); 
if	TokenNameif	
(	TokenNameLPAREN	
cost	TokenNameIdentifier	 cost
<	TokenNameLESS	
leastCost	TokenNameIdentifier	 least Cost
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" ** "); 	TokenNameCOMMENT_LINE	System.out.println(" ** "); 
leastCost	TokenNameIdentifier	 least Cost
=	TokenNameEQUAL	
cost	TokenNameIdentifier	 cost
;	TokenNameSEMICOLON	
leastIDX	TokenNameIdentifier	 least IDX
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//System.out.println(" leastIDX=" + leastIDX); 	TokenNameCOMMENT_LINE	System.out.println(" leastIDX=" + leastIDX); 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" afterPrune: "	TokenNameStringLiteral	 afterPrune: 
+	TokenNamePLUS	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
" arcs arriving; leastCost="	TokenNameStringLiteral	 arcs arriving; leastCost=
+	TokenNamePLUS	
leastCost	TokenNameIdentifier	 least Cost
+	TokenNamePLUS	
" vs threshold="	TokenNameStringLiteral	 vs threshold=
+	TokenNamePLUS	
maxCost	TokenNameIdentifier	 max Cost
+	TokenNamePLUS	
" lastLeftWordID="	TokenNameStringLiteral	 lastLeftWordID=
+	TokenNamePLUS	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
leastIDX	TokenNameIdentifier	 least IDX
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
leastCost	TokenNameIdentifier	 least Cost
<=	TokenNameLESS_EQUAL	
maxCost	TokenNameIdentifier	 max Cost
&&	TokenNameAND_AND	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
backPos	TokenNameIdentifier	 back Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We should have pruned the altToken from the graph: 	TokenNameCOMMENT_LINE	We should have pruned the altToken from the graph: 
assert	TokenNameassert	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
leastIDX	TokenNameIdentifier	 least IDX
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
// Save the current compound token, to output when 	TokenNameCOMMENT_LINE	Save the current compound token, to output when 
// this alternate path joins back: 	TokenNameCOMMENT_LINE	this alternate path joins back: 
altToken	TokenNameIdentifier	 alt Token
=	TokenNameEQUAL	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
,	TokenNameCOMMA	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
backPos	TokenNameIdentifier	 back Pos
-	TokenNameMINUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
backType	TokenNameIdentifier	 back Type
,	TokenNameCOMMA	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
backType	TokenNameIdentifier	 back Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Redirect our backtrace to 2nd best: 	TokenNameCOMMENT_LINE	Redirect our backtrace to 2nd best: 
bestIDX	TokenNameIdentifier	 best IDX
=	TokenNameEQUAL	
leastIDX	TokenNameIdentifier	 least IDX
;	TokenNameSEMICOLON	
nextBestIDX	TokenNameIdentifier	 next Best IDX
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backIndex	TokenNameIdentifier	 back Index
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
backPos	TokenNameIdentifier	 back Pos
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backPos	TokenNameIdentifier	 back Pos
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
-	TokenNameMINUS	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
backType	TokenNameIdentifier	 back Type
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backType	TokenNameIdentifier	 back Type
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
backID	TokenNameIdentifier	 back ID
=	TokenNameEQUAL	
posData	TokenNameIdentifier	 pos Data
.	TokenNameDOT	
backID	TokenNameIdentifier	 back ID
[	TokenNameLBRACKET	
bestIDX	TokenNameIdentifier	 best IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
backCount	TokenNameIdentifier	 back Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//System.out.println(" do alt token!"); 	TokenNameCOMMENT_LINE	System.out.println(" do alt token!"); 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// I think in theory it's possible there is no 	TokenNameCOMMENT_LINE	I think in theory it's possible there is no 
// 2nd best path, which is fine; in this case we 	TokenNameCOMMENT_LINE	2nd best path, which is fine; in this case we 
// only output the compound token: 	TokenNameCOMMENT_LINE	only output the compound token: 
//System.out.println(" no alt token! bestIDX=" + bestIDX); 	TokenNameCOMMENT_LINE	System.out.println(" no alt token! bestIDX=" + bestIDX); 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
backPos	TokenNameIdentifier	 back Pos
-	TokenNameMINUS	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
;	TokenNameSEMICOLON	
assert	TokenNameassert	
offset	TokenNameIdentifier	 offset
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
altToken	TokenNameIdentifier	 alt Token
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
altToken	TokenNameIdentifier	 alt Token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
backPos	TokenNameIdentifier	 back Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We've backtraced to the position where the 	TokenNameCOMMENT_LINE	We've backtraced to the position where the 
// compound token starts; add it now: 	TokenNameCOMMENT_LINE	compound token starts; add it now: 
// The pruning we did when we created the altToken 	TokenNameCOMMENT_LINE	The pruning we did when we created the altToken 
// ensures that the back trace will align back with 	TokenNameCOMMENT_LINE	ensures that the back trace will align back with 
// the start of the altToken: 	TokenNameCOMMENT_LINE	the start of the altToken: 
assert	TokenNameassert	
altToken	TokenNameIdentifier	 alt Token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
backPos	TokenNameIdentifier	 back Pos
:	TokenNameCOLON	
altToken	TokenNameIdentifier	 alt Token
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs "	TokenNameStringLiteral	 vs 
+	TokenNamePLUS	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
// NOTE: not quite right: the compound token may 	TokenNameCOMMENT_LINE	NOTE: not quite right: the compound token may 
// have had all punctuation back traced so far, but 	TokenNameCOMMENT_LINE	have had all punctuation back traced so far, but 
// then the decompounded token at this position is 	TokenNameCOMMENT_LINE	then the decompounded token at this position is 
// not punctuation. In this case backCount is 0, 	TokenNameCOMMENT_LINE	not punctuation. In this case backCount is 0, 
// but we should maybe add the altToken anyway...? 	TokenNameCOMMENT_LINE	but we should maybe add the altToken anyway...? 
if	TokenNameif	
(	TokenNameLPAREN	
backCount	TokenNameIdentifier	 back Count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
backCount	TokenNameIdentifier	 back Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
altToken	TokenNameIdentifier	 alt Token
.	TokenNameDOT	
setPositionLength	TokenNameIdentifier	 set Position Length
(	TokenNameLPAREN	
backCount	TokenNameIdentifier	 back Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" add altToken="	TokenNameStringLiteral	 add altToken=
+	TokenNamePLUS	
altToken	TokenNameIdentifier	 alt Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
altToken	TokenNameIdentifier	 alt Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This means alt token was all punct tokens: 	TokenNameCOMMENT_LINE	This means alt token was all punct tokens: 
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" discard all-punctuation altToken="	TokenNameStringLiteral	 discard all-punctuation altToken=
+	TokenNamePLUS	
altToken	TokenNameIdentifier	 alt Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
altToken	TokenNameIdentifier	 alt Token
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
Dictionary	TokenNameIdentifier	 Dictionary
dict	TokenNameIdentifier	 dict
=	TokenNameEQUAL	
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
backType	TokenNameIdentifier	 back Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
backType	TokenNameIdentifier	 back Type
==	TokenNameEQUAL_EQUAL	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Expand the phraseID we recorded into the actual 	TokenNameCOMMENT_LINE	Expand the phraseID we recorded into the actual 
// segmentation: 	TokenNameCOMMENT_LINE	segmentation: 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
=	TokenNameEQUAL	
userDictionary	TokenNameIdentifier	 user Dictionary
.	TokenNameDOT	
lookupSegmentation	TokenNameIdentifier	 lookup Segmentation
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
wordID	TokenNameIdentifier	 word ID
=	TokenNameEQUAL	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
len	TokenNameIdentifier	 len
=	TokenNameEQUAL	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" add user: len=" + len); 	TokenNameCOMMENT_LINE	System.out.println(" add user: len=" + len); 
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
wordID	TokenNameIdentifier	 word ID
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
+	TokenNamePLUS	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
len	TokenNameIdentifier	 len
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
USER	TokenNameIdentifier	 USER
,	TokenNameCOMMA	
current	TokenNameIdentifier	 current
+	TokenNamePLUS	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
dict	TokenNameIdentifier	 dict
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" add USER token="	TokenNameStringLiteral	 add USER token=
+	TokenNamePLUS	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
current	TokenNameIdentifier	 current
+=	TokenNamePLUS_EQUAL	
len	TokenNameIdentifier	 len
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Reverse the tokens we just added, because when we 	TokenNameCOMMENT_LINE	Reverse the tokens we just added, because when we 
// serve them up from incrementToken we serve in 	TokenNameCOMMENT_LINE	serve them up from incrementToken we serve in 
// reverse: 	TokenNameCOMMENT_LINE	reverse: 
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
subList	TokenNameIdentifier	 sub List
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
backCount	TokenNameIdentifier	 back Count
+=	TokenNamePLUS_EQUAL	
wordIDAndLength	TokenNameIdentifier	 word ID And Length
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
extendedMode	TokenNameIdentifier	 extended Mode
&&	TokenNameAND_AND	
backType	TokenNameIdentifier	 back Type
==	TokenNameEQUAL_EQUAL	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// In EXTENDED mode we convert unknown word into 	TokenNameCOMMENT_LINE	In EXTENDED mode we convert unknown word into 
// unigrams: 	TokenNameCOMMENT_LINE	unigrams: 
int	TokenNameint	
unigramTokenCount	TokenNameIdentifier	 unigram Token Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
charLen	TokenNameIdentifier	 char Len
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLowSurrogate	TokenNameIdentifier	 is Low Surrogate
(	TokenNameLPAREN	
fragment	TokenNameIdentifier	 fragment
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
charLen	TokenNameIdentifier	 char Len
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" extended tok offset=" 	TokenNameCOMMENT_LINE	System.out.println(" extended tok offset=" 
//+ (offset + i)); 	TokenNameCOMMENT_LINE	+ (offset + i)); 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
||	TokenNameOR_OR	
!	TokenNameNOT	
isPunctuation	TokenNameIdentifier	 is Punctuation
(	TokenNameLPAREN	
fragment	TokenNameIdentifier	 fragment
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
CharacterDefinition	TokenNameIdentifier	 Character Definition
.	TokenNameDOT	
NGRAM	TokenNameIdentifier	 NGRAM
,	TokenNameCOMMA	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
charLen	TokenNameIdentifier	 char Len
,	TokenNameCOMMA	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
UNKNOWN	TokenNameIdentifier	 UNKNOWN
,	TokenNameCOMMA	
backPos	TokenNameIdentifier	 back Pos
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
unkDictionary	TokenNameIdentifier	 unk Dictionary
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
unigramTokenCount	TokenNameIdentifier	 unigram Token Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
backCount	TokenNameIdentifier	 back Count
+=	TokenNamePLUS_EQUAL	
unigramTokenCount	TokenNameIdentifier	 unigram Token Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
discardPunctuation	TokenNameIdentifier	 discard Punctuation
||	TokenNameOR_OR	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
!	TokenNameNOT	
isPunctuation	TokenNameIdentifier	 is Punctuation
(	TokenNameLPAREN	
fragment	TokenNameIdentifier	 fragment
[	TokenNameLBRACKET	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
Token	TokenNameIdentifier	 Token
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
,	TokenNameCOMMA	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
backType	TokenNameIdentifier	 back Type
,	TokenNameCOMMA	
backPos	TokenNameIdentifier	 back Pos
,	TokenNameCOMMA	
dict	TokenNameIdentifier	 dict
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" add token="	TokenNameStringLiteral	 add token=
+	TokenNamePLUS	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pending	TokenNameIdentifier	 pending
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
backCount	TokenNameIdentifier	 back Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" skip punctuation token="	TokenNameStringLiteral	 skip punctuation token=
+	TokenNamePLUS	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
fragment	TokenNameIdentifier	 fragment
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
lastLeftWordID	TokenNameIdentifier	 last Left Word ID
=	TokenNameEQUAL	
dict	TokenNameIdentifier	 dict
.	TokenNameDOT	
getLeftId	TokenNameIdentifier	 get Left Id
(	TokenNameLPAREN	
backID	TokenNameIdentifier	 back ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
backPos	TokenNameIdentifier	 back Pos
;	TokenNameSEMICOLON	
bestIDX	TokenNameIdentifier	 best IDX
=	TokenNameEQUAL	
nextBestIDX	TokenNameIdentifier	 next Best IDX
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastBackTracePos	TokenNameIdentifier	 last Back Trace Pos
=	TokenNameEQUAL	
endPos	TokenNameIdentifier	 end Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
VERBOSE	TokenNameIdentifier	 VERBOSE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" freeBefore pos="	TokenNameStringLiteral	 freeBefore pos=
+	TokenNamePLUS	
endPos	TokenNameIdentifier	 end Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Notify the circular buffers that we are done with 	TokenNameCOMMENT_LINE	Notify the circular buffers that we are done with 
// these positions: 	TokenNameCOMMENT_LINE	these positions: 
buffer	TokenNameIdentifier	 buffer
.	TokenNameDOT	
freeBefore	TokenNameIdentifier	 free Before
(	TokenNameLPAREN	
endPos	TokenNameIdentifier	 end Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
freeBefore	TokenNameIdentifier	 free Before
(	TokenNameLPAREN	
endPos	TokenNameIdentifier	 end Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Dictionary	TokenNameIdentifier	 Dictionary
getDict	TokenNameIdentifier	 get Dict
(	TokenNameLPAREN	
Type	TokenNameIdentifier	 Type
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dictionaryMap	TokenNameIdentifier	 dictionary Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isPunctuation	TokenNameIdentifier	 is Punctuation
(	TokenNameLPAREN	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
SPACE_SEPARATOR	TokenNameIdentifier	 SPACE  SEPARATOR
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
LINE_SEPARATOR	TokenNameIdentifier	 LINE  SEPARATOR
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
PARAGRAPH_SEPARATOR	TokenNameIdentifier	 PARAGRAPH  SEPARATOR
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
CONTROL	TokenNameIdentifier	 CONTROL
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
FORMAT	TokenNameIdentifier	 FORMAT
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
DASH_PUNCTUATION	TokenNameIdentifier	 DASH  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
START_PUNCTUATION	TokenNameIdentifier	 START  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
END_PUNCTUATION	TokenNameIdentifier	 END  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
CONNECTOR_PUNCTUATION	TokenNameIdentifier	 CONNECTOR  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
OTHER_PUNCTUATION	TokenNameIdentifier	 OTHER  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
MATH_SYMBOL	TokenNameIdentifier	 MATH  SYMBOL
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
CURRENCY_SYMBOL	TokenNameIdentifier	 CURRENCY  SYMBOL
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
MODIFIER_SYMBOL	TokenNameIdentifier	 MODIFIER  SYMBOL
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
OTHER_SYMBOL	TokenNameIdentifier	 OTHER  SYMBOL
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
INITIAL_QUOTE_PUNCTUATION	TokenNameIdentifier	 INITIAL  QUOTE  PUNCTUATION
:	TokenNameCOLON	
case	TokenNamecase	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
FINAL_QUOTE_PUNCTUATION	TokenNameIdentifier	 FINAL  QUOTE  PUNCTUATION
:	TokenNameCOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
