/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Point2D	TokenNameIdentifier	 Point2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
.	TokenNameDOT	
timing	TokenNameIdentifier	 timing
.	TokenNameDOT	
TimedElement	TokenNameIdentifier	 Timed Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
.	TokenNameDOT	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
AnimatableAngleValue	TokenNameIdentifier	 Animatable Angle Value
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
.	TokenNameDOT	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
.	TokenNameDOT	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
AnimatableValue	TokenNameIdentifier	 Animatable Value
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
anim	TokenNameIdentifier	 anim
.	TokenNameDOT	
AnimatableElement	TokenNameIdentifier	 Animatable Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Cubic	TokenNameIdentifier	 Cubic
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
ExtendedGeneralPath	TokenNameIdentifier	 Extended General Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
ExtendedPathIterator	TokenNameIdentifier	 Extended Path Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
PathLength	TokenNameIdentifier	 Path Length
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SMILConstants	TokenNameIdentifier	 SMIL Constants
;	TokenNameSEMICOLON	
/** * An animation class for 'animateMotion' animations. * * @author <a href="mailto:cam%40mcc%2eid%2eau">Cameron McCormack</a> * @version $Id: MotionAnimation.java 575201 2007-09-13 07:41:26Z cam $ */	TokenNameCOMMENT_JAVADOC	 An animation class for 'animateMotion' animations. * @author <a href="mailto:cam%40mcc%2eid%2eau">Cameron McCormack</a> @version $Id: MotionAnimation.java 575201 2007-09-13 07:41:26Z cam $ 
public	TokenNamepublic	
class	TokenNameclass	
MotionAnimation	TokenNameIdentifier	 Motion Animation
extends	TokenNameextends	
InterpolatingAnimation	TokenNameIdentifier	 Interpolating Animation
{	TokenNameLBRACE	
/** * The path that describes the motion. */	TokenNameCOMMENT_JAVADOC	 The path that describes the motion. 
protected	TokenNameprotected	
ExtendedGeneralPath	TokenNameIdentifier	 Extended General Path
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
/** * The path length calculation object. */	TokenNameCOMMENT_JAVADOC	 The path length calculation object. 
protected	TokenNameprotected	
PathLength	TokenNameIdentifier	 Path Length
pathLength	TokenNameIdentifier	 path Length
;	TokenNameSEMICOLON	
/** * The points defining the distance along the path that the * keyTimes apply. */	TokenNameCOMMENT_JAVADOC	 The points defining the distance along the path that the keyTimes apply. 
protected	TokenNameprotected	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyPoints	TokenNameIdentifier	 key Points
;	TokenNameSEMICOLON	
/** * Whether automatic rotation should be performed. */	TokenNameCOMMENT_JAVADOC	 Whether automatic rotation should be performed. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
rotateAuto	TokenNameIdentifier	 rotate Auto
;	TokenNameSEMICOLON	
/** * Whether the automatic rotation should be reversed. */	TokenNameCOMMENT_JAVADOC	 Whether the automatic rotation should be reversed. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
;	TokenNameSEMICOLON	
/** * The angle of rotation (in radians) to use when automatic rotation is * not being used. */	TokenNameCOMMENT_JAVADOC	 The angle of rotation (in radians) to use when automatic rotation is not being used. 
protected	TokenNameprotected	
float	TokenNamefloat	
rotateAngle	TokenNameIdentifier	 rotate Angle
;	TokenNameSEMICOLON	
/** * Creates a new MotionAnimation. */	TokenNameCOMMENT_JAVADOC	 Creates a new MotionAnimation. 
public	TokenNamepublic	
MotionAnimation	TokenNameIdentifier	 Motion Animation
(	TokenNameLPAREN	
TimedElement	TokenNameIdentifier	 Timed Element
timedElement	TokenNameIdentifier	 timed Element
,	TokenNameCOMMA	
AnimatableElement	TokenNameIdentifier	 Animatable Element
animatableElement	TokenNameIdentifier	 animatable Element
,	TokenNameCOMMA	
int	TokenNameint	
calcMode	TokenNameIdentifier	 calc Mode
,	TokenNameCOMMA	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyTimes	TokenNameIdentifier	 key Times
,	TokenNameCOMMA	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keySplines	TokenNameIdentifier	 key Splines
,	TokenNameCOMMA	
boolean	TokenNameboolean	
additive	TokenNameIdentifier	 additive
,	TokenNameCOMMA	
boolean	TokenNameboolean	
cumulative	TokenNameIdentifier	 cumulative
,	TokenNameCOMMA	
AnimatableValue	TokenNameIdentifier	 Animatable Value
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
values	TokenNameIdentifier	 values
,	TokenNameCOMMA	
AnimatableValue	TokenNameIdentifier	 Animatable Value
from	TokenNameIdentifier	 from
,	TokenNameCOMMA	
AnimatableValue	TokenNameIdentifier	 Animatable Value
to	TokenNameIdentifier	 to
,	TokenNameCOMMA	
AnimatableValue	TokenNameIdentifier	 Animatable Value
by	TokenNameIdentifier	 by
,	TokenNameCOMMA	
ExtendedGeneralPath	TokenNameIdentifier	 Extended General Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyPoints	TokenNameIdentifier	 key Points
,	TokenNameCOMMA	
boolean	TokenNameboolean	
rotateAuto	TokenNameIdentifier	 rotate Auto
,	TokenNameCOMMA	
boolean	TokenNameboolean	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
,	TokenNameCOMMA	
float	TokenNamefloat	
rotateAngle	TokenNameIdentifier	 rotate Angle
,	TokenNameCOMMA	
short	TokenNameshort	
rotateAngleUnit	TokenNameIdentifier	 rotate Angle Unit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
timedElement	TokenNameIdentifier	 timed Element
,	TokenNameCOMMA	
animatableElement	TokenNameIdentifier	 animatable Element
,	TokenNameCOMMA	
calcMode	TokenNameIdentifier	 calc Mode
,	TokenNameCOMMA	
keyTimes	TokenNameIdentifier	 key Times
,	TokenNameCOMMA	
keySplines	TokenNameIdentifier	 key Splines
,	TokenNameCOMMA	
additive	TokenNameIdentifier	 additive
,	TokenNameCOMMA	
cumulative	TokenNameIdentifier	 cumulative
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
rotateAuto	TokenNameIdentifier	 rotate Auto
=	TokenNameEQUAL	
rotateAuto	TokenNameIdentifier	 rotate Auto
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
=	TokenNameEQUAL	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
rotateAngle	TokenNameIdentifier	 rotate Angle
=	TokenNameEQUAL	
AnimatableAngleValue	TokenNameIdentifier	 Animatable Angle Value
.	TokenNameDOT	
rad	TokenNameIdentifier	 rad
(	TokenNameLPAREN	
rotateAngle	TokenNameIdentifier	 rotate Angle
,	TokenNameCOMMA	
rotateAngleUnit	TokenNameIdentifier	 rotate Angle Unit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
ExtendedGeneralPath	TokenNameIdentifier	 Extended General Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
from	TokenNameIdentifier	 from
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
fromPt	TokenNameIdentifier	 from Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
from	TokenNameIdentifier	 from
;	TokenNameSEMICOLON	
float	TokenNamefloat	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
fromPt	TokenNameIdentifier	 from Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
y	TokenNameIdentifier	 y
=	TokenNameEQUAL	
fromPt	TokenNameIdentifier	 from Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
toPt	TokenNameIdentifier	 to Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
to	TokenNameIdentifier	 to
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
toPt	TokenNameIdentifier	 to Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
toPt	TokenNameIdentifier	 to Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
by	TokenNameIdentifier	 by
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
byPt	TokenNameIdentifier	 by Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
by	TokenNameIdentifier	 by
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
+	TokenNamePLUS	
byPt	TokenNameIdentifier	 by Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
y	TokenNameIdentifier	 y
+	TokenNamePLUS	
byPt	TokenNameIdentifier	 by Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
timedElement	TokenNameIdentifier	 timed Element
.	TokenNameDOT	
createException	TokenNameIdentifier	 create Exception
(	TokenNameLPAREN	
"values.to.by.path.missing"	TokenNameStringLiteral	values.to.by.path.missing
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
to	TokenNameIdentifier	 to
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
unPt	TokenNameIdentifier	 un Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
animatableElement	TokenNameIdentifier	 animatable Element
.	TokenNameDOT	
getUnderlyingValue	TokenNameIdentifier	 get Underlying Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
toPt	TokenNameIdentifier	 to Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
to	TokenNameIdentifier	 to
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
unPt	TokenNameIdentifier	 un Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
unPt	TokenNameIdentifier	 un Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
toPt	TokenNameIdentifier	 to Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
toPt	TokenNameIdentifier	 to Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cumulative	TokenNameIdentifier	 cumulative
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
by	TokenNameIdentifier	 by
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
byPt	TokenNameIdentifier	 by Pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
by	TokenNameIdentifier	 by
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
byPt	TokenNameIdentifier	 by Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
byPt	TokenNameIdentifier	 by Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
additive	TokenNameIdentifier	 additive
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
timedElement	TokenNameIdentifier	 timed Element
.	TokenNameDOT	
createException	TokenNameIdentifier	 create Exception
(	TokenNameLPAREN	
"values.to.by.path.missing"	TokenNameStringLiteral	values.to.by.path.missing
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
moveTo	TokenNameIdentifier	 move To
(	TokenNameLPAREN	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pt	TokenNameIdentifier	 pt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
)	TokenNameRPAREN	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
lineTo	TokenNameIdentifier	 line To
(	TokenNameLPAREN	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pt	TokenNameIdentifier	 pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
pathLength	TokenNameIdentifier	 path Length
=	TokenNameEQUAL	
new	TokenNamenew	
PathLength	TokenNameIdentifier	 Path Length
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
segments	TokenNameIdentifier	 segments
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ExtendedPathIterator	TokenNameIdentifier	 Extended Path Iterator
epi	TokenNameIdentifier	 epi
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
getExtendedPathIterator	TokenNameIdentifier	 get Extended Path Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
isDone	TokenNameIdentifier	 is Done
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
currentSegment	TokenNameIdentifier	 current Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
ExtendedPathIterator	TokenNameIdentifier	 Extended Path Iterator
.	TokenNameDOT	
SEG_MOVETO	TokenNameIdentifier	 SEG  MOVETO
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segments	TokenNameIdentifier	 segments
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
keyPoints	TokenNameIdentifier	 key Points
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
segments	TokenNameIdentifier	 segments
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
keyPoints	TokenNameIdentifier	 key Points
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
float	TokenNamefloat	
totalLength	TokenNameIdentifier	 total Length
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
calcMode	TokenNameIdentifier	 calc Mode
!=	TokenNameNOT_EQUAL	
CALC_MODE_PACED	TokenNameIdentifier	 CALC  MODE  PACED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
timedElement	TokenNameIdentifier	 timed Element
.	TokenNameDOT	
createException	TokenNameIdentifier	 create Exception
(	TokenNameLPAREN	
"attribute.malformed"	TokenNameStringLiteral	attribute.malformed
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
SMILConstants	TokenNameIdentifier	 SMIL Constants
.	TokenNameDOT	
SMIL_KEY_TIMES_ATTRIBUTE	TokenNameIdentifier	 SMIL  KEY  TIMES  ATTRIBUTE
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_LINEAR	TokenNameIdentifier	 CALC  MODE  LINEAR
||	TokenNameOR_OR	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_SPLINE	TokenNameIdentifier	 CALC  MODE  SPLINE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_DISCRETE	TokenNameIdentifier	 CALC  MODE  DISCRETE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
/	TokenNameDIVIDE	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// CALC_MODE_PACED 	TokenNameCOMMENT_LINE	CALC_MODE_PACED 
// This corrects the keyTimes to be paced, so from now on 	TokenNameCOMMENT_LINE	This corrects the keyTimes to be paced, so from now on 
// it can be considered the same as CALC_MODE_LINEAR. 	TokenNameCOMMENT_LINE	it can be considered the same as CALC_MODE_LINEAR. 
epi	TokenNameIdentifier	 epi
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
getExtendedPathIterator	TokenNameIdentifier	 get Extended Path Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
currentSegment	TokenNameIdentifier	 current Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ExtendedPathIterator	TokenNameIdentifier	 Extended Path Iterator
.	TokenNameDOT	
SEG_MOVETO	TokenNameIdentifier	 SEG  MOVETO
)	TokenNameRPAREN	
{	TokenNameLBRACE	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
getLengthAtSegment	TokenNameIdentifier	 get Length At Segment
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
totalLength	TokenNameIdentifier	 total Length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyPoints	TokenNameIdentifier	 key Points
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyPoints	TokenNameIdentifier	 key Points
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
keyTimes	TokenNameIdentifier	 key Times
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
timedElement	TokenNameIdentifier	 timed Element
.	TokenNameDOT	
createException	TokenNameIdentifier	 create Exception
(	TokenNameLPAREN	
"attribute.malformed"	TokenNameStringLiteral	attribute.malformed
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
SMILConstants	TokenNameIdentifier	 SMIL Constants
.	TokenNameDOT	
SMIL_KEY_POINTS_ATTRIBUTE	TokenNameIdentifier	 SMIL  KEY  POINTS  ATTRIBUTE
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
epi	TokenNameIdentifier	 epi
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
getExtendedPathIterator	TokenNameIdentifier	 get Extended Path Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyPoints	TokenNameIdentifier	 key Points
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
currentSegment	TokenNameIdentifier	 current Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ExtendedPathIterator	TokenNameIdentifier	 Extended Path Iterator
.	TokenNameDOT	
SEG_MOVETO	TokenNameIdentifier	 SEG  MOVETO
)	TokenNameRPAREN	
{	TokenNameLBRACE	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
keyPoints	TokenNameIdentifier	 key Points
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
getLengthAtSegment	TokenNameIdentifier	 get Length At Segment
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
totalLength	TokenNameIdentifier	 total Length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
epi	TokenNameIdentifier	 epi
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
keyPoints	TokenNameIdentifier	 key Points
[	TokenNameLBRACKET	
count	TokenNameIdentifier	 count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keyPoints	TokenNameIdentifier	 key Points
=	TokenNameEQUAL	
keyPoints	TokenNameIdentifier	 key Points
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Called when the element is sampled at the given unit time. This updates * the {@link #value} of the animation if active. */	TokenNameCOMMENT_JAVADOC	 Called when the element is sampled at the given unit time. This updates the {@link #value} of the animation if active. 
protected	TokenNameprotected	
void	TokenNamevoid	
sampledAtUnitTime	TokenNameIdentifier	 sampled At Unit Time
(	TokenNameLPAREN	
float	TokenNamefloat	
unitTime	TokenNameIdentifier	 unit Time
,	TokenNameCOMMA	
int	TokenNameint	
repeatIteration	TokenNameIdentifier	 repeat Iteration
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AnimatableValue	TokenNameIdentifier	 Animatable Value
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
accumulation	TokenNameIdentifier	 accumulation
;	TokenNameSEMICOLON	
float	TokenNamefloat	
interpolation	TokenNameIdentifier	 interpolation
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
unitTime	TokenNameIdentifier	 unit Time
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
keyTimeIndex	TokenNameIdentifier	 key Time Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
keyTimeIndex	TokenNameIdentifier	 key Time Index
<	TokenNameLESS	
keyTimes	TokenNameIdentifier	 key Times
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
unitTime	TokenNameIdentifier	 unit Time
>=	TokenNameGREATER_EQUAL	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyTimeIndex	TokenNameIdentifier	 key Time Index
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyTimeIndex	TokenNameIdentifier	 key Time Index
==	TokenNameEQUAL_EQUAL	
keyTimes	TokenNameIdentifier	 key Times
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_DISCRETE	TokenNameIdentifier	 CALC  MODE  DISCRETE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyTimeIndex	TokenNameIdentifier	 key Time Index
=	TokenNameEQUAL	
keyTimes	TokenNameIdentifier	 key Times
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
interpolation	TokenNameIdentifier	 interpolation
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_LINEAR	TokenNameIdentifier	 CALC  MODE  LINEAR
||	TokenNameOR_OR	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_PACED	TokenNameIdentifier	 CALC  MODE  PACED
||	TokenNameOR_OR	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_SPLINE	TokenNameIdentifier	 CALC  MODE  SPLINE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
unitTime	TokenNameIdentifier	 unit Time
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
interpolation	TokenNameIdentifier	 interpolation
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
interpolation	TokenNameIdentifier	 interpolation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
unitTime	TokenNameIdentifier	 unit Time
-	TokenNameMINUS	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
keyTimes	TokenNameIdentifier	 key Times
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
calcMode	TokenNameIdentifier	 calc Mode
==	TokenNameEQUAL_EQUAL	
CALC_MODE_SPLINE	TokenNameIdentifier	 CALC  MODE  SPLINE
&&	TokenNameAND_AND	
unitTime	TokenNameIdentifier	 unit Time
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// XXX This could be done better, e.g. with 	TokenNameCOMMENT_LINE	XXX This could be done better, e.g. with 
// Newton-Raphson. 	TokenNameCOMMENT_LINE	Newton-Raphson. 
Cubic	TokenNameIdentifier	 Cubic
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
keySplineCubics	TokenNameIdentifier	 key Spline Cubics
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
tolerance	TokenNameIdentifier	 tolerance
=	TokenNameEQUAL	
0.001f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Double	TokenNameIdentifier	 Double
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
float	TokenNamefloat	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
(	TokenNameLPAREN	
min	TokenNameIdentifier	 min
+	TokenNamePLUS	
max	TokenNameIdentifier	 max
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
eval	TokenNameIdentifier	 eval
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
x	TokenNameIdentifier	 x
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
abs	TokenNameIdentifier	 abs
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
-	TokenNameMINUS	
interpolation	TokenNameIdentifier	 interpolation
)	TokenNameRPAREN	
<	TokenNameLESS	
tolerance	TokenNameIdentifier	 tolerance
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
x	TokenNameIdentifier	 x
<	TokenNameLESS	
interpolation	TokenNameIdentifier	 interpolation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
min	TokenNameIdentifier	 min
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
max	TokenNameIdentifier	 max
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
interpolation	TokenNameIdentifier	 interpolation
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
float	TokenNamefloat	
point	TokenNameIdentifier	 point
=	TokenNameEQUAL	
keyPoints	TokenNameIdentifier	 key Points
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
interpolation	TokenNameIdentifier	 interpolation
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
point	TokenNameIdentifier	 point
+=	TokenNamePLUS_EQUAL	
interpolation	TokenNameIdentifier	 interpolation
*	TokenNameMULTIPLY	
(	TokenNameLPAREN	
keyPoints	TokenNameIdentifier	 key Points
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
keyPoints	TokenNameIdentifier	 key Points
[	TokenNameLBRACKET	
keyTimeIndex	TokenNameIdentifier	 key Time Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
point	TokenNameIdentifier	 point
*=	TokenNameMULTIPLY_EQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
pointAtLength	TokenNameIdentifier	 point At Length
(	TokenNameLPAREN	
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
ang	TokenNameIdentifier	 ang
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAuto	TokenNameIdentifier	 rotate Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
angleAtLength	TokenNameIdentifier	 angle At Length
(	TokenNameLPAREN	
point	TokenNameIdentifier	 point
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
+=	TokenNamePLUS_EQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
rotateAngle	TokenNameIdentifier	 rotate Angle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ang	TokenNameIdentifier	 ang
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
pointAtLength	TokenNameIdentifier	 point At Length
(	TokenNameLPAREN	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
ang	TokenNameIdentifier	 ang
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAuto	TokenNameIdentifier	 rotate Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
angleAtLength	TokenNameIdentifier	 angle At Length
(	TokenNameLPAREN	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
+=	TokenNamePLUS_EQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
rotateAngle	TokenNameIdentifier	 rotate Angle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
new	TokenNamenew	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ang	TokenNameIdentifier	 ang
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cumulative	TokenNameIdentifier	 cumulative
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
pointAtLength	TokenNameIdentifier	 point At Length
(	TokenNameLPAREN	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
ang	TokenNameIdentifier	 ang
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAuto	TokenNameIdentifier	 rotate Auto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
angleAtLength	TokenNameIdentifier	 angle At Length
(	TokenNameLPAREN	
pathLength	TokenNameIdentifier	 path Length
.	TokenNameDOT	
lengthOfPath	TokenNameIdentifier	 length Of Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rotateAutoReverse	TokenNameIdentifier	 rotate Auto Reverse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
+=	TokenNamePLUS_EQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
PI	TokenNameIdentifier	 PI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ang	TokenNameIdentifier	 ang
=	TokenNameEQUAL	
rotateAngle	TokenNameIdentifier	 rotate Angle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
accumulation	TokenNameIdentifier	 accumulation
=	TokenNameEQUAL	
new	TokenNamenew	
AnimatableMotionPointValue	TokenNameIdentifier	 Animatable Motion Point Value
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ang	TokenNameIdentifier	 ang
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
accumulation	TokenNameIdentifier	 accumulation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
interpolate	TokenNameIdentifier	 interpolate
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
interpolation	TokenNameIdentifier	 interpolation
,	TokenNameCOMMA	
accumulation	TokenNameIdentifier	 accumulation
,	TokenNameCOMMA	
repeatIteration	TokenNameIdentifier	 repeat Iteration
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
hasChanged	TokenNameIdentifier	 has Changed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
markDirty	TokenNameIdentifier	 mark Dirty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
