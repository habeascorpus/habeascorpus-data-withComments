/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: DOMHelper.java 468655 2006-10-28 07:12:06Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: DOMHelper.java 468655 2006-10-28 07:12:06Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
XMLConstants	TokenNameIdentifier	 XML Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilder	TokenNameIdentifier	 Document Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
parsers	TokenNameIdentifier	 parsers
.	TokenNameDOT	
ParserConfigurationException	TokenNameIdentifier	 Parser Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XMLMessages	TokenNameIdentifier	 XML Messages
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMImplementation	TokenNameIdentifier	 DOM Implementation
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DocumentType	TokenNameIdentifier	 Document Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Entity	TokenNameIdentifier	 Entity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Text	TokenNameIdentifier	 Text
;	TokenNameSEMICOLON	
/** * @deprecated Since the introduction of the DTM, this class will be removed. * This class provides a front-end to DOM implementations, providing * a number of utility functions that either aren't yet standardized * by the DOM spec or that are defined in optional DOM modules and * hence may not be present in all DOMs. */	TokenNameCOMMENT_JAVADOC	 @deprecated Since the introduction of the DTM, this class will be removed. This class provides a front-end to DOM implementations, providing a number of utility functions that either aren't yet standardized by the DOM spec or that are defined in optional DOM modules and hence may not be present in all DOMs. 
public	TokenNamepublic	
class	TokenNameclass	
DOMHelper	TokenNameIdentifier	 DOM Helper
{	TokenNameLBRACE	
/** * DOM Level 1 did not have a standard mechanism for creating a new * Document object. This function provides a DOM-implementation-independent * abstraction for that for that concept. It's typically used when * outputting a new DOM as the result of an operation. * <p> * TODO: This isn't directly compatable with DOM Level 2. * The Level 2 createDocument call also creates the root * element, and thus requires that you know what that element will be * before creating the Document. We should think about whether we want * to change this code, and the callers, so we can use the DOM's own * method. (It's also possible that DOM Level 3 may relax this * sequence, but you may give up some intelligence in the DOM by * doing so; the intent was that knowing the document type and root * element might let the DOM automatically switch to a specialized * subclass for particular kinds of documents.) * * @param isSecureProcessing state of the secure processing feature. * @return The newly created DOM Document object, with no children, or * null if we can't find a DOM implementation that permits creating * new empty Documents. */	TokenNameCOMMENT_JAVADOC	 DOM Level 1 did not have a standard mechanism for creating a new Document object. This function provides a DOM-implementation-independent abstraction for that for that concept. It's typically used when outputting a new DOM as the result of an operation. <p> TODO: This isn't directly compatable with DOM Level 2. The Level 2 createDocument call also creates the root element, and thus requires that you know what that element will be before creating the Document. We should think about whether we want to change this code, and the callers, so we can use the DOM's own method. (It's also possible that DOM Level 3 may relax this sequence, but you may give up some intelligence in the DOM by doing so; the intent was that knowing the document type and root element might let the DOM automatically switch to a specialized subclass for particular kinds of documents.) * @param isSecureProcessing state of the secure processing feature. @return The newly created DOM Document object, with no children, or null if we can't find a DOM implementation that permits creating new empty Documents. 
public	TokenNamepublic	
static	TokenNamestatic	
Document	TokenNameIdentifier	 Document
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
boolean	TokenNameboolean	
isSecureProcessing	TokenNameIdentifier	 is Secure Processing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// Use an implementation of the JAVA API for XML Parsing 1.0 to 	TokenNameCOMMENT_LINE	Use an implementation of the JAVA API for XML Parsing 1.0 to 
// create a DOM Document node to contain the result. 	TokenNameCOMMENT_LINE	create a DOM Document node to contain the result. 
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
dfactory	TokenNameIdentifier	 dfactory
=	TokenNameEQUAL	
DocumentBuilderFactory	TokenNameIdentifier	 Document Builder Factory
.	TokenNameDOT	
newInstance	TokenNameIdentifier	 new Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dfactory	TokenNameIdentifier	 dfactory
.	TokenNameDOT	
setNamespaceAware	TokenNameIdentifier	 set Namespace Aware
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dfactory	TokenNameIdentifier	 dfactory
.	TokenNameDOT	
setValidating	TokenNameIdentifier	 set Validating
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSecureProcessing	TokenNameIdentifier	 is Secure Processing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
dfactory	TokenNameIdentifier	 dfactory
.	TokenNameDOT	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
XMLConstants	TokenNameIdentifier	 XML Constants
.	TokenNameDOT	
FEATURE_SECURE_PROCESSING	TokenNameIdentifier	 FEATURE  SECURE  PROCESSING
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParserConfigurationException	TokenNameIdentifier	 Parser Configuration Exception
pce	TokenNameIdentifier	 pce
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
DocumentBuilder	TokenNameIdentifier	 Document Builder
docBuilder	TokenNameIdentifier	 doc Builder
=	TokenNameEQUAL	
dfactory	TokenNameIdentifier	 dfactory
.	TokenNameDOT	
newDocumentBuilder	TokenNameIdentifier	 new Document Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
outNode	TokenNameIdentifier	 out Node
=	TokenNameEQUAL	
docBuilder	TokenNameIdentifier	 doc Builder
.	TokenNameDOT	
newDocument	TokenNameIdentifier	 new Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
outNode	TokenNameIdentifier	 out Node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ParserConfigurationException	TokenNameIdentifier	 Parser Configuration Exception
pce	TokenNameIdentifier	 pce
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_CREATEDOCUMENT_NOT_SUPPORTED	TokenNameIdentifier	 ER  CREATEDOCUMENT  NOT  SUPPORTED
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"createDocument() not supported in XPathContext!"); 	TokenNameCOMMENT_LINE	"createDocument() not supported in XPathContext!"); 
// return null; 	TokenNameCOMMENT_LINE	return null; 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * DOM Level 1 did not have a standard mechanism for creating a new * Document object. This function provides a DOM-implementation-independent * abstraction for that for that concept. It's typically used when * outputting a new DOM as the result of an operation. * * @return The newly created DOM Document object, with no children, or * null if we can't find a DOM implementation that permits creating * new empty Documents. */	TokenNameCOMMENT_JAVADOC	 DOM Level 1 did not have a standard mechanism for creating a new Document object. This function provides a DOM-implementation-independent abstraction for that for that concept. It's typically used when outputting a new DOM as the result of an operation. * @return The newly created DOM Document object, with no children, or null if we can't find a DOM implementation that permits creating new empty Documents. 
public	TokenNamepublic	
static	TokenNamestatic	
Document	TokenNameIdentifier	 Document
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tells, through the combination of the default-space attribute * on xsl:stylesheet, xsl:strip-space, xsl:preserve-space, and the * xml:space attribute, whether or not extra whitespace should be stripped * from the node. Literal elements from template elements should * <em>not</em> be tested with this function. * @param textNode A text node from the source tree. * @return true if the text node should be stripped of extra whitespace. * * @throws javax.xml.transform.TransformerException * @xsl.usage advanced */	TokenNameCOMMENT_JAVADOC	 Tells, through the combination of the default-space attribute on xsl:stylesheet, xsl:strip-space, xsl:preserve-space, and the xml:space attribute, whether or not extra whitespace should be stripped from the node. Literal elements from template elements should <em>not</em> be tested with this function. @param textNode A text node from the source tree. @return true if the text node should be stripped of extra whitespace. * @throws javax.xml.transform.TransformerException @xsl.usage advanced 
public	TokenNamepublic	
boolean	TokenNameboolean	
shouldStripSourceNode	TokenNameIdentifier	 should Strip Source Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
textNode	TokenNameIdentifier	 text Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
// return (null == m_envSupport) ? false : m_envSupport.shouldStripSourceNode(textNode); 	TokenNameCOMMENT_LINE	return (null == m_envSupport) ? false : m_envSupport.shouldStripSourceNode(textNode); 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Supports the XPath function GenerateID by returning a unique * identifier string for any given DOM Node. * <p> * Warning: The base implementation uses the Node object's hashCode(), * which is NOT guaranteed to be unique. If that method hasn't been * overridden in this DOM ipmlementation, most Java implementions will * derive it from the object's address and should be OK... but if * your DOM uses a different definition of hashCode (eg hashing the * contents of the subtree), or if your DOM may have multiple objects * that represent a single Node in the data structure (eg via proxying), * you may need to find another way to assign a unique identifier. * <p> * Also, be aware that if nodes are destroyed and recreated, there is * an open issue regarding whether an ID may be reused. Currently * we're assuming that the input document is stable for the duration * of the XPath/XSLT operation, so this shouldn't arise in this context. * <p> * (DOM Level 3 is investigating providing a unique node "key", but * that won't help Level 1 and Level 2 implementations.) * * @param node whose identifier you want to obtain * * @return a string which should be different for every Node object. */	TokenNameCOMMENT_JAVADOC	 Supports the XPath function GenerateID by returning a unique identifier string for any given DOM Node. <p> Warning: The base implementation uses the Node object's hashCode(), which is NOT guaranteed to be unique. If that method hasn't been overridden in this DOM ipmlementation, most Java implementions will derive it from the object's address and should be OK... but if your DOM uses a different definition of hashCode (eg hashing the contents of the subtree), or if your DOM may have multiple objects that represent a single Node in the data structure (eg via proxying), you may need to find another way to assign a unique identifier. <p> Also, be aware that if nodes are destroyed and recreated, there is an open issue regarding whether an ID may be reused. Currently we're assuming that the input document is stable for the duration of the XPath/XSLT operation, so this shouldn't arise in this context. <p> (DOM Level 3 is investigating providing a unique node "key", but that won't help Level 1 and Level 2 implementations.) * @param node whose identifier you want to obtain * @return a string which should be different for every Node object. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getUniqueID	TokenNameIdentifier	 get Unique ID
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"N"	TokenNameStringLiteral	N
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toHexString	TokenNameIdentifier	 to Hex String
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Figure out whether node2 should be considered as being later * in the document than node1, in Document Order as defined * by the XPath model. This may not agree with the ordering defined * by other XML applications. * <p> * There are some cases where ordering isn't defined, and neither are * the results of this function -- though we'll generally return true. * * TODO: Make sure this does the right thing with attribute nodes!!! * * @param node1 DOM Node to perform position comparison on. * @param node2 DOM Node to perform position comparison on . * * @return false if node2 comes before node1, otherwise return true. * You can think of this as * <code>(node1.documentOrderPosition &lt;= node2.documentOrderPosition)</code>. */	TokenNameCOMMENT_JAVADOC	 Figure out whether node2 should be considered as being later in the document than node1, in Document Order as defined by the XPath model. This may not agree with the ordering defined by other XML applications. <p> There are some cases where ordering isn't defined, and neither are the results of this function -- though we'll generally return true. * TODO: Make sure this does the right thing with attribute nodes!!! * @param node1 DOM Node to perform position comparison on. @param node2 DOM Node to perform position comparison on . * @return false if node2 comes before node1, otherwise return true. You can think of this as <code>(node1.documentOrderPosition &lt;= node2.documentOrderPosition)</code>. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isNodeAfter	TokenNameIdentifier	 is Node After
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
==	TokenNameEQUAL_EQUAL	
node2	TokenNameIdentifier	 node2
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Default return value, if there is no defined ordering 	TokenNameCOMMENT_LINE	Default return value, if there is no defined ordering 
boolean	TokenNameboolean	
isNodeAfter	TokenNameIdentifier	 is Node After
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
parent1	TokenNameIdentifier	 parent1
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
parent2	TokenNameIdentifier	 parent2
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Optimize for most common case 	TokenNameCOMMENT_LINE	Optimize for most common case 
if	TokenNameif	
(	TokenNameLPAREN	
parent1	TokenNameIdentifier	 parent1
==	TokenNameEQUAL_EQUAL	
parent2	TokenNameIdentifier	 parent2
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
parent1	TokenNameIdentifier	 parent1
,	TokenNameCOMMA	
parent2	TokenNameIdentifier	 parent2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// then we know they are siblings 	TokenNameCOMMENT_LINE	then we know they are siblings 
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
parent1	TokenNameIdentifier	 parent1
)	TokenNameRPAREN	
isNodeAfter	TokenNameIdentifier	 is Node After
=	TokenNameEQUAL	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
(	TokenNameLPAREN	
parent1	TokenNameIdentifier	 parent1
,	TokenNameCOMMA	
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
// If both parents are null, ordering is not defined. 	TokenNameCOMMENT_LINE	If both parents are null, ordering is not defined. 
// We're returning a value in lieu of throwing an exception. 	TokenNameCOMMENT_LINE	We're returning a value in lieu of throwing an exception. 
// Not a case we expect to arise in XPath, but beware if you 	TokenNameCOMMENT_LINE	Not a case we expect to arise in XPath, but beware if you 
// try to reuse this method. 	TokenNameCOMMENT_LINE	try to reuse this method. 
// We can just fall through in this case, which allows us 	TokenNameCOMMENT_LINE	We can just fall through in this case, which allows us 
// to hit the debugging code at the end of the function. 	TokenNameCOMMENT_LINE	to hit the debugging code at the end of the function. 
//return isNodeAfter; 	TokenNameCOMMENT_LINE	return isNodeAfter; 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// General strategy: Figure out the lengths of the two 	TokenNameCOMMENT_LINE	General strategy: Figure out the lengths of the two 
// ancestor chains, reconcile the lengths, and look for 	TokenNameCOMMENT_LINE	ancestor chains, reconcile the lengths, and look for 
// the lowest common ancestor. If that ancestor is one of 	TokenNameCOMMENT_LINE	the lowest common ancestor. If that ancestor is one of 
// the nodes being compared, it comes before the other. 	TokenNameCOMMENT_LINE	the nodes being compared, it comes before the other. 
// Otherwise perform a sibling compare. 	TokenNameCOMMENT_LINE	Otherwise perform a sibling compare. 
// 	TokenNameCOMMENT_LINE	 
// NOTE: If no common ancestor is found, ordering is undefined 	TokenNameCOMMENT_LINE	NOTE: If no common ancestor is found, ordering is undefined 
// and we return the default value of isNodeAfter. 	TokenNameCOMMENT_LINE	and we return the default value of isNodeAfter. 
// Count parents in each ancestor chain 	TokenNameCOMMENT_LINE	Count parents in each ancestor chain 
int	TokenNameint	
nParents1	TokenNameIdentifier	 n Parents1
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
nParents2	TokenNameIdentifier	 n Parents2
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// include node & parent obtained above 	TokenNameCOMMENT_LINE	include node & parent obtained above 
while	TokenNamewhile	
(	TokenNameLPAREN	
parent1	TokenNameIdentifier	 parent1
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nParents1	TokenNameIdentifier	 n Parents1
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
parent1	TokenNameIdentifier	 parent1
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
parent1	TokenNameIdentifier	 parent1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
parent2	TokenNameIdentifier	 parent2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nParents2	TokenNameIdentifier	 n Parents2
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
parent2	TokenNameIdentifier	 parent2
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
parent2	TokenNameIdentifier	 parent2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Initially assume scan for common ancestor starts with 	TokenNameCOMMENT_LINE	Initially assume scan for common ancestor starts with 
// the input nodes. 	TokenNameCOMMENT_LINE	the input nodes. 
Node	TokenNameIdentifier	 Node
startNode1	TokenNameIdentifier	 start Node1
=	TokenNameEQUAL	
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
startNode2	TokenNameIdentifier	 start Node2
=	TokenNameEQUAL	
node2	TokenNameIdentifier	 node2
;	TokenNameSEMICOLON	
// If one ancestor chain is longer, adjust its start point 	TokenNameCOMMENT_LINE	If one ancestor chain is longer, adjust its start point 
// so we're comparing at the same depths 	TokenNameCOMMENT_LINE	so we're comparing at the same depths 
if	TokenNameif	
(	TokenNameLPAREN	
nParents1	TokenNameIdentifier	 n Parents1
<	TokenNameLESS	
nParents2	TokenNameIdentifier	 n Parents2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Adjust startNode2 to depth of startNode1 	TokenNameCOMMENT_LINE	Adjust startNode2 to depth of startNode1 
int	TokenNameint	
adjust	TokenNameIdentifier	 adjust
=	TokenNameEQUAL	
nParents2	TokenNameIdentifier	 n Parents2
-	TokenNameMINUS	
nParents1	TokenNameIdentifier	 n Parents1
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
adjust	TokenNameIdentifier	 adjust
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startNode2	TokenNameIdentifier	 start Node2
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
startNode2	TokenNameIdentifier	 start Node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nParents1	TokenNameIdentifier	 n Parents1
>	TokenNameGREATER	
nParents2	TokenNameIdentifier	 n Parents2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// adjust startNode1 to depth of startNode2 	TokenNameCOMMENT_LINE	adjust startNode1 to depth of startNode2 
int	TokenNameint	
adjust	TokenNameIdentifier	 adjust
=	TokenNameEQUAL	
nParents1	TokenNameIdentifier	 n Parents1
-	TokenNameMINUS	
nParents2	TokenNameIdentifier	 n Parents2
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
adjust	TokenNameIdentifier	 adjust
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
startNode1	TokenNameIdentifier	 start Node1
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
startNode1	TokenNameIdentifier	 start Node1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Node	TokenNameIdentifier	 Node
prevChild1	TokenNameIdentifier	 prev Child1
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
prevChild2	TokenNameIdentifier	 prev Child2
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// so we can "back up" 	TokenNameCOMMENT_LINE	so we can "back up" 
// Loop up the ancestor chain looking for common parent 	TokenNameCOMMENT_LINE	Loop up the ancestor chain looking for common parent 
while	TokenNamewhile	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
startNode1	TokenNameIdentifier	 start Node1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
startNode1	TokenNameIdentifier	 start Node1
==	TokenNameEQUAL_EQUAL	
startNode2	TokenNameIdentifier	 start Node2
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
startNode1	TokenNameIdentifier	 start Node1
,	TokenNameCOMMA	
startNode2	TokenNameIdentifier	 start Node2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// common parent? 	TokenNameCOMMENT_LINE	common parent? 
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
prevChild1	TokenNameIdentifier	 prev Child1
)	TokenNameRPAREN	
// first time in loop? 	TokenNameCOMMENT_LINE	first time in loop? 
{	TokenNameLBRACE	
// Edge condition: one is the ancestor of the other. 	TokenNameCOMMENT_LINE	Edge condition: one is the ancestor of the other. 
isNodeAfter	TokenNameIdentifier	 is Node After
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nParents1	TokenNameIdentifier	 n Parents1
<	TokenNameLESS	
nParents2	TokenNameIdentifier	 n Parents2
)	TokenNameRPAREN	
?	TokenNameQUESTION	
true	TokenNametrue	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// from while loop 	TokenNameCOMMENT_LINE	from while loop 
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Compare ancestors below lowest-common as siblings 	TokenNameCOMMENT_LINE	Compare ancestors below lowest-common as siblings 
isNodeAfter	TokenNameIdentifier	 is Node After
=	TokenNameEQUAL	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
(	TokenNameLPAREN	
startNode1	TokenNameIdentifier	 start Node1
,	TokenNameCOMMA	
prevChild1	TokenNameIdentifier	 prev Child1
,	TokenNameCOMMA	
prevChild2	TokenNameIdentifier	 prev Child2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// from while loop 	TokenNameCOMMENT_LINE	from while loop 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end if(startNode1 == startNode2) 	TokenNameCOMMENT_LINE	end if(startNode1 == startNode2) 
// Move up one level and try again 	TokenNameCOMMENT_LINE	Move up one level and try again 
prevChild1	TokenNameIdentifier	 prev Child1
=	TokenNameEQUAL	
startNode1	TokenNameIdentifier	 start Node1
;	TokenNameSEMICOLON	
startNode1	TokenNameIdentifier	 start Node1
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
startNode1	TokenNameIdentifier	 start Node1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prevChild2	TokenNameIdentifier	 prev Child2
=	TokenNameEQUAL	
startNode2	TokenNameIdentifier	 start Node2
;	TokenNameSEMICOLON	
startNode2	TokenNameIdentifier	 start Node2
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
startNode2	TokenNameIdentifier	 start Node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end while(parents exist to examine) 	TokenNameCOMMENT_LINE	end while(parents exist to examine) 
}	TokenNameRBRACE	
// end big else (not immediate siblings) 	TokenNameCOMMENT_LINE	end big else (not immediate siblings) 
// WARNING: The following diagnostic won't report the early 	TokenNameCOMMENT_LINE	WARNING: The following diagnostic won't report the early 
// "same node" case. Fix if/when needed. 	TokenNameCOMMENT_LINE	"same node" case. Fix if/when needed. 
/* -- please do not remove... very useful for diagnostics -- System.out.println("node1 = "+node1.getNodeName()+"("+node1.getNodeType()+")"+ ", node2 = "+node2.getNodeName() +"("+node2.getNodeType()+")"+ ", isNodeAfter = "+isNodeAfter); */	TokenNameCOMMENT_BLOCK	 -- please do not remove... very useful for diagnostics -- System.out.println("node1 = "+node1.getNodeName()+"("+node1.getNodeType()+")"+ ", node2 = "+node2.getNodeName() +"("+node2.getNodeType()+")"+ ", isNodeAfter = "+isNodeAfter); 
return	TokenNamereturn	
isNodeAfter	TokenNameIdentifier	 is Node After
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end isNodeAfter(Node node1, Node node2) 	TokenNameCOMMENT_LINE	end isNodeAfter(Node node1, Node node2) 
/** * Use DTMNodeProxy to determine whether two nodes are the same. * * @param node1 The first DOM node to compare. * @param node2 The second DOM node to compare. * @return true if the two nodes are the same. */	TokenNameCOMMENT_JAVADOC	 Use DTMNodeProxy to determine whether two nodes are the same. * @param node1 The first DOM node to compare. @param node2 The second DOM node to compare. @return true if the two nodes are the same. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node1	TokenNameIdentifier	 node1
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
instanceof	TokenNameinstanceof	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
&&	TokenNameAND_AND	
node2	TokenNameIdentifier	 node2
instanceof	TokenNameinstanceof	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
)	TokenNameRPAREN	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
)	TokenNameRPAREN	
node1	TokenNameIdentifier	 node1
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTMNodeProxy	TokenNameIdentifier	 DTM Node Proxy
)	TokenNameRPAREN	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
node1	TokenNameIdentifier	 node1
==	TokenNameEQUAL_EQUAL	
node2	TokenNameIdentifier	 node2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Figure out if child2 is after child1 in document order. * <p> * Warning: Some aspects of "document order" are not well defined. * For example, the order of attributes is considered * meaningless in XML, and the order reported by our model will * be consistant for a given invocation but may not * match that of either the source file or the serialized output. * * @param parent Must be the parent of both child1 and child2. * @param child1 Must be the child of parent and not equal to child2. * @param child2 Must be the child of parent and not equal to child1. * @return true if child 2 is after child1 in document order. */	TokenNameCOMMENT_JAVADOC	 Figure out if child2 is after child1 in document order. <p> Warning: Some aspects of "document order" are not well defined. For example, the order of attributes is considered meaningless in XML, and the order reported by our model will be consistant for a given invocation but may not match that of either the source file or the serialized output. * @param parent Must be the parent of both child1 and child2. @param child1 Must be the child of parent and not equal to child2. @param child2 Must be the child of parent and not equal to child1. @return true if child 2 is after child1 in document order. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
child1	TokenNameIdentifier	 child1
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
child2	TokenNameIdentifier	 child2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
short	TokenNameshort	
child1type	TokenNameIdentifier	 child1type
=	TokenNameEQUAL	
child1	TokenNameIdentifier	 child1
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
child2type	TokenNameIdentifier	 child2type
=	TokenNameEQUAL	
child2	TokenNameIdentifier	 child2
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
!=	TokenNameNOT_EQUAL	
child1type	TokenNameIdentifier	 child1type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
child2type	TokenNameIdentifier	 child2type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// always sort attributes before non-attributes. 	TokenNameCOMMENT_LINE	always sort attributes before non-attributes. 
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
child1type	TokenNameIdentifier	 child1type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
!=	TokenNameNOT_EQUAL	
child2type	TokenNameIdentifier	 child2type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// always sort attributes before non-attributes. 	TokenNameCOMMENT_LINE	always sort attributes before non-attributes. 
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
child1type	TokenNameIdentifier	 child1type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
children	TokenNameIdentifier	 children
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nNodes	TokenNameIdentifier	 n Nodes
=	TokenNameEQUAL	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
found1	TokenNameIdentifier	 found1
=	TokenNameEQUAL	
false	TokenNamefalse	
,	TokenNameCOMMA	
found2	TokenNameIdentifier	 found2
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Count from the start until we find one or the other. 	TokenNameCOMMENT_LINE	Count from the start until we find one or the other. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nNodes	TokenNameIdentifier	 n Nodes
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
children	TokenNameIdentifier	 children
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child1	TokenNameIdentifier	 child1
==	TokenNameEQUAL_EQUAL	
child	TokenNameIdentifier	 child
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
child1	TokenNameIdentifier	 child1
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
found2	TokenNameIdentifier	 found2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
found1	TokenNameIdentifier	 found1
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
child2	TokenNameIdentifier	 child2
==	TokenNameEQUAL_EQUAL	
child	TokenNameIdentifier	 child
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
child2	TokenNameIdentifier	 child2
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
found1	TokenNameIdentifier	 found1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
found2	TokenNameIdentifier	 found2
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// TODO: Check performance of alternate solution: 	TokenNameCOMMENT_LINE	TODO: Check performance of alternate solution: 
// There are two choices here: Count from the start of 	TokenNameCOMMENT_LINE	There are two choices here: Count from the start of 
// the document until we find one or the other, or count 	TokenNameCOMMENT_LINE	the document until we find one or the other, or count 
// from one until we find or fail to find the other. 	TokenNameCOMMENT_LINE	from one until we find or fail to find the other. 
// Either can wind up scanning all the siblings in the worst 	TokenNameCOMMENT_LINE	Either can wind up scanning all the siblings in the worst 
// case, which on a wide document can be a lot of work but 	TokenNameCOMMENT_LINE	case, which on a wide document can be a lot of work but 
// is more typically is a short list. 	TokenNameCOMMENT_LINE	is more typically is a short list. 
// Scanning from the start involves two tests per iteration, 	TokenNameCOMMENT_LINE	Scanning from the start involves two tests per iteration, 
// but it isn't clear that scanning from the middle doesn't 	TokenNameCOMMENT_LINE	but it isn't clear that scanning from the middle doesn't 
// yield more iterations on average. 	TokenNameCOMMENT_LINE	yield more iterations on average. 
// We should run some testcases. 	TokenNameCOMMENT_LINE	We should run some testcases. 
Node	TokenNameIdentifier	 Node
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
found1	TokenNameIdentifier	 found1
=	TokenNameEQUAL	
false	TokenNamefalse	
,	TokenNameCOMMA	
found2	TokenNameIdentifier	 found2
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Node child = children.item(i); 	TokenNameCOMMENT_LINE	Node child = children.item(i); 
if	TokenNameif	
(	TokenNameLPAREN	
child1	TokenNameIdentifier	 child1
==	TokenNameEQUAL_EQUAL	
child	TokenNameIdentifier	 child
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
child1	TokenNameIdentifier	 child1
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
found2	TokenNameIdentifier	 found2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
found1	TokenNameIdentifier	 found1
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
child2	TokenNameIdentifier	 child2
==	TokenNameEQUAL_EQUAL	
child	TokenNameIdentifier	 child
||	TokenNameOR_OR	
isNodeTheSame	TokenNameIdentifier	 is Node The Same
(	TokenNameLPAREN	
child2	TokenNameIdentifier	 child2
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
found1	TokenNameIdentifier	 found1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
found2	TokenNameIdentifier	 found2
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
isNodeAfterSibling	TokenNameIdentifier	 is Node After Sibling
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end isNodeAfterSibling(Node parent, Node child1, Node child2) 	TokenNameCOMMENT_LINE	end isNodeAfterSibling(Node parent, Node child1, Node child2) 
//========================================================== 	TokenNameCOMMENT_LINE	========================================================== 
// SECTION: Namespace resolution 	TokenNameCOMMENT_LINE	SECTION: Namespace resolution 
//========================================================== 	TokenNameCOMMENT_LINE	========================================================== 
/** * Get the depth level of this node in the tree (equals 1 for * a parentless node). * * @param n Node to be examined. * @return the number of ancestors, plus one * @xsl.usage internal */	TokenNameCOMMENT_JAVADOC	 Get the depth level of this node in the tree (equals 1 for a parentless node). * @param n Node to be examined. @return the number of ancestors, plus one @xsl.usage internal 
public	TokenNamepublic	
short	TokenNameshort	
getLevel	TokenNameIdentifier	 get Level
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
level	TokenNameIdentifier	 level
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
level	TokenNameIdentifier	 level
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
level	TokenNameIdentifier	 level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given an XML Namespace prefix and a context in which the prefix * is to be evaluated, return the Namespace Name this prefix was * bound to. Note that DOM Level 3 is expected to provide a version of * this which deals with the DOM's "early binding" behavior. * * Default handling: * * @param prefix String containing namespace prefix to be resolved, * without the ':' which separates it from the localname when used * in a Node Name. The empty sting signifies the default namespace * at this point in the document. * @param namespaceContext Element which provides context for resolution. * (We could extend this to work for other nodes by first seeking their * nearest Element ancestor.) * * @return a String containing the Namespace URI which this prefix * represents in the specified context. */	TokenNameCOMMENT_JAVADOC	 Given an XML Namespace prefix and a context in which the prefix is to be evaluated, return the Namespace Name this prefix was bound to. Note that DOM Level 3 is expected to provide a version of this which deals with the DOM's "early binding" behavior. * Default handling: * @param prefix String containing namespace prefix to be resolved, without the ':' which separates it from the localname when used in a Node Name. The empty sting signifies the default namespace at this point in the document. @param namespaceContext Element which provides context for resolution. (We could extend this to work for other nodes by first seeking their nearest Element ancestor.) * @return a String containing the Namespace URI which this prefix represents in the specified context. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceForPrefix	TokenNameIdentifier	 get Namespace For Prefix
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
namespaceContext	TokenNameIdentifier	 namespace Context
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xml"	TokenNameStringLiteral	xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
QName	TokenNameIdentifier	 Q Name
.	TokenNameDOT	
S_XMLNAMESPACEURI	TokenNameIdentifier	 S  XMLNAMESPACEURI
;	TokenNameSEMICOLON	
// Hardcoded, per Namespace spec 	TokenNameCOMMENT_LINE	Hardcoded, per Namespace spec 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xmlns"	TokenNameStringLiteral	xmlns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Hardcoded in the DOM spec, expected to be adopted by 	TokenNameCOMMENT_LINE	Hardcoded in the DOM spec, expected to be adopted by 
// Namespace spec. NOTE: Namespace declarations _must_ use 	TokenNameCOMMENT_LINE	Namespace spec. NOTE: Namespace declarations _must_ use 
// the xmlns: prefix; other prefixes declared as belonging 	TokenNameCOMMENT_LINE	the xmlns: prefix; other prefixes declared as belonging 
// to this namespace will not be recognized and should 	TokenNameCOMMENT_LINE	to this namespace will not be recognized and should 
// probably be rejected by parsers as erroneous declarations. 	TokenNameCOMMENT_LINE	probably be rejected by parsers as erroneous declarations. 
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
"http://www.w3.org/2000/xmlns/"	TokenNameStringLiteral	http://www.w3.org/2000/xmlns/
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Attribute name for this prefix's declaration 	TokenNameCOMMENT_LINE	Attribute name for this prefix's declaration 
String	TokenNameIdentifier	 String
declname	TokenNameIdentifier	 declname
=	TokenNameEQUAL	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
==	TokenNameEQUAL_EQUAL	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"xmlns"	TokenNameStringLiteral	xmlns
:	TokenNameCOLON	
"xmlns:"	TokenNameStringLiteral	xmlns:
+	TokenNamePLUS	
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
// Scan until we run out of Elements or have resolved the namespace 	TokenNameCOMMENT_LINE	Scan until we run out of Elements or have resolved the namespace 
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Look for the appropriate Namespace Declaration attribute, 	TokenNameCOMMENT_LINE	Look for the appropriate Namespace Declaration attribute, 
// either "xmlns:prefix" or (if prefix is "") "xmlns". 	TokenNameCOMMENT_LINE	either "xmlns:prefix" or (if prefix is "") "xmlns". 
// TODO: This does not handle "implicit declarations" 	TokenNameCOMMENT_LINE	TODO: This does not handle "implicit declarations" 
// which may be created when the DOM is edited. DOM Level 	TokenNameCOMMENT_LINE	which may be created when the DOM is edited. DOM Level 
// 3 will define how those should be interpreted. But 	TokenNameCOMMENT_LINE	3 will define how those should be interpreted. But 
// this issue won't arise in freshly-parsed DOMs. 	TokenNameCOMMENT_LINE	this issue won't arise in freshly-parsed DOMs. 
// NOTE: declname is set earlier, outside the loop. 	TokenNameCOMMENT_LINE	NOTE: declname is set earlier, outside the loop. 
Attr	TokenNameIdentifier	 Attr
attr	TokenNameIdentifier	 attr
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
.	TokenNameDOT	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
declname	TokenNameIdentifier	 declname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
namespace	TokenNameIdentifier	 namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * An experiment for the moment. */	TokenNameCOMMENT_JAVADOC	 An experiment for the moment. 
Hashtable	TokenNameIdentifier	 Hashtable
m_NSInfos	TokenNameIdentifier	 m  NS Infos
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has not been * processed, but has xmlns namespace decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has not been processed, but has xmlns namespace decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoUnProcWithXMLNS	TokenNameIdentifier	 m  NS Info Un Proc With XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has not been * processed, but has no xmlns namespace decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has not been processed, but has no xmlns namespace decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoUnProcWithoutXMLNS	TokenNameIdentifier	 m  NS Info Un Proc Without XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has not been * processed, and has no xmlns namespace decls, and has no ancestor decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has not been processed, and has no xmlns namespace decls, and has no ancestor decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoUnProcNoAncestorXMLNS	TokenNameIdentifier	 m  NS Info Un Proc No Ancestor XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
NSInfo	TokenNameIdentifier	 NS Info
.	TokenNameDOT	
ANCESTORNOXMLNS	TokenNameIdentifier	 ANCESTORNOXMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has been * processed, and has xmlns namespace decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has been processed, and has xmlns namespace decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoNullWithXMLNS	TokenNameIdentifier	 m  NS Info Null With XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has been * processed, and has no xmlns namespace decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has been processed, and has no xmlns namespace decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoNullWithoutXMLNS	TokenNameIdentifier	 m  NS Info Null Without XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Object to put into the m_NSInfos table that tells that a node has been * processed, and has no xmlns namespace decls. and has no ancestor decls. */	TokenNameCOMMENT_JAVADOC	 Object to put into the m_NSInfos table that tells that a node has been processed, and has no xmlns namespace decls. and has no ancestor decls. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
NSInfo	TokenNameIdentifier	 NS Info
m_NSInfoNullNoAncestorXMLNS	TokenNameIdentifier	 m  NS Info Null No Ancestor XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
NSInfo	TokenNameIdentifier	 NS Info
.	TokenNameDOT	
ANCESTORNOXMLNS	TokenNameIdentifier	 ANCESTORNOXMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Vector of node (odd indexes) and NSInfos (even indexes) that tell if * the given node is a candidate for ancestor namespace processing. */	TokenNameCOMMENT_JAVADOC	 Vector of node (odd indexes) and NSInfos (even indexes) that tell if the given node is a candidate for ancestor namespace processing. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Returns the namespace of the given node. Differs from simply getting * the node's prefix and using getNamespaceForPrefix in that it attempts * to cache some of the data in NSINFO objects, to avoid repeated lookup. * TODO: Should we consider moving that logic into getNamespaceForPrefix? * * @param n Node to be examined. * * @return String containing the Namespace Name (uri) for this node. * Note that this is undefined for any nodes other than Elements and * Attributes. */	TokenNameCOMMENT_JAVADOC	 Returns the namespace of the given node. Differs from simply getting the node's prefix and using getNamespaceForPrefix in that it attempts to cache some of the data in NSINFO objects, to avoid repeated lookup. TODO: Should we consider moving that logic into getNamespaceForPrefix? * @param n Node to be examined. * @return String containing the Namespace Name (uri) for this node. Note that this is undefined for any nodes other than Elements and Attributes. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceOfNode	TokenNameIdentifier	 get Namespace Of Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasProcessedNS	TokenNameIdentifier	 has Processed NS
;	TokenNameSEMICOLON	
NSInfo	TokenNameIdentifier	 NS Info
nsInfo	TokenNameIdentifier	 ns Info
;	TokenNameSEMICOLON	
short	TokenNameshort	
ntype	TokenNameIdentifier	 ntype
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
!=	TokenNameNOT_EQUAL	
ntype	TokenNameIdentifier	 ntype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
nsObj	TokenNameIdentifier	 ns Obj
=	TokenNameEQUAL	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return value 	TokenNameCOMMENT_LINE	return value 
nsInfo	TokenNameIdentifier	 ns Info
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nsObj	TokenNameIdentifier	 ns Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
(	TokenNameLPAREN	
NSInfo	TokenNameIdentifier	 NS Info
)	TokenNameRPAREN	
nsObj	TokenNameIdentifier	 ns Obj
;	TokenNameSEMICOLON	
hasProcessedNS	TokenNameIdentifier	 has Processed NS
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nsInfo	TokenNameIdentifier	 ns Info
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
false	TokenNamefalse	
:	TokenNameCOLON	
nsInfo	TokenNameIdentifier	 ns Info
.	TokenNameDOT	
m_hasProcessedNS	TokenNameIdentifier	 m has Processed NS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
hasProcessedNS	TokenNameIdentifier	 has Processed NS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
nsInfo	TokenNameIdentifier	 ns Info
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
hasProcessedNS	TokenNameIdentifier	 has Processed NS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
=	TokenNameEQUAL	
nsInfo	TokenNameIdentifier	 ns Info
.	TokenNameDOT	
m_namespace	TokenNameIdentifier	 m namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nodeName	TokenNameIdentifier	 node Name
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
indexOfNSSep	TokenNameIdentifier	 index Of NS Sep
=	TokenNameEQUAL	
nodeName	TokenNameIdentifier	 node Name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
ntype	TokenNameIdentifier	 ntype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexOfNSSep	TokenNameIdentifier	 index Of NS Sep
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
nodeName	TokenNameIdentifier	 node Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
indexOfNSSep	TokenNameIdentifier	 index Of NS Sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Attributes don't use the default namespace, so if 	TokenNameCOMMENT_LINE	Attributes don't use the default namespace, so if 
// there isn't a prefix, we're done. 	TokenNameCOMMENT_LINE	there isn't a prefix, we're done. 
return	TokenNamereturn	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
(	TokenNameLPAREN	
indexOfNSSep	TokenNameIdentifier	 index Of NS Sep
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
nodeName	TokenNameIdentifier	 node Name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
indexOfNSSep	TokenNameIdentifier	 index Of NS Sep
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
ancestorsHaveXMLNS	TokenNameIdentifier	 ancestors Have XMLNS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
nHasXMLNS	TokenNameIdentifier	 n Has XMLNS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xml"	TokenNameStringLiteral	xml
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
=	TokenNameEQUAL	
QName	TokenNameIdentifier	 Q Name
.	TokenNameDOT	
S_XMLNAMESPACEURI	TokenNameIdentifier	 S  XMLNAMESPACEURI
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
parentType	TokenNameIdentifier	 parent Type
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
nsInfo	TokenNameIdentifier	 ns Info
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
nsInfo	TokenNameIdentifier	 ns Info
.	TokenNameDOT	
m_ancestorHasXMLNSAttrs	TokenNameIdentifier	 m ancestor Has XMLNS Attrs
==	TokenNameEQUAL_EQUAL	
NSInfo	TokenNameIdentifier	 NS Info
.	TokenNameDOT	
ANCESTORNOXMLNS	TokenNameIdentifier	 ANCESTORNOXMLNS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
parentType	TokenNameIdentifier	 parent Type
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
nsInfo	TokenNameIdentifier	 ns Info
)	TokenNameRPAREN	
||	TokenNameOR_OR	
nsInfo	TokenNameIdentifier	 ns Info
.	TokenNameDOT	
m_hasXMLNSAttrs	TokenNameIdentifier	 m has XMLNS Attrs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
elementHasXMLNS	TokenNameIdentifier	 element Has XMLNS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parentType	TokenNameIdentifier	 parent Type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
nnm	TokenNameIdentifier	 nnm
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nnm	TokenNameIdentifier	 nnm
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
attr	TokenNameIdentifier	 attr
=	TokenNameEQUAL	
nnm	TokenNameIdentifier	 nnm
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
aname	TokenNameIdentifier	 aname
=	TokenNameEQUAL	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aname	TokenNameIdentifier	 aname
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
'x'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isPrefix	TokenNameIdentifier	 is Prefix
=	TokenNameEQUAL	
aname	TokenNameIdentifier	 aname
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"xmlns:"	TokenNameStringLiteral	xmlns:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aname	TokenNameIdentifier	 aname
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xmlns"	TokenNameStringLiteral	xmlns
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isPrefix	TokenNameIdentifier	 is Prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
==	TokenNameEQUAL_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
nHasXMLNS	TokenNameIdentifier	 n Has XMLNS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
elementHasXMLNS	TokenNameIdentifier	 element Has XMLNS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
ancestorsHaveXMLNS	TokenNameIdentifier	 ancestors Have XMLNS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
isPrefix	TokenNameIdentifier	 is Prefix
?	TokenNameQUESTION	
aname	TokenNameIdentifier	 aname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
=	TokenNameEQUAL	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
!=	TokenNameNOT_EQUAL	
parentType	TokenNameIdentifier	 parent Type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
nsInfo	TokenNameIdentifier	 ns Info
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nsInfo	TokenNameIdentifier	 ns Info
=	TokenNameEQUAL	
elementHasXMLNS	TokenNameIdentifier	 element Has XMLNS
?	TokenNameQUESTION	
m_NSInfoUnProcWithXMLNS	TokenNameIdentifier	 m  NS Info Un Proc With XMLNS
:	TokenNameCOLON	
m_NSInfoUnProcWithoutXMLNS	TokenNameIdentifier	 m  NS Info Un Proc Without XMLNS
;	TokenNameSEMICOLON	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
nsInfo	TokenNameIdentifier	 ns Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
parentType	TokenNameIdentifier	 parent Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
nsInfo	TokenNameIdentifier	 ns Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
nsObj	TokenNameIdentifier	 ns Obj
=	TokenNameEQUAL	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return value 	TokenNameCOMMENT_LINE	return value 
nsInfo	TokenNameIdentifier	 ns Info
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nsObj	TokenNameIdentifier	 ns Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
(	TokenNameLPAREN	
NSInfo	TokenNameIdentifier	 NS Info
)	TokenNameRPAREN	
nsObj	TokenNameIdentifier	 ns Obj
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
nCandidates	TokenNameIdentifier	 n Candidates
=	TokenNameEQUAL	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nCandidates	TokenNameIdentifier	 n Candidates
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
false	TokenNamefalse	
==	TokenNameEQUAL_EQUAL	
ancestorsHaveXMLNS	TokenNameIdentifier	 ancestors Have XMLNS
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nCandidates	TokenNameIdentifier	 n Candidates
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
candidateInfo	TokenNameIdentifier	 candidate Info
=	TokenNameEQUAL	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
candidateInfo	TokenNameIdentifier	 candidate Info
==	TokenNameEQUAL_EQUAL	
m_NSInfoUnProcWithoutXMLNS	TokenNameIdentifier	 m  NS Info Un Proc Without XMLNS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
m_NSInfoUnProcNoAncestorXMLNS	TokenNameIdentifier	 m  NS Info Un Proc No Ancestor XMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
candidateInfo	TokenNameIdentifier	 candidate Info
==	TokenNameEQUAL_EQUAL	
m_NSInfoNullWithoutXMLNS	TokenNameIdentifier	 m  NS Info Null Without XMLNS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
m_NSInfoNullNoAncestorXMLNS	TokenNameIdentifier	 m  NS Info Null No Ancestor XMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
m_candidateNoAncestorXMLNS	TokenNameIdentifier	 m candidate No Ancestor XMLNS
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
!=	TokenNameNOT_EQUAL	
ntype	TokenNameIdentifier	 ntype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ancestorsHaveXMLNS	TokenNameIdentifier	 ancestors Have XMLNS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nHasXMLNS	TokenNameIdentifier	 n Has XMLNS
)	TokenNameRPAREN	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
m_NSInfoNullWithXMLNS	TokenNameIdentifier	 m  NS Info Null With XMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
m_NSInfoNullWithoutXMLNS	TokenNameIdentifier	 m  NS Info Null Without XMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
m_NSInfoNullNoAncestorXMLNS	TokenNameIdentifier	 m  NS Info Null No Ancestor XMLNS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
m_NSInfos	TokenNameIdentifier	 m  NS Infos
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
new	TokenNamenew	
NSInfo	TokenNameIdentifier	 NS Info
(	TokenNameLPAREN	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
,	TokenNameCOMMA	
nHasXMLNS	TokenNameIdentifier	 n Has XMLNS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
namespaceOfPrefix	TokenNameIdentifier	 namespace Of Prefix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the local name of the given node. If the node's name begins * with a namespace prefix, this is the part after the colon; otherwise * it's the full node name. * * @param n the node to be examined. * * @return String containing the Local Name */	TokenNameCOMMENT_JAVADOC	 Returns the local name of the given node. If the node's name begins with a namespace prefix, this is the part after the colon; otherwise it's the full node name. * @param n the node to be examined. * @return String containing the Local Name 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getLocalNameOfNode	TokenNameIdentifier	 get Local Name Of Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
qname	TokenNameIdentifier	 qname
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
qname	TokenNameIdentifier	 qname
:	TokenNameCOLON	
qname	TokenNameIdentifier	 qname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the element name with the namespace prefix (if any) replaced * by the Namespace URI it was bound to. This is not a standard * representation of a node name, but it allows convenient * single-string comparison of the "universal" names of two nodes. * * @param elem Element to be examined. * * @return String in the form "namespaceURI:localname" if the node * belongs to a namespace, or simply "localname" if it doesn't. * @see #getExpandedAttributeName */	TokenNameCOMMENT_JAVADOC	 Returns the element name with the namespace prefix (if any) replaced by the Namespace URI it was bound to. This is not a standard representation of a node name, but it allows convenient single-string comparison of the "universal" names of two nodes. * @param elem Element to be examined. * @return String in the form "namespaceURI:localname" if the node belongs to a namespace, or simply "localname" if it doesn't. @see #getExpandedAttributeName 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getExpandedElementName	TokenNameIdentifier	 get Expanded Element Name
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
getNamespaceOfNode	TokenNameIdentifier	 get Namespace Of Node
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
?	TokenNameQUESTION	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
getLocalNameOfNode	TokenNameIdentifier	 get Local Name Of Node
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
:	TokenNameCOLON	
getLocalNameOfNode	TokenNameIdentifier	 get Local Name Of Node
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the attribute name with the namespace prefix (if any) replaced * by the Namespace URI it was bound to. This is not a standard * representation of a node name, but it allows convenient * single-string comparison of the "universal" names of two nodes. * * @param attr Attr to be examined * * @return String in the form "namespaceURI:localname" if the node * belongs to a namespace, or simply "localname" if it doesn't. * @see #getExpandedElementName */	TokenNameCOMMENT_JAVADOC	 Returns the attribute name with the namespace prefix (if any) replaced by the Namespace URI it was bound to. This is not a standard representation of a node name, but it allows convenient single-string comparison of the "universal" names of two nodes. * @param attr Attr to be examined * @return String in the form "namespaceURI:localname" if the node belongs to a namespace, or simply "localname" if it doesn't. @see #getExpandedElementName 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getExpandedAttributeName	TokenNameIdentifier	 get Expanded Attribute Name
(	TokenNameLPAREN	
Attr	TokenNameIdentifier	 Attr
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
=	TokenNameEQUAL	
getNamespaceOfNode	TokenNameIdentifier	 get Namespace Of Node
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
?	TokenNameQUESTION	
namespace	TokenNameIdentifier	 namespace
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
getLocalNameOfNode	TokenNameIdentifier	 get Local Name Of Node
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
:	TokenNameCOLON	
getLocalNameOfNode	TokenNameIdentifier	 get Local Name Of Node
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//========================================================== 	TokenNameCOMMENT_LINE	========================================================== 
// SECTION: DOM Helper Functions 	TokenNameCOMMENT_LINE	SECTION: DOM Helper Functions 
//========================================================== 	TokenNameCOMMENT_LINE	========================================================== 
/** * Tell if the node is ignorable whitespace. Note that this can * be determined only in the context of a DTD or other Schema, * and that DOM Level 2 has nostandardized DOM API which can * return that information. * @deprecated * * @param node Node to be examined * * @return CURRENTLY HARDCODED TO FALSE, but should return true if * and only if the node is of type Text, contains only whitespace, * and does not appear as part of the #PCDATA content of an element. * (Note that determining this last may require allowing for * Entity References.) */	TokenNameCOMMENT_JAVADOC	 Tell if the node is ignorable whitespace. Note that this can be determined only in the context of a DTD or other Schema, and that DOM Level 2 has nostandardized DOM API which can return that information. @deprecated * @param node Node to be examined * @return CURRENTLY HARDCODED TO FALSE, but should return true if and only if the node is of type Text, contains only whitespace, and does not appear as part of the #PCDATA content of an element. (Note that determining this last may require allowing for Entity References.) 
public	TokenNamepublic	
boolean	TokenNameboolean	
isIgnorableWhitespace	TokenNameIdentifier	 is Ignorable Whitespace
(	TokenNameLPAREN	
Text	TokenNameIdentifier	 Text
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isIgnorable	TokenNameIdentifier	 is Ignorable
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// return value 	TokenNameCOMMENT_LINE	return value 
// TODO: I can probably do something to figure out if this 	TokenNameCOMMENT_LINE	TODO: I can probably do something to figure out if this 
// space is ignorable from just the information in 	TokenNameCOMMENT_LINE	space is ignorable from just the information in 
// the DOM tree. 	TokenNameCOMMENT_LINE	the DOM tree. 
// -- You need to be able to distinguish whitespace 	TokenNameCOMMENT_LINE	-- You need to be able to distinguish whitespace 
// that is #PCDATA from whitespace that isn't. That requires 	TokenNameCOMMENT_LINE	that is #PCDATA from whitespace that isn't. That requires 
// DTD support, which won't be standardized until DOM Level 3. 	TokenNameCOMMENT_LINE	DTD support, which won't be standardized until DOM Level 3. 
return	TokenNamereturn	
isIgnorable	TokenNameIdentifier	 is Ignorable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the first unparented node in the ancestor chain. * @deprecated * * @param node Starting node, to specify which chain to chase * * @return the topmost ancestor. */	TokenNameCOMMENT_JAVADOC	 Get the first unparented node in the ancestor chain. @deprecated * @param node Starting node, to specify which chain to chase * @return the topmost ancestor. 
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
root	TokenNameIdentifier	 root
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
root	TokenNameIdentifier	 root
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the root node of the document tree, regardless of * whether or not the node passed in is a document node. * <p> * TODO: This doesn't handle DocumentFragments or "orphaned" subtrees * -- it's currently returning ownerDocument even when the tree is * not actually part of the main Document tree. We should either * rewrite the description to say that it finds the Document node, * or change the code to walk up the ancestor chain. * * @param n Node to be examined * * @return the Document node. Note that this is not the correct answer * if n was (or was a child of) a DocumentFragment or an orphaned node, * as can arise if the DOM has been edited rather than being generated * by a parser. */	TokenNameCOMMENT_JAVADOC	 Get the root node of the document tree, regardless of whether or not the node passed in is a document node. <p> TODO: This doesn't handle DocumentFragments or "orphaned" subtrees -- it's currently returning ownerDocument even when the tree is not actually part of the main Document tree. We should either rewrite the description to say that it finds the Document node, or change the code to walk up the ancestor chain. * @param n Node to be examined * @return the Document node. Note that this is not the correct answer if n was (or was a child of) a DocumentFragment or an orphaned node, as can arise if the DOM has been edited rather than being generated by a parser. 
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
getRootNode	TokenNameIdentifier	 get Root Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nt	TokenNameIdentifier	 nt
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
==	TokenNameEQUAL_EQUAL	
nt	TokenNameIdentifier	 nt
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_FRAGMENT_NODE	TokenNameIdentifier	 DOCUMENT  FRAGMENT  NODE
==	TokenNameEQUAL_EQUAL	
nt	TokenNameIdentifier	 nt
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
n	TokenNameIdentifier	 n
:	TokenNameCOLON	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Test whether the given node is a namespace decl node. In DOM Level 2 * this can be done in a namespace-aware manner, but in Level 1 DOMs * it has to be done by testing the node name. * * @param n Node to be examined. * * @return boolean -- true iff the node is an Attr whose name is * "xmlns" or has the "xmlns:" prefix. */	TokenNameCOMMENT_JAVADOC	 Test whether the given node is a namespace decl node. In DOM Level 2 this can be done in a namespace-aware manner, but in Level 1 DOMs it has to be done by testing the node name. * @param n Node to be examined. * @return boolean -- true iff the node is an Attr whose name is "xmlns" or has the "xmlns:" prefix. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isNamespaceNode	TokenNameIdentifier	 is Namespace Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
attrName	TokenNameIdentifier	 attr Name
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
attrName	TokenNameIdentifier	 attr Name
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"xmlns:"	TokenNameStringLiteral	xmlns:
)	TokenNameRPAREN	
||	TokenNameOR_OR	
attrName	TokenNameIdentifier	 attr Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"xmlns"	TokenNameStringLiteral	xmlns
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Obtain the XPath-model parent of a DOM node -- ownerElement for Attrs, * parent for other nodes. * <p> * Background: The DOM believes that you must be your Parent's * Child, and thus Attrs don't have parents. XPath said that Attrs * do have their owning Element as their parent. This function * bridges the difference, either by using the DOM Level 2 ownerElement * function or by using a "silly and expensive function" in Level 1 * DOMs. * <p> * (There's some discussion of future DOMs generalizing ownerElement * into ownerNode and making it work on all types of nodes. This * still wouldn't help the users of Level 1 or Level 2 DOMs) * <p> * * @param node Node whose XPath parent we want to obtain * * @return the parent of the node, or the ownerElement if it's an * Attr node, or null if the node is an orphan. * * @throws RuntimeException if the Document has no root element. * This can't arise if the Document was created * via the DOM Level 2 factory methods, but is possible if other * mechanisms were used to obtain it */	TokenNameCOMMENT_JAVADOC	 Obtain the XPath-model parent of a DOM node -- ownerElement for Attrs, parent for other nodes. <p> Background: The DOM believes that you must be your Parent's Child, and thus Attrs don't have parents. XPath said that Attrs do have their owning Element as their parent. This function bridges the difference, either by using the DOM Level 2 ownerElement function or by using a "silly and expensive function" in Level 1 DOMs. <p> (There's some discussion of future DOMs generalizing ownerElement into ownerNode and making it work on all types of nodes. This still wouldn't help the users of Level 1 or Level 2 DOMs) <p> * @param node Node whose XPath parent we want to obtain * @return the parent of the node, or the ownerElement if it's an Attr node, or null if the node is an orphan. * @throws RuntimeException if the Document has no root element. This can't arise if the Document was created via the DOM Level 2 factory methods, but is possible if other mechanisms were used to obtain it 
public	TokenNamepublic	
static	TokenNamestatic	
Node	TokenNameIdentifier	 Node
getParentOfNode	TokenNameIdentifier	 get Parent Of Node
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
throws	TokenNamethrows	
RuntimeException	TokenNameIdentifier	 Runtime Exception
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
short	TokenNameshort	
nodeType	TokenNameIdentifier	 node Type
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
==	TokenNameEQUAL_EQUAL	
nodeType	TokenNameIdentifier	 node Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getOwnerDocument	TokenNameIdentifier	 get Owner Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* TBD: if(null == doc) { throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CHILD_HAS_NO_OWNER_DOCUMENT, null));//"Attribute child does not have an owner document!"); } */	TokenNameCOMMENT_BLOCK	 TBD: if(null == doc) { throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CHILD_HAS_NO_OWNER_DOCUMENT, null));//"Attribute child does not have an owner document!"); } 
// Given how expensive the tree walk may be, we should first ask 	TokenNameCOMMENT_LINE	Given how expensive the tree walk may be, we should first ask 
// whether this DOM can answer the question for us. The additional 	TokenNameCOMMENT_LINE	whether this DOM can answer the question for us. The additional 
// test does slow down Level 1 DOMs slightly. DOMHelper2, which 	TokenNameCOMMENT_LINE	test does slow down Level 1 DOMs slightly. DOMHelper2, which 
// is currently specialized for Xerces, assumes it can use the 	TokenNameCOMMENT_LINE	is currently specialized for Xerces, assumes it can use the 
// Level 2 solution. We might want to have an intermediate stage, 	TokenNameCOMMENT_LINE	Level 2 solution. We might want to have an intermediate stage, 
// which would assume DOM Level 2 but not assume Xerces. 	TokenNameCOMMENT_LINE	which would assume DOM Level 2 but not assume Xerces. 
// 	TokenNameCOMMENT_LINE	 
// (Shouldn't have to check whether impl is null in a compliant DOM, 	TokenNameCOMMENT_LINE	(Shouldn't have to check whether impl is null in a compliant DOM, 
// but let's be paranoid for a moment...) 	TokenNameCOMMENT_LINE	but let's be paranoid for a moment...) 
DOMImplementation	TokenNameIdentifier	 DOM Implementation
impl	TokenNameIdentifier	 impl
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getImplementation	TokenNameIdentifier	 get Implementation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
impl	TokenNameIdentifier	 impl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
hasFeature	TokenNameIdentifier	 has Feature
(	TokenNameLPAREN	
"Core"	TokenNameStringLiteral	Core
,	TokenNameCOMMA	
"2.0"	TokenNameStringLiteral	2.0
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Attr	TokenNameIdentifier	 Attr
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DOM Level 1 solution, as fallback. Hugely expensive. 	TokenNameCOMMENT_LINE	DOM Level 1 solution, as fallback. Hugely expensive. 
Element	TokenNameIdentifier	 Element
rootElem	TokenNameIdentifier	 root Elem
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getDocumentElement	TokenNameIdentifier	 get Document Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
rootElem	TokenNameIdentifier	 root Elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
XMLMessages	TokenNameIdentifier	 XML Messages
.	TokenNameDOT	
createXMLMessage	TokenNameIdentifier	 create XML Message
(	TokenNameLPAREN	
XMLErrorResources	TokenNameIdentifier	 XML Error Resources
.	TokenNameDOT	
ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT	TokenNameIdentifier	 ER  CHILD  HAS  NO  OWNER  DOCUMENT  ELEMENT
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Attribute child does not have an owner document element!"); 	TokenNameCOMMENT_LINE	"Attribute child does not have an owner document element!"); 
}	TokenNameRBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
locateAttrParent	TokenNameIdentifier	 locate Attr Parent
(	TokenNameLPAREN	
rootElem	TokenNameIdentifier	 root Elem
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if((Node.DOCUMENT_NODE != nodeType) && (null == parent)) 	TokenNameCOMMENT_LINE	if((Node.DOCUMENT_NODE != nodeType) && (null == parent)) 
// { 	TokenNameCOMMENT_LINE	{ 
// throw new RuntimeException("Child does not have parent!"); 	TokenNameCOMMENT_LINE	throw new RuntimeException("Child does not have parent!"); 
// } 	TokenNameCOMMENT_LINE	} 
}	TokenNameRBRACE	
return	TokenNamereturn	
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given an ID, return the element. This can work only if the document * is interpreted in the context of a DTD or Schema, since otherwise * we don't know which attributes are or aren't IDs. * <p> * Note that DOM Level 1 had no ability to retrieve this information. * DOM Level 2 introduced it but does not promise that it will be * supported in all DOMs; those which can't support it will always * return null. * <p> * TODO: getElementByID is currently unimplemented. Support DOM Level 2? * * @param id The unique identifier to be searched for. * @param doc The document to search within. * @return CURRENTLY HARDCODED TO NULL, but it should be: * The node which has this unique identifier, or null if there * is no such node or this DOM can't reliably recognize it. */	TokenNameCOMMENT_JAVADOC	 Given an ID, return the element. This can work only if the document is interpreted in the context of a DTD or Schema, since otherwise we don't know which attributes are or aren't IDs. <p> Note that DOM Level 1 had no ability to retrieve this information. DOM Level 2 introduced it but does not promise that it will be supported in all DOMs; those which can't support it will always return null. <p> TODO: getElementByID is currently unimplemented. Support DOM Level 2? * @param id The unique identifier to be searched for. @param doc The document to search within. @return CURRENTLY HARDCODED TO NULL, but it should be: The node which has this unique identifier, or null if there is no such node or this DOM can't reliably recognize it. 
public	TokenNamepublic	
Element	TokenNameIdentifier	 Element
getElementByID	TokenNameIdentifier	 get Element By ID
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The getUnparsedEntityURI function returns the URI of the unparsed * entity with the specified name in the same document as the context * node (see [3.3 Unparsed Entities]). It returns the empty string if * there is no such entity. * <p> * XML processors may choose to use the System Identifier (if one * is provided) to resolve the entity, rather than the URI in the * Public Identifier. The details are dependent on the processor, and * we would have to support some form of plug-in resolver to handle * this properly. Currently, we simply return the System Identifier if * present, and hope that it a usable URI or that our caller can * map it to one. * TODO: Resolve Public Identifiers... or consider changing function name. * <p> * If we find a relative URI * reference, XML expects it to be resolved in terms of the base URI * of the document. The DOM doesn't do that for us, and it isn't * entirely clear whether that should be done here; currently that's * pushed up to a higher levelof our application. (Note that DOM Level * 1 didn't store the document's base URI.) * TODO: Consider resolving Relative URIs. * <p> * (The DOM's statement that "An XML processor may choose to * completely expand entities before the structure model is passed * to the DOM" refers only to parsed entities, not unparsed, and hence * doesn't affect this function.) * * @param name A string containing the Entity Name of the unparsed * entity. * @param doc Document node for the document to be searched. * * @return String containing the URI of the Unparsed Entity, or an * empty string if no such entity exists. */	TokenNameCOMMENT_JAVADOC	 The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]). It returns the empty string if there is no such entity. <p> XML processors may choose to use the System Identifier (if one is provided) to resolve the entity, rather than the URI in the Public Identifier. The details are dependent on the processor, and we would have to support some form of plug-in resolver to handle this properly. Currently, we simply return the System Identifier if present, and hope that it a usable URI or that our caller can map it to one. TODO: Resolve Public Identifiers... or consider changing function name. <p> If we find a relative URI reference, XML expects it to be resolved in terms of the base URI of the document. The DOM doesn't do that for us, and it isn't entirely clear whether that should be done here; currently that's pushed up to a higher levelof our application. (Note that DOM Level 1 didn't store the document's base URI.) TODO: Consider resolving Relative URIs. <p> (The DOM's statement that "An XML processor may choose to completely expand entities before the structure model is passed to the DOM" refers only to parsed entities, not unparsed, and hence doesn't affect this function.) * @param name A string containing the Entity Name of the unparsed entity. @param doc Document node for the document to be searched. * @return String containing the URI of the Unparsed Entity, or an empty string if no such entity exists. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getUnparsedEntityURI	TokenNameIdentifier	 get Unparsed Entity URI
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
DocumentType	TokenNameIdentifier	 Document Type
doctype	TokenNameIdentifier	 doctype
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
getDoctype	TokenNameIdentifier	 get Doctype
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
doctype	TokenNameIdentifier	 doctype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
entities	TokenNameIdentifier	 entities
=	TokenNameEQUAL	
doctype	TokenNameIdentifier	 doctype
.	TokenNameDOT	
getEntities	TokenNameIdentifier	 get Entities
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
entities	TokenNameIdentifier	 entities
)	TokenNameRPAREN	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
Entity	TokenNameIdentifier	 Entity
entity	TokenNameIdentifier	 entity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Entity	TokenNameIdentifier	 Entity
)	TokenNameRPAREN	
entities	TokenNameIdentifier	 entities
.	TokenNameDOT	
getNamedItem	TokenNameIdentifier	 get Named Item
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
entity	TokenNameIdentifier	 entity
)	TokenNameRPAREN	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
notationName	TokenNameIdentifier	 notation Name
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getNotationName	TokenNameIdentifier	 get Notation Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
notationName	TokenNameIdentifier	 notation Name
)	TokenNameRPAREN	
// then it's unparsed 	TokenNameCOMMENT_LINE	then it's unparsed 
{	TokenNameLBRACE	
// The draft says: "The XSLT processor may use the public 	TokenNameCOMMENT_LINE	The draft says: "The XSLT processor may use the public 
// identifier to generate a URI for the entity instead of the URI 	TokenNameCOMMENT_LINE	identifier to generate a URI for the entity instead of the URI 
// specified in the system identifier. If the XSLT processor does 	TokenNameCOMMENT_LINE	specified in the system identifier. If the XSLT processor does 
// not use the public identifier to generate the URI, it must use 	TokenNameCOMMENT_LINE	not use the public identifier to generate the URI, it must use 
// the system identifier; if the system identifier is a relative 	TokenNameCOMMENT_LINE	the system identifier; if the system identifier is a relative 
// URI, it must be resolved into an absolute URI using the URI of 	TokenNameCOMMENT_LINE	URI, it must be resolved into an absolute URI using the URI of 
// the resource containing the entity declaration as the base 	TokenNameCOMMENT_LINE	the resource containing the entity declaration as the base 
// URI [RFC2396]." 	TokenNameCOMMENT_LINE	URI [RFC2396]." 
// So I'm falling a bit short here. 	TokenNameCOMMENT_LINE	So I'm falling a bit short here. 
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
url	TokenNameIdentifier	 url
)	TokenNameRPAREN	
{	TokenNameLBRACE	
url	TokenNameIdentifier	 url
=	TokenNameEQUAL	
entity	TokenNameIdentifier	 entity
.	TokenNameDOT	
getPublicId	TokenNameIdentifier	 get Public Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// This should be resolved to an absolute URL, but that's hard 	TokenNameCOMMENT_LINE	This should be resolved to an absolute URL, but that's hard 
// to do from here. 	TokenNameCOMMENT_LINE	to do from here. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
url	TokenNameIdentifier	 url
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Support for getParentOfNode; walks a DOM tree until it finds * the Element which owns the Attr. This is hugely expensive, and * if at all possible you should use the DOM Level 2 Attr.ownerElement() * method instead. * <p> * The DOM Level 1 developers expected that folks would keep track * of the last Element they'd seen and could recover the info from * that source. Obviously that doesn't work very well if the only * information you've been presented with is the Attr. The DOM Level 2 * getOwnerElement() method fixes that, but only for Level 2 and * later DOMs. * * @param elem Element whose subtree is to be searched for this Attr * @param attr Attr whose owner is to be located. * * @return the first Element whose attribute list includes the provided * attr. In modern DOMs, this will also be the only such Element. (Early * DOMs had some hope that Attrs might be sharable, but this idea has * been abandoned.) */	TokenNameCOMMENT_JAVADOC	 Support for getParentOfNode; walks a DOM tree until it finds the Element which owns the Attr. This is hugely expensive, and if at all possible you should use the DOM Level 2 Attr.ownerElement() method instead. <p> The DOM Level 1 developers expected that folks would keep track of the last Element they'd seen and could recover the info from that source. Obviously that doesn't work very well if the only information you've been presented with is the Attr. The DOM Level 2 getOwnerElement() method fixes that, but only for Level 2 and later DOMs. * @param elem Element whose subtree is to be searched for this Attr @param attr Attr whose owner is to be located. * @return the first Element whose attribute list includes the provided attr. In modern DOMs, this will also be the only such Element. (Early DOMs had some hope that Attrs might be sharable, but this idea has been abandoned.) 
private	TokenNameprivate	
static	TokenNamestatic	
Node	TokenNameIdentifier	 Node
locateAttrParent	TokenNameIdentifier	 locate Attr Parent
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elem	TokenNameIdentifier	 elem
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// This should only be called for Level 1 DOMs, so we don't have to 	TokenNameCOMMENT_LINE	This should only be called for Level 1 DOMs, so we don't have to 
// worry about namespace issues. In later levels, it's possible 	TokenNameCOMMENT_LINE	worry about namespace issues. In later levels, it's possible 
// for a DOM to have two Attrs with the same NodeName but 	TokenNameCOMMENT_LINE	for a DOM to have two Attrs with the same NodeName but 
// different namespaces, and we'd need to get getAttributeNodeNS... 	TokenNameCOMMENT_LINE	different namespaces, and we'd need to get getAttributeNodeNS... 
// but later levels also have Attr.getOwnerElement. 	TokenNameCOMMENT_LINE	but later levels also have Attr.getOwnerElement. 
Attr	TokenNameIdentifier	 Attr
check	TokenNameIdentifier	 check
=	TokenNameEQUAL	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttributeNode	TokenNameIdentifier	 get Attribute Node
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
check	TokenNameIdentifier	 check
==	TokenNameEQUAL_EQUAL	
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
elem	TokenNameIdentifier	 elem
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
==	TokenNameEQUAL_EQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
locateAttrParent	TokenNameIdentifier	 locate Attr Parent
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
parent	TokenNameIdentifier	 parent
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
parent	TokenNameIdentifier	 parent
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The factory object used for creating nodes * in the result tree. */	TokenNameCOMMENT_JAVADOC	 The factory object used for creating nodes in the result tree. 
protected	TokenNameprotected	
Document	TokenNameIdentifier	 Document
m_DOMFactory	TokenNameIdentifier	 m  DOM Factory
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Store the factory object required to create DOM nodes * in the result tree. In fact, that's just the result tree's * Document node... * * @param domFactory The DOM Document Node within whose context * the result tree will be built. */	TokenNameCOMMENT_JAVADOC	 Store the factory object required to create DOM nodes in the result tree. In fact, that's just the result tree's Document node... * @param domFactory The DOM Document Node within whose context the result tree will be built. 
public	TokenNamepublic	
void	TokenNamevoid	
setDOMFactory	TokenNameIdentifier	 set DOM Factory
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
domFactory	TokenNameIdentifier	 dom Factory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
m_DOMFactory	TokenNameIdentifier	 m  DOM Factory
=	TokenNameEQUAL	
domFactory	TokenNameIdentifier	 dom Factory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieve the factory object required to create DOM nodes * in the result tree. * * @return The result tree's DOM Document Node. */	TokenNameCOMMENT_JAVADOC	 Retrieve the factory object required to create DOM nodes in the result tree. * @return The result tree's DOM Document Node. 
public	TokenNamepublic	
Document	TokenNameIdentifier	 Document
getDOMFactory	TokenNameIdentifier	 get DOM Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
m_DOMFactory	TokenNameIdentifier	 m  DOM Factory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
m_DOMFactory	TokenNameIdentifier	 m  DOM Factory
=	TokenNameEQUAL	
createDocument	TokenNameIdentifier	 create Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
m_DOMFactory	TokenNameIdentifier	 m  DOM Factory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the textual contents of the node. See * getNodeData(Node,FastStringBuffer) for discussion of how * whitespace nodes are handled. * * @param node DOM Node to be examined * @return String containing a concatenation of all the * textual content within that node. * @see #getNodeData(Node,FastStringBuffer) * */	TokenNameCOMMENT_JAVADOC	 Get the textual contents of the node. See getNodeData(Node,FastStringBuffer) for discussion of how whitespace nodes are handled. * @param node DOM Node to be examined @return String containing a concatenation of all the textual content within that node. @see #getNodeData(Node,FastStringBuffer) 
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieve the text content of a DOM subtree, appending it into a * user-supplied FastStringBuffer object. Note that attributes are * not considered part of the content of an element. * <p> * There are open questions regarding whitespace stripping. * Currently we make no special effort in that regard, since the standard * DOM doesn't yet provide DTD-based information to distinguish * whitespace-in-element-context from genuine #PCDATA. Note that we * should probably also consider xml:space if/when we address this. * DOM Level 3 may solve the problem for us. * * @param node Node whose subtree is to be walked, gathering the * contents of all Text or CDATASection nodes. * @param buf FastStringBuffer into which the contents of the text * nodes are to be concatenated. */	TokenNameCOMMENT_JAVADOC	 Retrieve the text content of a DOM subtree, appending it into a user-supplied FastStringBuffer object. Note that attributes are not considered part of the content of an element. <p> There are open questions regarding whitespace stripping. Currently we make no special effort in that regard, since the standard DOM doesn't yet provide DTD-based information to distinguish whitespace-in-element-context from genuine #PCDATA. Note that we should probably also consider xml:space if/when we address this. DOM Level 3 may solve the problem for us. * @param node Node whose subtree is to be walked, gathering the contents of all Text or CDATASection nodes. @param buf FastStringBuffer into which the contents of the text nodes are to be concatenated. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_FRAGMENT_NODE	TokenNameIdentifier	 DOCUMENT  FRAGMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
getNodeData	TokenNameIdentifier	 get Node Data
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
buf	TokenNameIdentifier	 buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
:	TokenNameCOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
:	TokenNameCOLON	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
// warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 	TokenNameCOMMENT_LINE	warning(XPATHErrorResources.WG_PARSING_AND_PREPARING); 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
// ignore 	TokenNameCOMMENT_LINE	ignore 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
