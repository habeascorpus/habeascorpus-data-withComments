package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
NumberFormat	TokenNameIdentifier	 Number Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Collection	TokenNameIdentifier	 Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicLong	TokenNameIdentifier	 Atomic Long
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
Document	TokenNameIdentifier	 Document
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Similarity	TokenNameIdentifier	 Similarity
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
Directory	TokenNameIdentifier	 Directory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
store	TokenNameIdentifier	 store
.	TokenNameDOT	
RAMFile	TokenNameIdentifier	 RAM File
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
BitVector	TokenNameIdentifier	 Bit Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
;	TokenNameSEMICOLON	
/** * This class accepts multiple added documents and directly * writes a single segment file. It does this more * efficiently than creating a single segment per document * (with DocumentWriter) and doing standard merges on those * segments. * * Each added document is passed to the {@link DocConsumer}, * which in turn processes the document and interacts with * other consumers in the indexing chain. Certain * consumers, like {@link StoredFieldsWriter} and {@link * TermVectorsTermsWriter}, digest a document and * immediately write bytes to the "doc store" files (ie, * they do not consume RAM per document, except while they * are processing the document). * * Other consumers, eg {@link FreqProxTermsWriter} and * {@link NormsWriter}, buffer bytes in RAM and flush only * when a new segment is produced. * Once we have used our allowed RAM buffer, or the number * of added docs is large enough (in the case we are * flushing by doc count instead of RAM usage), we create a * real segment and flush it to the Directory. * * Threads: * * Multiple threads are allowed into addDocument at once. * There is an initial synchronized call to getThreadState * which allocates a ThreadState for this thread. The same * thread will get the same ThreadState over time (thread * affinity) so that if there are consistent patterns (for * example each thread is indexing a different content * source) then we make better use of RAM. Then * processDocument is called on that ThreadState without * synchronization (most of the "heavy lifting" is in this * call). Finally the synchronized "finishDocument" is * called to flush changes to the directory. * * When flush is called by IndexWriter we forcefully idle * all threads and flush only once they are all idle. This * means you can call flush with a given thread even while * other threads are actively adding/deleting documents. * * * Exceptions: * * Because this class directly updates in-memory posting * lists, and flushes stored fields and term vectors * directly to files in the directory, there are certain * limited times when an exception can corrupt this state. * For example, a disk full while flushing stored fields * leaves this file in a corrupt state. Or, an OOM * exception while appending to the in-memory posting lists * can corrupt that posting list. We call such exceptions * "aborting exceptions". In these cases we must call * abort() to discard all docs added since the last flush. * * All other exceptions ("non-aborting exceptions") can * still partially update the index structures. These * updates are consistent, but, they represent only a part * of the document seen up until the exception was hit. * When this happens, we immediately mark the document as * deleted so that the document is always atomically ("all * or none") added to the index. */	TokenNameCOMMENT_JAVADOC	 This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments. * Each added document is passed to the {@link DocConsumer}, which in turn processes the document and interacts with other consumers in the indexing chain. Certain consumers, like {@link StoredFieldsWriter} and {@link TermVectorsTermsWriter}, digest a document and immediately write bytes to the "doc store" files (ie, they do not consume RAM per document, except while they are processing the document). * Other consumers, eg {@link FreqProxTermsWriter} and {@link NormsWriter}, buffer bytes in RAM and flush only when a new segment is produced. Once we have used our allowed RAM buffer, or the number of added docs is large enough (in the case we are flushing by doc count instead of RAM usage), we create a real segment and flush it to the Directory. * Threads: * Multiple threads are allowed into addDocument at once. There is an initial synchronized call to getThreadState which allocates a ThreadState for this thread. The same thread will get the same ThreadState over time (thread affinity) so that if there are consistent patterns (for example each thread is indexing a different content source) then we make better use of RAM. Then processDocument is called on that ThreadState without synchronization (most of the "heavy lifting" is in this call). Finally the synchronized "finishDocument" is called to flush changes to the directory. * When flush is called by IndexWriter we forcefully idle all threads and flush only once they are all idle. This means you can call flush with a given thread even while other threads are actively adding/deleting documents. * Exceptions: * Because this class directly updates in-memory posting lists, and flushes stored fields and term vectors directly to files in the directory, there are certain limited times when an exception can corrupt this state. For example, a disk full while flushing stored fields leaves this file in a corrupt state. Or, an OOM exception while appending to the in-memory posting lists can corrupt that posting list. We call such exceptions "aborting exceptions". In these cases we must call abort() to discard all docs added since the last flush. * All other exceptions ("non-aborting exceptions") can still partially update the index structures. These updates are consistent, but, they represent only a part of the document seen up until the exception was hit. When this happens, we immediately mark the document as deleted so that the document is always atomically ("all or none") added to the index. 
final	TokenNamefinal	
class	TokenNameclass	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
{	TokenNameLBRACE	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
bytesUsed	TokenNameIdentifier	 bytes Used
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
;	TokenNameSEMICOLON	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
segment	TokenNameIdentifier	 segment
;	TokenNameSEMICOLON	
// Current segment we are working on 	TokenNameCOMMENT_LINE	Current segment we are working on 
private	TokenNameprivate	
int	TokenNameint	
nextDocID	TokenNameIdentifier	 next Doc ID
;	TokenNameSEMICOLON	
// Next docID to be added 	TokenNameCOMMENT_LINE	Next docID to be added 
private	TokenNameprivate	
int	TokenNameint	
numDocs	TokenNameIdentifier	 num Docs
;	TokenNameSEMICOLON	
// # of docs added, but not yet flushed 	TokenNameCOMMENT_LINE	# of docs added, but not yet flushed 
// Max # ThreadState instances; if there are more threads 	TokenNameCOMMENT_LINE	Max # ThreadState instances; if there are more threads 
// than this they share ThreadStates 	TokenNameCOMMENT_LINE	than this they share ThreadStates 
private	TokenNameprivate	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
threadStates	TokenNameIdentifier	 thread States
=	TokenNameEQUAL	
new	TokenNamenew	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Thread	TokenNameIdentifier	 Thread
,	TokenNameCOMMA	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
>	TokenNameGREATER	
threadBindings	TokenNameIdentifier	 thread Bindings
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Thread	TokenNameIdentifier	 Thread
,	TokenNameCOMMA	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
bufferIsFull	TokenNameIdentifier	 buffer Is Full
;	TokenNameSEMICOLON	
// True when it's time to write segment 	TokenNameCOMMENT_LINE	True when it's time to write segment 
private	TokenNameprivate	
boolean	TokenNameboolean	
aborting	TokenNameIdentifier	 aborting
;	TokenNameSEMICOLON	
// True if an abort is pending 	TokenNameCOMMENT_LINE	True if an abort is pending 
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
int	TokenNameint	
maxFieldLength	TokenNameIdentifier	 max Field Length
=	TokenNameEQUAL	
IndexWriter	TokenNameIdentifier	 Index Writer
.	TokenNameDOT	
DEFAULT_MAX_FIELD_LENGTH	TokenNameIdentifier	 DEFAULT  MAX  FIELD  LENGTH
;	TokenNameSEMICOLON	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
// max # simultaneous threads; if there are more than 	TokenNameCOMMENT_LINE	max # simultaneous threads; if there are more than 
// this, they wait for others to finish first 	TokenNameCOMMENT_LINE	this, they wait for others to finish first 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
maxThreadStates	TokenNameIdentifier	 max Thread States
;	TokenNameSEMICOLON	
// Deletes for our still-in-RAM (to be flushed next) segment 	TokenNameCOMMENT_LINE	Deletes for our still-in-RAM (to be flushed next) segment 
private	TokenNameprivate	
BufferedDeletes	TokenNameIdentifier	 Buffered Deletes
pendingDeletes	TokenNameIdentifier	 pending Deletes
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedDeletes	TokenNameIdentifier	 Buffered Deletes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
class	TokenNameclass	
DocState	TokenNameIdentifier	 Doc State
{	TokenNameLBRACE	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
docWriter	TokenNameIdentifier	 doc Writer
;	TokenNameSEMICOLON	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
int	TokenNameint	
maxFieldLength	TokenNameIdentifier	 max Field Length
;	TokenNameSEMICOLON	
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
maxTermPrefix	TokenNameIdentifier	 max Term Prefix
;	TokenNameSEMICOLON	
// Only called by asserts 	TokenNameCOMMENT_LINE	Only called by asserts 
public	TokenNamepublic	
boolean	TokenNameboolean	
testPoint	TokenNameIdentifier	 test Point
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
docWriter	TokenNameIdentifier	 doc Writer
.	TokenNameDOT	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
testPoint	TokenNameIdentifier	 test Point
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// don't hold onto doc nor analyzer, in case it is 	TokenNameCOMMENT_LINE	don't hold onto doc nor analyzer, in case it is 
// largish: 	TokenNameCOMMENT_LINE	largish: 
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Consumer returns this on each doc. This holds any * state that must be flushed synchronized "in docID * order". We gather these and flush them in order. */	TokenNameCOMMENT_JAVADOC	 Consumer returns this on each doc. This holds any state that must be flushed synchronized "in docID order". We gather these and flush them in order. 
abstract	TokenNameabstract	
static	TokenNamestatic	
class	TokenNameclass	
DocWriter	TokenNameIdentifier	 Doc Writer
{	TokenNameLBRACE	
DocWriter	TokenNameIdentifier	 Doc Writer
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
abstract	TokenNameabstract	
void	TokenNamevoid	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
abstract	TokenNameabstract	
void	TokenNamevoid	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
abstract	TokenNameabstract	
long	TokenNamelong	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
void	TokenNamevoid	
setNext	TokenNameIdentifier	 set Next
(	TokenNameLPAREN	
DocWriter	TokenNameIdentifier	 Doc Writer
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create and return a new DocWriterBuffer. */	TokenNameCOMMENT_JAVADOC	 Create and return a new DocWriterBuffer. 
PerDocBuffer	TokenNameIdentifier	 Per Doc Buffer
newPerDocBuffer	TokenNameIdentifier	 new Per Doc Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
PerDocBuffer	TokenNameIdentifier	 Per Doc Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * RAMFile buffer for DocWriters. */	TokenNameCOMMENT_JAVADOC	 RAMFile buffer for DocWriters. 
class	TokenNameclass	
PerDocBuffer	TokenNameIdentifier	 Per Doc Buffer
extends	TokenNameextends	
RAMFile	TokenNameIdentifier	 RAM File
{	TokenNameLBRACE	
/** * Allocate bytes used from shared pool. */	TokenNameCOMMENT_JAVADOC	 Allocate bytes used from shared pool. 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newBuffer	TokenNameIdentifier	 new Buffer
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
PER_DOC_BLOCK_SIZE	TokenNameIdentifier	 PER  DOC  BLOCK  SIZE
;	TokenNameSEMICOLON	
return	TokenNamereturn	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
getByteBlock	TokenNameIdentifier	 get Byte Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recycle the bytes used. */	TokenNameCOMMENT_JAVADOC	 Recycle the bytes used. 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
recycle	TokenNameIdentifier	 recycle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
buffers	TokenNameIdentifier	 buffers
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Recycle the blocks 	TokenNameCOMMENT_LINE	Recycle the blocks 
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
recycleByteBlocks	TokenNameIdentifier	 recycle Byte Blocks
(	TokenNameLPAREN	
buffers	TokenNameIdentifier	 buffers
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buffers	TokenNameIdentifier	 buffers
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sizeInBytes	TokenNameIdentifier	 size In Bytes
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
numBuffers	TokenNameIdentifier	 num Buffers
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * The IndexingChain must define the {@link #getChain(DocumentsWriter)} method * which returns the DocConsumer that the DocumentsWriter calls to process the * documents. */	TokenNameCOMMENT_JAVADOC	 The IndexingChain must define the {@link #getChain(DocumentsWriter)} method which returns the DocConsumer that the DocumentsWriter calls to process the documents. 
abstract	TokenNameabstract	
static	TokenNamestatic	
class	TokenNameclass	
IndexingChain	TokenNameIdentifier	 Indexing Chain
{	TokenNameLBRACE	
abstract	TokenNameabstract	
DocConsumer	TokenNameIdentifier	 Doc Consumer
getChain	TokenNameIdentifier	 get Chain
(	TokenNameLPAREN	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
documentsWriter	TokenNameIdentifier	 documents Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
IndexingChain	TokenNameIdentifier	 Indexing Chain
defaultIndexingChain	TokenNameIdentifier	 default Indexing Chain
=	TokenNameEQUAL	
new	TokenNamenew	
IndexingChain	TokenNameIdentifier	 Indexing Chain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
DocConsumer	TokenNameIdentifier	 Doc Consumer
getChain	TokenNameIdentifier	 get Chain
(	TokenNameLPAREN	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
documentsWriter	TokenNameIdentifier	 documents Writer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* This is the current indexing chain: DocConsumer / DocConsumerPerThread --> code: DocFieldProcessor / DocFieldProcessorPerThread --> DocFieldConsumer / DocFieldConsumerPerThread / DocFieldConsumerPerField --> code: DocFieldConsumers / DocFieldConsumersPerThread / DocFieldConsumersPerField --> code: DocInverter / DocInverterPerThread / DocInverterPerField --> InvertedDocConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField --> code: TermsHash / TermsHashPerThread / TermsHashPerField --> TermsHashConsumer / TermsHashConsumerPerThread / TermsHashConsumerPerField --> code: FreqProxTermsWriter / FreqProxTermsWriterPerThread / FreqProxTermsWriterPerField --> code: TermVectorsTermsWriter / TermVectorsTermsWriterPerThread / TermVectorsTermsWriterPerField --> InvertedDocEndConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField --> code: NormsWriter / NormsWriterPerThread / NormsWriterPerField --> code: StoredFieldsWriter / StoredFieldsWriterPerThread / StoredFieldsWriterPerField */	TokenNameCOMMENT_BLOCK	 This is the current indexing chain: DocConsumer / DocConsumerPerThread --> code: DocFieldProcessor / DocFieldProcessorPerThread --> DocFieldConsumer / DocFieldConsumerPerThread / DocFieldConsumerPerField --> code: DocFieldConsumers / DocFieldConsumersPerThread / DocFieldConsumersPerField --> code: DocInverter / DocInverterPerThread / DocInverterPerField --> InvertedDocConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField --> code: TermsHash / TermsHashPerThread / TermsHashPerField --> TermsHashConsumer / TermsHashConsumerPerThread / TermsHashConsumerPerField --> code: FreqProxTermsWriter / FreqProxTermsWriterPerThread / FreqProxTermsWriterPerField --> code: TermVectorsTermsWriter / TermVectorsTermsWriterPerThread / TermVectorsTermsWriterPerField --> InvertedDocEndConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField --> code: NormsWriter / NormsWriterPerThread / NormsWriterPerField --> code: StoredFieldsWriter / StoredFieldsWriterPerThread / StoredFieldsWriterPerField 
// Build up indexing chain: 	TokenNameCOMMENT_LINE	Build up indexing chain: 
final	TokenNamefinal	
TermsHashConsumer	TokenNameIdentifier	 Terms Hash Consumer
termVectorsWriter	TokenNameIdentifier	 term Vectors Writer
=	TokenNameEQUAL	
new	TokenNamenew	
TermVectorsTermsWriter	TokenNameIdentifier	 Term Vectors Terms Writer
(	TokenNameLPAREN	
documentsWriter	TokenNameIdentifier	 documents Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
TermsHashConsumer	TokenNameIdentifier	 Terms Hash Consumer
freqProxWriter	TokenNameIdentifier	 freq Prox Writer
=	TokenNameEQUAL	
new	TokenNamenew	
FreqProxTermsWriter	TokenNameIdentifier	 Freq Prox Terms Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
InvertedDocConsumer	TokenNameIdentifier	 Inverted Doc Consumer
termsHash	TokenNameIdentifier	 terms Hash
=	TokenNameEQUAL	
new	TokenNamenew	
TermsHash	TokenNameIdentifier	 Terms Hash
(	TokenNameLPAREN	
documentsWriter	TokenNameIdentifier	 documents Writer
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
freqProxWriter	TokenNameIdentifier	 freq Prox Writer
,	TokenNameCOMMA	
new	TokenNamenew	
TermsHash	TokenNameIdentifier	 Terms Hash
(	TokenNameLPAREN	
documentsWriter	TokenNameIdentifier	 documents Writer
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
termVectorsWriter	TokenNameIdentifier	 term Vectors Writer
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
NormsWriter	TokenNameIdentifier	 Norms Writer
normsWriter	TokenNameIdentifier	 norms Writer
=	TokenNameEQUAL	
new	TokenNamenew	
NormsWriter	TokenNameIdentifier	 Norms Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
DocInverter	TokenNameIdentifier	 Doc Inverter
docInverter	TokenNameIdentifier	 doc Inverter
=	TokenNameEQUAL	
new	TokenNamenew	
DocInverter	TokenNameIdentifier	 Doc Inverter
(	TokenNameLPAREN	
termsHash	TokenNameIdentifier	 terms Hash
,	TokenNameCOMMA	
normsWriter	TokenNameIdentifier	 norms Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
DocFieldProcessor	TokenNameIdentifier	 Doc Field Processor
(	TokenNameLPAREN	
documentsWriter	TokenNameIdentifier	 documents Writer
,	TokenNameCOMMA	
docInverter	TokenNameIdentifier	 doc Inverter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
DocConsumer	TokenNameIdentifier	 Doc Consumer
consumer	TokenNameIdentifier	 consumer
;	TokenNameSEMICOLON	
// How much RAM we can use before flushing. This is 0 if 	TokenNameCOMMENT_LINE	How much RAM we can use before flushing. This is 0 if 
// we are flushing by doc count instead. 	TokenNameCOMMENT_LINE	we are flushing by doc count instead. 
private	TokenNameprivate	
final	TokenNamefinal	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
config	TokenNameIdentifier	 config
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
closed	TokenNameIdentifier	 closed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BufferedDeletesStream	TokenNameIdentifier	 Buffered Deletes Stream
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
IndexWriter	TokenNameIdentifier	 Index Writer
.	TokenNameDOT	
FlushControl	TokenNameIdentifier	 Flush Control
flushControl	TokenNameIdentifier	 flush Control
;	TokenNameSEMICOLON	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
(	TokenNameLPAREN	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
config	TokenNameIdentifier	 config
,	TokenNameCOMMA	
Directory	TokenNameIdentifier	 Directory
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
FieldInfos	TokenNameIdentifier	 Field Infos
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
BufferedDeletesStream	TokenNameIdentifier	 Buffered Deletes Stream
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
similarity	TokenNameIdentifier	 similarity
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getSimilarity	TokenNameIdentifier	 get Similarity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxThreadStates	TokenNameIdentifier	 max Thread States
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getMaxThreadStates	TokenNameIdentifier	 get Max Thread States
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
fieldInfos	TokenNameIdentifier	 field Infos
=	TokenNameEQUAL	
fieldInfos	TokenNameIdentifier	 field Infos
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
=	TokenNameEQUAL	
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
;	TokenNameSEMICOLON	
flushControl	TokenNameIdentifier	 flush Control
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
flushControl	TokenNameIdentifier	 flush Control
;	TokenNameSEMICOLON	
consumer	TokenNameIdentifier	 consumer
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getIndexingChain	TokenNameIdentifier	 get Indexing Chain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getChain	TokenNameIdentifier	 get Chain
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
config	TokenNameIdentifier	 config
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Buffer a specific docID for deletion. Currently only 	TokenNameCOMMENT_LINE	Buffer a specific docID for deletion. Currently only 
// used when we hit a exception when adding a document 	TokenNameCOMMENT_LINE	used when we hit a exception when adding a document 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
deleteDocID	TokenNameIdentifier	 delete Doc ID
(	TokenNameLPAREN	
int	TokenNameint	
docIDUpto	TokenNameIdentifier	 doc ID Upto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addDocID	TokenNameIdentifier	 add Doc ID
(	TokenNameLPAREN	
docIDUpto	TokenNameIdentifier	 doc ID Upto
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// NOTE: we do not trigger flush here. This is 	TokenNameCOMMENT_LINE	NOTE: we do not trigger flush here. This is 
// potentially a RAM leak, if you have an app that tries 	TokenNameCOMMENT_LINE	potentially a RAM leak, if you have an app that tries 
// to add docs but every single doc always hits a 	TokenNameCOMMENT_LINE	to add docs but every single doc always hits a 
// non-aborting exception. Allowing a flush here gets 	TokenNameCOMMENT_LINE	non-aborting exception. Allowing a flush here gets 
// very messy because we are only invoked when handling 	TokenNameCOMMENT_LINE	very messy because we are only invoked when handling 
// exceptions so to do this properly, while handling an 	TokenNameCOMMENT_LINE	exceptions so to do this properly, while handling an 
// exception we'd have to go off and flush new deletes 	TokenNameCOMMENT_LINE	exception we'd have to go off and flush new deletes 
// which is risky (likely would hit some other 	TokenNameCOMMENT_LINE	which is risky (likely would hit some other 
// confounding exception). 	TokenNameCOMMENT_LINE	confounding exception). 
}	TokenNameRBRACE	
boolean	TokenNameboolean	
deleteQueries	TokenNameIdentifier	 delete Queries
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
...	TokenNameELLIPSIS	
queries	TokenNameIdentifier	 queries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
queries	TokenNameIdentifier	 queries
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
:	TokenNameCOLON	
queries	TokenNameIdentifier	 queries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addQuery	TokenNameIdentifier	 add Query
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
deleteQuery	TokenNameIdentifier	 delete Query
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addQuery	TokenNameIdentifier	 add Query
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
deleteTerms	TokenNameIdentifier	 delete Terms
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
...	TokenNameELLIPSIS	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
terms	TokenNameIdentifier	 terms
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
:	TokenNameCOLON	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO: we could check w/ FreqProxTermsWriter: if the 	TokenNameCOMMENT_LINE	TODO: we could check w/ FreqProxTermsWriter: if the 
// term doesn't exist, don't bother buffering into the 	TokenNameCOMMENT_LINE	term doesn't exist, don't bother buffering into the 
// per-DWPT map (but still must go into the global map) 	TokenNameCOMMENT_LINE	per-DWPT map (but still must go into the global map) 
boolean	TokenNameboolean	
deleteTerm	TokenNameIdentifier	 delete Term
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
boolean	TokenNameboolean	
skipWait	TokenNameIdentifier	 skip Wait
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
skipWait	TokenNameIdentifier	 skip Wait
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
FieldInfos	TokenNameIdentifier	 Field Infos
getFieldInfos	TokenNameIdentifier	 get Field Infos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fieldInfos	TokenNameIdentifier	 field Infos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** If non-null, various details of indexing are printed * here. */	TokenNameCOMMENT_JAVADOC	 If non-null, various details of indexing are printed here. 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setInfoStream	TokenNameIdentifier	 set Info Stream
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
infoStream	TokenNameIdentifier	 info Stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
infoStream	TokenNameIdentifier	 info Stream
=	TokenNameEQUAL	
infoStream	TokenNameIdentifier	 info Stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setMaxFieldLength	TokenNameIdentifier	 set Max Field Length
(	TokenNameLPAREN	
int	TokenNameint	
maxFieldLength	TokenNameIdentifier	 max Field Length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
maxFieldLength	TokenNameIdentifier	 max Field Length
=	TokenNameEQUAL	
maxFieldLength	TokenNameIdentifier	 max Field Length
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
maxFieldLength	TokenNameIdentifier	 max Field Length
=	TokenNameEQUAL	
maxFieldLength	TokenNameIdentifier	 max Field Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setSimilarity	TokenNameIdentifier	 set Similarity
(	TokenNameLPAREN	
Similarity	TokenNameIdentifier	 Similarity
similarity	TokenNameIdentifier	 similarity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
similarity	TokenNameIdentifier	 similarity
=	TokenNameEQUAL	
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
similarity	TokenNameIdentifier	 similarity
=	TokenNameEQUAL	
similarity	TokenNameIdentifier	 similarity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Get current segment name we are writing. */	TokenNameCOMMENT_JAVADOC	 Get current segment name we are writing. 
synchronized	TokenNamesynchronized	
String	TokenNameIdentifier	 String
getSegment	TokenNameIdentifier	 get Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
segment	TokenNameIdentifier	 segment
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns how many docs are currently buffered in RAM. */	TokenNameCOMMENT_JAVADOC	 Returns how many docs are currently buffered in RAM. 
synchronized	TokenNamesynchronized	
int	TokenNameint	
getNumDocs	TokenNameIdentifier	 get Num Docs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
numDocs	TokenNameIdentifier	 num Docs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"DW: "	TokenNameStringLiteral	DW: 
+	TokenNamePLUS	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
setAborting	TokenNameIdentifier	 set Aborting
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"setAborting"	TokenNameStringLiteral	setAborting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
aborting	TokenNameIdentifier	 aborting
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Called if we hit an exception at a bad time (when * updating the index files) and must discard all * currently buffered docs. This resets our state, * discarding any docs added since last flush. */	TokenNameCOMMENT_JAVADOC	 Called if we hit an exception at a bad time (when updating the index files) and must discard all currently buffered docs. This resets our state, discarding any docs added since last flush. 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"docWriter: abort"	TokenNameStringLiteral	docWriter: abort
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// Forcefully remove waiting ThreadStates from line 	TokenNameCOMMENT_LINE	Forcefully remove waiting ThreadStates from line 
try	TokenNametry	
{	TokenNameLBRACE	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// Wait for all other threads to finish with 	TokenNameCOMMENT_LINE	Wait for all other threads to finish with 
// DocumentsWriter: 	TokenNameCOMMENT_LINE	DocumentsWriter: 
try	TokenNametry	
{	TokenNameLBRACE	
waitIdle	TokenNameIdentifier	 wait Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"docWriter: abort waitIdle done"	TokenNameStringLiteral	docWriter: abort waitIdle done
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
numWaiting	TokenNameIdentifier	 num Waiting
:	TokenNameCOLON	
"waitQueue.numWaiting="	TokenNameStringLiteral	waitQueue.numWaiting=
+	TokenNamePLUS	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
numWaiting	TokenNameIdentifier	 num Waiting
;	TokenNameSEMICOLON	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
waitingBytes	TokenNameIdentifier	 waiting Bytes
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
threadState	TokenNameIdentifier	 thread State
:	TokenNameCOLON	
threadStates	TokenNameIdentifier	 thread States
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
threadState	TokenNameIdentifier	 thread State
.	TokenNameDOT	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// Reset all postings data 	TokenNameCOMMENT_LINE	Reset all postings data 
doAfterFlush	TokenNameIdentifier	 do After Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
aborting	TokenNameIdentifier	 aborting
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"docWriter: done abort; success="	TokenNameStringLiteral	docWriter: done abort; success=
+	TokenNamePLUS	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Reset after a flush */	TokenNameCOMMENT_JAVADOC	 Reset after a flush 
private	TokenNameprivate	
void	TokenNamevoid	
doAfterFlush	TokenNameIdentifier	 do After Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// All ThreadStates should be idle when we are called 	TokenNameCOMMENT_LINE	All ThreadStates should be idle when we are called 
assert	TokenNameassert	
allThreadsIdle	TokenNameIdentifier	 all Threads Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
threadBindings	TokenNameIdentifier	 thread Bindings
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segment	TokenNameIdentifier	 segment
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
numDocs	TokenNameIdentifier	 num Docs
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextDocID	TokenNameIdentifier	 next Doc ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferIsFull	TokenNameIdentifier	 buffer Is Full
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
doAfterFlush	TokenNameIdentifier	 do After Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
allThreadsIdle	TokenNameIdentifier	 all Threads Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
anyChanges	TokenNameIdentifier	 any Changes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
numDocs	TokenNameIdentifier	 num Docs
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// for testing 	TokenNameCOMMENT_LINE	for testing 
public	TokenNamepublic	
BufferedDeletes	TokenNameIdentifier	 Buffered Deletes
getPendingDeletes	TokenNameIdentifier	 get Pending Deletes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pendingDeletes	TokenNameIdentifier	 pending Deletes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
pushDeletes	TokenNameIdentifier	 push Deletes
(	TokenNameLPAREN	
SegmentInfo	TokenNameIdentifier	 Segment Info
newSegment	TokenNameIdentifier	 new Segment
,	TokenNameCOMMA	
SegmentInfos	TokenNameIdentifier	 Segment Infos
segmentInfos	TokenNameIdentifier	 segment Infos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Lock order: DW -> BD 	TokenNameCOMMENT_LINE	Lock order: DW -> BD 
final	TokenNamefinal	
long	TokenNamelong	
delGen	TokenNameIdentifier	 del Gen
=	TokenNameEQUAL	
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
.	TokenNameDOT	
getNextGen	TokenNameIdentifier	 get Next Gen
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
segmentInfos	TokenNameIdentifier	 segment Infos
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
newSegment	TokenNameIdentifier	 new Segment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
FrozenBufferedDeletes	TokenNameIdentifier	 Frozen Buffered Deletes
packet	TokenNameIdentifier	 packet
=	TokenNameEQUAL	
new	TokenNamenew	
FrozenBufferedDeletes	TokenNameIdentifier	 Frozen Buffered Deletes
(	TokenNameLPAREN	
pendingDeletes	TokenNameIdentifier	 pending Deletes
,	TokenNameCOMMA	
delGen	TokenNameIdentifier	 del Gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: push buffered deletes startSize="	TokenNameStringLiteral	flush: push buffered deletes startSize=
+	TokenNamePLUS	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" frozenSize="	TokenNameStringLiteral	 frozenSize=
+	TokenNamePLUS	
packet	TokenNameIdentifier	 packet
.	TokenNameDOT	
bytesUsed	TokenNameIdentifier	 bytes Used
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
packet	TokenNameIdentifier	 packet
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: delGen="	TokenNameStringLiteral	flush: delGen=
+	TokenNamePLUS	
packet	TokenNameIdentifier	 packet
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newSegment	TokenNameIdentifier	 new Segment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
setBufferedDeletesGen	TokenNameIdentifier	 set Buffered Deletes Gen
(	TokenNameLPAREN	
packet	TokenNameIdentifier	 packet
.	TokenNameDOT	
gen	TokenNameIdentifier	 gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: drop buffered deletes: no segments"	TokenNameStringLiteral	flush: drop buffered deletes: no segments
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We can safely discard these deletes: since 	TokenNameCOMMENT_LINE	We can safely discard these deletes: since 
// there are no segments, the deletions cannot 	TokenNameCOMMENT_LINE	there are no segments, the deletions cannot 
// affect anything. 	TokenNameCOMMENT_LINE	affect anything. 
}	TokenNameRBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
newSegment	TokenNameIdentifier	 new Segment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
setBufferedDeletesGen	TokenNameIdentifier	 set Buffered Deletes Gen
(	TokenNameLPAREN	
delGen	TokenNameIdentifier	 del Gen
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
anyDeletions	TokenNameIdentifier	 any Deletions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
any	TokenNameIdentifier	 any
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Flush all pending docs to a new segment */	TokenNameCOMMENT_JAVADOC	 Flush all pending docs to a new segment 
// Lock order: IW -> DW 	TokenNameCOMMENT_LINE	Lock order: IW -> DW 
synchronized	TokenNamesynchronized	
SegmentInfo	TokenNameIdentifier	 Segment Info
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
IndexWriter	TokenNameIdentifier	 Index Writer
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
IndexFileDeleter	TokenNameIdentifier	 Index File Deleter
deleter	TokenNameIdentifier	 deleter
,	TokenNameCOMMA	
MergePolicy	TokenNameIdentifier	 Merge Policy
mergePolicy	TokenNameIdentifier	 merge Policy
,	TokenNameCOMMA	
SegmentInfos	TokenNameIdentifier	 Segment Infos
segmentInfos	TokenNameIdentifier	 segment Infos
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We change writer's segmentInfos: 	TokenNameCOMMENT_LINE	We change writer's segmentInfos: 
assert	TokenNameassert	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
holdsLock	TokenNameIdentifier	 holds Lock
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
waitIdle	TokenNameIdentifier	 wait Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numDocs	TokenNameIdentifier	 num Docs
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// nothing to do! 	TokenNameCOMMENT_LINE	nothing to do! 
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: no docs; skipping"	TokenNameStringLiteral	flush: no docs; skipping
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Lock order: IW -> DW -> BD 	TokenNameCOMMENT_LINE	Lock order: IW -> DW -> BD 
pushDeletes	TokenNameIdentifier	 push Deletes
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
segmentInfos	TokenNameIdentifier	 segment Infos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: skip because aborting is set"	TokenNameStringLiteral	flush: skip because aborting is set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
SegmentInfo	TokenNameIdentifier	 Segment Info
newSegment	TokenNameIdentifier	 new Segment
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
//System.out.println(Thread.currentThread().getName() + ": nw=" + waitQueue.numWaiting); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": nw=" + waitQueue.numWaiting); 
assert	TokenNameassert	
nextDocID	TokenNameIdentifier	 next Doc ID
==	TokenNameEQUAL_EQUAL	
numDocs	TokenNameIdentifier	 num Docs
:	TokenNameCOLON	
"nextDocID="	TokenNameStringLiteral	nextDocID=
+	TokenNamePLUS	
nextDocID	TokenNameIdentifier	 next Doc ID
+	TokenNamePLUS	
" numDocs="	TokenNameStringLiteral	 numDocs=
+	TokenNamePLUS	
numDocs	TokenNameIdentifier	 num Docs
;	TokenNameSEMICOLON	
assert	TokenNameassert	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
numWaiting	TokenNameIdentifier	 num Waiting
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"numWaiting="	TokenNameStringLiteral	numWaiting=
+	TokenNamePLUS	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
numWaiting	TokenNameIdentifier	 num Waiting
;	TokenNameSEMICOLON	
assert	TokenNameassert	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
waitingBytes	TokenNameIdentifier	 waiting Bytes
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush postings as segment "	TokenNameStringLiteral	flush postings as segment 
+	TokenNamePLUS	
segment	TokenNameIdentifier	 segment
+	TokenNamePLUS	
" numDocs="	TokenNameStringLiteral	 numDocs=
+	TokenNamePLUS	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
SegmentWriteState	TokenNameIdentifier	 Segment Write State
flushState	TokenNameIdentifier	 flush State
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentWriteState	TokenNameIdentifier	 Segment Write State
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
fieldInfos	TokenNameIdentifier	 field Infos
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
getConfig	TokenNameIdentifier	 get Config
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTermIndexInterval	TokenNameIdentifier	 get Term Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pendingDeletes	TokenNameIdentifier	 pending Deletes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Apply delete-by-docID now (delete-byDocID only 	TokenNameCOMMENT_LINE	Apply delete-by-docID now (delete-byDocID only 
// happens when an exception is hit processing that 	TokenNameCOMMENT_LINE	happens when an exception is hit processing that 
// doc, eg if analyzer has some problem w/ the text): 	TokenNameCOMMENT_LINE	doc, eg if analyzer has some problem w/ the text): 
if	TokenNameif	
(	TokenNameLPAREN	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
docIDs	TokenNameIdentifier	 doc I Ds
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
=	TokenNameEQUAL	
new	TokenNamenew	
BitVector	TokenNameIdentifier	 Bit Vector
(	TokenNameLPAREN	
numDocs	TokenNameIdentifier	 num Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
delDocID	TokenNameIdentifier	 del Doc ID
:	TokenNameCOLON	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
docIDs	TokenNameIdentifier	 doc I Ds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
delDocID	TokenNameIdentifier	 del Doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
-	TokenNameMINUS	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
docIDs	TokenNameIdentifier	 doc I Ds
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
BufferedDeletes	TokenNameIdentifier	 Buffered Deletes
.	TokenNameDOT	
BYTES_PER_DEL_DOCID	TokenNameIdentifier	 BYTES  PER  DEL  DOCID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
docIDs	TokenNameIdentifier	 doc I Ds
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
newSegment	TokenNameIdentifier	 new Segment
=	TokenNameEQUAL	
new	TokenNamenew	
SegmentInfo	TokenNameIdentifier	 Segment Info
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
numDocs	TokenNameIdentifier	 num Docs
,	TokenNameCOMMA	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
fieldInfos	TokenNameIdentifier	 field Infos
.	TokenNameDOT	
hasProx	TokenNameIdentifier	 has Prox
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
DocConsumerPerThread	TokenNameIdentifier	 Doc Consumer Per Thread
>	TokenNameGREATER	
threads	TokenNameIdentifier	 threads
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
DocConsumerPerThread	TokenNameIdentifier	 Doc Consumer Per Thread
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
threadState	TokenNameIdentifier	 thread State
:	TokenNameCOLON	
threadStates	TokenNameIdentifier	 thread States
)	TokenNameRPAREN	
{	TokenNameLBRACE	
threads	TokenNameIdentifier	 threads
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
threadState	TokenNameIdentifier	 thread State
.	TokenNameDOT	
consumer	TokenNameIdentifier	 consumer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
double	TokenNamedouble	
startMBUsed	TokenNameIdentifier	 start MB Used
=	TokenNameEQUAL	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
threads	TokenNameIdentifier	 threads
,	TokenNameCOMMA	
flushState	TokenNameIdentifier	 flush State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
setHasVectors	TokenNameIdentifier	 set Has Vectors
(	TokenNameLPAREN	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
hasVectors	TokenNameIdentifier	 has Vectors
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"new segment has "	TokenNameStringLiteral	new segment has 
+	TokenNamePLUS	
(	TokenNameLPAREN	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
hasVectors	TokenNameIdentifier	 has Vectors
?	TokenNameQUESTION	
"vectors"	TokenNameStringLiteral	vectors
:	TokenNameCOLON	
"no vectors"	TokenNameStringLiteral	no vectors
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"new segment has "	TokenNameStringLiteral	new segment has 
+	TokenNamePLUS	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" deleted docs"	TokenNameStringLiteral	 deleted docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flushedFiles="	TokenNameStringLiteral	flushedFiles=
+	TokenNamePLUS	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mergePolicy	TokenNameIdentifier	 merge Policy
.	TokenNameDOT	
useCompoundFile	TokenNameIdentifier	 use Compound File
(	TokenNameLPAREN	
segmentInfos	TokenNameIdentifier	 segment Infos
,	TokenNameCOMMA	
newSegment	TokenNameIdentifier	 new Segment
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
cfsFileName	TokenNameIdentifier	 cfs File Name
=	TokenNameEQUAL	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
segmentFileName	TokenNameIdentifier	 segment File Name
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
IndexFileNames	TokenNameIdentifier	 Index File Names
.	TokenNameDOT	
COMPOUND_FILE_EXTENSION	TokenNameIdentifier	 COMPOUND  FILE  EXTENSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: create compound file ""	TokenNameStringLiteral	flush: create compound file "
+	TokenNamePLUS	
cfsFileName	TokenNameIdentifier	 cfs File Name
+	TokenNamePLUS	
"""	TokenNameStringLiteral	"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CompoundFileWriter	TokenNameIdentifier	 Compound File Writer
cfsWriter	TokenNameIdentifier	 cfs Writer
=	TokenNameEQUAL	
new	TokenNamenew	
CompoundFileWriter	TokenNameIdentifier	 Compound File Writer
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
cfsFileName	TokenNameIdentifier	 cfs File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
fileName	TokenNameIdentifier	 file Name
:	TokenNameCOLON	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfsWriter	TokenNameIdentifier	 cfs Writer
.	TokenNameDOT	
addFile	TokenNameIdentifier	 add File
(	TokenNameLPAREN	
fileName	TokenNameIdentifier	 file Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cfsWriter	TokenNameIdentifier	 cfs Writer
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
deleter	TokenNameIdentifier	 deleter
.	TokenNameDOT	
deleteNewFiles	TokenNameIdentifier	 delete New Files
(	TokenNameLPAREN	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
files	TokenNameIdentifier	 files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
setUseCompoundFile	TokenNameIdentifier	 set Use Compound File
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Must write deleted docs after the CFS so we don't 	TokenNameCOMMENT_LINE	Must write deleted docs after the CFS so we don't 
// slurp the del file into CFS: 	TokenNameCOMMENT_LINE	slurp the del file into CFS: 
if	TokenNameif	
(	TokenNameLPAREN	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
delCount	TokenNameIdentifier	 del Count
=	TokenNameEQUAL	
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
delCount	TokenNameIdentifier	 del Count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
setDelCount	TokenNameIdentifier	 set Del Count
(	TokenNameLPAREN	
delCount	TokenNameIdentifier	 del Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
advanceDelGen	TokenNameIdentifier	 advance Del Gen
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
delFileName	TokenNameIdentifier	 del File Name
=	TokenNameEQUAL	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
getDelFileName	TokenNameIdentifier	 get Del File Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: write "	TokenNameStringLiteral	flush: write 
+	TokenNamePLUS	
delCount	TokenNameIdentifier	 del Count
+	TokenNamePLUS	
" deletes to "	TokenNameStringLiteral	 deletes to 
+	TokenNamePLUS	
delFileName	TokenNameIdentifier	 del File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// TODO: in the NRT case it'd be better to hand 	TokenNameCOMMENT_LINE	TODO: in the NRT case it'd be better to hand 
// this del vector over to the 	TokenNameCOMMENT_LINE	this del vector over to the 
// shortly-to-be-opened SegmentReader and let it 	TokenNameCOMMENT_LINE	shortly-to-be-opened SegmentReader and let it 
// carry the changes; there's no reason to use 	TokenNameCOMMENT_LINE	carry the changes; there's no reason to use 
// filesystem as intermediary here. 	TokenNameCOMMENT_LINE	filesystem as intermediary here. 
flushState	TokenNameIdentifier	 flush State
.	TokenNameDOT	
deletedDocs	TokenNameIdentifier	 deleted Docs
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
delFileName	TokenNameIdentifier	 del File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success2	TokenNameIdentifier	 success2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
deleteFile	TokenNameIdentifier	 delete File
(	TokenNameLPAREN	
delFileName	TokenNameIdentifier	 del File Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// suppress this so we keep throwing the 	TokenNameCOMMENT_LINE	suppress this so we keep throwing the 
// original exception 	TokenNameCOMMENT_LINE	original exception 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush: segment="	TokenNameStringLiteral	flush: segment=
+	TokenNamePLUS	
newSegment	TokenNameIdentifier	 new Segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
double	TokenNamedouble	
newSegmentSizeNoStore	TokenNameIdentifier	 new Segment Size No Store
=	TokenNameEQUAL	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
double	TokenNamedouble	
newSegmentSize	TokenNameIdentifier	 new Segment Size
=	TokenNameEQUAL	
newSegment	TokenNameIdentifier	 new Segment
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
" ramUsed="	TokenNameStringLiteral	 ramUsed=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
startMBUsed	TokenNameIdentifier	 start MB Used
)	TokenNameRPAREN	
+	TokenNamePLUS	
" MB"	TokenNameStringLiteral	 MB
+	TokenNamePLUS	
" newFlushedSize="	TokenNameStringLiteral	 newFlushedSize=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
newSegmentSize	TokenNameIdentifier	 new Segment Size
)	TokenNameRPAREN	
+	TokenNamePLUS	
" MB"	TokenNameStringLiteral	 MB
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
newSegmentSizeNoStore	TokenNameIdentifier	 new Segment Size No Store
)	TokenNameRPAREN	
+	TokenNamePLUS	
" MB w/o doc stores)"	TokenNameStringLiteral	 MB w/o doc stores)
+	TokenNamePLUS	
" docs/MB="	TokenNameStringLiteral	 docs/MB=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
numDocs	TokenNameIdentifier	 num Docs
/	TokenNameDIVIDE	
newSegmentSize	TokenNameIdentifier	 new Segment Size
)	TokenNameRPAREN	
+	TokenNamePLUS	
" new/old="	TokenNameStringLiteral	 new/old=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
100.0	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
newSegmentSizeNoStore	TokenNameIdentifier	 new Segment Size No Store
/	TokenNameDIVIDE	
startMBUsed	TokenNameIdentifier	 start MB Used
)	TokenNameRPAREN	
+	TokenNamePLUS	
"%"	TokenNameStringLiteral	%
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deleter	TokenNameIdentifier	 deleter
.	TokenNameDOT	
refresh	TokenNameIdentifier	 refresh
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
doAfterFlush	TokenNameIdentifier	 do After Flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Lock order: IW -> DW -> BD 	TokenNameCOMMENT_LINE	Lock order: IW -> DW -> BD 
pushDeletes	TokenNameIdentifier	 push Deletes
(	TokenNameLPAREN	
newSegment	TokenNameIdentifier	 new Segment
,	TokenNameCOMMA	
segmentInfos	TokenNameIdentifier	 segment Infos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"flush time "	TokenNameStringLiteral	flush time 
+	TokenNamePLUS	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
+	TokenNamePLUS	
" msec"	TokenNameStringLiteral	 msec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
newSegment	TokenNameIdentifier	 new Segment
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
closed	TokenNameIdentifier	 closed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns a free (idle) ThreadState that may be used for * indexing this one document. This call also pauses if a * flush is pending. If delTerm is non-null then we * buffer this deleted term after the thread state has * been acquired. */	TokenNameCOMMENT_JAVADOC	 Returns a free (idle) ThreadState that may be used for indexing this one document. This call also pauses if a flush is pending. If delTerm is non-null then we buffer this deleted term after the thread state has been acquired. 
synchronized	TokenNamesynchronized	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
getThreadState	TokenNameIdentifier	 get Thread State
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
delTerm	TokenNameIdentifier	 del Term
,	TokenNameCOMMA	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
Thread	TokenNameIdentifier	 Thread
currentThread	TokenNameIdentifier	 current Thread
=	TokenNameEQUAL	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
currentThread	TokenNameIdentifier	 current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
!	TokenNameNOT	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
holdsLock	TokenNameIdentifier	 holds Lock
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// First, find a thread state. If this thread already 	TokenNameCOMMENT_LINE	First, find a thread state. If this thread already 
// has affinity to a specific ThreadState, use that one 	TokenNameCOMMENT_LINE	has affinity to a specific ThreadState, use that one 
// again. 	TokenNameCOMMENT_LINE	again. 
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
threadBindings	TokenNameIdentifier	 thread Bindings
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
currentThread	TokenNameIdentifier	 current Thread
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// First time this thread has called us since last 	TokenNameCOMMENT_LINE	First time this thread has called us since last 
// flush. Find the least loaded thread state: 	TokenNameCOMMENT_LINE	flush. Find the least loaded thread state: 
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
minThreadState	TokenNameIdentifier	 min Thread State
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
ts	TokenNameIdentifier	 ts
=	TokenNameEQUAL	
threadStates	TokenNameIdentifier	 thread States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
minThreadState	TokenNameIdentifier	 min Thread State
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
ts	TokenNameIdentifier	 ts
.	TokenNameDOT	
numThreads	TokenNameIdentifier	 num Threads
<	TokenNameLESS	
minThreadState	TokenNameIdentifier	 min Thread State
.	TokenNameDOT	
numThreads	TokenNameIdentifier	 num Threads
)	TokenNameRPAREN	
{	TokenNameLBRACE	
minThreadState	TokenNameIdentifier	 min Thread State
=	TokenNameEQUAL	
ts	TokenNameIdentifier	 ts
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
minThreadState	TokenNameIdentifier	 min Thread State
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
minThreadState	TokenNameIdentifier	 min Thread State
.	TokenNameDOT	
numThreads	TokenNameIdentifier	 num Threads
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>=	TokenNameGREATER_EQUAL	
maxThreadStates	TokenNameIdentifier	 max Thread States
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
minThreadState	TokenNameIdentifier	 min Thread State
;	TokenNameSEMICOLON	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
numThreads	TokenNameIdentifier	 num Threads
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Just create a new "private" thread state 	TokenNameCOMMENT_LINE	Just create a new "private" thread state 
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArray	TokenNameIdentifier	 new Array
=	TokenNameEQUAL	
new	TokenNamenew	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
threadStates	TokenNameIdentifier	 thread States
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
[	TokenNameLBRACKET	
threadStates	TokenNameIdentifier	 thread States
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
threadStates	TokenNameIdentifier	 thread States
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
threadBindings	TokenNameIdentifier	 thread Bindings
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
currentThread	TokenNameIdentifier	 current Thread
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Next, wait until my thread state is idle (in case 	TokenNameCOMMENT_LINE	Next, wait until my thread state is idle (in case 
// it's shared with other threads), and no flush/abort 	TokenNameCOMMENT_LINE	it's shared with other threads), and no flush/abort 
// pending 	TokenNameCOMMENT_LINE	pending 
waitReady	TokenNameIdentifier	 wait Ready
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Allocate segment name if this is the first doc since 	TokenNameCOMMENT_LINE	Allocate segment name if this is the first doc since 
// last flush: 	TokenNameCOMMENT_LINE	last flush: 
if	TokenNameif	
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segment	TokenNameIdentifier	 segment
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
newSegmentName	TokenNameIdentifier	 new Segment Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
numDocs	TokenNameIdentifier	 num Docs
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
nextDocID	TokenNameIdentifier	 next Doc ID
;	TokenNameSEMICOLON	
nextDocID	TokenNameIdentifier	 next Doc ID
+=	TokenNamePLUS_EQUAL	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
delTerm	TokenNameIdentifier	 del Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
delTerm	TokenNameIdentifier	 del Term
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
numDocs	TokenNameIdentifier	 num Docs
+=	TokenNamePLUS_EQUAL	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
addDocument	TokenNameIdentifier	 add Document
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
updateDocument	TokenNameIdentifier	 update Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
analyzer	TokenNameIdentifier	 analyzer
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
updateDocument	TokenNameIdentifier	 update Document
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
delTerm	TokenNameIdentifier	 del Term
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Possibly trigger a flush, or wait until any running flush completes: 	TokenNameCOMMENT_LINE	Possibly trigger a flush, or wait until any running flush completes: 
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
delTerm	TokenNameIdentifier	 del Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This call is synchronized but fast 	TokenNameCOMMENT_LINE	This call is synchronized but fast 
final	TokenNamefinal	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
getThreadState	TokenNameIdentifier	 get Thread State
(	TokenNameLPAREN	
delTerm	TokenNameIdentifier	 del Term
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
DocState	TokenNameIdentifier	 Doc State
docState	TokenNameIdentifier	 doc State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
;	TokenNameSEMICOLON	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// This call is not synchronized and does all the 	TokenNameCOMMENT_LINE	This call is not synchronized and does all the 
// work 	TokenNameCOMMENT_LINE	work 
final	TokenNamefinal	
DocWriter	TokenNameIdentifier	 Doc Writer
perDoc	TokenNameIdentifier	 per Doc
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
perDoc	TokenNameIdentifier	 per Doc
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
processDocument	TokenNameIdentifier	 process Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This call is synchronized but fast 	TokenNameCOMMENT_LINE	This call is synchronized but fast 
finishDocument	TokenNameIdentifier	 finish Document
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
perDoc	TokenNameIdentifier	 per Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this thread state had decided to flush, we 	TokenNameCOMMENT_LINE	If this thread state had decided to flush, we 
// must clear it so another thread can flush 	TokenNameCOMMENT_LINE	must clear it so another thread can flush 
if	TokenNameif	
(	TokenNameLPAREN	
doFlush	TokenNameIdentifier	 do Flush
)	TokenNameRPAREN	
{	TokenNameLBRACE	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
clearFlushPending	TokenNameIdentifier	 clear Flush Pending
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"exception in updateDocument aborting="	TokenNameStringLiteral	exception in updateDocument aborting=
+	TokenNamePLUS	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success2	TokenNameIdentifier	 success2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Immediately mark this document as deleted 	TokenNameCOMMENT_LINE	Immediately mark this document as deleted 
// since likely it was partially added. This 	TokenNameCOMMENT_LINE	since likely it was partially added. This 
// keeps indexing as "all or none" (atomic) when 	TokenNameCOMMENT_LINE	keeps indexing as "all or none" (atomic) when 
// adding a document: 	TokenNameCOMMENT_LINE	adding a document: 
deleteDocID	TokenNameIdentifier	 delete Doc ID
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
doFlush	TokenNameIdentifier	 do Flush
|=	TokenNameOR_EQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
flushByRAMUsage	TokenNameIdentifier	 flush By RAM Usage
(	TokenNameLPAREN	
"new document"	TokenNameStringLiteral	new document
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
updateDocuments	TokenNameIdentifier	 update Documents
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Document	TokenNameIdentifier	 Document
>	TokenNameGREATER	
docs	TokenNameIdentifier	 docs
,	TokenNameCOMMA	
Analyzer	TokenNameIdentifier	 Analyzer
analyzer	TokenNameIdentifier	 analyzer
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
delTerm	TokenNameIdentifier	 del Term
)	TokenNameRPAREN	
throws	TokenNamethrows	
CorruptIndexException	TokenNameIdentifier	 Corrupt Index Exception
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Possibly trigger a flush, or wait until any running flush completes: 	TokenNameCOMMENT_LINE	Possibly trigger a flush, or wait until any running flush completes: 
boolean	TokenNameboolean	
doFlush	TokenNameIdentifier	 do Flush
=	TokenNameEQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
waitUpdate	TokenNameIdentifier	 wait Update
(	TokenNameLPAREN	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
delTerm	TokenNameIdentifier	 del Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
docCount	TokenNameIdentifier	 doc Count
=	TokenNameEQUAL	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// This call is synchronized but fast -- we allocate the 	TokenNameCOMMENT_LINE	This call is synchronized but fast -- we allocate the 
// N docIDs up front: 	TokenNameCOMMENT_LINE	N docIDs up front: 
final	TokenNamefinal	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
state	TokenNameIdentifier	 state
=	TokenNameEQUAL	
getThreadState	TokenNameIdentifier	 get Thread State
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
docCount	TokenNameIdentifier	 doc Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
DocState	TokenNameIdentifier	 Doc State
docState	TokenNameIdentifier	 doc State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
startDocID	TokenNameIdentifier	 start Doc ID
=	TokenNameEQUAL	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
startDocID	TokenNameIdentifier	 start Doc ID
;	TokenNameSEMICOLON	
//System.out.println(Thread.currentThread().getName() + ": A " + docCount); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": A " + docCount); 
for	TokenNamefor	
(	TokenNameLPAREN	
Document	TokenNameIdentifier	 Document
doc	TokenNameIdentifier	 doc
:	TokenNameCOLON	
docs	TokenNameIdentifier	 docs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
analyzer	TokenNameIdentifier	 analyzer
=	TokenNameEQUAL	
analyzer	TokenNameIdentifier	 analyzer
;	TokenNameSEMICOLON	
// Assign next docID from our block: 	TokenNameCOMMENT_LINE	Assign next docID from our block: 
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docID	TokenNameIdentifier	 doc ID
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// This call is not synchronized and does all the 	TokenNameCOMMENT_LINE	This call is not synchronized and does all the 
// work 	TokenNameCOMMENT_LINE	work 
final	TokenNamefinal	
DocWriter	TokenNameIdentifier	 Doc Writer
perDoc	TokenNameIdentifier	 per Doc
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
perDoc	TokenNameIdentifier	 per Doc
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
processDocument	TokenNameIdentifier	 process Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Must call this w/o holding synchronized(this) else 	TokenNameCOMMENT_LINE	Must call this w/o holding synchronized(this) else 
// we'll hit deadlock: 	TokenNameCOMMENT_LINE	we'll hit deadlock: 
balanceRAM	TokenNameIdentifier	 balance RAM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Synchronized but fast 	TokenNameCOMMENT_LINE	Synchronized but fast 
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
perDoc	TokenNameIdentifier	 per Doc
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
perDoc	TokenNameIdentifier	 per Doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
==	TokenNameEQUAL_EQUAL	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
doPause	TokenNameIdentifier	 do Pause
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
perDoc	TokenNameIdentifier	 per Doc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
perDoc	TokenNameIdentifier	 per Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(Thread.currentThread().getName() + ": E"); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": E"); 
// If this thread state had decided to flush, we 	TokenNameCOMMENT_LINE	If this thread state had decided to flush, we 
// must clear it so another thread can flush 	TokenNameCOMMENT_LINE	must clear it so another thread can flush 
if	TokenNameif	
(	TokenNameLPAREN	
doFlush	TokenNameIdentifier	 do Flush
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"clearFlushPending!"	TokenNameStringLiteral	clearFlushPending!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
clearFlushPending	TokenNameIdentifier	 clear Flush Pending
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"exception in updateDocuments aborting="	TokenNameStringLiteral	exception in updateDocuments aborting=
+	TokenNamePLUS	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Fill hole in the doc stores for all 	TokenNameCOMMENT_LINE	Fill hole in the doc stores for all 
// docIDs we pre-allocated 	TokenNameCOMMENT_LINE	docIDs we pre-allocated 
//System.out.println(Thread.currentThread().getName() + ": F " + docCount); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": F " + docCount); 
final	TokenNamefinal	
int	TokenNameint	
endDocID	TokenNameIdentifier	 end Doc ID
=	TokenNameEQUAL	
startDocID	TokenNameIdentifier	 start Doc ID
+	TokenNamePLUS	
docCount	TokenNameIdentifier	 doc Count
;	TokenNameSEMICOLON	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
<	TokenNameLESS	
endDocID	TokenNameIdentifier	 end Doc ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
docID	TokenNameIdentifier	 doc ID
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
success2	TokenNameIdentifier	 success2
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success2	TokenNameIdentifier	 success2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//System.out.println(Thread.currentThread().getName() + ": F " + docCount + " done"); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": F " + docCount + " done"); 
// Mark all pre-allocated docIDs as deleted: 	TokenNameCOMMENT_LINE	Mark all pre-allocated docIDs as deleted: 
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
startDocID	TokenNameIdentifier	 start Doc ID
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
<	TokenNameLESS	
startDocID	TokenNameIdentifier	 start Doc ID
+	TokenNamePLUS	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deleteDocID	TokenNameIdentifier	 delete Doc ID
(	TokenNameLPAREN	
docID	TokenNameIdentifier	 doc ID
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We must delay pausing until the full doc block is 	TokenNameCOMMENT_LINE	We must delay pausing until the full doc block is 
// added, else we can hit deadlock if more than one 	TokenNameCOMMENT_LINE	added, else we can hit deadlock if more than one 
// thread is adding a block and we need to pause when 	TokenNameCOMMENT_LINE	thread is adding a block and we need to pause when 
// both are only part way done: 	TokenNameCOMMENT_LINE	both are only part way done: 
if	TokenNameif	
(	TokenNameLPAREN	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
doPause	TokenNameIdentifier	 do Pause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waitForWaitQueue	TokenNameIdentifier	 wait For Wait Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(Thread.currentThread().getName() + ": A " + docCount); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": A " + docCount); 
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We are currently aborting, and another thread is 	TokenNameCOMMENT_LINE	We are currently aborting, and another thread is 
// waiting for me to become idle. We just forcefully 	TokenNameCOMMENT_LINE	waiting for me to become idle. We just forcefully 
// idle this threadState; it will be fully reset by 	TokenNameCOMMENT_LINE	idle this threadState; it will be fully reset by 
// abort() 	TokenNameCOMMENT_LINE	abort() 
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// wakes up any threads waiting on the wait queue 	TokenNameCOMMENT_LINE	wakes up any threads waiting on the wait queue 
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doFlush	TokenNameIdentifier	 do Flush
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
"clearFlushPending!"	TokenNameStringLiteral	clearFlushPending!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
clearFlushPending	TokenNameIdentifier	 clear Flush Pending
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Apply delTerm only after all indexing has 	TokenNameCOMMENT_LINE	Apply delTerm only after all indexing has 
// succeeded, but apply it only to docs prior to when 	TokenNameCOMMENT_LINE	succeeded, but apply it only to docs prior to when 
// this batch started: 	TokenNameCOMMENT_LINE	this batch started: 
if	TokenNameif	
(	TokenNameLPAREN	
delTerm	TokenNameIdentifier	 del Term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
addTerm	TokenNameIdentifier	 add Term
(	TokenNameLPAREN	
delTerm	TokenNameIdentifier	 del Term
,	TokenNameCOMMA	
startDocID	TokenNameIdentifier	 start Doc ID
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// wakes up any threads waiting on the wait queue 	TokenNameCOMMENT_LINE	wakes up any threads waiting on the wait queue 
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
doFlush	TokenNameIdentifier	 do Flush
|=	TokenNameOR_EQUAL	
flushControl	TokenNameIdentifier	 flush Control
.	TokenNameDOT	
flushByRAMUsage	TokenNameIdentifier	 flush By RAM Usage
(	TokenNameLPAREN	
"new document"	TokenNameStringLiteral	new document
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(Thread.currentThread().getName() + ": B " + docCount); 	TokenNameCOMMENT_LINE	System.out.println(Thread.currentThread().getName() + ": B " + docCount); 
return	TokenNamereturn	
doFlush	TokenNameIdentifier	 do Flush
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
waitIdle	TokenNameIdentifier	 wait Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
allThreadsIdle	TokenNameIdentifier	 all Threads Idle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
wait	TokenNameIdentifier	 wait
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
(	TokenNameLPAREN	
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
waitReady	TokenNameIdentifier	 wait Ready
(	TokenNameLPAREN	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
closed	TokenNameIdentifier	 closed
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
||	TokenNameOR_OR	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
wait	TokenNameIdentifier	 wait
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
(	TokenNameLPAREN	
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
closed	TokenNameIdentifier	 closed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AlreadyClosedException	TokenNameIdentifier	 Already Closed Exception
(	TokenNameLPAREN	
"this IndexWriter is closed"	TokenNameStringLiteral	this IndexWriter is closed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Does the synchronized work to finish/flush the * inverted document. */	TokenNameCOMMENT_JAVADOC	 Does the synchronized work to finish/flush the inverted document. 
private	TokenNameprivate	
void	TokenNamevoid	
finishDocument	TokenNameIdentifier	 finish Document
(	TokenNameLPAREN	
DocumentsWriterThreadState	TokenNameIdentifier	 Documents Writer Thread State
perThread	TokenNameIdentifier	 per Thread
,	TokenNameCOMMA	
DocWriter	TokenNameIdentifier	 Doc Writer
docWriter	TokenNameIdentifier	 doc Writer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Must call this w/o holding synchronized(this) else 	TokenNameCOMMENT_LINE	Must call this w/o holding synchronized(this) else 
// we'll hit deadlock: 	TokenNameCOMMENT_LINE	we'll hit deadlock: 
balanceRAM	TokenNameIdentifier	 balance RAM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
docWriter	TokenNameIdentifier	 doc Writer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
docWriter	TokenNameIdentifier	 doc Writer
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
==	TokenNameEQUAL_EQUAL	
perThread	TokenNameIdentifier	 per Thread
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
aborting	TokenNameIdentifier	 aborting
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We are currently aborting, and another thread is 	TokenNameCOMMENT_LINE	We are currently aborting, and another thread is 
// waiting for me to become idle. We just forcefully 	TokenNameCOMMENT_LINE	waiting for me to become idle. We just forcefully 
// idle this threadState; it will be fully reset by 	TokenNameCOMMENT_LINE	idle this threadState; it will be fully reset by 
// abort() 	TokenNameCOMMENT_LINE	abort() 
if	TokenNameif	
(	TokenNameLPAREN	
docWriter	TokenNameIdentifier	 doc Writer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
docWriter	TokenNameIdentifier	 doc Writer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
perThread	TokenNameIdentifier	 per Thread
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// wakes up any threads waiting on the wait queue 	TokenNameCOMMENT_LINE	wakes up any threads waiting on the wait queue 
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doPause	TokenNameIdentifier	 do Pause
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
docWriter	TokenNameIdentifier	 doc Writer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doPause	TokenNameIdentifier	 do Pause
=	TokenNameEQUAL	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
docWriter	TokenNameIdentifier	 doc Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
=	TokenNameEQUAL	
perThread	TokenNameIdentifier	 per Thread
.	TokenNameDOT	
docState	TokenNameIdentifier	 doc State
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
doPause	TokenNameIdentifier	 do Pause
=	TokenNameEQUAL	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doPause	TokenNameIdentifier	 do Pause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waitForWaitQueue	TokenNameIdentifier	 wait For Wait Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
perThread	TokenNameIdentifier	 per Thread
.	TokenNameDOT	
isIdle	TokenNameIdentifier	 is Idle
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// wakes up any threads waiting on the wait queue 	TokenNameCOMMENT_LINE	wakes up any threads waiting on the wait queue 
notifyAll	TokenNameIdentifier	 notify All
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
waitForWaitQueue	TokenNameIdentifier	 wait For Wait Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
wait	TokenNameIdentifier	 wait
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
ThreadInterruptedException	TokenNameIdentifier	 Thread Interrupted Exception
(	TokenNameLPAREN	
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
waitQueue	TokenNameIdentifier	 wait Queue
.	TokenNameDOT	
doResume	TokenNameIdentifier	 do Resume
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
SkipDocWriter	TokenNameIdentifier	 Skip Doc Writer
extends	TokenNameextends	
DocWriter	TokenNameIdentifier	 Doc Writer
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
void	TokenNamevoid	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
void	TokenNamevoid	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
long	TokenNamelong	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
SkipDocWriter	TokenNameIdentifier	 Skip Doc Writer
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
=	TokenNameEQUAL	
new	TokenNamenew	
SkipDocWriter	TokenNameIdentifier	 Skip Doc Writer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
NumberFormat	TokenNameIdentifier	 Number Format
nf	TokenNameIdentifier	 nf
=	TokenNameEQUAL	
NumberFormat	TokenNameIdentifier	 Number Format
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Initial chunks size of the shared byte[] blocks used to store postings data */	TokenNameCOMMENT_BLOCK	 Initial chunks size of the shared byte[] blocks used to store postings data 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BYTE_BLOCK_SHIFT	TokenNameIdentifier	 BYTE  BLOCK  SHIFT
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BYTE_BLOCK_SIZE	TokenNameIdentifier	 BYTE  BLOCK  SIZE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
BYTE_BLOCK_SHIFT	TokenNameIdentifier	 BYTE  BLOCK  SHIFT
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BYTE_BLOCK_MASK	TokenNameIdentifier	 BYTE  BLOCK  MASK
=	TokenNameEQUAL	
BYTE_BLOCK_SIZE	TokenNameIdentifier	 BYTE  BLOCK  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
BYTE_BLOCK_NOT_MASK	TokenNameIdentifier	 BYTE  BLOCK  NOT  MASK
=	TokenNameEQUAL	
~	TokenNameTWIDDLE	
BYTE_BLOCK_MASK	TokenNameIdentifier	 BYTE  BLOCK  MASK
;	TokenNameSEMICOLON	
private	TokenNameprivate	
class	TokenNameclass	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
extends	TokenNameextends	
ByteBlockPool	TokenNameIdentifier	 Byte Block Pool
.	TokenNameDOT	
Allocator	TokenNameIdentifier	 Allocator
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
blockSize	TokenNameIdentifier	 block Size
;	TokenNameSEMICOLON	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
(	TokenNameLPAREN	
int	TokenNameint	
blockSize	TokenNameIdentifier	 block Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
blockSize	TokenNameIdentifier	 block Size
=	TokenNameEQUAL	
blockSize	TokenNameIdentifier	 block Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Allocate another byte[] from the shared pool */	TokenNameCOMMENT_BLOCK	 Allocate another byte[] from the shared pool 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getByteBlock	TokenNameIdentifier	 get Byte Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
blockSize	TokenNameIdentifier	 block Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
blockSize	TokenNameIdentifier	 block Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* Return byte[]'s to the pool */	TokenNameCOMMENT_BLOCK	 Return byte[]'s to the pool 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
void	TokenNamevoid	
recycleByteBlocks	TokenNameIdentifier	 recycle Byte Blocks
(	TokenNameLPAREN	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
blocks	TokenNameIdentifier	 blocks
,	TokenNameCOMMA	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
start	TokenNameIdentifier	 start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
void	TokenNamevoid	
recycleByteBlocks	TokenNameIdentifier	 recycle Byte Blocks
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
blocks	TokenNameIdentifier	 blocks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
DocumentsWriter	TokenNameIdentifier	 Documents Writer
.	TokenNameDOT	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
blocks	TokenNameIdentifier	 blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
blocks	TokenNameIdentifier	 blocks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
blocks	TokenNameIdentifier	 blocks
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* Initial chunks size of the shared int[] blocks used to store postings data */	TokenNameCOMMENT_BLOCK	 Initial chunks size of the shared int[] blocks used to store postings data 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
INT_BLOCK_SHIFT	TokenNameIdentifier	 INT  BLOCK  SHIFT
=	TokenNameEQUAL	
13	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
INT_BLOCK_SIZE	TokenNameIdentifier	 INT  BLOCK  SIZE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
INT_BLOCK_SHIFT	TokenNameIdentifier	 INT  BLOCK  SHIFT
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
INT_BLOCK_MASK	TokenNameIdentifier	 INT  BLOCK  MASK
=	TokenNameEQUAL	
INT_BLOCK_SIZE	TokenNameIdentifier	 INT  BLOCK  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Allocate another int[] from the shared pool */	TokenNameCOMMENT_BLOCK	 Allocate another int[] from the shared pool 
synchronized	TokenNamesynchronized	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getIntBlock	TokenNameIdentifier	 get Int Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INT_BLOCK_SIZE	TokenNameIdentifier	 INT  BLOCK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
INT_BLOCK_SIZE	TokenNameIdentifier	 INT  BLOCK  SIZE
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
long	TokenNamelong	
numBytes	TokenNameIdentifier	 num Bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
numBytes	TokenNameIdentifier	 num Bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
pendingDeletes	TokenNameIdentifier	 pending Deletes
.	TokenNameDOT	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Return int[]s to the pool */	TokenNameCOMMENT_BLOCK	 Return int[]s to the pool 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
recycleIntBlocks	TokenNameIdentifier	 recycle Int Blocks
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
blocks	TokenNameIdentifier	 blocks
,	TokenNameCOMMA	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
start	TokenNameIdentifier	 start
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
=	TokenNameEQUAL	
new	TokenNamenew	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
(	TokenNameLPAREN	
BYTE_BLOCK_SIZE	TokenNameIdentifier	 BYTE  BLOCK  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
PER_DOC_BLOCK_SIZE	TokenNameIdentifier	 PER  DOC  BLOCK  SIZE
=	TokenNameEQUAL	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
=	TokenNameEQUAL	
new	TokenNamenew	
ByteBlockAllocator	TokenNameIdentifier	 Byte Block Allocator
(	TokenNameLPAREN	
PER_DOC_BLOCK_SIZE	TokenNameIdentifier	 PER  DOC  BLOCK  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Initial chunk size of the shared char[] blocks used to store term text */	TokenNameCOMMENT_BLOCK	 Initial chunk size of the shared char[] blocks used to store term text 
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
CHAR_BLOCK_SHIFT	TokenNameIdentifier	 CHAR  BLOCK  SHIFT
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
CHAR_BLOCK_SHIFT	TokenNameIdentifier	 CHAR  BLOCK  SHIFT
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
CHAR_BLOCK_MASK	TokenNameIdentifier	 CHAR  BLOCK  MASK
=	TokenNameEQUAL	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
int	TokenNameint	
MAX_TERM_LENGTH	TokenNameIdentifier	 MAX  TERM  LENGTH
=	TokenNameEQUAL	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Allocate another char[] from the shared pool */	TokenNameCOMMENT_BLOCK	 Allocate another char[] from the shared pool 
synchronized	TokenNamesynchronized	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getCharBlock	TokenNameIdentifier	 get Char Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_CHAR	TokenNameIdentifier	 NUM  BYTES  CHAR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We always track allocations of char blocks, for now, 	TokenNameCOMMENT_LINE	We always track allocations of char blocks, for now, 
// because nothing that skips allocation tracking 	TokenNameCOMMENT_LINE	because nothing that skips allocation tracking 
// (currently only term vectors) uses its own char 	TokenNameCOMMENT_LINE	(currently only term vectors) uses its own char 
// blocks. 	TokenNameCOMMENT_LINE	blocks. 
return	TokenNamereturn	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Return char[]s to the pool */	TokenNameCOMMENT_BLOCK	 Return char[]s to the pool 
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
recycleCharBlocks	TokenNameIdentifier	 recycle Char Blocks
(	TokenNameLPAREN	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
blocks	TokenNameIdentifier	 blocks
,	TokenNameCOMMA	
int	TokenNameint	
numBlocks	TokenNameIdentifier	 num Blocks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numBlocks	TokenNameIdentifier	 num Blocks
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
blocks	TokenNameIdentifier	 blocks
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
long	TokenNamelong	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* We have four pools of RAM: Postings, byte blocks * (holds freq/prox posting data), char blocks (holds * characters in the term) and per-doc buffers (stored fields/term vectors). * Different docs require varying amount of storage from * these four classes. * * For example, docs with many unique single-occurrence * short terms will use up the Postings RAM and hardly any * of the other two. Whereas docs with very large terms * will use alot of char blocks RAM and relatively less of * the other two. This method just frees allocations from * the pools once we are over-budget, which balances the * pools to match the current docs. */	TokenNameCOMMENT_BLOCK	 We have four pools of RAM: Postings, byte blocks (holds freq/prox posting data), char blocks (holds characters in the term) and per-doc buffers (stored fields/term vectors). Different docs require varying amount of storage from these four classes. * For example, docs with many unique single-occurrence short terms will use up the Postings RAM and hardly any of the other two. Whereas docs with very large terms will use alot of char blocks RAM and relatively less of the other two. This method just frees allocations from the pools once we are over-budget, which balances the pools to match the current docs. 
void	TokenNamevoid	
balanceRAM	TokenNameIdentifier	 balance RAM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
boolean	TokenNameboolean	
doBalance	TokenNameIdentifier	 do Balance
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
;	TokenNameSEMICOLON	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
=	TokenNameEQUAL	
bufferedDeletesStream	TokenNameIdentifier	 buffered Deletes Stream
.	TokenNameDOT	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
;	TokenNameSEMICOLON	
final	TokenNamefinal	
double	TokenNamedouble	
mb	TokenNameIdentifier	 mb
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getRAMBufferSizeMB	TokenNameIdentifier	 get RAM Buffer Size MB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
==	TokenNameEQUAL_EQUAL	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
DISABLE_AUTO_FLUSH	TokenNameIdentifier	 DISABLE  AUTO  FLUSH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
=	TokenNameEQUAL	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
DISABLE_AUTO_FLUSH	TokenNameIdentifier	 DISABLE  AUTO  FLUSH
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
==	TokenNameEQUAL_EQUAL	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
DISABLE_AUTO_FLUSH	TokenNameIdentifier	 DISABLE  AUTO  FLUSH
||	TokenNameOR_OR	
bufferIsFull	TokenNameIdentifier	 buffer Is Full
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
doBalance	TokenNameIdentifier	 do Balance
=	TokenNameEQUAL	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
>=	TokenNameGREATER_EQUAL	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doBalance	TokenNameIdentifier	 do Balance
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
" RAM: balance allocations: usedMB="	TokenNameStringLiteral	 RAM: balance allocations: usedMB=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" vs trigger="	TokenNameStringLiteral	 vs trigger=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
)	TokenNameRPAREN	
+	TokenNamePLUS	
" deletesMB="	TokenNameStringLiteral	 deletesMB=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
)	TokenNameRPAREN	
+	TokenNamePLUS	
" byteBlockFree="	TokenNameStringLiteral	 byteBlockFree=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
BYTE_BLOCK_SIZE	TokenNameIdentifier	 BYTE  BLOCK  SIZE
)	TokenNameRPAREN	
+	TokenNamePLUS	
" perDocFree="	TokenNameStringLiteral	 perDocFree=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
PER_DOC_BLOCK_SIZE	TokenNameIdentifier	 PER  DOC  BLOCK  SIZE
)	TokenNameRPAREN	
+	TokenNamePLUS	
" charBlockFree="	TokenNameStringLiteral	 charBlockFree=
+	TokenNamePLUS	
toMB	TokenNameIdentifier	 to MB
(	TokenNameLPAREN	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_CHAR	TokenNameIdentifier	 NUM  BYTES  CHAR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
long	TokenNamelong	
startBytesUsed	TokenNameIdentifier	 start Bytes Used
=	TokenNameEQUAL	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
;	TokenNameSEMICOLON	
int	TokenNameint	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// We free equally from each pool in 32 KB 	TokenNameCOMMENT_LINE	We free equally from each pool in 32 KB 
// chunks until we are below our threshold 	TokenNameCOMMENT_LINE	chunks until we are below our threshold 
// (freeLevel) 	TokenNameCOMMENT_LINE	(freeLevel) 
boolean	TokenNameboolean	
any	TokenNameIdentifier	 any
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
freeLevel	TokenNameIdentifier	 free Level
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
0.95	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
>	TokenNameGREATER	
freeLevel	TokenNameIdentifier	 free Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
any	TokenNameIdentifier	 any
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Nothing else to free -- must flush now. 	TokenNameCOMMENT_LINE	Nothing else to free -- must flush now. 
bufferIsFull	TokenNameIdentifier	 buffer Is Full
=	TokenNameEQUAL	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
>	TokenNameGREATER	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
>	TokenNameGREATER	
ramBufferSize	TokenNameIdentifier	 ram Buffer Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
" nothing to free; set bufferIsFull"	TokenNameStringLiteral	 nothing to free; set bufferIsFull
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
" nothing to free"	TokenNameStringLiteral	 nothing to free
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
%	TokenNameREMAINDER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
byteBlockAllocator	TokenNameIdentifier	 byte Block Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
-	TokenNameMINUS	
BYTE_BLOCK_SIZE	TokenNameIdentifier	 BYTE  BLOCK  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
%	TokenNameREMAINDER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
freeCharBlocks	TokenNameIdentifier	 free Char Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
-	TokenNameMINUS	
CHAR_BLOCK_SIZE	TokenNameIdentifier	 CHAR  BLOCK  SIZE
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_CHAR	TokenNameIdentifier	 NUM  BYTES  CHAR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
%	TokenNameREMAINDER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
freeIntBlocks	TokenNameIdentifier	 free Int Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
-	TokenNameMINUS	
INT_BLOCK_SIZE	TokenNameIdentifier	 INT  BLOCK  SIZE
*	TokenNameMULTIPLY	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_INT	TokenNameIdentifier	 NUM  BYTES  INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
%	TokenNameREMAINDER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Remove upwards of 32 blocks (each block is 1K) 	TokenNameCOMMENT_LINE	Remove upwards of 32 blocks (each block is 1K) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
32	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bytesUsed	TokenNameIdentifier	 bytes Used
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
-	TokenNameMINUS	
PER_DOC_BLOCK_SIZE	TokenNameIdentifier	 PER  DOC  BLOCK  SIZE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
perDocAllocator	TokenNameIdentifier	 per Doc Allocator
.	TokenNameDOT	
freeByteBlocks	TokenNameIdentifier	 free Byte Blocks
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
4	TokenNameIntegerLiteral	
==	TokenNameEQUAL_EQUAL	
iter	TokenNameIdentifier	 iter
%	TokenNameREMAINDER	
5	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
any	TokenNameIdentifier	 any
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Ask consumer to free any recycled state 	TokenNameCOMMENT_LINE	Ask consumer to free any recycled state 
any	TokenNameIdentifier	 any
=	TokenNameEQUAL	
consumer	TokenNameIdentifier	 consumer
.	TokenNameDOT	
freeRAM	TokenNameIdentifier	 free RAM
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
iter	TokenNameIdentifier	 iter
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
infoStream	TokenNameIdentifier	 info Stream
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
(	TokenNameLPAREN	
" after free: freedMB="	TokenNameStringLiteral	 after free: freedMB=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
(	TokenNameLPAREN	
startBytesUsed	TokenNameIdentifier	 start Bytes Used
-	TokenNameMINUS	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" usedMB="	TokenNameStringLiteral	 usedMB=
+	TokenNamePLUS	
nf	TokenNameIdentifier	 nf
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
(	TokenNameLPAREN	
bytesUsed	TokenNameIdentifier	 bytes Used
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
deletesRAMUsed	TokenNameIdentifier	 deletes RAM Used
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
/	TokenNameDIVIDE	
1024.	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
WaitQueue	TokenNameIdentifier	 Wait Queue
waitQueue	TokenNameIdentifier	 wait Queue
=	TokenNameEQUAL	
new	TokenNamenew	
WaitQueue	TokenNameIdentifier	 Wait Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
class	TokenNameclass	
WaitQueue	TokenNameIdentifier	 Wait Queue
{	TokenNameLBRACE	
DocWriter	TokenNameIdentifier	 Doc Writer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
waiting	TokenNameIdentifier	 waiting
;	TokenNameSEMICOLON	
int	TokenNameint	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
;	TokenNameSEMICOLON	
int	TokenNameint	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
;	TokenNameSEMICOLON	
int	TokenNameint	
numWaiting	TokenNameIdentifier	 num Waiting
;	TokenNameSEMICOLON	
long	TokenNamelong	
waitingBytes	TokenNameIdentifier	 waiting Bytes
;	TokenNameSEMICOLON	
public	TokenNamepublic	
WaitQueue	TokenNameIdentifier	 Wait Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waiting	TokenNameIdentifier	 waiting
=	TokenNameEQUAL	
new	TokenNamenew	
DocWriter	TokenNameIdentifier	 Doc Writer
[	TokenNameLBRACKET	
10	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// NOTE: nextWriteLoc doesn't need to be reset 	TokenNameCOMMENT_LINE	NOTE: nextWriteLoc doesn't need to be reset 
assert	TokenNameassert	
numWaiting	TokenNameIdentifier	 num Waiting
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
waitingBytes	TokenNameIdentifier	 waiting Bytes
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
doResume	TokenNameIdentifier	 do Resume
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
double	TokenNamedouble	
mb	TokenNameIdentifier	 mb
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getRAMBufferSizeMB	TokenNameIdentifier	 get RAM Buffer Size MB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
waitQueueResumeBytes	TokenNameIdentifier	 wait Queue Resume Bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
==	TokenNameEQUAL_EQUAL	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
DISABLE_AUTO_FLUSH	TokenNameIdentifier	 DISABLE  AUTO  FLUSH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waitQueueResumeBytes	TokenNameIdentifier	 wait Queue Resume Bytes
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
waitQueueResumeBytes	TokenNameIdentifier	 wait Queue Resume Bytes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
0.05	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
waitingBytes	TokenNameIdentifier	 waiting Bytes
<=	TokenNameLESS_EQUAL	
waitQueueResumeBytes	TokenNameIdentifier	 wait Queue Resume Bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
boolean	TokenNameboolean	
doPause	TokenNameIdentifier	 do Pause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
double	TokenNamedouble	
mb	TokenNameIdentifier	 mb
=	TokenNameEQUAL	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
getRAMBufferSizeMB	TokenNameIdentifier	 get RAM Buffer Size MB
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
long	TokenNamelong	
waitQueuePauseBytes	TokenNameIdentifier	 wait Queue Pause Bytes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
==	TokenNameEQUAL_EQUAL	
IndexWriterConfig	TokenNameIdentifier	 Index Writer Config
.	TokenNameDOT	
DISABLE_AUTO_FLUSH	TokenNameIdentifier	 DISABLE  AUTO  FLUSH
)	TokenNameRPAREN	
{	TokenNameLBRACE	
waitQueuePauseBytes	TokenNameIdentifier	 wait Queue Pause Bytes
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
waitQueuePauseBytes	TokenNameIdentifier	 wait Queue Pause Bytes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
mb	TokenNameIdentifier	 mb
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
1024	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
0.1	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
waitingBytes	TokenNameIdentifier	 waiting Bytes
>	TokenNameGREATER	
waitQueuePauseBytes	TokenNameIdentifier	 wait Queue Pause Bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
void	TokenNamevoid	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
DocWriter	TokenNameIdentifier	 Doc Writer
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
waitingBytes	TokenNameIdentifier	 waiting Bytes
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
count	TokenNameIdentifier	 count
==	TokenNameEQUAL_EQUAL	
numWaiting	TokenNameIdentifier	 num Waiting
;	TokenNameSEMICOLON	
numWaiting	TokenNameIdentifier	 num Waiting
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeDocument	TokenNameIdentifier	 write Document
(	TokenNameLPAREN	
DocWriter	TokenNameIdentifier	 Doc Writer
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
doc	TokenNameIdentifier	 doc
==	TokenNameEQUAL_EQUAL	
skipDocWriter	TokenNameIdentifier	 skip Doc Writer
||	TokenNameOR_OR	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
==	TokenNameEQUAL_EQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
<=	TokenNameLESS_EQUAL	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
==	TokenNameEQUAL_EQUAL	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setAborting	TokenNameIdentifier	 set Aborting
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
synchronized	TokenNamesynchronized	
public	TokenNamepublic	
boolean	TokenNameboolean	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
DocWriter	TokenNameIdentifier	 Doc Writer
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
>=	TokenNameGREATER_EQUAL	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
==	TokenNameEQUAL_EQUAL	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeDocument	TokenNameIdentifier	 write Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numWaiting	TokenNameIdentifier	 num Waiting
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
waitingBytes	TokenNameIdentifier	 waiting Bytes
-=	TokenNameMINUS_EQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeDocument	TokenNameIdentifier	 write Document
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// I finished before documents that were added 	TokenNameCOMMENT_LINE	I finished before documents that were added 
// before me. This can easily happen when I am a 	TokenNameCOMMENT_LINE	before me. This can easily happen when I am a 
// small doc and the docs before me were large, or, 	TokenNameCOMMENT_LINE	small doc and the docs before me were large, or, 
// just due to luck in the thread scheduling. Just 	TokenNameCOMMENT_LINE	just due to luck in the thread scheduling. Just 
// add myself to the queue and when that large doc 	TokenNameCOMMENT_LINE	add myself to the queue and when that large doc 
// finishes, it will flush me: 	TokenNameCOMMENT_LINE	finishes, it will flush me: 
int	TokenNameint	
gap	TokenNameIdentifier	 gap
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
-	TokenNameMINUS	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
gap	TokenNameIdentifier	 gap
>=	TokenNameGREATER_EQUAL	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Grow queue 	TokenNameCOMMENT_LINE	Grow queue 
DocWriter	TokenNameIdentifier	 Doc Writer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArray	TokenNameIdentifier	 new Array
=	TokenNameEQUAL	
new	TokenNamenew	
DocWriter	TokenNameIdentifier	 Doc Writer
[	TokenNameLBRACKET	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
oversize	TokenNameIdentifier	 oversize
(	TokenNameLPAREN	
gap	TokenNameIdentifier	 gap
,	TokenNameCOMMA	
RamUsageEstimator	TokenNameIdentifier	 Ram Usage Estimator
.	TokenNameDOT	
NUM_BYTES_OBJECT_REF	TokenNameIdentifier	 NUM  BYTES  OBJECT  REF
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
waiting	TokenNameIdentifier	 waiting
,	TokenNameCOMMA	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
waiting	TokenNameIdentifier	 waiting
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
,	TokenNameCOMMA	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
waiting	TokenNameIdentifier	 waiting
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
;	TokenNameSEMICOLON	
gap	TokenNameIdentifier	 gap
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
docID	TokenNameIdentifier	 doc ID
-	TokenNameMINUS	
nextWriteDocID	TokenNameIdentifier	 next Write Doc ID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
nextWriteLoc	TokenNameIdentifier	 next Write Loc
+	TokenNamePLUS	
gap	TokenNameIdentifier	 gap
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
>=	TokenNameGREATER_EQUAL	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
loc	TokenNameIdentifier	 loc
-=	TokenNameMINUS_EQUAL	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We should only wrap one time 	TokenNameCOMMENT_LINE	We should only wrap one time 
assert	TokenNameassert	
loc	TokenNameIdentifier	 loc
<	TokenNameLESS	
waiting	TokenNameIdentifier	 waiting
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
// Nobody should be in my spot! 	TokenNameCOMMENT_LINE	Nobody should be in my spot! 
assert	TokenNameassert	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
loc	TokenNameIdentifier	 loc
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
waiting	TokenNameIdentifier	 waiting
[	TokenNameLBRACKET	
loc	TokenNameIdentifier	 loc
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
numWaiting	TokenNameIdentifier	 num Waiting
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
waitingBytes	TokenNameIdentifier	 waiting Bytes
+=	TokenNamePLUS_EQUAL	
doc	TokenNameIdentifier	 doc
.	TokenNameDOT	
sizeInBytes	TokenNameIdentifier	 size In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
doPause	TokenNameIdentifier	 do Pause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
