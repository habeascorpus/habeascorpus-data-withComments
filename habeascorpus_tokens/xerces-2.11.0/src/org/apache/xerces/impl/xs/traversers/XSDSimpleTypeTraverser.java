/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
traversers	TokenNameIdentifier	 traversers
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
SchemaDVFactory	TokenNameIdentifier	 Schema DV Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaDVFactoryImpl	TokenNameIdentifier	 Schema DV Factory Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XInt	TokenNameIdentifier	 X Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DOMUtil	TokenNameIdentifier	 DOM Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
/** * The simple type definition schema component traverser. * * <simpleType * final = (#all | (list | union | restriction)) * id = ID * name = NCName * {any attributes with non-schema namespace . . .}> * Content: (annotation?, (restriction | list | union)) * </simpleType> * * <restriction * base = QName * id = ID * {any attributes with non-schema namespace . . .}> * Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)) * </restriction> * * <list * id = ID * itemType = QName * {any attributes with non-schema namespace . . .}> * Content: (annotation?, (simpleType?)) * </list> * * <union * id = ID * memberTypes = List of QName * {any attributes with non-schema namespace . . .}> * Content: (annotation?, (simpleType*)) * </union> * * @xerces.internal * * @author Elena Litani, IBM * @author Neeraj Bajaj, Sun Microsystems, Inc. * @author Sandy Gao, IBM * * @version $Id: XSDSimpleTypeTraverser.java 819653 2009-09-28 17:29:56Z knoaman $ */	TokenNameCOMMENT_JAVADOC	 The simple type definition schema component traverser. * <simpleType final = (#all | (list | union | restriction)) id = ID name = NCName {any attributes with non-schema namespace . . .}> Content: (annotation?, (restriction | list | union)) </simpleType> * <restriction base = QName id = ID {any attributes with non-schema namespace . . .}> Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)) </restriction> * <list id = ID itemType = QName {any attributes with non-schema namespace . . .}> Content: (annotation?, (simpleType?)) </list> * <union id = ID memberTypes = List of QName {any attributes with non-schema namespace . . .}> Content: (annotation?, (simpleType*)) </union> * @xerces.internal * @author Elena Litani, IBM @author Neeraj Bajaj, Sun Microsystems, Inc. @author Sandy Gao, IBM * @version $Id: XSDSimpleTypeTraverser.java 819653 2009-09-28 17:29:56Z knoaman $ 
class	TokenNameclass	
XSDSimpleTypeTraverser	TokenNameIdentifier	 XSD Simple Type Traverser
extends	TokenNameextends	
XSDAbstractTraverser	TokenNameIdentifier	 XSD Abstract Traverser
{	TokenNameLBRACE	
// whether the type being parsed is a S4S built-in type. 	TokenNameCOMMENT_LINE	whether the type being parsed is a S4S built-in type. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsBuiltIn	TokenNameIdentifier	 f Is Built In
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
XSDSimpleTypeTraverser	TokenNameIdentifier	 XSD Simple Type Traverser
(	TokenNameLPAREN	
XSDHandler	TokenNameIdentifier	 XSD Handler
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
handler	TokenNameIdentifier	 handler
,	TokenNameCOMMA	
gAttrCheck	TokenNameIdentifier	 g Attr Check
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//return qualified name of simpleType or empty string if error occured 	TokenNameCOMMENT_LINE	return qualified name of simpleType or empty string if error occured 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
traverseGlobal	TokenNameIdentifier	 traverse Global
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// General Attribute Checking 	TokenNameCOMMENT_LINE	General Attribute Checking 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nameAtt	TokenNameIdentifier	 name Att
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAME	TokenNameIdentifier	 ATTIDX  NAME
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAME	TokenNameIdentifier	 ATTIDX  NAME
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
NO_NAME	TokenNameIdentifier	 NO  NAME
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
traverseSimpleTypeDecl	TokenNameIdentifier	 traverse Simple Type Decl
(	TokenNameLPAREN	
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if it's a global type without a name, return null 	TokenNameCOMMENT_LINE	if it's a global type without a name, return null 
if	TokenNameif	
(	TokenNameLPAREN	
nameAtt	TokenNameIdentifier	 name Att
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-att-must-appear"	TokenNameStringLiteral	s4s-att-must-appear
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// don't add global components without name to the grammar 	TokenNameCOMMENT_LINE	don't add global components without name to the grammar 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalSimpleTypeDecl	TokenNameIdentifier	 add Global Simple Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// also add it to extended map 	TokenNameCOMMENT_LINE	also add it to extended map 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
loc	TokenNameIdentifier	 loc
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
schemaDocument2SystemId	TokenNameIdentifier	 schema Document2 System Id
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type2	TokenNameIdentifier	 type2
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
addGlobalSimpleTypeDecl	TokenNameIdentifier	 add Global Simple Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handle duplicates 	TokenNameCOMMENT_LINE	handle duplicates 
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fTolerateDuplicates	TokenNameIdentifier	 f Tolerate Duplicates
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type2	TokenNameIdentifier	 type2
instanceof	TokenNameinstanceof	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
type2	TokenNameIdentifier	 type2
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
addGlobalTypeDecl	TokenNameIdentifier	 add Global Type Decl
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// General Attribute Checking 	TokenNameCOMMENT_LINE	General Attribute Checking 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
genAnonTypeName	TokenNameIdentifier	 gen Anon Type Name
(	TokenNameLPAREN	
elmNode	TokenNameIdentifier	 elm Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
elmNode	TokenNameIdentifier	 elm Node
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
setAnonymous	TokenNameIdentifier	 set Anonymous
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
traverseSimpleTypeDecl	TokenNameIdentifier	 traverse Simple Type Decl
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get name and final values 	TokenNameCOMMENT_LINE	get name and final values 
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_NAME	TokenNameIdentifier	 ATTIDX  NAME
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Generate a name for an anonymous type */	TokenNameCOMMENT_BLOCK	 Generate a name for an anonymous type 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
genAnonTypeName	TokenNameIdentifier	 gen Anon Type Name
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Generate a unique name for the anonymous type by concatenating together the 	TokenNameCOMMENT_LINE	Generate a unique name for the anonymous type by concatenating together the 
// names of parent nodes 	TokenNameCOMMENT_LINE	names of parent nodes 
// The name is quite good for debugging/error purposes, but we may want to 	TokenNameCOMMENT_LINE	The name is quite good for debugging/error purposes, but we may want to 
// revisit how this is done for performance reasons (LM). 	TokenNameCOMMENT_LINE	revisit how this is done for performance reasons (LM). 
StringBuffer	TokenNameIdentifier	 String Buffer
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
"#AnonType_"	TokenNameStringLiteral	#AnonType_
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Element	TokenNameIdentifier	 Element
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getRoot	TokenNameIdentifier	 get Root
(	TokenNameLPAREN	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getDocument	TokenNameIdentifier	 get Document
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATT_NAME	TokenNameIdentifier	 ATT  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param name * @param simpleTypeDecl * @param attrValues * @param schemaDoc * @param grammar * @return */	TokenNameCOMMENT_JAVADOC	 @param name @param simpleTypeDecl @param attrValues @param schemaDoc @param grammar @return 
private	TokenNameprivate	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XInt	TokenNameIdentifier	 X Int
finalAttr	TokenNameIdentifier	 final Attr
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XInt	TokenNameIdentifier	 X Int
)	TokenNameRPAREN	
attrValues	TokenNameIdentifier	 attr Values
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_FINAL	TokenNameIdentifier	 ATTIDX  FINAL
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
finalProperty	TokenNameIdentifier	 final Property
=	TokenNameEQUAL	
finalAttr	TokenNameIdentifier	 final Attr
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fFinalDefault	TokenNameIdentifier	 f Final Default
:	TokenNameCOLON	
finalAttr	TokenNameIdentifier	 final Attr
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// annotation?,(list|restriction|union) 	TokenNameCOMMENT_LINE	annotation?,(list|restriction|union) 
Element	TokenNameIdentifier	 Element
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
attrValues	TokenNameIdentifier	 attr Values
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// (list|restriction|union) 	TokenNameCOMMENT_LINE	(list|restriction|union) 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.2"	TokenNameStringLiteral	s4s-elt-must-match.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
,	TokenNameCOMMA	
"(annotation?, (restriction | list | union))"	TokenNameStringLiteral	(annotation?, (restriction | list | union))
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// derivation type: restriction/list/union 	TokenNameCOMMENT_LINE	derivation type: restriction/list/union 
String	TokenNameIdentifier	 String
varietyProperty	TokenNameIdentifier	 variety Property
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
false	TokenNamefalse	
,	TokenNameCOMMA	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
false	TokenNamefalse	
,	TokenNameCOMMA	
union	TokenNameIdentifier	 union
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
varietyProperty	TokenNameIdentifier	 variety Property
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
varietyProperty	TokenNameIdentifier	 variety Property
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_LIST	TokenNameIdentifier	 ELT  LIST
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
;	TokenNameSEMICOLON	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
varietyProperty	TokenNameIdentifier	 variety Property
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_UNION	TokenNameIdentifier	 ELT  UNION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
refType	TokenNameIdentifier	 ref Type
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
;	TokenNameSEMICOLON	
union	TokenNameIdentifier	 union
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
,	TokenNameCOMMA	
"(annotation?, (restriction | list | union))"	TokenNameStringLiteral	(annotation?, (restriction | list | union))
,	TokenNameCOMMA	
varietyProperty	TokenNameIdentifier	 variety Property
}	TokenNameRBRACE	
,	TokenNameCOMMA	
simpleTypeDecl	TokenNameIdentifier	 simple Type Decl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// nothing should follow this element 	TokenNameCOMMENT_LINE	nothing should follow this element 
Element	TokenNameIdentifier	 Element
nextChild	TokenNameIdentifier	 next Child
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextChild	TokenNameIdentifier	 next Child
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
,	TokenNameCOMMA	
"(annotation?, (restriction | list | union))"	TokenNameStringLiteral	(annotation?, (restriction | list | union))
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
nextChild	TokenNameIdentifier	 next Child
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
nextChild	TokenNameIdentifier	 next Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// General Attribute Checking: get base/item/member types 	TokenNameCOMMENT_LINE	General Attribute Checking: get base/item/member types 
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
contentAttrs	TokenNameIdentifier	 content Attrs
=	TokenNameEQUAL	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
checkAttributes	TokenNameIdentifier	 check Attributes
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
baseTypeName	TokenNameIdentifier	 base Type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
[	TokenNameLBRACKET	
restriction	TokenNameIdentifier	 restriction
?	TokenNameQUESTION	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_BASE	TokenNameIdentifier	 ATTIDX  BASE
:	TokenNameCOLON	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_ITEMTYPE	TokenNameIdentifier	 ATTIDX  ITEMTYPE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
memberTypes	TokenNameIdentifier	 member Types
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
[	TokenNameLBRACKET	
XSAttributeChecker	TokenNameIdentifier	 XS Attribute Checker
.	TokenNameDOT	
ATTIDX_MEMBERTYPES	TokenNameIdentifier	 ATTIDX  MEMBERTYPES
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//content = {annotation?,simpleType?...} 	TokenNameCOMMENT_LINE	content = {annotation?,simpleType?...} 
Element	TokenNameIdentifier	 Element
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getFirstChildElement	TokenNameIdentifier	 get First Child Element
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//check content (annotation?, ...) 	TokenNameCOMMENT_LINE	check content (annotation?, ...) 
if	TokenNameif	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_ANNOTATION	TokenNameIdentifier	 ELT  ANNOTATION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseAnnotationDecl	TokenNameIdentifier	 traverse Annotation Decl
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotation	TokenNameIdentifier	 annotation
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempArray	TokenNameIdentifier	 temp Array
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
tempArray	TokenNameIdentifier	 temp Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
tempArray	TokenNameIdentifier	 temp Array
;	TokenNameSEMICOLON	
annotations	TokenNameIdentifier	 annotations
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
annotation	TokenNameIdentifier	 annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getSyntheticAnnotation	TokenNameIdentifier	 get Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
annotation	TokenNameIdentifier	 annotation
=	TokenNameEQUAL	
traverseSyntheticAnnotation	TokenNameIdentifier	 traverse Synthetic Annotation
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
annotation	TokenNameIdentifier	 annotation
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tempArray	TokenNameIdentifier	 temp Array
=	TokenNameEQUAL	
new	TokenNamenew	
XSAnnotationImpl	TokenNameIdentifier	 XS Annotation Impl
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
tempArray	TokenNameIdentifier	 temp Array
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
annotations	TokenNameIdentifier	 annotations
=	TokenNameEQUAL	
tempArray	TokenNameIdentifier	 temp Array
;	TokenNameSEMICOLON	
annotations	TokenNameIdentifier	 annotations
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
annotation	TokenNameIdentifier	 annotation
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get base type from "base" attribute 	TokenNameCOMMENT_LINE	get base type from "base" attribute 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
||	TokenNameOR_OR	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
baseTypeName	TokenNameIdentifier	 base Type Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
findDTValidator	TokenNameIdentifier	 find DT Validator
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
baseTypeName	TokenNameIdentifier	 base Type Name
,	TokenNameCOMMA	
refType	TokenNameIdentifier	 ref Type
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if its the built-in type, return null from here 	TokenNameCOMMENT_LINE	if its the built-in type, return null from here 
if	TokenNameif	
(	TokenNameLPAREN	
baseValidator	TokenNameIdentifier	 base Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fIsBuiltIn	TokenNameIdentifier	 f Is Built In
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIsBuiltIn	TokenNameIdentifier	 f Is Built In
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get types from "memberTypes" attribute 	TokenNameCOMMENT_LINE	get types from "memberTypes" attribute 
ArrayList	TokenNameIdentifier	 Array List
dTValidators	TokenNameIdentifier	 d T Validators
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSObjectList	TokenNameIdentifier	 XS Object List
dvs	TokenNameIdentifier	 dvs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
&&	TokenNameAND_AND	
memberTypes	TokenNameIdentifier	 member Types
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dTValidators	TokenNameIdentifier	 d T Validators
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// for each qname in the list 	TokenNameCOMMENT_LINE	for each qname in the list 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the type decl 	TokenNameCOMMENT_LINE	get the type decl 
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
findDTValidator	TokenNameIdentifier	 find DT Validator
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if it's a union, expand it 	TokenNameCOMMENT_LINE	if it's a union, expand it 
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dvs	TokenNameIdentifier	 dvs
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
dvs	TokenNameIdentifier	 dvs
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
dvs	TokenNameIdentifier	 dvs
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check if there is a child "simpleType" 	TokenNameCOMMENT_LINE	check if there is a child "simpleType" 
if	TokenNameif	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
||	TokenNameOR_OR	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// it's an error for both "base" and "simpleType" to appear 	TokenNameCOMMENT_LINE	it's an error for both "base" and "simpleType" to appear 
if	TokenNameif	
(	TokenNameLPAREN	
baseTypeName	TokenNameIdentifier	 base Type Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
?	TokenNameQUESTION	
"src-simple-type.3.a"	TokenNameStringLiteral	src-simple-type.3.a
:	TokenNameCOLON	
"src-simple-type.2.a"	TokenNameStringLiteral	src-simple-type.2.a
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseValidator	TokenNameIdentifier	 base Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// traverse this child to get the base type 	TokenNameCOMMENT_LINE	traverse this child to get the base type 
baseValidator	TokenNameIdentifier	 base Validator
=	TokenNameEQUAL	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get the next element 	TokenNameCOMMENT_LINE	get the next element 
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dTValidators	TokenNameIdentifier	 d T Validators
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dTValidators	TokenNameIdentifier	 d T Validators
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
// traverse this child to get the member type 	TokenNameCOMMENT_LINE	traverse this child to get the member type 
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
traverseLocal	TokenNameIdentifier	 traverse Local
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if it's a union, expand it 	TokenNameCOMMENT_LINE	if it's a union, expand it 
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dvs	TokenNameIdentifier	 dvs
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
dvs	TokenNameIdentifier	 dvs
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
dvs	TokenNameIdentifier	 dvs
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get the next element 	TokenNameCOMMENT_LINE	get the next element 
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getNextSiblingElement	TokenNameIdentifier	 get Next Sibling Element
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_SIMPLETYPE	TokenNameIdentifier	 ELT  SIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
||	TokenNameOR_OR	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
baseTypeName	TokenNameIdentifier	 base Type Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// it's an error if neither "base/itemType" nor "simpleType" appears 	TokenNameCOMMENT_LINE	it's an error if neither "base/itemType" nor "simpleType" appears 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
?	TokenNameQUESTION	
"src-simple-type.3.b"	TokenNameStringLiteral	src-simple-type.3.b
:	TokenNameCOLON	
"src-simple-type.2.b"	TokenNameStringLiteral	src-simple-type.2.b
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
memberTypes	TokenNameIdentifier	 member Types
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
memberTypes	TokenNameIdentifier	 member Types
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// it's an error if "memberTypes" is empty and no "simpleType" appears 	TokenNameCOMMENT_LINE	it's an error if "memberTypes" is empty and no "simpleType" appears 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"src-union-memberTypes-or-simpleTypes"	TokenNameStringLiteral	src-union-memberTypes-or-simpleTypes
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// error finding "base" or error traversing "simpleType". 	TokenNameCOMMENT_LINE	error finding "base" or error traversing "simpleType". 
// don't need to report an error, since some error has been reported. 	TokenNameCOMMENT_LINE	don't need to report an error, since some error has been reported. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
||	TokenNameOR_OR	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
baseValidator	TokenNameIdentifier	 base Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
restriction	TokenNameIdentifier	 restriction
?	TokenNameQUESTION	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
:	TokenNameCOLON	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// error finding "memberTypes" or error traversing "simpleType". 	TokenNameCOMMENT_LINE	error finding "memberTypes" or error traversing "simpleType". 
// don't need to report an error, since some error has been reported. 	TokenNameCOMMENT_LINE	don't need to report an error, since some error has been reported. 
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
dTValidators	TokenNameIdentifier	 d T Validators
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// item type of list types can't have list content 	TokenNameCOMMENT_LINE	item type of list types can't have list content 
if	TokenNameif	
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
&&	TokenNameAND_AND	
isListDatatype	TokenNameIdentifier	 is List Datatype
(	TokenNameLPAREN	
baseValidator	TokenNameIdentifier	 base Validator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cos-st-restricts.2.1"	TokenNameStringLiteral	cos-st-restricts.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// create the simple type based on the "base" type 	TokenNameCOMMENT_LINE	create the simple type based on the "base" type 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
newDecl	TokenNameIdentifier	 new Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newDecl	TokenNameIdentifier	 new Decl
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeRestriction	TokenNameIdentifier	 create Type Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
finalProperty	TokenNameIdentifier	 final Property
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newDecl	TokenNameIdentifier	 new Decl
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeList	TokenNameIdentifier	 create Type List
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
finalProperty	TokenNameIdentifier	 final Property
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
memberDecls	TokenNameIdentifier	 member Decls
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
dTValidators	TokenNameIdentifier	 d T Validators
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newDecl	TokenNameIdentifier	 new Decl
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeUnion	TokenNameIdentifier	 create Type Union
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
finalProperty	TokenNameIdentifier	 final Property
,	TokenNameCOMMA	
memberDecls	TokenNameIdentifier	 member Decls
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now traverse facets, if it's derived by restriction 	TokenNameCOMMENT_LINE	now traverse facets, if it's derived by restriction 
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
&&	TokenNameAND_AND	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FacetInfo	TokenNameIdentifier	 Facet Info
fi	TokenNameIdentifier	 fi
=	TokenNameEQUAL	
traverseFacets	TokenNameIdentifier	 traverse Facets
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
nodeAfterFacets	TokenNameIdentifier	 node After Facets
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fNamespaceSupport	TokenNameIdentifier	 f Namespace Support
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newDecl	TokenNameIdentifier	 new Decl
.	TokenNameDOT	
applyFacets	TokenNameIdentifier	 apply Facets
(	TokenNameLPAREN	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
facetdata	TokenNameIdentifier	 facetdata
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
fPresentFacets	TokenNameIdentifier	 f Present Facets
,	TokenNameCOMMA	
fi	TokenNameIdentifier	 fi
.	TokenNameDOT	
fFixedFacets	TokenNameIdentifier	 f Fixed Facets
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeFacetException	TokenNameIdentifier	 Invalid Datatype Facet Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Recreate the type, ignoring the facets 	TokenNameCOMMENT_LINE	Recreate the type, ignoring the facets 
newDecl	TokenNameIdentifier	 new Decl
=	TokenNameEQUAL	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeRestriction	TokenNameIdentifier	 create Type Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
finalProperty	TokenNameIdentifier	 final Property
,	TokenNameCOMMA	
baseValidator	TokenNameIdentifier	 base Validator
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
new	TokenNamenew	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
(	TokenNameLPAREN	
annotations	TokenNameIdentifier	 annotations
,	TokenNameCOMMA	
annotations	TokenNameIdentifier	 annotations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// no element should appear after this point 	TokenNameCOMMENT_LINE	no element should appear after this point 
if	TokenNameif	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_RESTRICTION	TokenNameIdentifier	 ELT  RESTRICTION
,	TokenNameCOMMA	
"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))"	TokenNameStringLiteral	(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_LIST	TokenNameIdentifier	 ELT  LIST
,	TokenNameCOMMA	
"(annotation?, (simpleType?))"	TokenNameStringLiteral	(annotation?, (simpleType?))
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
union	TokenNameIdentifier	 union
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"s4s-elt-must-match.1"	TokenNameStringLiteral	s4s-elt-must-match.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ELT_UNION	TokenNameIdentifier	 ELT  UNION
,	TokenNameCOMMA	
"(annotation?, (simpleType*))"	TokenNameStringLiteral	(annotation?, (simpleType*))
,	TokenNameCOMMA	
DOMUtil	TokenNameIdentifier	 DOM Util
.	TokenNameDOT	
getLocalName	TokenNameIdentifier	 get Local Name
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fAttrChecker	TokenNameIdentifier	 f Attr Checker
.	TokenNameDOT	
returnAttrArray	TokenNameIdentifier	 return Attr Array
(	TokenNameLPAREN	
contentAttrs	TokenNameIdentifier	 content Attrs
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return the new type 	TokenNameCOMMENT_LINE	return the new type 
return	TokenNamereturn	
newDecl	TokenNameIdentifier	 new Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//@param: elm - top element 	TokenNameCOMMENT_LINE	@param: elm - top element 
//@param: baseTypeStr - type (base/itemType/memberTypes) 	TokenNameCOMMENT_LINE	@param: baseTypeStr - type (base/itemType/memberTypes) 
//@param: baseRefContext: whether the caller is using this type as a base for restriction, union or list 	TokenNameCOMMENT_LINE	@param: baseRefContext: whether the caller is using this type as a base for restriction, union or list 
//return XSSimpleType available for the baseTypeStr, null if not found or disallowed. 	TokenNameCOMMENT_LINE	return XSSimpleType available for the baseTypeStr, null if not found or disallowed. 
// also throws an error if the base type won't allow itself to be used in this context. 	TokenNameCOMMENT_LINE	also throws an error if the base type won't allow itself to be used in this context. 
// REVISIT: can this code be re-used? 	TokenNameCOMMENT_LINE	REVISIT: can this code be re-used? 
private	TokenNameprivate	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
findDTValidator	TokenNameIdentifier	 find DT Validator
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elm	TokenNameIdentifier	 elm
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
refName	TokenNameIdentifier	 ref Name
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
baseTypeStr	TokenNameIdentifier	 base Type Str
,	TokenNameCOMMA	
short	TokenNameshort	
baseRefContext	TokenNameIdentifier	 base Ref Context
,	TokenNameCOMMA	
XSDocumentInfo	TokenNameIdentifier	 XS Document Info
schemaDoc	TokenNameIdentifier	 schema Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseTypeStr	TokenNameIdentifier	 base Type Str
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
baseType	TokenNameIdentifier	 base Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
getGlobalDecl	TokenNameIdentifier	 get Global Decl
(	TokenNameLPAREN	
schemaDoc	TokenNameIdentifier	 schema Doc
,	TokenNameCOMMA	
XSDHandler	TokenNameIdentifier	 XSD Handler
.	TokenNameDOT	
TYPEDECL_TYPE	TokenNameIdentifier	 TYPEDECL  TYPE
,	TokenNameCOMMA	
baseTypeStr	TokenNameIdentifier	 base Type Str
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cos-st-restricts.1.1"	TokenNameStringLiteral	cos-st-restricts.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
baseTypeStr	TokenNameIdentifier	 base Type Str
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
refName	TokenNameIdentifier	 ref Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if it's a complex type, or if its restriction of anySimpleType 	TokenNameCOMMENT_LINE	if it's a complex type, or if its restriction of anySimpleType 
if	TokenNameif	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
&&	TokenNameAND_AND	
baseRefContext	TokenNameIdentifier	 base Ref Context
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the base type is anySimpleType and the current type is 	TokenNameCOMMENT_LINE	if the base type is anySimpleType and the current type is 
// a S4S built-in type, return null. (not an error). 	TokenNameCOMMENT_LINE	a S4S built-in type, return null. (not an error). 
if	TokenNameif	
(	TokenNameLPAREN	
checkBuiltIn	TokenNameIdentifier	 check Built In
(	TokenNameLPAREN	
refName	TokenNameIdentifier	 ref Name
,	TokenNameCOMMA	
schemaDoc	TokenNameIdentifier	 schema Doc
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cos-st-restricts.1.1"	TokenNameStringLiteral	cos-st-restricts.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
baseTypeStr	TokenNameIdentifier	 base Type Str
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
refName	TokenNameIdentifier	 ref Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
baseType	TokenNameIdentifier	 base Type
.	TokenNameDOT	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&	TokenNameAND	
baseRefContext	TokenNameIdentifier	 base Ref Context
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
baseRefContext	TokenNameIdentifier	 base Ref Context
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"st-props-correct.3"	TokenNameStringLiteral	st-props-correct.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
refName	TokenNameIdentifier	 ref Name
,	TokenNameCOMMA	
baseTypeStr	TokenNameIdentifier	 base Type Str
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseRefContext	TokenNameIdentifier	 base Ref Context
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cos-st-restricts.2.3.1.1"	TokenNameStringLiteral	cos-st-restricts.2.3.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
baseTypeStr	TokenNameIdentifier	 base Type Str
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
refName	TokenNameIdentifier	 ref Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
baseRefContext	TokenNameIdentifier	 base Ref Context
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cos-st-restricts.3.3.1.1"	TokenNameStringLiteral	cos-st-restricts.3.3.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
baseTypeStr	TokenNameIdentifier	 base Type Str
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
refName	TokenNameIdentifier	 ref Name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
elm	TokenNameIdentifier	 elm
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
baseType	TokenNameIdentifier	 base Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check whethe the type denoted by the name and namespace is a S4S 	TokenNameCOMMENT_LINE	check whethe the type denoted by the name and namespace is a S4S 
// built-in type. update fIsBuiltIn at the same time. 	TokenNameCOMMENT_LINE	built-in type. update fIsBuiltIn at the same time. 
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
checkBuiltIn	TokenNameIdentifier	 check Built In
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fIsBuiltIn	TokenNameIdentifier	 f Is Built In
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
fIsBuiltIn	TokenNameIdentifier	 f Is Built In
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// find if a datatype validator is a list or has list datatype member. 	TokenNameCOMMENT_LINE	find if a datatype validator is a list or has list datatype member. 
private	TokenNameprivate	
boolean	TokenNameboolean	
isListDatatype	TokenNameIdentifier	 is List Datatype
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getMemberTypes	TokenNameIdentifier	 get Member Types
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
temp	TokenNameIdentifier	 temp
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
temp	TokenNameIdentifier	 temp
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_LIST	TokenNameIdentifier	 VARIETY  LIST
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//isListDatatype(XSSimpleTypeDecl):boolean 	TokenNameCOMMENT_LINE	isListDatatype(XSSimpleTypeDecl):boolean 
private	TokenNameprivate	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
errorType	TokenNameIdentifier	 error Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
short	TokenNameshort	
refType	TokenNameIdentifier	 ref Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
stringType	TokenNameIdentifier	 string Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getTypeDefinition	TokenNameIdentifier	 get Type Definition
(	TokenNameLPAREN	
"string"	TokenNameStringLiteral	string
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
refType	TokenNameIdentifier	 ref Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
:	TokenNameCOLON	
return	TokenNamereturn	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeRestriction	TokenNameIdentifier	 create Type Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
stringType	TokenNameIdentifier	 string Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
:	TokenNameCOLON	
return	TokenNamereturn	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeList	TokenNameIdentifier	 create Type List
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
stringType	TokenNameIdentifier	 string Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
:	TokenNameCOLON	
return	TokenNamereturn	
fSchemaHandler	TokenNameIdentifier	 f Schema Handler
.	TokenNameDOT	
fDVFactory	TokenNameIdentifier	 f DV Factory
.	TokenNameDOT	
createTypeUnion	TokenNameIdentifier	 create Type Union
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
new	TokenNamenew	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
stringType	TokenNameIdentifier	 string Type
}	TokenNameRBRACE	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//class XSDSimpleTypeTraverser 	TokenNameCOMMENT_LINE	class XSDSimpleTypeTraverser 
