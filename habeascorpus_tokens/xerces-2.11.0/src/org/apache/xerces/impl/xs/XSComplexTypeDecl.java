/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMBuilder	TokenNameIdentifier	 CM Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSComplexTypeDefinition	TokenNameIdentifier	 XS Complex Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticle	TokenNameIdentifier	 XS Particle
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSWildcard	TokenNameIdentifier	 XS Wildcard
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
TypeInfo	TokenNameIdentifier	 Type Info
;	TokenNameSEMICOLON	
/** * The XML representation for a complexType * schema component is a &lt;complexType&gt; element information item * * @xerces.internal * * @author Elena Litani, IBM * @author Sandy Gao, IBM * @version $Id: XSComplexTypeDecl.java 965250 2010-07-18 16:04:58Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 The XML representation for a complexType schema component is a &lt;complexType&gt; element information item * @xerces.internal * @author Elena Litani, IBM @author Sandy Gao, IBM @version $Id: XSComplexTypeDecl.java 965250 2010-07-18 16:04:58Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
implements	TokenNameimplements	
XSComplexTypeDefinition	TokenNameIdentifier	 XS Complex Type Definition
,	TokenNameCOMMA	
TypeInfo	TokenNameIdentifier	 Type Info
{	TokenNameLBRACE	
// name of the complexType 	TokenNameCOMMENT_LINE	name of the complexType 
String	TokenNameIdentifier	 String
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// target namespace of the complexType 	TokenNameCOMMENT_LINE	target namespace of the complexType 
String	TokenNameIdentifier	 String
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// base type of the complexType 	TokenNameCOMMENT_LINE	base type of the complexType 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// derivation method of the complexType 	TokenNameCOMMENT_LINE	derivation method of the complexType 
short	TokenNameshort	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
// final set of the complexType 	TokenNameCOMMENT_LINE	final set of the complexType 
short	TokenNameshort	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
// block set (prohibited substitution) of the complexType 	TokenNameCOMMENT_LINE	block set (prohibited substitution) of the complexType 
short	TokenNameshort	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
// flags: whether is abstract; whether contains ID type; 	TokenNameCOMMENT_LINE	flags: whether is abstract; whether contains ID type; 
// whether it's an anonymous tpye 	TokenNameCOMMENT_LINE	whether it's an anonymous tpye 
short	TokenNameshort	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// the attribute group that holds the attribute uses and attribute wildcard 	TokenNameCOMMENT_LINE	the attribute group that holds the attribute uses and attribute wildcard 
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
fAttrGrp	TokenNameIdentifier	 f Attr Grp
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the content type of the complexType 	TokenNameCOMMENT_LINE	the content type of the complexType 
short	TokenNameshort	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
;	TokenNameSEMICOLON	
// if the content type is simple, then the corresponding simpleType 	TokenNameCOMMENT_LINE	if the content type is simple, then the corresponding simpleType 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// if the content type is element or mixed, the particle 	TokenNameCOMMENT_LINE	if the content type is element or mixed, the particle 
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// if there is a particle, the content model corresponding to that particle 	TokenNameCOMMENT_LINE	if there is a particle, the content model corresponding to that particle 
XSCMValidator	TokenNameIdentifier	 XSCM Validator
fCMValidator	TokenNameIdentifier	 f CM Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the content model that's sufficient for computing UPA 	TokenNameCOMMENT_LINE	the content model that's sufficient for computing UPA 
XSCMValidator	TokenNameIdentifier	 XSCM Validator
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// list of annotations affiliated with this type 	TokenNameCOMMENT_LINE	list of annotations affiliated with this type 
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// The namespace schema information item corresponding to the target namespace 	TokenNameCOMMENT_LINE	The namespace schema information item corresponding to the target namespace 
// of the complex type definition, if it is globally declared; or null otherwise. 	TokenNameCOMMENT_LINE	of the complex type definition, if it is globally declared; or null otherwise. 
private	TokenNameprivate	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// DOM Level 3 TypeInfo Derivation Method constants 	TokenNameCOMMENT_LINE	DOM Level 3 TypeInfo Derivation Method constants 
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_ANY	TokenNameIdentifier	 DERIVATION  ANY
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// do-nothing constructor for now. 	TokenNameCOMMENT_LINE	do-nothing constructor for now. 
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setValues	TokenNameIdentifier	 set Values
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
targetNamespace	TokenNameIdentifier	 target Namespace
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
baseType	TokenNameIdentifier	 base Type
,	TokenNameCOMMA	
short	TokenNameshort	
derivedBy	TokenNameIdentifier	 derived By
,	TokenNameCOMMA	
short	TokenNameshort	
schemaFinal	TokenNameIdentifier	 schema Final
,	TokenNameCOMMA	
short	TokenNameshort	
block	TokenNameIdentifier	 block
,	TokenNameCOMMA	
short	TokenNameshort	
contentType	TokenNameIdentifier	 content Type
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isAbstract	TokenNameIdentifier	 is Abstract
,	TokenNameCOMMA	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
attrGrp	TokenNameIdentifier	 attr Grp
,	TokenNameCOMMA	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
simpleType	TokenNameIdentifier	 simple Type
,	TokenNameCOMMA	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
particle	TokenNameIdentifier	 particle
,	TokenNameCOMMA	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
annotations	TokenNameIdentifier	 annotations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
targetNamespace	TokenNameIdentifier	 target Namespace
;	TokenNameSEMICOLON	
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
baseType	TokenNameIdentifier	 base Type
;	TokenNameSEMICOLON	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
derivedBy	TokenNameIdentifier	 derived By
;	TokenNameSEMICOLON	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
schemaFinal	TokenNameIdentifier	 schema Final
;	TokenNameSEMICOLON	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
block	TokenNameIdentifier	 block
;	TokenNameSEMICOLON	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
contentType	TokenNameIdentifier	 content Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isAbstract	TokenNameIdentifier	 is Abstract
)	TokenNameRPAREN	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
|=	TokenNameOR_EQUAL	
CT_IS_ABSTRACT	TokenNameIdentifier	 CT  IS  ABSTRACT
;	TokenNameSEMICOLON	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
=	TokenNameEQUAL	
attrGrp	TokenNameIdentifier	 attr Grp
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
simpleType	TokenNameIdentifier	 simple Type
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
particle	TokenNameIdentifier	 particle
;	TokenNameSEMICOLON	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
annotations	TokenNameIdentifier	 annotations
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setName	TokenNameIdentifier	 set Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTypeName	TokenNameIdentifier	 get Type Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fName	TokenNameIdentifier	 f Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
short	TokenNameshort	
getFinalSet	TokenNameIdentifier	 get Final Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fFinal	TokenNameIdentifier	 f Final
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTargetNamespace	TokenNameIdentifier	 get Target Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// flags for the misc flag 	TokenNameCOMMENT_LINE	flags for the misc flag 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
CT_IS_ABSTRACT	TokenNameIdentifier	 CT  IS  ABSTRACT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
CT_HAS_TYPE_ID	TokenNameIdentifier	 CT  HAS  TYPE  ID
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
CT_IS_ANONYMOUS	TokenNameIdentifier	 CT  IS  ANONYMOUS
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// methods to get/set misc flag 	TokenNameCOMMENT_LINE	methods to get/set misc flag 
public	TokenNamepublic	
boolean	TokenNameboolean	
containsTypeID	TokenNameIdentifier	 contains Type ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
&	TokenNameAND	
CT_HAS_TYPE_ID	TokenNameIdentifier	 CT  HAS  TYPE  ID
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setIsAbstractType	TokenNameIdentifier	 set Is Abstract Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
|=	TokenNameOR_EQUAL	
CT_IS_ABSTRACT	TokenNameIdentifier	 CT  IS  ABSTRACT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setContainsTypeID	TokenNameIdentifier	 set Contains Type ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
|=	TokenNameOR_EQUAL	
CT_HAS_TYPE_ID	TokenNameIdentifier	 CT  HAS  TYPE  ID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setIsAnonymous	TokenNameIdentifier	 set Is Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
|=	TokenNameOR_EQUAL	
CT_IS_ANONYMOUS	TokenNameIdentifier	 CT  IS  ANONYMOUS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
CMBuilder	TokenNameIdentifier	 CM Builder
cmBuilder	TokenNameIdentifier	 cm Builder
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
cmBuilder	TokenNameIdentifier	 cm Builder
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
synchronized	TokenNamesynchronized	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
CMBuilder	TokenNameIdentifier	 CM Builder
cmBuilder	TokenNameIdentifier	 cm Builder
,	TokenNameCOMMA	
boolean	TokenNameboolean	
forUPA	TokenNameIdentifier	 for UPA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCMValidator	TokenNameIdentifier	 f CM Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
forUPA	TokenNameIdentifier	 for UPA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
=	TokenNameEQUAL	
cmBuilder	TokenNameIdentifier	 cm Builder
.	TokenNameDOT	
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
.	TokenNameDOT	
isCompactedForUPA	TokenNameIdentifier	 is Compacted For UPA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCMValidator	TokenNameIdentifier	 f CM Validator
=	TokenNameEQUAL	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fCMValidator	TokenNameIdentifier	 f CM Validator
=	TokenNameEQUAL	
cmBuilder	TokenNameIdentifier	 cm Builder
.	TokenNameDOT	
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
fCMValidator	TokenNameIdentifier	 f CM Validator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// some utility methods: 	TokenNameCOMMENT_LINE	some utility methods: 
// return the attribute group for this complex type 	TokenNameCOMMENT_LINE	return the attribute group for this complex type 
public	TokenNamepublic	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
appendTypeInfo	TokenNameIdentifier	 append Type Info
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
appendTypeInfo	TokenNameIdentifier	 append Type Info
(	TokenNameLPAREN	
StringBuffer	TokenNameIdentifier	 String Buffer
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
contentType	TokenNameIdentifier	 content Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"EMPTY"	TokenNameStringLiteral	EMPTY
,	TokenNameCOMMA	
"SIMPLE"	TokenNameStringLiteral	SIMPLE
,	TokenNameCOMMA	
"ELEMENT"	TokenNameStringLiteral	ELEMENT
,	TokenNameCOMMA	
"MIXED"	TokenNameStringLiteral	MIXED
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
derivedBy	TokenNameIdentifier	 derived By
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"EMPTY"	TokenNameStringLiteral	EMPTY
,	TokenNameCOMMA	
"EXTENSION"	TokenNameStringLiteral	EXTENSION
,	TokenNameCOMMA	
"RESTRICTION"	TokenNameStringLiteral	RESTRICTION
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Complex type name='"	TokenNameStringLiteral	Complex type name='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getTypeName	TokenNameIdentifier	 get Type Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" base type name='"	TokenNameStringLiteral	 base type name='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" content type='"	TokenNameStringLiteral	 content type='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
contentType	TokenNameIdentifier	 content Type
[	TokenNameLBRACKET	
fContentType	TokenNameIdentifier	 f Content Type
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" isAbstract='"	TokenNameStringLiteral	 isAbstract='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
getAbstract	TokenNameIdentifier	 get Abstract
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" hasTypeId='"	TokenNameStringLiteral	 hasTypeId='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
containsTypeID	TokenNameIdentifier	 contains Type ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" final='"	TokenNameStringLiteral	 final='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fFinal	TokenNameIdentifier	 f Final
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" block='"	TokenNameStringLiteral	 block='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fBlock	TokenNameIdentifier	 f Block
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" particle='"	TokenNameStringLiteral	 particle='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fParticle	TokenNameIdentifier	 f Particle
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"', "	TokenNameStringLiteral	', 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" derivedBy='"	TokenNameStringLiteral	 derivedBy='
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
derivedBy	TokenNameIdentifier	 derived By
[	TokenNameLBRACKET	
fDerivedBy	TokenNameIdentifier	 f Derived By
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"'. "	TokenNameStringLiteral	'. 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
derivedFromType	TokenNameIdentifier	 derived From Type
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
ancestor	TokenNameIdentifier	 ancestor
,	TokenNameCOMMA	
short	TokenNameshort	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ancestor is null, retur false 	TokenNameCOMMENT_LINE	ancestor is null, retur false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestor	TokenNameIdentifier	 ancestor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
if	TokenNameif	
(	TokenNameLPAREN	
ancestor	TokenNameIdentifier	 ancestor
==	TokenNameEQUAL_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// recursively get base, and compare it with ancestor 	TokenNameCOMMENT_LINE	recursively get base, and compare it with ancestor 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
ancestor	TokenNameIdentifier	 ancestor
&&	TokenNameAND_AND	
// compare with ancestor 	TokenNameCOMMENT_LINE	compare with ancestor 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
&&	TokenNameAND_AND	
// reached anySimpleType 	TokenNameCOMMENT_LINE	reached anySimpleType 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reached anyType 	TokenNameCOMMENT_LINE	reached anyType 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
ancestor	TokenNameIdentifier	 ancestor
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
derivedFrom	TokenNameIdentifier	 derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
short	TokenNameshort	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ancestor is null, retur false 	TokenNameCOMMENT_LINE	ancestor is null, retur false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// recursively get base, and compare it with ancestor 	TokenNameCOMMENT_LINE	recursively get base, and compare it with ancestor 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
// compare with ancestor 	TokenNameCOMMENT_LINE	compare with ancestor 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
&&	TokenNameAND_AND	
// reached anySimpleType 	TokenNameCOMMENT_LINE	reached anySimpleType 
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reached anyType 	TokenNameCOMMENT_LINE	reached anyType 
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnySimpleType	TokenNameIdentifier	 f Any Simple Type
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another given the the name, namespace * and derivation method. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param derivationMethod * The derivation method * * @return boolean True if the ancestor type is derived from the reference * type by the specifiied derivation method. */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another given the the name, namespace and derivation method. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param derivationMethod The derivation method * @return boolean True if the ancestor type is derived from the reference type by the specifiied derivation method. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ancestor is null, retur false 	TokenNameCOMMENT_LINE	ancestor is null, retur false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ancestor is anyType, return true 	TokenNameCOMMENT_LINE	ancestor is anyType, return true 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
==	TokenNameEQUAL_EQUAL	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
&&	TokenNameAND_AND	
derivationMethod	TokenNameIdentifier	 derivation Method
==	TokenNameEQUAL_EQUAL	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// restriction 	TokenNameCOMMENT_LINE	restriction 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// extension 	TokenNameCOMMENT_LINE	extension 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByExtension	TokenNameIdentifier	 is Derived By Extension
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// list or union 	TokenNameCOMMENT_LINE	list or union 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestorName	TokenNameIdentifier	 ancestor Name
=	TokenNameEQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYSIMPLETYPE	TokenNameIdentifier	 ATTVAL  ANYSIMPLETYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
fName	TokenNameIdentifier	 f Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fBaseType	TokenNameIdentifier	 f Base Type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
)	TokenNameRPAREN	
.	TokenNameDOT	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fBaseType	TokenNameIdentifier	 f Base Type
instanceof	TokenNameinstanceof	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fBaseType	TokenNameIdentifier	 f Base Type
)	TokenNameRPAREN	
.	TokenNameDOT	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// If the value of the parameter is 0 i.e. no bit (corresponding to 	TokenNameCOMMENT_LINE	If the value of the parameter is 0 i.e. no bit (corresponding to 
// restriction, list, extension or union) is set to 1 for the 	TokenNameCOMMENT_LINE	restriction, list, extension or union) is set to 1 for the 
// derivationMethod parameter. 	TokenNameCOMMENT_LINE	derivationMethod parameter. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_LIST	TokenNameIdentifier	 DERIVATION  LIST
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_UNION	TokenNameIdentifier	 DERIVATION  UNION
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isDerivedByAny	TokenNameIdentifier	 is Derived By Any
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by any combination of * restriction, list ir union. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param derivationMethod * A short indication the method of derivation * @param type * The reference type definition * * @return boolean True if the type is derived by any method for the * reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by any combination of restriction, list ir union. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param derivationMethod A short indication the method of derivation @param type The reference type definition * @return boolean True if the type is derived by any method for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByAny	TokenNameIdentifier	 is Derived By Any
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
derivedFrom	TokenNameIdentifier	 derived From
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
oldType	TokenNameIdentifier	 old Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If the ancestor type is reached or is the same as this type. 	TokenNameCOMMENT_LINE	If the ancestor type is reached or is the same as this type. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
derivedFrom	TokenNameIdentifier	 derived From
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check if this type is derived from the base by restriction or 	TokenNameCOMMENT_LINE	Check if this type is derived from the base by restriction or 
// extension 	TokenNameCOMMENT_LINE	extension 
if	TokenNameif	
(	TokenNameLPAREN	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isDerivedByExtension	TokenNameIdentifier	 is Derived By Extension
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
derivedFrom	TokenNameIdentifier	 derived From
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by restriction. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param derivationMethod * A short indication the method of derivation * * @param type * The reference type definition * * @return boolean True if the type is derived by restriciton for the * reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by restriction. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param derivationMethod A short indication the method of derivation * @param type The reference type definition * @return boolean True if the type is derived by restriciton for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByRestriction	TokenNameIdentifier	 is Derived By Restriction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
oldType	TokenNameIdentifier	 old Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ancestor is anySimpleType, return false 	TokenNameCOMMENT_LINE	ancestor is anySimpleType, return false 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYSIMPLETYPE	TokenNameIdentifier	 ATTVAL  ANYSIMPLETYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if the name and namespace of this type is the same as the 	TokenNameCOMMENT_LINE	if the name and namespace of this type is the same as the 
// ancestor return true 	TokenNameCOMMENT_LINE	ancestor return true 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the base type is a complexType with simpleContent 	TokenNameCOMMENT_LINE	If the base type is a complexType with simpleContent 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestorName	TokenNameIdentifier	 ancestor Name
=	TokenNameEQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYSIMPLETYPE	TokenNameIdentifier	 ATTVAL  ANYSIMPLETYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// If the base type is a complex type 	TokenNameCOMMENT_LINE	If the base type is a complex type 
// Every derivation step till the base type should be 	TokenNameCOMMENT_LINE	Every derivation step till the base type should be 
// restriction. If not return false 	TokenNameCOMMENT_LINE	restriction. If not return false 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getDerivationMethod	TokenNameIdentifier	 get Derivation Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Checks if a type is derived from another by extension. See: * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * * @param ancestorNS * The namspace of the ancestor type declaration * @param ancestorName * The name of the ancestor type declaration * @param derivationMethod * A short indication the method of derivation * @param type * The reference type definition * * @return boolean True if the type is derived by extension for the * reference type */	TokenNameCOMMENT_JAVADOC	 Checks if a type is derived from another by extension. See: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#TypeInfo-isDerivedFrom * @param ancestorNS The namspace of the ancestor type declaration @param ancestorName The name of the ancestor type declaration @param derivationMethod A short indication the method of derivation @param type The reference type definition * @return boolean True if the type is derived by extension for the reference type 
private	TokenNameprivate	
boolean	TokenNameboolean	
isDerivedByExtension	TokenNameIdentifier	 is Derived By Extension
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
,	TokenNameCOMMA	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
extension	TokenNameIdentifier	 extension
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
!=	TokenNameNOT_EQUAL	
oldType	TokenNameIdentifier	 old Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If ancestor is anySimpleType return false. 	TokenNameCOMMENT_LINE	If ancestor is anySimpleType return false. 
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYSIMPLETYPE	TokenNameIdentifier	 ATTVAL  ANYSIMPLETYPE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// returns true if atleast one derivation step was extension 	TokenNameCOMMENT_LINE	returns true if atleast one derivation step was extension 
return	TokenNamereturn	
extension	TokenNameIdentifier	 extension
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If the base type is a complexType with simpleContent 	TokenNameCOMMENT_LINE	If the base type is a complexType with simpleContent 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
ancestorName	TokenNameIdentifier	 ancestor Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYTYPE	TokenNameIdentifier	 ATTVAL  ANYTYPE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestorName	TokenNameIdentifier	 ancestor Name
=	TokenNameEQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_ANYSIMPLETYPE	TokenNameIdentifier	 ATTVAL  ANYSIMPLETYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// derivationMethod extension will always return false for a 	TokenNameCOMMENT_LINE	derivationMethod extension will always return false for a 
// simpleType, 	TokenNameCOMMENT_LINE	simpleType, 
// we treat it like a restriction 	TokenNameCOMMENT_LINE	we treat it like a restriction 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
extension	TokenNameIdentifier	 extension
&	TokenNameAND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
(	TokenNameLPAREN	
derivationMethod	TokenNameIdentifier	 derivation Method
&	TokenNameAND	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
extension	TokenNameIdentifier	 extension
&	TokenNameAND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
ancestorNS	TokenNameIdentifier	 ancestor NS
,	TokenNameCOMMA	
ancestorName	TokenNameIdentifier	 ancestor Name
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// If the base type is a complex type 	TokenNameCOMMENT_LINE	If the base type is a complex type 
// At least one derivation step upto the ancestor type should be 	TokenNameCOMMENT_LINE	At least one derivation step upto the ancestor type should be 
// extension. 	TokenNameCOMMENT_LINE	extension. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
getDerivationMethod	TokenNameIdentifier	 get Derivation Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_EXTENSION	TokenNameIdentifier	 DERIVATION  EXTENSION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
extension	TokenNameIdentifier	 extension
=	TokenNameEQUAL	
extension	TokenNameIdentifier	 extension
|	TokenNameOR	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fName	TokenNameIdentifier	 f Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fBaseType	TokenNameIdentifier	 f Base Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fDerivedBy	TokenNameIdentifier	 f Derived By
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_RESTRICTION	TokenNameIdentifier	 DERIVATION  RESTRICTION
;	TokenNameSEMICOLON	
fFinal	TokenNameIdentifier	 f Final
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
fBlock	TokenNameIdentifier	 f Block
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// reset attribute group 	TokenNameCOMMENT_LINE	reset attribute group 
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContentType	TokenNameIdentifier	 f Content Type
=	TokenNameEQUAL	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
;	TokenNameSEMICOLON	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fParticle	TokenNameIdentifier	 f Particle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fCMValidator	TokenNameIdentifier	 f CM Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fUPACMValidator	TokenNameIdentifier	 f UPACM Validator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// help out the garbage collector 	TokenNameCOMMENT_LINE	help out the garbage collector 
fAnnotations	TokenNameIdentifier	 f Annotations
.	TokenNameDOT	
clearXSObjectList	TokenNameIdentifier	 clear XS Object List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fAnnotations	TokenNameIdentifier	 f Annotations
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the type of the object, i.e ELEMENT_DECLARATION. */	TokenNameCOMMENT_JAVADOC	 Get the type of the object, i.e ELEMENT_DECLARATION. 
public	TokenNamepublic	
short	TokenNameshort	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
TYPE_DEFINITION	TokenNameIdentifier	 TYPE  DEFINITION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The <code>name</code> of this <code>XSObject</code> depending on the * <code>XSObject</code> type. */	TokenNameCOMMENT_JAVADOC	 The <code>name</code> of this <code>XSObject</code> depending on the <code>XSObject</code> type. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fName	TokenNameIdentifier	 f Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A boolean that specifies if the type definition is anonymous. * Convenience attribute. This is a field is not part of * XML Schema component model. */	TokenNameCOMMENT_JAVADOC	 A boolean that specifies if the type definition is anonymous. Convenience attribute. This is a field is not part of XML Schema component model. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getAnonymous	TokenNameIdentifier	 get Anonymous
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
&	TokenNameAND	
CT_IS_ANONYMOUS	TokenNameIdentifier	 CT  IS  ANONYMOUS
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The namespace URI of this node, or <code>null</code> if it is * unspecified. defines how a namespace URI is attached to schema * components. */	TokenNameCOMMENT_JAVADOC	 The namespace URI of this node, or <code>null</code> if it is unspecified. defines how a namespace URI is attached to schema components. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {base type definition} Either a simple type definition or a complex * type definition. */	TokenNameCOMMENT_JAVADOC	 {base type definition} Either a simple type definition or a complex type definition. 
public	TokenNamepublic	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
getBaseType	TokenNameIdentifier	 get Base Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fBaseType	TokenNameIdentifier	 f Base Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {derivation method} Either extension or restriction. The valid constant * value for this <code>XSConstants</code> EXTENTION, RESTRICTION. */	TokenNameCOMMENT_JAVADOC	 {derivation method} Either extension or restriction. The valid constant value for this <code>XSConstants</code> EXTENTION, RESTRICTION. 
public	TokenNamepublic	
short	TokenNameshort	
getDerivationMethod	TokenNameIdentifier	 get Derivation Method
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDerivedBy	TokenNameIdentifier	 f Derived By
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {final} For complex type definition it is a subset of {extension, * restriction}. For simple type definition it is a subset of * {extension, list, restriction, union}. * @param derivation Extension, restriction, list, union constants * (defined in <code>XSConstants</code>). * @return True if derivation is in the final set, otherwise false. */	TokenNameCOMMENT_JAVADOC	 {final} For complex type definition it is a subset of {extension, restriction}. For simple type definition it is a subset of {extension, list, restriction, union}. @param derivation Extension, restriction, list, union constants (defined in <code>XSConstants</code>). @return True if derivation is in the final set, otherwise false. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isFinal	TokenNameIdentifier	 is Final
(	TokenNameLPAREN	
short	TokenNameshort	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fFinal	TokenNameIdentifier	 f Final
&	TokenNameAND	
derivation	TokenNameIdentifier	 derivation
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {final} For complex type definition it is a subset of {extension, restriction}. * * @return A bit flag that represents: * {extension, restriction) or none for complexTypes; * {extension, list, restriction, union} or none for simpleTypes; */	TokenNameCOMMENT_JAVADOC	 {final} For complex type definition it is a subset of {extension, restriction}. * @return A bit flag that represents: {extension, restriction) or none for complexTypes; {extension, list, restriction, union} or none for simpleTypes; 
public	TokenNamepublic	
short	TokenNameshort	
getFinal	TokenNameIdentifier	 get Final
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fFinal	TokenNameIdentifier	 f Final
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {abstract} A boolean. Complex types for which {abstract} is true must * not be used as the {type definition} for the validation of element * information items. */	TokenNameCOMMENT_JAVADOC	 {abstract} A boolean. Complex types for which {abstract} is true must not be used as the {type definition} for the validation of element information items. 
public	TokenNamepublic	
boolean	TokenNameboolean	
getAbstract	TokenNameIdentifier	 get Abstract
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fMiscFlags	TokenNameIdentifier	 f Misc Flags
&	TokenNameAND	
CT_IS_ABSTRACT	TokenNameIdentifier	 CT  IS  ABSTRACT
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {attribute uses} A set of attribute uses. */	TokenNameCOMMENT_JAVADOC	 {attribute uses} A set of attribute uses. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {attribute wildcard} Optional. A wildcard. */	TokenNameCOMMENT_JAVADOC	 {attribute wildcard} Optional. A wildcard. 
public	TokenNamepublic	
XSWildcard	TokenNameIdentifier	 XS Wildcard
getAttributeWildcard	TokenNameIdentifier	 get Attribute Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
getAttributeWildcard	TokenNameIdentifier	 get Attribute Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {content type} One of empty, a simple type definition (see * <code>simpleType</code>, or mixed, element-only (see * <code>cmParticle</code>). */	TokenNameCOMMENT_JAVADOC	 {content type} One of empty, a simple type definition (see <code>simpleType</code>, or mixed, element-only (see <code>cmParticle</code>). 
public	TokenNamepublic	
short	TokenNameshort	
getContentType	TokenNameIdentifier	 get Content Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fContentType	TokenNameIdentifier	 f Content Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A simple type definition corresponding to simple content model, * otherwise <code>null</code> */	TokenNameCOMMENT_JAVADOC	 A simple type definition corresponding to simple content model, otherwise <code>null</code> 
public	TokenNamepublic	
XSSimpleTypeDefinition	TokenNameIdentifier	 XS Simple Type Definition
getSimpleType	TokenNameIdentifier	 get Simple Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A particle for mixed or element-only content model, otherwise * <code>null</code> */	TokenNameCOMMENT_JAVADOC	 A particle for mixed or element-only content model, otherwise <code>null</code> 
public	TokenNamepublic	
XSParticle	TokenNameIdentifier	 XS Particle
getParticle	TokenNameIdentifier	 get Particle
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fParticle	TokenNameIdentifier	 f Particle
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {prohibited substitutions} A subset of {extension, restriction}. * @param prohibited extention or restriction constants (defined in * <code>XSConstants</code>). * @return True if prohibited is a prohibited substitution, otherwise * false. */	TokenNameCOMMENT_JAVADOC	 {prohibited substitutions} A subset of {extension, restriction}. @param prohibited extention or restriction constants (defined in <code>XSConstants</code>). @return True if prohibited is a prohibited substitution, otherwise false. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isProhibitedSubstitution	TokenNameIdentifier	 is Prohibited Substitution
(	TokenNameLPAREN	
short	TokenNameshort	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fBlock	TokenNameIdentifier	 f Block
&	TokenNameAND	
prohibited	TokenNameIdentifier	 prohibited
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * {prohibited substitutions} * * @return A bit flag corresponding to prohibited substitutions */	TokenNameCOMMENT_JAVADOC	 {prohibited substitutions} * @return A bit flag corresponding to prohibited substitutions 
public	TokenNamepublic	
short	TokenNameshort	
getProhibitedSubstitutions	TokenNameIdentifier	 get Prohibited Substitutions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fBlock	TokenNameIdentifier	 f Block
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Optional. Annotation. */	TokenNameCOMMENT_JAVADOC	 Optional. Annotation. 
public	TokenNamepublic	
XSObjectList	TokenNameIdentifier	 XS Object List
getAnnotations	TokenNameIdentifier	 get Annotations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
fAnnotations	TokenNameIdentifier	 f Annotations
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fAnnotations	TokenNameIdentifier	 f Annotations
:	TokenNameCOLON	
XSObjectListImpl	TokenNameIdentifier	 XS Object List Impl
.	TokenNameDOT	
EMPTY_LIST	TokenNameIdentifier	 EMPTY  LIST
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see org.apache.xerces.xs.XSObject#getNamespaceItem() */	TokenNameCOMMENT_JAVADOC	 @see org.apache.xerces.xs.XSObject#getNamespaceItem() 
public	TokenNamepublic	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
getNamespaceItem	TokenNameIdentifier	 get Namespace Item
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
setNamespaceItem	TokenNameIdentifier	 set Namespace Item
(	TokenNameLPAREN	
XSNamespaceItem	TokenNameIdentifier	 XS Namespace Item
namespaceItem	TokenNameIdentifier	 namespace Item
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaceItem	TokenNameIdentifier	 f Namespace Item
=	TokenNameEQUAL	
namespaceItem	TokenNameIdentifier	 namespace Item
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* (non-Javadoc) * @see org.apache.xerces.xs.XSComplexTypeDefinition#getAttributeUse(java.lang.String, java.lang.String) */	TokenNameCOMMENT_BLOCK	 (non-Javadoc) @see org.apache.xerces.xs.XSComplexTypeDefinition#getAttributeUse(java.lang.String, java.lang.String) 
public	TokenNamepublic	
XSAttributeUse	TokenNameIdentifier	 XS Attribute Use
getAttributeUse	TokenNameIdentifier	 get Attribute Use
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fAttrGrp	TokenNameIdentifier	 f Attr Grp
.	TokenNameDOT	
getAttributeUse	TokenNameIdentifier	 get Attribute Use
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTypeNamespace	TokenNameIdentifier	 get Type Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNamespace	TokenNameIdentifier	 get Namespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isDerivedFrom	TokenNameIdentifier	 is Derived From
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
typeNamespaceArg	TokenNameIdentifier	 type Namespace Arg
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
typeNameArg	TokenNameIdentifier	 type Name Arg
,	TokenNameCOMMA	
int	TokenNameint	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isDOMDerivedFrom	TokenNameIdentifier	 is DOM Derived From
(	TokenNameLPAREN	
typeNamespaceArg	TokenNameIdentifier	 type Namespace Arg
,	TokenNameCOMMA	
typeNameArg	TokenNameIdentifier	 type Name Arg
,	TokenNameCOMMA	
derivationMethod	TokenNameIdentifier	 derivation Method
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class XSComplexTypeDecl 	TokenNameCOMMENT_LINE	class XSComplexTypeDecl 
