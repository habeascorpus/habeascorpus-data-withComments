/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cli	TokenNameIdentifier	 cli
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
InputStream	TokenNameIdentifier	 Input Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
InetAddress	TokenNameIdentifier	 Inet Address
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
charset	TokenNameIdentifier	 charset
.	TokenNameDOT	
CharacterCodingException	TokenNameIdentifier	 Character Coding Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Charsets	TokenNameIdentifier	 Charsets
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Predicate	TokenNameIdentifier	 Predicate
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Collections2	TokenNameIdentifier	 Collections2
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Iterables	TokenNameIdentifier	 Iterables
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
antlr	TokenNameIdentifier	 antlr
.	TokenNameDOT	
runtime	TokenNameIdentifier	 runtime
.	TokenNameDOT	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
Tree	TokenNameIdentifier	 Tree
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
auth	TokenNameIdentifier	 auth
.	TokenNameDOT	
IAuthenticator	TokenNameIdentifier	 I Authenticator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
ColumnFamilyStoreMBean	TokenNameIdentifier	 Column Family Store M Bean
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
CompactionManagerMBean	TokenNameIdentifier	 Compaction Manager M Bean
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
OperationType	TokenNameIdentifier	 Operation Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
locator	TokenNameIdentifier	 locator
.	TokenNameDOT	
SimpleSnitch	TokenNameIdentifier	 Simple Snitch
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
NodeProbe	TokenNameIdentifier	 Node Probe
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FBUtilities	TokenNameIdentifier	 FB Utilities
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
UUIDGen	TokenNameIdentifier	 UUID Gen
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
TBaseHelper	TokenNameIdentifier	 T Base Helper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
TException	TokenNameIdentifier	 T Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
codehaus	TokenNameIdentifier	 codehaus
.	TokenNameDOT	
jackson	TokenNameIdentifier	 jackson
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
yaml	TokenNameIdentifier	 yaml
.	TokenNameDOT	
snakeyaml	TokenNameIdentifier	 snakeyaml
.	TokenNameDOT	
Loader	TokenNameIdentifier	 Loader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
yaml	TokenNameIdentifier	 yaml
.	TokenNameDOT	
snakeyaml	TokenNameIdentifier	 snakeyaml
.	TokenNameDOT	
TypeDescription	TokenNameIdentifier	 Type Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
yaml	TokenNameIdentifier	 yaml
.	TokenNameDOT	
snakeyaml	TokenNameIdentifier	 snakeyaml
.	TokenNameDOT	
Yaml	TokenNameIdentifier	 Yaml
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
yaml	TokenNameIdentifier	 yaml
.	TokenNameDOT	
snakeyaml	TokenNameIdentifier	 snakeyaml
.	TokenNameDOT	
constructor	TokenNameIdentifier	 constructor
.	TokenNameDOT	
Constructor	TokenNameIdentifier	 Constructor
;	TokenNameSEMICOLON	
// Cli Client Side Library 	TokenNameCOMMENT_LINE	Cli Client Side Library 
public	TokenNamepublic	
class	TokenNameclass	
CliClient	TokenNameIdentifier	 Cli Client
{	TokenNameLBRACE	
/** * Available value conversion functions * Used by convertValueByFunction(Tree functionCall) method */	TokenNameCOMMENT_JAVADOC	 Available value conversion functions Used by convertValueByFunction(Tree functionCall) method 
public	TokenNamepublic	
enum	TokenNameenum	
Function	TokenNameIdentifier	 Function
{	TokenNameLBRACE	
BYTES	TokenNameIdentifier	 BYTES
(	TokenNameLPAREN	
BytesType	TokenNameIdentifier	 Bytes Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
INTEGER	TokenNameIdentifier	 INTEGER
(	TokenNameLPAREN	
IntegerType	TokenNameIdentifier	 Integer Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
LONG	TokenNameIdentifier	 LONG
(	TokenNameLPAREN	
LongType	TokenNameIdentifier	 Long Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
INT	TokenNameIdentifier	 INT
(	TokenNameLPAREN	
Int32Type	TokenNameIdentifier	 Int32 Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
LEXICALUUID	TokenNameIdentifier	 LEXICALUUID
(	TokenNameLPAREN	
LexicalUUIDType	TokenNameIdentifier	 Lexical UUID Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
TIMEUUID	TokenNameIdentifier	 TIMEUUID
(	TokenNameLPAREN	
TimeUUIDType	TokenNameIdentifier	 Time UUID Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
UTF8	TokenNameIdentifier	 UT F8
(	TokenNameLPAREN	
UTF8Type	TokenNameIdentifier	 UT F8 Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ASCII	TokenNameIdentifier	 ASCII
(	TokenNameLPAREN	
AsciiType	TokenNameIdentifier	 Ascii Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
DOUBLE	TokenNameIdentifier	 DOUBLE
(	TokenNameLPAREN	
DoubleType	TokenNameIdentifier	 Double Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
,	TokenNameCOMMA	
COUNTERCOLUMN	TokenNameIdentifier	 COUNTERCOLUMN
(	TokenNameLPAREN	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
;	TokenNameSEMICOLON	
Function	TokenNameIdentifier	 Function
(	TokenNameLPAREN	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
validator	TokenNameIdentifier	 validator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getValidator	TokenNameIdentifier	 get Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
.	TokenNameDOT	
validator	TokenNameIdentifier	 validator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
getFunctionNames	TokenNameIdentifier	 get Function Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Function	TokenNameIdentifier	 Function
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
functions	TokenNameIdentifier	 functions
=	TokenNameEQUAL	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuilder	TokenNameIdentifier	 String Builder
functionNames	TokenNameIdentifier	 function Names
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
functions	TokenNameIdentifier	 functions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
currentName	TokenNameIdentifier	 current Name
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
functions	TokenNameIdentifier	 functions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
functionNames	TokenNameIdentifier	 function Names
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
currentName	TokenNameIdentifier	 current Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
functions	TokenNameIdentifier	 functions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
", "	TokenNameStringLiteral	, 
:	TokenNameCOLON	
"."	TokenNameStringLiteral	.
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
functionNames	TokenNameIdentifier	 function Names
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * the <i>add keyspace</i> command requires a list of arguments, * this enum defines which arguments are valid */	TokenNameCOMMENT_BLOCK	 the <i>add keyspace</i> command requires a list of arguments, this enum defines which arguments are valid 
private	TokenNameprivate	
enum	TokenNameenum	
AddKeyspaceArgument	TokenNameIdentifier	 Add Keyspace Argument
{	TokenNameLBRACE	
PLACEMENT_STRATEGY	TokenNameIdentifier	 PLACEMENT  STRATEGY
,	TokenNameCOMMA	
STRATEGY_OPTIONS	TokenNameIdentifier	 STRATEGY  OPTIONS
,	TokenNameCOMMA	
DURABLE_WRITES	TokenNameIdentifier	 DURABLE  WRITES
}	TokenNameRBRACE	
/* * the <i>add column family</i> command requires a list of arguments, * this enum defines which arguments are valid. */	TokenNameCOMMENT_BLOCK	 the <i>add column family</i> command requires a list of arguments, this enum defines which arguments are valid. 
protected	TokenNameprotected	
enum	TokenNameenum	
ColumnFamilyArgument	TokenNameIdentifier	 Column Family Argument
{	TokenNameLBRACE	
COLUMN_TYPE	TokenNameIdentifier	 COLUMN  TYPE
,	TokenNameCOMMA	
COMPARATOR	TokenNameIdentifier	 COMPARATOR
,	TokenNameCOMMA	
SUBCOMPARATOR	TokenNameIdentifier	 SUBCOMPARATOR
,	TokenNameCOMMA	
COMMENT	TokenNameIdentifier	 COMMENT
,	TokenNameCOMMA	
READ_REPAIR_CHANCE	TokenNameIdentifier	 READ  REPAIR  CHANCE
,	TokenNameCOMMA	
DCLOCAL_READ_REPAIR_CHANCE	TokenNameIdentifier	 DCLOCAL  READ  REPAIR  CHANCE
,	TokenNameCOMMA	
GC_GRACE	TokenNameIdentifier	 GC  GRACE
,	TokenNameCOMMA	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
,	TokenNameCOMMA	
MEMTABLE_OPERATIONS	TokenNameIdentifier	 MEMTABLE  OPERATIONS
,	TokenNameCOMMA	
MEMTABLE_THROUGHPUT	TokenNameIdentifier	 MEMTABLE  THROUGHPUT
,	TokenNameCOMMA	
DEFAULT_VALIDATION_CLASS	TokenNameIdentifier	 DEFAULT  VALIDATION  CLASS
,	TokenNameCOMMA	
MIN_COMPACTION_THRESHOLD	TokenNameIdentifier	 MIN  COMPACTION  THRESHOLD
,	TokenNameCOMMA	
MAX_COMPACTION_THRESHOLD	TokenNameIdentifier	 MAX  COMPACTION  THRESHOLD
,	TokenNameCOMMA	
REPLICATE_ON_WRITE	TokenNameIdentifier	 REPLICATE  ON  WRITE
,	TokenNameCOMMA	
KEY_VALIDATION_CLASS	TokenNameIdentifier	 KEY  VALIDATION  CLASS
,	TokenNameCOMMA	
COMPACTION_STRATEGY	TokenNameIdentifier	 COMPACTION  STRATEGY
,	TokenNameCOMMA	
COMPACTION_STRATEGY_OPTIONS	TokenNameIdentifier	 COMPACTION  STRATEGY  OPTIONS
,	TokenNameCOMMA	
COMPRESSION_OPTIONS	TokenNameIdentifier	 COMPRESSION  OPTIONS
,	TokenNameCOMMA	
BLOOM_FILTER_FP_CHANCE	TokenNameIdentifier	 BLOOM  FILTER  FP  CHANCE
,	TokenNameCOMMA	
CACHING	TokenNameIdentifier	 CACHING
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DEFAULT_PLACEMENT_STRATEGY	TokenNameIdentifier	 DEFAULT  PLACEMENT  STRATEGY
=	TokenNameEQUAL	
"org.apache.cassandra.locator.NetworkTopologyStrategy"	TokenNameStringLiteral	org.apache.cassandra.locator.NetworkTopologyStrategy
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NEWLINE	TokenNameIdentifier	 NEWLINE
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TAB	TokenNameIdentifier	 TAB
=	TokenNameEQUAL	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
thriftClient	TokenNameIdentifier	 thrift Client
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CliSessionState	TokenNameIdentifier	 Cli Session State
sessionState	TokenNameIdentifier	 session State
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
keySpace	TokenNameIdentifier	 key Space
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>>	TokenNameRIGHT_SHIFT	
cql3KeyspacesMap	TokenNameIdentifier	 cql3 Keyspaces Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
cfKeysComparators	TokenNameIdentifier	 cf Keys Comparators
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
consistencyLevel	TokenNameIdentifier	 consistency Level
=	TokenNameEQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ONE	TokenNameIdentifier	 ONE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CfAssumptions	TokenNameIdentifier	 Cf Assumptions
assumptions	TokenNameIdentifier	 assumptions
=	TokenNameEQUAL	
new	TokenNamenew	
CfAssumptions	TokenNameIdentifier	 Cf Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CliUserHelp	TokenNameIdentifier	 Cli User Help
help	TokenNameIdentifier	 help
;	TokenNameSEMICOLON	
public	TokenNamepublic	
CliClient	TokenNameIdentifier	 Cli Client
(	TokenNameLPAREN	
CliSessionState	TokenNameIdentifier	 Cli Session State
cliSessionState	TokenNameIdentifier	 cli Session State
,	TokenNameCOMMA	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
thriftClient	TokenNameIdentifier	 thrift Client
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sessionState	TokenNameIdentifier	 session State
=	TokenNameEQUAL	
cliSessionState	TokenNameIdentifier	 cli Session State
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
thriftClient	TokenNameIdentifier	 thrift Client
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cfKeysComparators	TokenNameIdentifier	 cf Keys Comparators
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
readAssumptions	TokenNameIdentifier	 read Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CliUserHelp	TokenNameIdentifier	 Cli User Help
getHelp	TokenNameIdentifier	 get Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
help	TokenNameIdentifier	 help
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
help	TokenNameIdentifier	 help
=	TokenNameEQUAL	
loadHelp	TokenNameIdentifier	 load Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
help	TokenNameIdentifier	 help
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CliUserHelp	TokenNameIdentifier	 Cli User Help
loadHelp	TokenNameIdentifier	 load Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
InputStream	TokenNameIdentifier	 Input Stream
is	TokenNameIdentifier	 is
=	TokenNameEQUAL	
CliClient	TokenNameIdentifier	 Cli Client
.	TokenNameDOT	
class	TokenNameclass	
.	TokenNameDOT	
getClassLoader	TokenNameIdentifier	 get Class Loader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getResourceAsStream	TokenNameIdentifier	 get Resource As Stream
(	TokenNameLPAREN	
"org/apache/cassandra/cli/CliHelp.yaml"	TokenNameStringLiteral	org/apache/cassandra/cli/CliHelp.yaml
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
is	TokenNameIdentifier	 is
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
Constructor	TokenNameIdentifier	 Constructor
constructor	TokenNameIdentifier	 constructor
=	TokenNameEQUAL	
new	TokenNamenew	
Constructor	TokenNameIdentifier	 Constructor
(	TokenNameLPAREN	
CliUserHelp	TokenNameIdentifier	 Cli User Help
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
TypeDescription	TokenNameIdentifier	 Type Description
desc	TokenNameIdentifier	 desc
=	TokenNameEQUAL	
new	TokenNamenew	
TypeDescription	TokenNameIdentifier	 Type Description
(	TokenNameLPAREN	
CliUserHelp	TokenNameIdentifier	 Cli User Help
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
putListPropertyType	TokenNameIdentifier	 put List Property Type
(	TokenNameLPAREN	
"commands"	TokenNameStringLiteral	commands
,	TokenNameCOMMA	
CliCommandHelp	TokenNameIdentifier	 Cli Command Help
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Yaml	TokenNameIdentifier	 Yaml
yaml	TokenNameIdentifier	 yaml
=	TokenNameEQUAL	
new	TokenNamenew	
Yaml	TokenNameIdentifier	 Yaml
(	TokenNameLPAREN	
new	TokenNamenew	
Loader	TokenNameIdentifier	 Loader
(	TokenNameLPAREN	
constructor	TokenNameIdentifier	 constructor
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
CliUserHelp	TokenNameIdentifier	 Cli User Help
)	TokenNameRPAREN	
yaml	TokenNameIdentifier	 yaml
.	TokenNameDOT	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
is	TokenNameIdentifier	 is
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
printBanner	TokenNameIdentifier	 print Banner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Welcome to Cassandra CLI version "	TokenNameStringLiteral	Welcome to Cassandra CLI version 
+	TokenNamePLUS	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getReleaseVersionString	TokenNameIdentifier	 get Release Version String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
getHelp	TokenNameIdentifier	 get Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
banner	TokenNameIdentifier	 banner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Execute a CLI Statement 	TokenNameCOMMENT_LINE	Execute a CLI Statement 
public	TokenNamepublic	
void	TokenNamevoid	
executeCLIStatement	TokenNameIdentifier	 execute CLI Statement
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
CharacterCodingException	TokenNameIdentifier	 Character Coding Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
tree	TokenNameIdentifier	 tree
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
compileQuery	TokenNameIdentifier	 compile Query
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_EXIT	TokenNameIdentifier	 NODE  EXIT
:	TokenNameCOLON	
cleanupAndExit	TokenNameIdentifier	 cleanup And Exit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_GET	TokenNameIdentifier	 NODE  THRIFT  GET
:	TokenNameCOLON	
executeGet	TokenNameIdentifier	 execute Get
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_GET_WITH_CONDITIONS	TokenNameIdentifier	 NODE  THRIFT  GET  WITH  CONDITIONS
:	TokenNameCOLON	
executeGetWithConditions	TokenNameIdentifier	 execute Get With Conditions
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_HELP	TokenNameIdentifier	 NODE  HELP
:	TokenNameCOLON	
executeHelp	TokenNameIdentifier	 execute Help
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_SET	TokenNameIdentifier	 NODE  THRIFT  SET
:	TokenNameCOLON	
executeSet	TokenNameIdentifier	 execute Set
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_DEL	TokenNameIdentifier	 NODE  THRIFT  DEL
:	TokenNameCOLON	
executeDelete	TokenNameIdentifier	 execute Delete
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_COUNT	TokenNameIdentifier	 NODE  THRIFT  COUNT
:	TokenNameCOLON	
executeCount	TokenNameIdentifier	 execute Count
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_ADD_KEYSPACE	TokenNameIdentifier	 NODE  ADD  KEYSPACE
:	TokenNameCOLON	
executeAddKeySpace	TokenNameIdentifier	 execute Add Key Space
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_ADD_COLUMN_FAMILY	TokenNameIdentifier	 NODE  ADD  COLUMN  FAMILY
:	TokenNameCOLON	
executeAddColumnFamily	TokenNameIdentifier	 execute Add Column Family
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_UPDATE_KEYSPACE	TokenNameIdentifier	 NODE  UPDATE  KEYSPACE
:	TokenNameCOLON	
executeUpdateKeySpace	TokenNameIdentifier	 execute Update Key Space
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_UPDATE_COLUMN_FAMILY	TokenNameIdentifier	 NODE  UPDATE  COLUMN  FAMILY
:	TokenNameCOLON	
executeUpdateColumnFamily	TokenNameIdentifier	 execute Update Column Family
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_DEL_COLUMN_FAMILY	TokenNameIdentifier	 NODE  DEL  COLUMN  FAMILY
:	TokenNameCOLON	
executeDelColumnFamily	TokenNameIdentifier	 execute Del Column Family
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_DEL_KEYSPACE	TokenNameIdentifier	 NODE  DEL  KEYSPACE
:	TokenNameCOLON	
executeDelKeySpace	TokenNameIdentifier	 execute Del Key Space
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_SHOW_CLUSTER_NAME	TokenNameIdentifier	 NODE  SHOW  CLUSTER  NAME
:	TokenNameCOLON	
executeShowClusterName	TokenNameIdentifier	 execute Show Cluster Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_SHOW_VERSION	TokenNameIdentifier	 NODE  SHOW  VERSION
:	TokenNameCOLON	
executeShowVersion	TokenNameIdentifier	 execute Show Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_SHOW_KEYSPACES	TokenNameIdentifier	 NODE  SHOW  KEYSPACES
:	TokenNameCOLON	
executeShowKeySpaces	TokenNameIdentifier	 execute Show Key Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_SHOW_SCHEMA	TokenNameIdentifier	 NODE  SHOW  SCHEMA
:	TokenNameCOLON	
executeShowSchema	TokenNameIdentifier	 execute Show Schema
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_DESCRIBE	TokenNameIdentifier	 NODE  DESCRIBE
:	TokenNameCOLON	
executeDescribe	TokenNameIdentifier	 execute Describe
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_DESCRIBE_CLUSTER	TokenNameIdentifier	 NODE  DESCRIBE  CLUSTER
:	TokenNameCOLON	
executeDescribeCluster	TokenNameIdentifier	 execute Describe Cluster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_USE_TABLE	TokenNameIdentifier	 NODE  USE  TABLE
:	TokenNameCOLON	
executeUseKeySpace	TokenNameIdentifier	 execute Use Key Space
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_TRACE_NEXT_QUERY	TokenNameIdentifier	 NODE  TRACE  NEXT  QUERY
:	TokenNameCOLON	
executeTraceNextQuery	TokenNameIdentifier	 execute Trace Next Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_CONNECT	TokenNameIdentifier	 NODE  CONNECT
:	TokenNameCOLON	
executeConnect	TokenNameIdentifier	 execute Connect
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_LIST	TokenNameIdentifier	 NODE  LIST
:	TokenNameCOLON	
executeList	TokenNameIdentifier	 execute List
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_TRUNCATE	TokenNameIdentifier	 NODE  TRUNCATE
:	TokenNameCOLON	
executeTruncate	TokenNameIdentifier	 execute Truncate
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_ASSUME	TokenNameIdentifier	 NODE  ASSUME
:	TokenNameCOLON	
executeAssumeStatement	TokenNameIdentifier	 execute Assume Statement
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_CONSISTENCY_LEVEL	TokenNameIdentifier	 NODE  CONSISTENCY  LEVEL
:	TokenNameCOLON	
executeConsistencyLevelStatement	TokenNameIdentifier	 execute Consistency Level Statement
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_INCR	TokenNameIdentifier	 NODE  THRIFT  INCR
:	TokenNameCOLON	
executeIncr	TokenNameIdentifier	 execute Incr
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
,	TokenNameCOMMA	
1L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_THRIFT_DECR	TokenNameIdentifier	 NODE  THRIFT  DECR
:	TokenNameCOLON	
executeIncr	TokenNameIdentifier	 execute Incr
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
,	TokenNameCOMMA	
-	TokenNameMINUS	
1L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_DROP_INDEX	TokenNameIdentifier	 NODE  DROP  INDEX
:	TokenNameCOLON	
executeDropIndex	TokenNameIdentifier	 execute Drop Index
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_NO_OP	TokenNameIdentifier	 NODE  NO  OP
:	TokenNameCOLON	
// comment lines come here; they are treated as no ops. 	TokenNameCOMMENT_LINE	comment lines come here; they are treated as no ops. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid Statement (Type: "	TokenNameStringLiteral	Invalid Statement (Type: 
+	TokenNamePLUS	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
batch	TokenNameIdentifier	 batch
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SchemaDisagreementException	TokenNameIdentifier	 Schema Disagreement Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"schema does not match across nodes, (try again later)."	TokenNameStringLiteral	schema does not match across nodes, (try again later).
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
cleanupAndExit	TokenNameIdentifier	 cleanup And Exit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
disconnect	TokenNameIdentifier	 disconnect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
writeAssumptions	TokenNameIdentifier	 write Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
KsDef	TokenNameIdentifier	 Ks Def
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
throws	TokenNamethrows	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
// Lazily lookup keyspace meta-data. 	TokenNameCOMMENT_LINE	Lazily lookup keyspace meta-data. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
containsKey	TokenNameIdentifier	 contains Key
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
ksDef	TokenNameIdentifier	 ks Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cql3KeyspacesMap	TokenNameIdentifier	 cql3 Keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
loadCql3Defs	TokenNameIdentifier	 load Cql3 Defs
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
,	TokenNameCOMMA	
ksDef	TokenNameIdentifier	 ks Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
replayAssumptions	TokenNameIdentifier	 replay Assumptions
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
loadCql3Defs	TokenNameIdentifier	 load Cql3 Defs
(	TokenNameLPAREN	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
thriftClient	TokenNameIdentifier	 thrift Client
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
thriftKs	TokenNameIdentifier	 thrift Ks
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
loadCql3DefsUnchecked	TokenNameIdentifier	 load Cql3 Defs Unchecked
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
,	TokenNameCOMMA	
thriftKs	TokenNameIdentifier	 thrift Ks
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
loadCql3DefsUnchecked	TokenNameIdentifier	 load Cql3 Defs Unchecked
(	TokenNameLPAREN	
Cassandra	TokenNameIdentifier	 Cassandra
.	TokenNameDOT	
Client	TokenNameIdentifier	 Client
thriftClient	TokenNameIdentifier	 thrift Client
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
thriftKs	TokenNameIdentifier	 thrift Ks
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
cql3Defs	TokenNameIdentifier	 cql3 Defs
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
query	TokenNameIdentifier	 query
=	TokenNameEQUAL	
"SELECT columnfamily_name, comparator, default_validator, key_validator FROM system.schema_columnfamilies WHERE keyspace_name='%s'"	TokenNameStringLiteral	SELECT columnfamily_name, comparator, default_validator, key_validator FROM system.schema_columnfamilies WHERE keyspace_name='%s'
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
formatted	TokenNameIdentifier	 formatted
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
thriftKs	TokenNameIdentifier	 thrift Ks
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CqlResult	TokenNameIdentifier	 Cql Result
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
execute_cql3_query	TokenNameIdentifier	 execute cql3 query
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
(	TokenNameLPAREN	
formatted	TokenNameIdentifier	 formatted
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Compression	TokenNameIdentifier	 Compression
.	TokenNameDOT	
NONE	TokenNameIdentifier	 NONE
,	TokenNameCOMMA	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
ONE	TokenNameIdentifier	 ONE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
outer	TokenNameIdentifier	 outer
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CqlRow	TokenNameIdentifier	 Cql Row
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
result	TokenNameIdentifier	 result
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Column	TokenNameIdentifier	 Column
rawName	TokenNameIdentifier	 raw Name
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawName	TokenNameIdentifier	 raw Name
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"columnfamily_name"	TokenNameStringLiteral	columnfamily_name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawName	TokenNameIdentifier	 raw Name
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Column	TokenNameIdentifier	 Column
rawComparator	TokenNameIdentifier	 raw Comparator
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawComparator	TokenNameIdentifier	 raw Comparator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"comparator"	TokenNameStringLiteral	comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawComparator	TokenNameIdentifier	 raw Comparator
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Column	TokenNameIdentifier	 Column
rawValidator	TokenNameIdentifier	 raw Validator
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawValidator	TokenNameIdentifier	 raw Validator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"default_validator"	TokenNameStringLiteral	default_validator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawValidator	TokenNameIdentifier	 raw Validator
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Column	TokenNameIdentifier	 Column
rawKeyValidator	TokenNameIdentifier	 raw Key Validator
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawKeyValidator	TokenNameIdentifier	 raw Key Validator
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"key_validator"	TokenNameStringLiteral	key_validator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
keyValidator	TokenNameIdentifier	 key Validator
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
rawKeyValidator	TokenNameIdentifier	 raw Key Validator
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cf_def	TokenNameIdentifier	 cf def
:	TokenNameCOLON	
thriftKs	TokenNameIdentifier	 thrift Ks
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
outer	TokenNameIdentifier	 outer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CfDef	TokenNameIdentifier	 Cf Def
thriftDef	TokenNameIdentifier	 thrift Def
=	TokenNameEQUAL	
new	TokenNamenew	
CfDef	TokenNameIdentifier	 Cf Def
(	TokenNameLPAREN	
thriftKs	TokenNameIdentifier	 thrift Ks
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
.	TokenNameDOT	
setComparator_type	TokenNameIdentifier	 set Comparator type
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
.	TokenNameDOT	
setDefault_validation_class	TokenNameIdentifier	 set Default validation class
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
.	TokenNameDOT	
setKey_validation_class	TokenNameIdentifier	 set Key validation class
(	TokenNameLPAREN	
keyValidator	TokenNameIdentifier	 key Validator
)	TokenNameRPAREN	
.	TokenNameDOT	
setColumn_metadata	TokenNameIdentifier	 set Column metadata
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cql3Defs	TokenNameIdentifier	 cql3 Defs
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
thriftDef	TokenNameIdentifier	 thrift Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
cql3Defs	TokenNameIdentifier	 cql3 Defs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeHelp	TokenNameIdentifier	 execute Help
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
tree	TokenNameIdentifier	 tree
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tree	TokenNameIdentifier	 tree
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CliCommandHelp	TokenNameIdentifier	 Cli Command Help
ch	TokenNameIdentifier	 ch
:	TokenNameCOLON	
getHelp	TokenNameIdentifier	 get Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
commands	TokenNameIdentifier	 commands
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
help	TokenNameIdentifier	 help
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
getHelp	TokenNameIdentifier	 get Help
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
help	TokenNameIdentifier	 help
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeCount	TokenNameIdentifier	 execute Count
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
columnFamilySpec	TokenNameIdentifier	 column Family Spec
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
numColumnSpecifiers	TokenNameIdentifier	 num Column Specifiers
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnParent	TokenNameIdentifier	 Column Parent
colParent	TokenNameIdentifier	 col Parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
)	TokenNameRPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
columnTree	TokenNameIdentifier	 column Tree
=	TokenNameEQUAL	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumn	TokenNameIdentifier	 super Column
=	TokenNameEQUAL	
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
colParent	TokenNameIdentifier	 col Parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SliceRange	TokenNameIdentifier	 Slice Range
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
SliceRange	TokenNameIdentifier	 Slice Range
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
=	TokenNameEQUAL	
new	TokenNamenew	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setColumn_names	TokenNameIdentifier	 set Column names
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
setSlice_range	TokenNameIdentifier	 set Slice range
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get_count	TokenNameIdentifier	 get count
(	TokenNameLPAREN	
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
colParent	TokenNameIdentifier	 col Parent
,	TokenNameCOMMA	
predicate	TokenNameIdentifier	 predicate
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%d columns%n"	TokenNameStringLiteral	%d columns%n
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Iterables	TokenNameIdentifier	 Iterables
.	TokenNameDOT	
concat	TokenNameIdentifier	 concat
(	TokenNameLPAREN	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
,	TokenNameCOMMA	
cql3KeyspacesMap	TokenNameIdentifier	 cql3 Keyspaces Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeDelete	TokenNameIdentifier	 execute Delete
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
columnFamilySpec	TokenNameIdentifier	 column Family Spec
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
numColumnSpecifiers	TokenNameIdentifier	 num Column Specifiers
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSuper	TokenNameIdentifier	 is Super
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid row, super column, or column specification."	TokenNameStringLiteral	Invalid row, super column, or column specification.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
columnTree	TokenNameIdentifier	 column Tree
=	TokenNameEQUAL	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
subColumnTree	TokenNameIdentifier	 sub Column Tree
=	TokenNameEQUAL	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
columnTree	TokenNameIdentifier	 column Tree
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnNameBytes	TokenNameIdentifier	 column Name Bytes
=	TokenNameEQUAL	
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSuper	TokenNameIdentifier	 is Super
)	TokenNameRPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
columnNameBytes	TokenNameIdentifier	 column Name Bytes
;	TokenNameSEMICOLON	
else	TokenNameelse	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
columnNameBytes	TokenNameIdentifier	 column Name Bytes
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
columnTree	TokenNameIdentifier	 column Tree
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
subColumnTree	TokenNameIdentifier	 sub Column Tree
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// table.cf['key']['column']['column'] 	TokenNameCOMMENT_LINE	table.cf['key']['column']['column'] 
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
subColumnTree	TokenNameIdentifier	 sub Column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
subColumnTree	TokenNameIdentifier	 sub Column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
subColumnNameAsByteArray	TokenNameIdentifier	 sub Column Name As Byte Array
(	TokenNameLPAREN	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnPath	TokenNameIdentifier	 Column Path
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnPath	TokenNameIdentifier	 Column Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
setColumn	TokenNameIdentifier	 set Column
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCounterCF	TokenNameIdentifier	 is Counter CF
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
remove_counter	TokenNameIdentifier	 remove counter
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
timestampMicros	TokenNameIdentifier	 timestamp Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s removed."	TokenNameStringLiteral	%s removed.
,	TokenNameCOMMA	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"row"	TokenNameStringLiteral	row
:	TokenNameCOLON	
"column"	TokenNameStringLiteral	column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
doSlice	TokenNameIdentifier	 do Slice
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumnName	TokenNameIdentifier	 super Column Name
,	TokenNameCOMMA	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnParent	TokenNameIdentifier	 Column Parent
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SliceRange	TokenNameIdentifier	 Slice Range
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
SliceRange	TokenNameIdentifier	 Slice Range
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
=	TokenNameEQUAL	
new	TokenNamenew	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
setColumn_names	TokenNameIdentifier	 set Column names
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
.	TokenNameDOT	
setSlice_range	TokenNameIdentifier	 set Slice range
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSuperCF	TokenNameIdentifier	 is Super CF
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get_slice	TokenNameIdentifier	 get slice
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
predicate	TokenNameIdentifier	 predicate
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
;	TokenNameSEMICOLON	
// Print out super columns or columns. 	TokenNameCOMMENT_LINE	Print out super columns or columns. 
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
cosc	TokenNameIdentifier	 cosc
:	TokenNameCOLON	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
isSetSuper_column	TokenNameIdentifier	 is Set Super column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SuperColumn	TokenNameIdentifier	 Super Column
superColumn	TokenNameIdentifier	 super Column
=	TokenNameEQUAL	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (super_column=%s,"	TokenNameStringLiteral	=> (super_column=%s,
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Column	TokenNameIdentifier	 Column
col	TokenNameIdentifier	 col
:	TokenNameCOLON	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
getColumns	TokenNameIdentifier	 get Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%n (column=%s, value=%s, timestamp=%d%s)"	TokenNameStringLiteral	%n (column=%s, value=%s, timestamp=%d%s)
,	TokenNameCOMMA	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
isSetTtl	TokenNameIdentifier	 is Set Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
", ttl=%d"	TokenNameStringLiteral	, ttl=%d
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getTtl	TokenNameIdentifier	 get Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
isSetColumn	TokenNameIdentifier	 is Set Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Column	TokenNameIdentifier	 Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
formattedName	TokenNameIdentifier	 formatted Name
=	TokenNameEQUAL	
isSuperCF	TokenNameIdentifier	 is Super CF
?	TokenNameQUESTION	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (column=%s, value=%s, timestamp=%d%s)%n"	TokenNameStringLiteral	=> (column=%s, value=%s, timestamp=%d%s)%n
,	TokenNameCOMMA	
formattedName	TokenNameIdentifier	 formatted Name
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
isSetTtl	TokenNameIdentifier	 is Set Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
", ttl=%d"	TokenNameStringLiteral	, ttl=%d
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getTtl	TokenNameIdentifier	 get Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
isSetCounter_super_column	TokenNameIdentifier	 is Set Counter super column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CounterSuperColumn	TokenNameIdentifier	 Counter Super Column
superColumn	TokenNameIdentifier	 super Column
=	TokenNameEQUAL	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_super_column	TokenNameIdentifier	 counter super column
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (super_column=%s,"	TokenNameStringLiteral	=> (super_column=%s,
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CounterColumn	TokenNameIdentifier	 Counter Column
col	TokenNameIdentifier	 col
:	TokenNameCOLON	
superColumn	TokenNameIdentifier	 super Column
.	TokenNameDOT	
getColumns	TokenNameIdentifier	 get Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%n (counter=%s, value=%s)"	TokenNameStringLiteral	%n (counter=%s, value=%s)
,	TokenNameCOMMA	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
// cosc.isSetCounter_column() 	TokenNameCOMMENT_LINE	cosc.isSetCounter_column() 
{	TokenNameLBRACE	
CounterColumn	TokenNameIdentifier	 Counter Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
cosc	TokenNameIdentifier	 cosc
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
formattedName	TokenNameIdentifier	 formatted Name
=	TokenNameEQUAL	
isSuperCF	TokenNameIdentifier	 is Super CF
?	TokenNameQUESTION	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (counter=%s, value=%s)%n"	TokenNameStringLiteral	=> (counter=%s, value=%s)%n
,	TokenNameCOMMA	
formattedName	TokenNameIdentifier	 formatted Name
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Returned "	TokenNameStringLiteral	Returned 
+	TokenNamePLUS	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" results."	TokenNameStringLiteral	 results.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
compareWith	TokenNameIdentifier	 compare With
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Function	TokenNameIdentifier	 Function
function	TokenNameIdentifier	 function
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
function	TokenNameIdentifier	 function
=	TokenNameEQUAL	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
compareWith	TokenNameIdentifier	 compare With
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
TypeParser	TokenNameIdentifier	 Type Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
compareWith	TokenNameIdentifier	 compare With
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
ce	TokenNameIdentifier	 ce
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
errorMessage	TokenNameIdentifier	 error Message
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
"Unknown comparator '"	TokenNameStringLiteral	Unknown comparator '
+	TokenNamePLUS	
compareWith	TokenNameIdentifier	 compare With
+	TokenNamePLUS	
"'. "	TokenNameStringLiteral	'. 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
errorMessage	TokenNameIdentifier	 error Message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Available functions: "	TokenNameStringLiteral	Available functions: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
errorMessage	TokenNameIdentifier	 error Message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
getFunctionNames	TokenNameIdentifier	 get Function Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
function	TokenNameIdentifier	 function
.	TokenNameDOT	
getValidator	TokenNameIdentifier	 get Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Execute GET statement 	TokenNameCOMMENT_LINE	Execute GET statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeGet	TokenNameIdentifier	 execute Get
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
columnFamilySpec	TokenNameIdentifier	 column Family Spec
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
numColumnSpecifiers	TokenNameIdentifier	 num Column Specifiers
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSuper	TokenNameIdentifier	 is Super
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
typeTree	TokenNameIdentifier	 type Tree
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
limitTree	TokenNameIdentifier	 limit Tree
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
1000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
CONVERT_TO_TYPE	TokenNameIdentifier	 CONVERT  TO  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
typeTree	TokenNameIdentifier	 type Tree
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
limitTree	TokenNameIdentifier	 limit Tree
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
limitTree	TokenNameIdentifier	 limit Tree
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
limitTree	TokenNameIdentifier	 limit Tree
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
limitTree	TokenNameIdentifier	 limit Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
limit	TokenNameIdentifier	 limit
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"LIMIT should be greater than zero."	TokenNameStringLiteral	LIMIT should be greater than zero.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// table.cf['key'] -- row slice 	TokenNameCOMMENT_LINE	table.cf['key'] -- row slice 
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doSlice	TokenNameIdentifier	 do Slice
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
superColumnName	TokenNameIdentifier	 super Column Name
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// table.cf['key']['column'] -- slice of a super, or get of a standard 	TokenNameCOMMENT_LINE	table.cf['key']['column'] -- slice of a super, or get of a standard 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isSuper	TokenNameIdentifier	 is Super
)	TokenNameRPAREN	
{	TokenNameLBRACE	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
columnName	TokenNameIdentifier	 column Name
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doSlice	TokenNameIdentifier	 do Slice
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
superColumnName	TokenNameIdentifier	 super Column Name
,	TokenNameCOMMA	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// table.cf['key']['column']['column'] -- get of a sub-column 	TokenNameCOMMENT_LINE	table.cf['key']['column']['column'] -- get of a sub-column 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getSubColumnName	TokenNameIdentifier	 get Sub Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The parser groks an arbitrary number of these so it is possible to get here. 	TokenNameCOMMENT_LINE	The parser groks an arbitrary number of these so it is possible to get here. 
else	TokenNameelse	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid row, super column, or column specification."	TokenNameStringLiteral	Invalid row, super column, or column specification.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
TBaseHelper	TokenNameIdentifier	 T Base Helper
.	TokenNameDOT	
byteBufferToByteArray	TokenNameIdentifier	 byte Buffer To Byte Array
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Perform a get() 	TokenNameCOMMENT_LINE	Perform a get() 
ColumnPath	TokenNameIdentifier	 Column Path
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnPath	TokenNameIdentifier	 Column Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
setColumn	TokenNameIdentifier	 set Column
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isCounterCF	TokenNameIdentifier	 is Counter CF
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
doGetCounter	TokenNameIdentifier	 do Get Counter
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Column	TokenNameIdentifier	 Column
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
.	TokenNameDOT	
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NotFoundException	TokenNameIdentifier	 Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Value was not found"	TokenNameStringLiteral	Value was not found
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnValue	TokenNameIdentifier	 column Value
=	TokenNameEQUAL	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
valueAsString	TokenNameIdentifier	 value As String
;	TokenNameSEMICOLON	
// we have ^(CONVERT_TO_TYPE <type>) inside of GET statement 	TokenNameCOMMENT_LINE	we have ^(CONVERT_TO_TYPE <type>) inside of GET statement 
// which means that we should try to represent byte[] value according 	TokenNameCOMMENT_LINE	which means that we should try to represent byte[] value according 
// to specified type 	TokenNameCOMMENT_LINE	to specified type 
if	TokenNameif	
(	TokenNameLPAREN	
typeTree	TokenNameIdentifier	 type Tree
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// .getText() will give us <type> 	TokenNameCOMMENT_LINE	.getText() will give us <type> 
String	TokenNameIdentifier	 String
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
typeTree	TokenNameIdentifier	 type Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// building AbstractType from <type> 	TokenNameCOMMENT_LINE	building AbstractType from <type> 
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
valueValidator	TokenNameIdentifier	 value Validator
=	TokenNameEQUAL	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
typeName	TokenNameIdentifier	 type Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// setting value for output 	TokenNameCOMMENT_LINE	setting value for output 
valueAsString	TokenNameIdentifier	 value As String
=	TokenNameEQUAL	
valueValidator	TokenNameIdentifier	 value Validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
columnValue	TokenNameIdentifier	 column Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// updating column value validator class 	TokenNameCOMMENT_LINE	updating column value validator class 
updateColumnMetaData	TokenNameIdentifier	 update Column Meta Data
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
valueValidator	TokenNameIdentifier	 value Validator
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
valueAsString	TokenNameIdentifier	 value As String
=	TokenNameEQUAL	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
columnValue	TokenNameIdentifier	 column Value
,	TokenNameCOMMA	
Charsets	TokenNameIdentifier	 Charsets
.	TokenNameDOT	
UTF_8	TokenNameIdentifier	 UTF 8
)	TokenNameRPAREN	
:	TokenNameCOLON	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
columnValue	TokenNameIdentifier	 column Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
formattedColumnName	TokenNameIdentifier	 formatted Column Name
=	TokenNameEQUAL	
isSuper	TokenNameIdentifier	 is Super
?	TokenNameQUESTION	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// print results 	TokenNameCOMMENT_LINE	print results 
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (column=%s, value=%s, timestamp=%d%s)%n"	TokenNameStringLiteral	=> (column=%s, value=%s, timestamp=%d%s)%n
,	TokenNameCOMMA	
formattedColumnName	TokenNameIdentifier	 formatted Column Name
,	TokenNameCOMMA	
valueAsString	TokenNameIdentifier	 value As String
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
isSetTtl	TokenNameIdentifier	 is Set Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
", ttl=%d"	TokenNameStringLiteral	, ttl=%d
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getTtl	TokenNameIdentifier	 get Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
doGetCounter	TokenNameIdentifier	 do Get Counter
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnPath	TokenNameIdentifier	 Column Path
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
isSuper	TokenNameIdentifier	 is Super
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
CounterColumn	TokenNameIdentifier	 Counter Column
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NotFoundException	TokenNameIdentifier	 Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Value was not found"	TokenNameStringLiteral	Value was not found
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
formattedColumnName	TokenNameIdentifier	 formatted Column Name
=	TokenNameEQUAL	
isSuper	TokenNameIdentifier	 is Super
?	TokenNameQUESTION	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
column_family	TokenNameIdentifier	 column family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
column_family	TokenNameIdentifier	 column family
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// print results 	TokenNameCOMMENT_LINE	print results 
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (counter=%s, value=%d)%n"	TokenNameStringLiteral	=> (counter=%s, value=%d)%n
,	TokenNameCOMMA	
formattedColumnName	TokenNameIdentifier	 formatted Column Name
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Process get operation with conditions (using Thrift get_indexed_slices method) * @param statement - tree representation of the current statement * Format: ^(NODE_THRIFT_GET_WITH_CONDITIONS cf ^(CONDITIONS ^(CONDITION >= column1 value1) ...) ^(NODE_LIMIT int)*) */	TokenNameCOMMENT_JAVADOC	 Process get operation with conditions (using Thrift get_indexed_slices method) @param statement - tree representation of the current statement Format: ^(NODE_THRIFT_GET_WITH_CONDITIONS cf ^(CONDITIONS ^(CONDITION >= column1 value1) ...) ^(NODE_LIMIT int)*) 
private	TokenNameprivate	
void	TokenNamevoid	
executeGetWithConditions	TokenNameIdentifier	 execute Get With Conditions
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexClause	TokenNameIdentifier	 Index Clause
clause	TokenNameIdentifier	 clause
=	TokenNameEQUAL	
new	TokenNamenew	
IndexClause	TokenNameIdentifier	 Index Clause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ^(CONDITIONS ^(CONDITION $column $value) ...) 	TokenNameCOMMENT_LINE	^(CONDITIONS ^(CONDITION $column $value) ...) 
Tree	TokenNameIdentifier	 Tree
conditions	TokenNameIdentifier	 conditions
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fetching column family definition 	TokenNameCOMMENT_LINE	fetching column family definition 
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// fetching all columns 	TokenNameCOMMENT_LINE	fetching all columns 
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
=	TokenNameEQUAL	
new	TokenNamenew	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SliceRange	TokenNameIdentifier	 Slice Range
sliceRange	TokenNameIdentifier	 slice Range
=	TokenNameEQUAL	
new	TokenNamenew	
SliceRange	TokenNameIdentifier	 Slice Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sliceRange	TokenNameIdentifier	 slice Range
.	TokenNameDOT	
setStart	TokenNameIdentifier	 set Start
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
setFinish	TokenNameIdentifier	 set Finish
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
setSlice_range	TokenNameIdentifier	 set Slice range
(	TokenNameLPAREN	
sliceRange	TokenNameIdentifier	 slice Range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
conditions	TokenNameIdentifier	 conditions
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// ^(CONDITION operator $column $value) 	TokenNameCOMMENT_LINE	^(CONDITION operator $column $value) 
Tree	TokenNameIdentifier	 Tree
condition	TokenNameIdentifier	 condition
=	TokenNameEQUAL	
conditions	TokenNameIdentifier	 conditions
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// =, >, >=, <, <= 	TokenNameCOMMENT_LINE	=, >, >=, <, <= 
String	TokenNameIdentifier	 String
operator	TokenNameIdentifier	 operator
=	TokenNameEQUAL	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnNameString	TokenNameIdentifier	 column Name String
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// it could be a basic string or function call 	TokenNameCOMMENT_LINE	it could be a basic string or function call 
Tree	TokenNameIdentifier	 Tree
valueTree	TokenNameIdentifier	 value Tree
=	TokenNameEQUAL	
condition	TokenNameIdentifier	 condition
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
columnNameString	TokenNameIdentifier	 column Name String
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
valueTree	TokenNameIdentifier	 value Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
valueTree	TokenNameIdentifier	 value Tree
,	TokenNameCOMMA	
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
valueString	TokenNameIdentifier	 value String
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
valueTree	TokenNameIdentifier	 value Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
columnValueAsBytes	TokenNameIdentifier	 column Value As Bytes
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
valueString	TokenNameIdentifier	 value String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// index operator from string 	TokenNameCOMMENT_LINE	index operator from string 
IndexOperator	TokenNameIdentifier	 Index Operator
idxOperator	TokenNameIdentifier	 idx Operator
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
getIndexOperator	TokenNameIdentifier	 get Index Operator
(	TokenNameLPAREN	
operator	TokenNameIdentifier	 operator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// adding new index expression into index clause 	TokenNameCOMMENT_LINE	adding new index expression into index clause 
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
addToExpressions	TokenNameIdentifier	 add To Expressions
(	TokenNameLPAREN	
new	TokenNamenew	
IndexExpression	TokenNameIdentifier	 Index Expression
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
idxOperator	TokenNameIdentifier	 idx Operator
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
slices	TokenNameIdentifier	 slices
;	TokenNameSEMICOLON	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
setStart_key	TokenNameIdentifier	 set Start key
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// when we have ^(NODE_LIMIT Integer) 	TokenNameCOMMENT_LINE	when we have ^(NODE_LIMIT Integer) 
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
limitNode	TokenNameIdentifier	 limit Node
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
limitValue	TokenNameIdentifier	 limit Value
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
limitNode	TokenNameIdentifier	 limit Node
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
limitValue	TokenNameIdentifier	 limit Value
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"LIMIT should be greater than zero."	TokenNameStringLiteral	LIMIT should be greater than zero.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
setCount	TokenNameIdentifier	 set Count
(	TokenNameLPAREN	
limitValue	TokenNameIdentifier	 limit Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
ColumnParent	TokenNameIdentifier	 Column Parent
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
slices	TokenNameIdentifier	 slices
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get_indexed_slices	TokenNameIdentifier	 get indexed slices
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
predicate	TokenNameIdentifier	 predicate
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
printSliceList	TokenNameIdentifier	 print Slice List
(	TokenNameLPAREN	
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
slices	TokenNameIdentifier	 slices
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Execute SET statement 	TokenNameCOMMENT_LINE	Execute SET statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeSet	TokenNameIdentifier	 execute Set
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ^(NODE_COLUMN_ACCESS <cf> <key> <column>) 	TokenNameCOMMENT_LINE	^(NODE_COLUMN_ACCESS <cf> <key> <column>) 
Tree	TokenNameIdentifier	 Tree
columnFamilySpec	TokenNameIdentifier	 column Family Spec
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
keyTree	TokenNameIdentifier	 key Tree
=	TokenNameEQUAL	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// could be a function or regular text 	TokenNameCOMMENT_LINE	could be a function or regular text 
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
numColumnSpecifiers	TokenNameIdentifier	 num Column Specifiers
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
valueTree	TokenNameIdentifier	 value Tree
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
;	TokenNameSEMICOLON	
// table.cf['key'] 	TokenNameCOMMENT_LINE	table.cf['key'] 
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"No column name specified, (type 'help;' or '?' for help on syntax)."	TokenNameStringLiteral	No column name specified, (type 'help;' or '?' for help on syntax).
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// table.cf['key']['column'] = 'value' 	TokenNameCOMMENT_LINE	table.cf['key']['column'] = 'value' 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get the column name 	TokenNameCOMMENT_LINE	get the column name 
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Column family "	TokenNameStringLiteral	Column family 
+	TokenNamePLUS	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
" may only contain SuperColumns"	TokenNameStringLiteral	 may only contain SuperColumns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// table.cf['key']['super_column']['column'] = 'value' 	TokenNameCOMMENT_LINE	table.cf['key']['super_column']['column'] = 'value' 
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
"serious parsing error (this is a bug)."	TokenNameStringLiteral	serious parsing error (this is a bug).
;	TokenNameSEMICOLON	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getSubColumnName	TokenNameIdentifier	 get Sub Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnValueInBytes	TokenNameIdentifier	 column Value In Bytes
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
valueTree	TokenNameIdentifier	 value Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
:	TokenNameCOLON	
columnValueInBytes	TokenNameIdentifier	 column Value In Bytes
=	TokenNameEQUAL	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
valueTree	TokenNameIdentifier	 value Tree
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
columnValueInBytes	TokenNameIdentifier	 column Value In Bytes
=	TokenNameEQUAL	
columnValueAsBytes	TokenNameIdentifier	 column Value As Bytes
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnParent	TokenNameIdentifier	 Column Parent
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Column	TokenNameIdentifier	 Column
columnToInsert	TokenNameIdentifier	 column To Insert
=	TokenNameEQUAL	
new	TokenNamenew	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
columnValueInBytes	TokenNameIdentifier	 column Value In Bytes
)	TokenNameRPAREN	
.	TokenNameDOT	
setTimestamp	TokenNameIdentifier	 set Timestamp
(	TokenNameLPAREN	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
timestampMicros	TokenNameIdentifier	 timestamp Micros
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// children count = 3 mean that we have ttl in arguments 	TokenNameCOMMENT_LINE	children count = 3 mean that we have ttl in arguments 
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
ttl	TokenNameIdentifier	 ttl
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
columnToInsert	TokenNameIdentifier	 column To Insert
.	TokenNameDOT	
setTtl	TokenNameIdentifier	 set Ttl
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
ttl	TokenNameIdentifier	 ttl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"TTL '%s' is invalid, should be a positive integer."	TokenNameStringLiteral	TTL '%s' is invalid, should be a positive integer.
,	TokenNameCOMMA	
ttl	TokenNameIdentifier	 ttl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// do the insert 	TokenNameCOMMENT_LINE	do the insert 
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
insert	TokenNameIdentifier	 insert
(	TokenNameLPAREN	
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
keyTree	TokenNameIdentifier	 key Tree
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
columnToInsert	TokenNameIdentifier	 column To Insert
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Value inserted."	TokenNameStringLiteral	Value inserted.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Execute INCR statement 	TokenNameCOMMENT_LINE	Execute INCR statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeIncr	TokenNameIdentifier	 execute Incr
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
long	TokenNamelong	
multiplier	TokenNameIdentifier	 multiplier
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
ClassNotFoundException	TokenNameIdentifier	 Class Not Found Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
columnFamilySpec	TokenNameIdentifier	 column Family Spec
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
numColumnSpecifiers	TokenNameIdentifier	 num Column Specifiers
(	TokenNameLPAREN	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
;	TokenNameSEMICOLON	
// table.cf['key']['column'] -- incr standard 	TokenNameCOMMENT_LINE	table.cf['key']['column'] -- incr standard 
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// table.cf['key']['column']['column'] -- incr super 	TokenNameCOMMENT_LINE	table.cf['key']['column']['column'] -- incr super 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnSpecCnt	TokenNameIdentifier	 column Spec Cnt
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
superColumnName	TokenNameIdentifier	 super Column Name
=	TokenNameEQUAL	
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
array	TokenNameIdentifier	 array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
getSubColumnName	TokenNameIdentifier	 get Sub Column Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnFamilySpec	TokenNameIdentifier	 column Family Spec
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The parser groks an arbitrary number of these so it is possible to get here. 	TokenNameCOMMENT_LINE	The parser groks an arbitrary number of these so it is possible to get here. 
else	TokenNameelse	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid row, super column, or column specification."	TokenNameStringLiteral	Invalid row, super column, or column specification.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnParent	TokenNameIdentifier	 Column Parent
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
setSuper_column	TokenNameIdentifier	 set Super column
(	TokenNameLPAREN	
superColumnName	TokenNameIdentifier	 super Column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
// children count = 3 mean that we have by in arguments 	TokenNameCOMMENT_LINE	children count = 3 mean that we have by in arguments 
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
byValue	TokenNameIdentifier	 by Value
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
parseLong	TokenNameIdentifier	 parse Long
(	TokenNameLPAREN	
byValue	TokenNameIdentifier	 by Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"'%s' is an invalid value, should be an integer."	TokenNameStringLiteral	'%s' is an invalid value, should be an integer.
,	TokenNameCOMMA	
byValue	TokenNameIdentifier	 by Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
CounterColumn	TokenNameIdentifier	 Counter Column
columnToInsert	TokenNameIdentifier	 column To Insert
=	TokenNameEQUAL	
new	TokenNamenew	
CounterColumn	TokenNameIdentifier	 Counter Column
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
multiplier	TokenNameIdentifier	 multiplier
*	TokenNameMULTIPLY	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// do the insert 	TokenNameCOMMENT_LINE	do the insert 
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
columnToInsert	TokenNameIdentifier	 column To Insert
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"Value %s%n"	TokenNameStringLiteral	Value %s%n
,	TokenNameCOMMA	
multiplier	TokenNameIdentifier	 multiplier
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
"decremented."	TokenNameStringLiteral	decremented.
:	TokenNameCOLON	
"incremented."	TokenNameStringLiteral	incremented.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeShowClusterName	TokenNameIdentifier	 execute Show Cluster Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_cluster_name	TokenNameIdentifier	 describe cluster name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a keyspace * @param statement - a token tree representing current statement */	TokenNameCOMMENT_JAVADOC	 Add a keyspace @param statement - a token tree representing current statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeAddKeySpace	TokenNameIdentifier	 execute Add Key Space
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// first value is the keyspace name, after that it is all key=value 	TokenNameCOMMENT_LINE	first value is the keyspace name, after that it is all key=value 
String	TokenNameIdentifier	 String
keyspaceName	TokenNameIdentifier	 keyspace Name
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
=	TokenNameEQUAL	
new	TokenNamenew	
KsDef	TokenNameIdentifier	 Ks Def
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
,	TokenNameCOMMA	
DEFAULT_PLACEMENT_STRATEGY	TokenNameIdentifier	 DEFAULT  PLACEMENT  STRATEGY
,	TokenNameCOMMA	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
<	TokenNameLESS	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_add_keyspace	TokenNameIdentifier	 system add keyspace
(	TokenNameLPAREN	
updateKsDefAttributes	TokenNameIdentifier	 update Ks Def Attributes
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
ksDef	TokenNameIdentifier	 ks Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a column family * @param statement - a token tree representing current statement */	TokenNameCOMMENT_JAVADOC	 Add a column family @param statement - a token tree representing current statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeAddColumnFamily	TokenNameIdentifier	 execute Add Column Family
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// first value is the column family name, after that it is all key=value 	TokenNameCOMMENT_LINE	first value is the column family name, after that it is all key=value 
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
new	TokenNamenew	
CfDef	TokenNameIdentifier	 Cf Def
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_add_column_family	TokenNameIdentifier	 system add column family
(	TokenNameLPAREN	
updateCfDefAttributes	TokenNameIdentifier	 update Cf Def Attributes
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Update existing keyspace identified by name * @param statement - tree represeting statement */	TokenNameCOMMENT_JAVADOC	 Update existing keyspace identified by name @param statement - tree represeting statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeUpdateKeySpace	TokenNameIdentifier	 execute Update Key Space
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
keyspaceName	TokenNameIdentifier	 keyspace Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getKeySpace	TokenNameIdentifier	 get Key Space
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KsDef	TokenNameIdentifier	 Ks Def
currentKsDef	TokenNameIdentifier	 current Ks Def
=	TokenNameEQUAL	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KsDef	TokenNameIdentifier	 Ks Def
updatedKsDef	TokenNameIdentifier	 updated Ks Def
=	TokenNameEQUAL	
updateKsDefAttributes	TokenNameIdentifier	 update Ks Def Attributes
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentKsDef	TokenNameIdentifier	 current Ks Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_update_keyspace	TokenNameIdentifier	 system update keyspace
(	TokenNameLPAREN	
updatedKsDef	TokenNameIdentifier	 updated Ks Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Update existing column family identified by name * @param statement - tree represeting statement */	TokenNameCOMMENT_JAVADOC	 Update existing column family identified by name @param statement - tree represeting statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeUpdateColumnFamily	TokenNameIdentifier	 execute Update Column Family
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// request correct cfDef from the server 	TokenNameCOMMENT_LINE	request correct cfDef from the server 
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Column Family "	TokenNameStringLiteral	Column Family 
+	TokenNamePLUS	
cfName	TokenNameIdentifier	 cf Name
+	TokenNamePLUS	
" was not found in the current keyspace."	TokenNameStringLiteral	 was not found in the current keyspace.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_update_column_family	TokenNameIdentifier	 system update column family
(	TokenNameLPAREN	
updateCfDefAttributes	TokenNameIdentifier	 update Cf Def Attributes
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Used to update keyspace definition attributes * @param statement - ANTRL tree representing current statement * @param ksDefToUpdate - keyspace definition to update * @return ksDef - updated keyspace definition */	TokenNameCOMMENT_JAVADOC	 Used to update keyspace definition attributes @param statement - ANTRL tree representing current statement @param ksDefToUpdate - keyspace definition to update @return ksDef - updated keyspace definition 
private	TokenNameprivate	
KsDef	TokenNameIdentifier	 Ks Def
updateKsDefAttributes	TokenNameIdentifier	 update Ks Def Attributes
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
ksDefToUpdate	TokenNameIdentifier	 ks Def To Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
=	TokenNameEQUAL	
new	TokenNamenew	
KsDef	TokenNameIdentifier	 Ks Def
(	TokenNameLPAREN	
ksDefToUpdate	TokenNameIdentifier	 ks Def To Update
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// removing all column definitions - thrift system_update_keyspace method requires that 	TokenNameCOMMENT_LINE	removing all column definitions - thrift system_update_keyspace method requires that 
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
setCf_defs	TokenNameIdentifier	 set Cf defs
(	TokenNameLPAREN	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
<	TokenNameLESS	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
currentStatement	TokenNameIdentifier	 current Statement
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AddKeyspaceArgument	TokenNameIdentifier	 Add Keyspace Argument
mArgument	TokenNameIdentifier	 m Argument
=	TokenNameEQUAL	
AddKeyspaceArgument	TokenNameIdentifier	 Add Keyspace Argument
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
currentStatement	TokenNameIdentifier	 current Statement
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mValue	TokenNameIdentifier	 m Value
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
mArgument	TokenNameIdentifier	 m Argument
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
PLACEMENT_STRATEGY	TokenNameIdentifier	 PLACEMENT  STRATEGY
:	TokenNameCOLON	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
setStrategy_class	TokenNameIdentifier	 set Strategy class
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
STRATEGY_OPTIONS	TokenNameIdentifier	 STRATEGY  OPTIONS
:	TokenNameCOLON	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
setStrategy_options	TokenNameIdentifier	 set Strategy options
(	TokenNameLPAREN	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DURABLE_WRITES	TokenNameIdentifier	 DURABLE  WRITES
:	TokenNameCOLON	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
setDurable_writes	TokenNameIdentifier	 set Durable writes
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
//must match one of the above or we'd throw an exception at the valueOf statement above. 	TokenNameCOMMENT_LINE	must match one of the above or we'd throw an exception at the valueOf statement above. 
assert	TokenNameassert	
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// using default snitch options if strategy is NetworkTopologyStrategy and no options were set. 	TokenNameCOMMENT_LINE	using default snitch options if strategy is NetworkTopologyStrategy and no options were set. 
if	TokenNameif	
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
getStrategy_class	TokenNameIdentifier	 get Strategy class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
".NetworkTopologyStrategy"	TokenNameStringLiteral	.NetworkTopologyStrategy
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
currentStrategyOptions	TokenNameIdentifier	 current Strategy Options
=	TokenNameEQUAL	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
getStrategy_options	TokenNameIdentifier	 get Strategy options
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// adding default data center from SimpleSnitch 	TokenNameCOMMENT_LINE	adding default data center from SimpleSnitch 
if	TokenNameif	
(	TokenNameLPAREN	
currentStrategyOptions	TokenNameIdentifier	 current Strategy Options
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
currentStrategyOptions	TokenNameIdentifier	 current Strategy Options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SimpleSnitch	TokenNameIdentifier	 Simple Snitch
snitch	TokenNameIdentifier	 snitch
=	TokenNameEQUAL	
new	TokenNamenew	
SimpleSnitch	TokenNameIdentifier	 Simple Snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
options	TokenNameIdentifier	 options
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
snitch	TokenNameIdentifier	 snitch
.	TokenNameDOT	
getDatacenter	TokenNameIdentifier	 get Datacenter
(	TokenNameLPAREN	
InetAddress	TokenNameIdentifier	 Inet Address
.	TokenNameDOT	
getLocalHost	TokenNameIdentifier	 get Local Host
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"1"	TokenNameStringLiteral	1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
UnknownHostException	TokenNameIdentifier	 Unknown Host Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
setStrategy_options	TokenNameIdentifier	 set Strategy options
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
ksDef	TokenNameIdentifier	 ks Def
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Update column family definition attributes * @param statement - ANTLR tree representing current statement * @param cfDefToUpdate - column family definition to apply updates on * @return cfDef - updated column family definition */	TokenNameCOMMENT_JAVADOC	 Update column family definition attributes @param statement - ANTLR tree representing current statement @param cfDefToUpdate - column family definition to apply updates on @return cfDef - updated column family definition 
private	TokenNameprivate	
CfDef	TokenNameIdentifier	 Cf Def
updateCfDefAttributes	TokenNameIdentifier	 update Cf Def Attributes
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cfDefToUpdate	TokenNameIdentifier	 cf Def To Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
new	TokenNamenew	
CfDef	TokenNameIdentifier	 Cf Def
(	TokenNameLPAREN	
cfDefToUpdate	TokenNameIdentifier	 cf Def To Update
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
currentArgument	TokenNameIdentifier	 current Argument
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamilyArgument	TokenNameIdentifier	 Column Family Argument
mArgument	TokenNameIdentifier	 m Argument
=	TokenNameEQUAL	
ColumnFamilyArgument	TokenNameIdentifier	 Column Family Argument
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
currentArgument	TokenNameIdentifier	 current Argument
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mValue	TokenNameIdentifier	 m Value
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
mArgument	TokenNameIdentifier	 m Argument
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
COLUMN_TYPE	TokenNameIdentifier	 COLUMN  TYPE
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setColumn_type	TokenNameIdentifier	 set Column type
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMPARATOR	TokenNameIdentifier	 COMPARATOR
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setComparator_type	TokenNameIdentifier	 set Comparator type
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
SUBCOMPARATOR	TokenNameIdentifier	 SUBCOMPARATOR
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setSubcomparator_type	TokenNameIdentifier	 set Subcomparator type
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMMENT	TokenNameIdentifier	 COMMENT
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setComment	TokenNameIdentifier	 set Comment
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
READ_REPAIR_CHANCE	TokenNameIdentifier	 READ  REPAIR  CHANCE
:	TokenNameCOLON	
double	TokenNamedouble	
chance	TokenNameIdentifier	 chance
=	TokenNameEQUAL	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
parseDouble	TokenNameIdentifier	 parse Double
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chance	TokenNameIdentifier	 chance
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
chance	TokenNameIdentifier	 chance
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error: read_repair_chance must be between 0 and 1."	TokenNameStringLiteral	Error: read_repair_chance must be between 0 and 1.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setRead_repair_chance	TokenNameIdentifier	 set Read repair chance
(	TokenNameLPAREN	
chance	TokenNameIdentifier	 chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DCLOCAL_READ_REPAIR_CHANCE	TokenNameIdentifier	 DCLOCAL  READ  REPAIR  CHANCE
:	TokenNameCOLON	
double	TokenNamedouble	
localChance	TokenNameIdentifier	 local Chance
=	TokenNameEQUAL	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
parseDouble	TokenNameIdentifier	 parse Double
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localChance	TokenNameIdentifier	 local Chance
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
localChance	TokenNameIdentifier	 local Chance
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Error: dclocal_read_repair_chance must be between 0 and 1."	TokenNameStringLiteral	Error: dclocal_read_repair_chance must be between 0 and 1.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setDclocal_read_repair_chance	TokenNameIdentifier	 set Dclocal read repair chance
(	TokenNameLPAREN	
localChance	TokenNameIdentifier	 local Chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GC_GRACE	TokenNameIdentifier	 GC  GRACE
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setGc_grace_seconds	TokenNameIdentifier	 set Gc grace seconds
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
:	TokenNameCOLON	
Tree	TokenNameIdentifier	 Tree
arrayOfMetaAttributes	TokenNameIdentifier	 array Of Meta Attributes
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
arrayOfMetaAttributes	TokenNameIdentifier	 array Of Meta Attributes
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"ARRAY"	TokenNameStringLiteral	ARRAY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"'column_metadata' format - [{ k:v, k:v, ..}, { ... }, ...]"	TokenNameStringLiteral	'column_metadata' format - [{ k:v, k:v, ..}, { ... }, ...]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setColumn_metadata	TokenNameIdentifier	 set Column metadata
(	TokenNameLPAREN	
getCFColumnMetaFromTree	TokenNameIdentifier	 get CF Column Meta From Tree
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
arrayOfMetaAttributes	TokenNameIdentifier	 array Of Meta Attributes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MEMTABLE_OPERATIONS	TokenNameIdentifier	 MEMTABLE  OPERATIONS
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MEMTABLE_THROUGHPUT	TokenNameIdentifier	 MEMTABLE  THROUGHPUT
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DEFAULT_VALIDATION_CLASS	TokenNameIdentifier	 DEFAULT  VALIDATION  CLASS
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setDefault_validation_class	TokenNameIdentifier	 set Default validation class
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MIN_COMPACTION_THRESHOLD	TokenNameIdentifier	 MIN  COMPACTION  THRESHOLD
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setMin_compaction_threshold	TokenNameIdentifier	 set Min compaction threshold
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
MAX_COMPACTION_THRESHOLD	TokenNameIdentifier	 MAX  COMPACTION  THRESHOLD
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setMax_compaction_threshold	TokenNameIdentifier	 set Max compaction threshold
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
REPLICATE_ON_WRITE	TokenNameIdentifier	 REPLICATE  ON  WRITE
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setReplicate_on_write	TokenNameIdentifier	 set Replicate on write
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
.	TokenNameDOT	
parseBoolean	TokenNameIdentifier	 parse Boolean
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
KEY_VALIDATION_CLASS	TokenNameIdentifier	 KEY  VALIDATION  CLASS
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setKey_validation_class	TokenNameIdentifier	 set Key validation class
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMPACTION_STRATEGY	TokenNameIdentifier	 COMPACTION  STRATEGY
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setCompaction_strategy	TokenNameIdentifier	 set Compaction strategy
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMPACTION_STRATEGY_OPTIONS	TokenNameIdentifier	 COMPACTION  STRATEGY  OPTIONS
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setCompaction_strategy_options	TokenNameIdentifier	 set Compaction strategy options
(	TokenNameLPAREN	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COMPRESSION_OPTIONS	TokenNameIdentifier	 COMPRESSION  OPTIONS
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setCompression_options	TokenNameIdentifier	 set Compression options
(	TokenNameLPAREN	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
BLOOM_FILTER_FP_CHANCE	TokenNameIdentifier	 BLOOM  FILTER  FP  CHANCE
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setBloom_filter_fp_chance	TokenNameIdentifier	 set Bloom filter fp chance
(	TokenNameLPAREN	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
parseDouble	TokenNameIdentifier	 parse Double
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CACHING	TokenNameIdentifier	 CACHING
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
setCaching	TokenNameIdentifier	 set Caching
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
mValue	TokenNameIdentifier	 m Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
//must match one of the above or we'd throw an exception at the valueOf statement above. 	TokenNameCOMMENT_LINE	must match one of the above or we'd throw an exception at the valueOf statement above. 
assert	TokenNameassert	
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
cfDef	TokenNameIdentifier	 cf Def
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Delete a keyspace * @param statement - a token tree representing current statement * @throws TException - exception * @throws InvalidRequestException - exception * @throws NotFoundException - exception * @throws SchemaDisagreementException */	TokenNameCOMMENT_JAVADOC	 Delete a keyspace @param statement - a token tree representing current statement @throws TException - exception @throws InvalidRequestException - exception @throws NotFoundException - exception @throws SchemaDisagreementException 
private	TokenNameprivate	
void	TokenNamevoid	
executeDelKeySpace	TokenNameIdentifier	 execute Del Key Space
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
SchemaDisagreementException	TokenNameIdentifier	 Schema Disagreement Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
keyspaceName	TokenNameIdentifier	 keyspace Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getKeySpace	TokenNameIdentifier	 get Key Space
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_drop_keyspace	TokenNameIdentifier	 system drop keyspace
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
)	TokenNameRPAREN	
//we just deleted the keyspace we were authenticated too 	TokenNameCOMMENT_LINE	we just deleted the keyspace we were authenticated too 
keySpace	TokenNameIdentifier	 key Space
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Delete a column family * @param statement - a token tree representing current statement * @throws TException - exception * @throws InvalidRequestException - exception * @throws NotFoundException - exception * @throws SchemaDisagreementException */	TokenNameCOMMENT_JAVADOC	 Delete a column family @param statement - a token tree representing current statement @throws TException - exception @throws InvalidRequestException - exception @throws NotFoundException - exception @throws SchemaDisagreementException 
private	TokenNameprivate	
void	TokenNamevoid	
executeDelColumnFamily	TokenNameIdentifier	 execute Del Column Family
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
SchemaDisagreementException	TokenNameIdentifier	 Schema Disagreement Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_drop_column_family	TokenNameIdentifier	 system drop column family
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeList	TokenNameIdentifier	 execute List
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
,	TokenNameCOMMA	
CharacterCodingException	TokenNameIdentifier	 Character Coding Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// extract column family 	TokenNameCOMMENT_LINE	extract column family 
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
rawStartKey	TokenNameIdentifier	 raw Start Key
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
rawEndKey	TokenNameIdentifier	 raw End Key
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
int	TokenNameint	
limitCount	TokenNameIdentifier	 limit Count
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
// will reset to default later if it's not specified 	TokenNameCOMMENT_LINE	will reset to default later if it's not specified 
int	TokenNameint	
columnCount	TokenNameIdentifier	 column Count
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
// will reset to default later if it's not specified 	TokenNameCOMMENT_LINE	will reset to default later if it's not specified 
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// optional arguments: key range and limit 	TokenNameCOMMENT_LINE	optional arguments: key range and limit 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_KEY_RANGE	TokenNameIdentifier	 NODE  KEY  RANGE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rawStartKey	TokenNameIdentifier	 raw Start Key
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
rawEndKey	TokenNameIdentifier	 raw End Key
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_LIMIT	TokenNameIdentifier	 NODE  LIMIT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid limit clause"	TokenNameStringLiteral	Invalid limit clause
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
limitCount	TokenNameIdentifier	 limit Count
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
limitCount	TokenNameIdentifier	 limit Count
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid limit "	TokenNameStringLiteral	Invalid limit 
+	TokenNamePLUS	
limitCount	TokenNameIdentifier	 limit Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_COLUMNS	TokenNameIdentifier	 NODE  COLUMNS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid columns clause."	TokenNameStringLiteral	Invalid columns clause.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
columnCount	TokenNameIdentifier	 column Count
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnCount	TokenNameIdentifier	 column Count
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid column limit: "	TokenNameStringLiteral	Invalid column limit: 
+	TokenNamePLUS	
columnCount	TokenNameIdentifier	 column Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
reversed	TokenNameIdentifier	 reversed
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
NODE_REVERSED	TokenNameIdentifier	 NODE  REVERSED
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
nfe	TokenNameIdentifier	 nfe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid column number format: "	TokenNameStringLiteral	Invalid column number format: 
+	TokenNamePLUS	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
limitCount	TokenNameIdentifier	 limit Count
==	TokenNameEQUAL_EQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
limitCount	TokenNameIdentifier	 limit Count
=	TokenNameEQUAL	
100	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Using default limit of 100"	TokenNameStringLiteral	Using default limit of 100
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
columnCount	TokenNameIdentifier	 column Count
==	TokenNameEQUAL_EQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnCount	TokenNameIdentifier	 column Count
=	TokenNameEQUAL	
100	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Using default column limit of 100"	TokenNameStringLiteral	Using default column limit of 100
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// read all columns and superColumns 	TokenNameCOMMENT_LINE	read all columns and superColumns 
SlicePredicate	TokenNameIdentifier	 Slice Predicate
predicate	TokenNameIdentifier	 predicate
=	TokenNameEQUAL	
new	TokenNamenew	
SlicePredicate	TokenNameIdentifier	 Slice Predicate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SliceRange	TokenNameIdentifier	 Slice Range
sliceRange	TokenNameIdentifier	 slice Range
=	TokenNameEQUAL	
new	TokenNamenew	
SliceRange	TokenNameIdentifier	 Slice Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sliceRange	TokenNameIdentifier	 slice Range
.	TokenNameDOT	
setStart	TokenNameIdentifier	 set Start
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
setFinish	TokenNameIdentifier	 set Finish
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sliceRange	TokenNameIdentifier	 slice Range
.	TokenNameDOT	
setCount	TokenNameIdentifier	 set Count
(	TokenNameLPAREN	
columnCount	TokenNameIdentifier	 column Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sliceRange	TokenNameIdentifier	 slice Range
.	TokenNameDOT	
setReversed	TokenNameIdentifier	 set Reversed
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
predicate	TokenNameIdentifier	 predicate
.	TokenNameDOT	
setSlice_range	TokenNameIdentifier	 set Slice range
(	TokenNameLPAREN	
sliceRange	TokenNameIdentifier	 slice Range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// set the key range 	TokenNameCOMMENT_LINE	set the key range 
KeyRange	TokenNameIdentifier	 Key Range
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
KeyRange	TokenNameIdentifier	 Key Range
(	TokenNameLPAREN	
limitCount	TokenNameIdentifier	 limit Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
keyComparator	TokenNameIdentifier	 key Comparator
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
cfKeysComparators	TokenNameIdentifier	 cf Keys Comparators
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
startKey	TokenNameIdentifier	 start Key
=	TokenNameEQUAL	
rawStartKey	TokenNameIdentifier	 raw Start Key
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
:	TokenNameCOLON	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
rawStartKey	TokenNameIdentifier	 raw Start Key
,	TokenNameCOMMA	
keyComparator	TokenNameIdentifier	 key Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
endKey	TokenNameIdentifier	 end Key
=	TokenNameEQUAL	
rawEndKey	TokenNameIdentifier	 raw End Key
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
:	TokenNameCOLON	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
rawEndKey	TokenNameIdentifier	 raw End Key
,	TokenNameCOMMA	
keyComparator	TokenNameIdentifier	 key Comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
setStart_key	TokenNameIdentifier	 set Start key
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
)	TokenNameRPAREN	
.	TokenNameDOT	
setEnd_key	TokenNameIdentifier	 set End key
(	TokenNameLPAREN	
endKey	TokenNameIdentifier	 end Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnParent	TokenNameIdentifier	 Column Parent
columnParent	TokenNameIdentifier	 column Parent
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnParent	TokenNameIdentifier	 Column Parent
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
keySlices	TokenNameIdentifier	 key Slices
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
get_range_slices	TokenNameIdentifier	 get range slices
(	TokenNameLPAREN	
columnParent	TokenNameIdentifier	 column Parent
,	TokenNameCOMMA	
predicate	TokenNameIdentifier	 predicate
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
printSliceList	TokenNameIdentifier	 print Slice List
(	TokenNameLPAREN	
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
keySlices	TokenNameIdentifier	 key Slices
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// DROP INDEX ON <CF>.<COLUMN> 	TokenNameCOMMENT_LINE	DROP INDEX ON <CF>.<COLUMN> 
private	TokenNameprivate	
void	TokenNamevoid	
executeDropIndex	TokenNameIdentifier	 execute Drop Index
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
SchemaDisagreementException	TokenNameIdentifier	 Schema Disagreement Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// getColumnFamily will check if CF exists for us 	TokenNameCOMMENT_LINE	getColumnFamily will check if CF exists for us 
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
rawColumName	TokenNameIdentifier	 raw Colum Name
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
rawColumName	TokenNameIdentifier	 raw Colum Name
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
foundColumn	TokenNameIdentifier	 found Column
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
column	TokenNameIdentifier	 column
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
foundColumn	TokenNameIdentifier	 found Column
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getIndex_type	TokenNameIdentifier	 get Index type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Column '%s' does not have an index."	TokenNameStringLiteral	Column '%s' does not have an index.
,	TokenNameCOMMA	
rawColumName	TokenNameIdentifier	 raw Colum Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
setIndex_name	TokenNameIdentifier	 set Index name
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
setIndex_type	TokenNameIdentifier	 set Index type
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
foundColumn	TokenNameIdentifier	 found Column
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Column '%s' definition was not found in ColumnFamily '%s'."	TokenNameStringLiteral	Column '%s' definition was not found in ColumnFamily '%s'.
,	TokenNameCOMMA	
rawColumName	TokenNameIdentifier	 raw Colum Name
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
mySchemaVersion	TokenNameIdentifier	 my Schema Version
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
system_update_column_family	TokenNameIdentifier	 system update column family
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
mySchemaVersion	TokenNameIdentifier	 my Schema Version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TRUNCATE <columnFamily> 	TokenNameCOMMENT_LINE	TRUNCATE <columnFamily> 
private	TokenNameprivate	
void	TokenNamevoid	
executeTruncate	TokenNameIdentifier	 execute Truncate
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnavailableException	TokenNameIdentifier	 Unavailable Exception
,	TokenNameCOMMA	
TimedOutException	TokenNameIdentifier	 Timed Out Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// getting CfDef, it will fail if there is no such column family in current keySpace. 	TokenNameCOMMENT_LINE	getting CfDef, it will fail if there is no such column family in current keySpace. 
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
truncate	TokenNameIdentifier	 truncate
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
+	TokenNamePLUS	
" truncated."	TokenNameStringLiteral	 truncated.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Command: CONSISTENCYLEVEL AS (ONE | QUORUM ...) * Tree: ^(NODE_CONSISTENCY_LEVEL AS (ONE | QUORUM ...)) * @param statement - tree representing current statement */	TokenNameCOMMENT_JAVADOC	 Command: CONSISTENCYLEVEL AS (ONE | QUORUM ...) Tree: ^(NODE_CONSISTENCY_LEVEL AS (ONE | QUORUM ...)) @param statement - tree representing current statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeConsistencyLevelStatement	TokenNameIdentifier	 execute Consistency Level Statement
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
userSuppliedLevel	TokenNameIdentifier	 user Supplied Level
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
consistencyLevel	TokenNameIdentifier	 consistency Level
=	TokenNameEQUAL	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
userSuppliedLevel	TokenNameIdentifier	 user Supplied Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
elements	TokenNameIdentifier	 elements
=	TokenNameEQUAL	
"ONE, TWO, THREE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM, ANY"	TokenNameStringLiteral	ONE, TWO, THREE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM, ANY
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"'%s' is invalid. Available: %s"	TokenNameStringLiteral	'%s' is invalid. Available: %s
,	TokenNameCOMMA	
userSuppliedLevel	TokenNameIdentifier	 user Supplied Level
,	TokenNameCOMMA	
elements	TokenNameIdentifier	 elements
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Consistency level is set to '%s'."	TokenNameStringLiteral	Consistency level is set to '%s'.
,	TokenNameCOMMA	
consistencyLevel	TokenNameIdentifier	 consistency Level
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Command: ASSUME <columnFamily> (VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR) AS <type> * Tree: ^(NODE_ASSUME <columnFamily> (VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR) <type>)) * @param statement - tree representing current statement */	TokenNameCOMMENT_JAVADOC	 Command: ASSUME <columnFamily> (VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR) AS <type> Tree: ^(NODE_ASSUME <columnFamily> (VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR) <type>)) @param statement - tree representing current statement 
private	TokenNameprivate	
void	TokenNamevoid	
executeAssumeStatement	TokenNameIdentifier	 execute Assume Statement
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
currentCfDefs	TokenNameIdentifier	 current Cf Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR 	TokenNameCOMMENT_LINE	VALIDATOR | COMPARATOR | KEYS | SUB_COMPARATOR 
String	TokenNameIdentifier	 String
assumptionElement	TokenNameIdentifier	 assumption Element
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Could be UTF8Type, IntegerType, LexicalUUIDType etc. 	TokenNameCOMMENT_LINE	Could be UTF8Type, IntegerType, LexicalUUIDType etc. 
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
applyAssumption	TokenNameIdentifier	 apply Assumption
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
assumptionElement	TokenNameIdentifier	 assumption Element
,	TokenNameCOMMA	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
addAssumption	TokenNameIdentifier	 add Assumption
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
assumptionElement	TokenNameIdentifier	 assumption Element
,	TokenNameCOMMA	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Assumption for column family '%s' added successfully."	TokenNameStringLiteral	Assumption for column family '%s' added successfully.
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
applyAssumption	TokenNameIdentifier	 apply Assumption
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
assumptionElement	TokenNameIdentifier	 assumption Element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CfDef	TokenNameIdentifier	 Cf Def
columnFamily	TokenNameIdentifier	 column Family
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RuntimeException	TokenNameIdentifier	 Runtime Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// just fail if CF does not exist 	TokenNameCOMMENT_LINE	just fail if CF does not exist 
}	TokenNameRBRACE	
// used to store in this.cfKeysComparator 	TokenNameCOMMENT_LINE	used to store in this.cfKeysComparator 
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
TypeParser	TokenNameIdentifier	 Type Parser
.	TokenNameDOT	
parse	TokenNameIdentifier	 parse
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getValidator	TokenNameIdentifier	 get Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ne	TokenNameIdentifier	 ne
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
functions	TokenNameIdentifier	 functions
=	TokenNameEQUAL	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
getFunctionNames	TokenNameIdentifier	 get Function Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Type '"	TokenNameStringLiteral	Type '
+	TokenNamePLUS	
defaultType	TokenNameIdentifier	 default Type
+	TokenNamePLUS	
"' was not found. Available: "	TokenNameStringLiteral	' was not found. Available: 
+	TokenNamePLUS	
functions	TokenNameIdentifier	 functions
+	TokenNamePLUS	
" Or any class which extends o.a.c.db.marshal.AbstractType."	TokenNameStringLiteral	 Or any class which extends o.a.c.db.marshal.AbstractType.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// making string representation look property e.g. o.a.c.db.marshal.UTF8Type 	TokenNameCOMMENT_LINE	making string representation look property e.g. o.a.c.db.marshal.UTF8Type 
defaultType	TokenNameIdentifier	 default Type
=	TokenNameEQUAL	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionElement	TokenNameIdentifier	 assumption Element
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"COMPARATOR"	TokenNameStringLiteral	COMPARATOR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
setComparator_type	TokenNameIdentifier	 set Comparator type
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionElement	TokenNameIdentifier	 assumption Element
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"SUB_COMPARATOR"	TokenNameStringLiteral	SUB_COMPARATOR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
setSubcomparator_type	TokenNameIdentifier	 set Subcomparator type
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionElement	TokenNameIdentifier	 assumption Element
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"VALIDATOR"	TokenNameStringLiteral	VALIDATOR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
setDefault_validation_class	TokenNameIdentifier	 set Default validation class
(	TokenNameLPAREN	
defaultType	TokenNameIdentifier	 default Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionElement	TokenNameIdentifier	 assumption Element
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"KEYS"	TokenNameStringLiteral	KEYS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
cfKeysComparators	TokenNameIdentifier	 cf Keys Comparators
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
elements	TokenNameIdentifier	 elements
=	TokenNameEQUAL	
"VALIDATOR, COMPARATOR, KEYS, SUB_COMPARATOR."	TokenNameStringLiteral	VALIDATOR, COMPARATOR, KEYS, SUB_COMPARATOR.
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"'%s' is invalid. Available: %s"	TokenNameStringLiteral	'%s' is invalid. Available: %s
,	TokenNameCOMMA	
assumptionElement	TokenNameIdentifier	 assumption Element
,	TokenNameCOMMA	
elements	TokenNameIdentifier	 elements
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// SHOW API VERSION 	TokenNameCOMMENT_LINE	SHOW API VERSION 
private	TokenNameprivate	
void	TokenNamevoid	
executeShowVersion	TokenNameIdentifier	 execute Show Version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_version	TokenNameIdentifier	 describe version
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// SHOW KEYSPACES 	TokenNameCOMMENT_LINE	SHOW KEYSPACES 
private	TokenNameprivate	
void	TokenNamevoid	
executeShowKeySpaces	TokenNameIdentifier	 execute Show Key Spaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
keySpaces	TokenNameIdentifier	 key Spaces
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
keySpaces	TokenNameIdentifier	 key Spaces
,	TokenNameCOMMA	
new	TokenNamenew	
KsDefNamesComparator	TokenNameIdentifier	 Ks Def Names Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
KsDef	TokenNameIdentifier	 Ks Def
keySpace	TokenNameIdentifier	 key Space
:	TokenNameCOLON	
keySpaces	TokenNameIdentifier	 key Spaces
)	TokenNameRPAREN	
{	TokenNameLBRACE	
describeKeySpace	TokenNameIdentifier	 describe Key Space
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// SHOW SCHEMA 	TokenNameCOMMENT_LINE	SHOW SCHEMA 
private	TokenNameprivate	
void	TokenNamevoid	
executeShowSchema	TokenNameIdentifier	 execute Show Schema
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
keyspaces	TokenNameIdentifier	 keyspaces
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
keyspaces	TokenNameIdentifier	 keyspaces
,	TokenNameCOMMA	
new	TokenNamenew	
KsDefNamesComparator	TokenNameIdentifier	 Ks Def Names Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
keyspaceName	TokenNameIdentifier	 keyspace Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
keySpace	TokenNameIdentifier	 key Space
:	TokenNameCOLON	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getKeySpace	TokenNameIdentifier	 get Key Space
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
,	TokenNameCOMMA	
keyspaces	TokenNameIdentifier	 keyspaces
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
ksIter	TokenNameIdentifier	 ks Iter
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyspaceName	TokenNameIdentifier	 keyspace Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
ksIter	TokenNameIdentifier	 ks Iter
=	TokenNameEQUAL	
Collections2	TokenNameIdentifier	 Collections2
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
keyspaces	TokenNameIdentifier	 keyspaces
,	TokenNameCOMMA	
new	TokenNamenew	
Predicate	TokenNameIdentifier	 Predicate
<	TokenNameLESS	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
keyspaceName	TokenNameIdentifier	 keyspace Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
ksIter	TokenNameIdentifier	 ks Iter
=	TokenNameEQUAL	
keyspaces	TokenNameIdentifier	 keyspaces
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ksIter	TokenNameIdentifier	 ks Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
showKeyspace	TokenNameIdentifier	 show Keyspace
(	TokenNameLPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
,	TokenNameCOMMA	
ksIter	TokenNameIdentifier	 ks Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
flush	TokenNameIdentifier	 flush
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a CLI script to create the Keyspace it's Column Families * * @param output StringBuilder to write to. * @param ksDef KsDef to create the cli script for. */	TokenNameCOMMENT_JAVADOC	 Creates a CLI script to create the Keyspace it's Column Families * @param output StringBuilder to write to. @param ksDef KsDef to create the cli script for. 
private	TokenNameprivate	
void	TokenNamevoid	
showKeyspace	TokenNameIdentifier	 show Keyspace
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"create keyspace "	TokenNameStringLiteral	create keyspace 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
"placement_strategy"	TokenNameStringLiteral	placement_strategy
,	TokenNameCOMMA	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
strategy_class	TokenNameIdentifier	 strategy class
,	TokenNameCOMMA	
"org.apache.cassandra.locator"	TokenNameStringLiteral	org.apache.cassandra.locator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
strategy_options	TokenNameIdentifier	 strategy options
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
strategy_options	TokenNameIdentifier	 strategy options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
StringBuilder	TokenNameIdentifier	 String Builder
opts	TokenNameIdentifier	 opts
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
opts	TokenNameIdentifier	 opts
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
opt	TokenNameIdentifier	 opt
:	TokenNameCOLON	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
strategy_options	TokenNameIdentifier	 strategy options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
opts	TokenNameIdentifier	 opts
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
opt	TokenNameIdentifier	 opt
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" : "	TokenNameStringLiteral	 : 
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
opt	TokenNameIdentifier	 opt
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
", "	TokenNameStringLiteral	, 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
opts	TokenNameIdentifier	 opts
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"strategy_options"	TokenNameStringLiteral	strategy_options
,	TokenNameCOMMA	
opts	TokenNameIdentifier	 opts
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"durable_writes"	TokenNameStringLiteral	durable_writes
,	TokenNameCOMMA	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
durable_writes	TokenNameIdentifier	 durable writes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
";"	TokenNameStringLiteral	;
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"use "	TokenNameStringLiteral	use 
+	TokenNamePLUS	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
";"	TokenNameStringLiteral	;
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
,	TokenNameCOMMA	
new	TokenNamenew	
CfDefNamesComparator	TokenNameIdentifier	 Cf Def Names Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
:	TokenNameCOLON	
ksDef	TokenNameIdentifier	 ks Def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
)	TokenNameRPAREN	
showColumnFamily	TokenNameIdentifier	 show Column Family
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a CLI script for the CfDef including meta data to the supplied StringBuilder. * * @param output File to write to. * @param cfDef CfDef to export attributes from. */	TokenNameCOMMENT_JAVADOC	 Creates a CLI script for the CfDef including meta data to the supplied StringBuilder. * @param output File to write to. @param cfDef CfDef to export attributes from. 
private	TokenNameprivate	
void	TokenNamevoid	
showColumnFamily	TokenNameIdentifier	 show Column Family
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"create column family "	TokenNameStringLiteral	create column family 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
"column_type"	TokenNameStringLiteral	column_type
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"comparator"	TokenNameStringLiteral	comparator
,	TokenNameCOMMA	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
,	TokenNameCOMMA	
"org.apache.cassandra.db.marshal"	TokenNameStringLiteral	org.apache.cassandra.db.marshal
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
)	TokenNameRPAREN	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"subcomparator"	TokenNameStringLiteral	subcomparator
,	TokenNameCOMMA	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
,	TokenNameCOMMA	
"org.apache.cassandra.db.marshal"	TokenNameStringLiteral	org.apache.cassandra.db.marshal
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"default_validation_class"	TokenNameStringLiteral	default_validation_class
,	TokenNameCOMMA	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
,	TokenNameCOMMA	
"org.apache.cassandra.db.marshal"	TokenNameStringLiteral	org.apache.cassandra.db.marshal
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"key_validation_class"	TokenNameStringLiteral	key_validation_class
,	TokenNameCOMMA	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
key_validation_class	TokenNameIdentifier	 key validation class
,	TokenNameCOMMA	
"org.apache.cassandra.db.marshal"	TokenNameStringLiteral	org.apache.cassandra.db.marshal
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"read_repair_chance"	TokenNameStringLiteral	read_repair_chance
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
read_repair_chance	TokenNameIdentifier	 read repair chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"dclocal_read_repair_chance"	TokenNameStringLiteral	dclocal_read_repair_chance
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
dclocal_read_repair_chance	TokenNameIdentifier	 dclocal read repair chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"gc_grace"	TokenNameStringLiteral	gc_grace
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
gc_grace_seconds	TokenNameIdentifier	 gc grace seconds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"min_compaction_threshold"	TokenNameStringLiteral	min_compaction_threshold
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
min_compaction_threshold	TokenNameIdentifier	 min compaction threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"max_compaction_threshold"	TokenNameStringLiteral	max_compaction_threshold
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
max_compaction_threshold	TokenNameIdentifier	 max compaction threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"replicate_on_write"	TokenNameStringLiteral	replicate_on_write
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
replicate_on_write	TokenNameIdentifier	 replicate on write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"compaction_strategy"	TokenNameStringLiteral	compaction_strategy
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compaction_strategy	TokenNameIdentifier	 compaction strategy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"caching"	TokenNameStringLiteral	caching
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
caching	TokenNameIdentifier	 caching
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isSetBloom_filter_fp_chance	TokenNameIdentifier	 is Set Bloom filter fp chance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"bloom_filter_fp_chance"	TokenNameStringLiteral	bloom_filter_fp_chance
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
bloom_filter_fp_chance	TokenNameIdentifier	 bloom filter fp chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compaction_strategy_options	TokenNameIdentifier	 compaction strategy options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
cOptions	TokenNameIdentifier	 c Options
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cOptions	TokenNameIdentifier	 c Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
options	TokenNameIdentifier	 options
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compaction_strategy_options	TokenNameIdentifier	 compaction strategy options
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cOptions	TokenNameIdentifier	 c Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
quote	TokenNameIdentifier	 quote
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" : "	TokenNameStringLiteral	 : 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
quote	TokenNameIdentifier	 quote
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
cOptions	TokenNameIdentifier	 c Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cOptions	TokenNameIdentifier	 c Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"compaction_strategy_options"	TokenNameStringLiteral	compaction_strategy_options
,	TokenNameCOMMA	
cOptions	TokenNameIdentifier	 c Options
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
)	TokenNameRPAREN	
)	TokenNameRPAREN	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"comment"	TokenNameStringLiteral	comment
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_metadata	TokenNameIdentifier	 column metadata
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"and column_metadata = ["	TokenNameStringLiteral	and column_metadata = [
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
colDef	TokenNameIdentifier	 col Def
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_metadata	TokenNameIdentifier	 column metadata
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
showColumnMeta	TokenNameIdentifier	 show Column Meta
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
colDef	TokenNameIdentifier	 col Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
compOptions	TokenNameIdentifier	 comp Options
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compOptions	TokenNameIdentifier	 comp Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compOptions	TokenNameIdentifier	 comp Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
quote	TokenNameIdentifier	 quote
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" : "	TokenNameStringLiteral	 : 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
quote	TokenNameIdentifier	 quote
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
compOptions	TokenNameIdentifier	 comp Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
compOptions	TokenNameIdentifier	 comp Options
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
"compression_options"	TokenNameStringLiteral	compression_options
,	TokenNameCOMMA	
compOptions	TokenNameIdentifier	 comp Options
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
";"	TokenNameStringLiteral	;
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Writes the supplied ColumnDef to the StringBuilder as a cli script. * * @param output The File to write to. * @param cfDef The CfDef as a source for comparator/validator * @param colDef The Column Definition to export */	TokenNameCOMMENT_JAVADOC	 Writes the supplied ColumnDef to the StringBuilder as a cli script. * @param output The File to write to. @param cfDef The CfDef as a source for comparator/validator @param colDef The Column Definition to export 
private	TokenNameprivate	
void	TokenNamevoid	
showColumnMeta	TokenNameIdentifier	 show Column Meta
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
ColumnDef	TokenNameIdentifier	 Column Def
colDef	TokenNameIdentifier	 col Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
?	TokenNameQUESTION	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"column_name : '"	TokenNameStringLiteral	column_name : '
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"',"	TokenNameStringLiteral	',
+	TokenNamePLUS	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
validationClass	TokenNameIdentifier	 validation Class
=	TokenNameEQUAL	
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
validation_class	TokenNameIdentifier	 validation class
,	TokenNameCOMMA	
"org.apache.cassandra.db.marshal"	TokenNameStringLiteral	org.apache.cassandra.db.marshal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
"validation_class : "	TokenNameStringLiteral	validation_class : 
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
isSetIndex_name	TokenNameIdentifier	 is Set Index name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
"index_name : '"	TokenNameStringLiteral	index_name : '
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_name	TokenNameIdentifier	 index name
)	TokenNameRPAREN	
+	TokenNamePLUS	
"',"	TokenNameStringLiteral	',
+	TokenNamePLUS	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
"index_type : "	TokenNameStringLiteral	index_type : 
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_type	TokenNameIdentifier	 index type
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_options	TokenNameIdentifier	 index options
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_options	TokenNameIdentifier	 index options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
"index_options : {"	TokenNameStringLiteral	index_options : {
+	TokenNamePLUS	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
numOpts	TokenNameIdentifier	 num Opts
=	TokenNameEQUAL	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_options	TokenNameIdentifier	 index options
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
colDef	TokenNameIdentifier	 col Def
.	TokenNameDOT	
index_options	TokenNameIdentifier	 index options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
option	TokenNameIdentifier	 option
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
optionValue	TokenNameIdentifier	 option Value
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
+	TokenNamePLUS	
TAB	TokenNameIdentifier	 TAB
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"'"	TokenNameStringLiteral	'
+	TokenNamePLUS	
option	TokenNameIdentifier	 option
+	TokenNamePLUS	
"' : '"	TokenNameStringLiteral	' : '
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
optionValue	TokenNameIdentifier	 option Value
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
--	TokenNameMINUS_MINUS	
numOpts	TokenNameIdentifier	 num Opts
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
normaliseType	TokenNameIdentifier	 normalise Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
expectedPackage	TokenNameIdentifier	 expected Package
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
expectedPackage	TokenNameIdentifier	 expected Package
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
expectedPackage	TokenNameIdentifier	 expected Package
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Number	TokenNameIdentifier	 Number
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeAttr	TokenNameIdentifier	 write Attr
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
"'"	TokenNameStringLiteral	'
+	TokenNamePLUS	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
escapeSQLString	TokenNameIdentifier	 escape SQL String
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
+	TokenNamePLUS	
"'"	TokenNameStringLiteral	'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeAttrRaw	TokenNameIdentifier	 write Attr Raw
(	TokenNameLPAREN	
PrintStream	TokenNameIdentifier	 Print Stream
output	TokenNameIdentifier	 output
,	TokenNameCOMMA	
boolean	TokenNameboolean	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
NEWLINE	TokenNameIdentifier	 NEWLINE
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
TAB	TokenNameIdentifier	 TAB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
?	TokenNameQUESTION	
"with "	TokenNameStringLiteral	with 
:	TokenNameCOLON	
"and "	TokenNameStringLiteral	and 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" = "	TokenNameStringLiteral	 = 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
output	TokenNameIdentifier	 output
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if this.keySpace is set, false otherwise * @return boolean */	TokenNameCOMMENT_JAVADOC	 Returns true if this.keySpace is set, false otherwise @return boolean 
private	TokenNameprivate	
boolean	TokenNameboolean	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
boolean	TokenNameboolean	
printError	TokenNameIdentifier	 print Error
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
hasKeyspace	TokenNameIdentifier	 has Keyspace
=	TokenNameEQUAL	
keySpace	TokenNameIdentifier	 key Space
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasKeyspace	TokenNameIdentifier	 has Keyspace
&&	TokenNameAND_AND	
printError	TokenNameIdentifier	 print Error
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Not authorized to a working keyspace."	TokenNameStringLiteral	Not authorized to a working keyspace.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
hasKeyspace	TokenNameIdentifier	 has Keyspace
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getKeySpace	TokenNameIdentifier	 get Key Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
keySpace	TokenNameIdentifier	 key Space
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"unknown"	TokenNameStringLiteral	unknown
:	TokenNameCOLON	
keySpace	TokenNameIdentifier	 key Space
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setKeySpace	TokenNameIdentifier	 set Key Space
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
throws	TokenNamethrows	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
keySpace	TokenNameIdentifier	 key Space
=	TokenNameEQUAL	
keySpace	TokenNameIdentifier	 key Space
;	TokenNameSEMICOLON	
// We do nothing with the return value, but it hits a cache and the tab-completer. 	TokenNameCOMMENT_LINE	We do nothing with the return value, but it hits a cache and the tab-completer. 
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getUsername	TokenNameIdentifier	 get Username
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
username	TokenNameIdentifier	 username
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
"default"	TokenNameStringLiteral	default
:	TokenNameCOLON	
username	TokenNameIdentifier	 username
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setUsername	TokenNameIdentifier	 set Username
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
username	TokenNameIdentifier	 username
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
username	TokenNameIdentifier	 username
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// USE <keyspace_name> 	TokenNameCOMMENT_LINE	USE <keyspace_name> 
private	TokenNameprivate	
void	TokenNamevoid	
executeUseKeySpace	TokenNameIdentifier	 execute Use Key Space
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
int	TokenNameint	
childCount	TokenNameIdentifier	 child Count
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
keySpaceName	TokenNameIdentifier	 key Space Name
,	TokenNameCOMMA	
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
password	TokenNameIdentifier	 password
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Get keyspace name 	TokenNameCOMMENT_LINE	Get keyspace name 
keySpaceName	TokenNameIdentifier	 key Space Name
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childCount	TokenNameIdentifier	 child Count
==	TokenNameEQUAL_EQUAL	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
password	TokenNameIdentifier	 password
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Keyspace argument required"	TokenNameStringLiteral	Keyspace argument required
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
AuthenticationRequest	TokenNameIdentifier	 Authentication Request
authRequest	TokenNameIdentifier	 auth Request
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
credentials	TokenNameIdentifier	 credentials
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keySpaceName	TokenNameIdentifier	 key Space Name
=	TokenNameEQUAL	
CliCompiler	TokenNameIdentifier	 Cli Compiler
.	TokenNameDOT	
getKeySpace	TokenNameIdentifier	 get Key Space
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
set_keyspace	TokenNameIdentifier	 set keyspace
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
username	TokenNameIdentifier	 username
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
password	TokenNameIdentifier	 password
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* remove quotes */	TokenNameCOMMENT_BLOCK	 remove quotes 
password	TokenNameIdentifier	 password
=	TokenNameEQUAL	
password	TokenNameIdentifier	 password
.	TokenNameDOT	
replace	TokenNameIdentifier	 replace
(	TokenNameLPAREN	
"'"	TokenNameStringLiteral	'
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
credentials	TokenNameIdentifier	 credentials
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
IAuthenticator	TokenNameIdentifier	 I Authenticator
.	TokenNameDOT	
USERNAME_KEY	TokenNameIdentifier	 USERNAME  KEY
,	TokenNameCOMMA	
username	TokenNameIdentifier	 username
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
credentials	TokenNameIdentifier	 credentials
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
IAuthenticator	TokenNameIdentifier	 I Authenticator
.	TokenNameDOT	
PASSWORD_KEY	TokenNameIdentifier	 PASSWORD  KEY
,	TokenNameCOMMA	
password	TokenNameIdentifier	 password
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
authRequest	TokenNameIdentifier	 auth Request
=	TokenNameEQUAL	
new	TokenNamenew	
AuthenticationRequest	TokenNameIdentifier	 Authentication Request
(	TokenNameLPAREN	
credentials	TokenNameIdentifier	 credentials
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
login	TokenNameIdentifier	 login
(	TokenNameLPAREN	
authRequest	TokenNameIdentifier	 auth Request
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
keySpace	TokenNameIdentifier	 key Space
=	TokenNameEQUAL	
keySpaceName	TokenNameIdentifier	 key Space Name
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
username	TokenNameIdentifier	 username
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
username	TokenNameIdentifier	 username
:	TokenNameCOLON	
"default"	TokenNameStringLiteral	default
;	TokenNameSEMICOLON	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
updateCompletor	TokenNameIdentifier	 update Completor
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
getCfNamesByKeySpace	TokenNameIdentifier	 get Cf Names By Key Space
(	TokenNameLPAREN	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Authenticated to keyspace: "	TokenNameStringLiteral	Authenticated to keyspace: 
+	TokenNamePLUS	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
AuthenticationException	TokenNameIdentifier	 Authentication Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Exception during authentication to the cassandra node: "	TokenNameStringLiteral	Exception during authentication to the cassandra node: 
+	TokenNamePLUS	
"verify keyspace exists, and you are using correct credentials."	TokenNameStringLiteral	verify keyspace exists, and you are using correct credentials.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
AuthorizationException	TokenNameIdentifier	 Authorization Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"You are not authorized to use keyspace: "	TokenNameStringLiteral	You are not authorized to use keyspace: 
+	TokenNamePLUS	
keySpaceName	TokenNameIdentifier	 key Space Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
+	TokenNamePLUS	
" does not exist."	TokenNameStringLiteral	 does not exist.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NotFoundException	TokenNameIdentifier	 Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
+	TokenNamePLUS	
" does not exist."	TokenNameStringLiteral	 does not exist.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TException	TokenNameIdentifier	 T Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
printStackTrace	TokenNameIdentifier	 print Stack Trace
(	TokenNameLPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Login failure. Did you specify 'keyspace', 'username' and 'password'?"	TokenNameStringLiteral	Login failure. Did you specify 'keyspace', 'username' and 'password'?
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
executeTraceNextQuery	TokenNameIdentifier	 execute Trace Next Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
CharacterCodingException	TokenNameIdentifier	 Character Coding Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
UUID	TokenNameIdentifier	 UUID
sessionId	TokenNameIdentifier	 session Id
=	TokenNameEQUAL	
TimeUUIDType	TokenNameIdentifier	 Time UUID Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
compose	TokenNameIdentifier	 compose
(	TokenNameLPAREN	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
trace_next_query	TokenNameIdentifier	 trace next query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Will trace next query. Session ID: "	TokenNameStringLiteral	Will trace next query. Session ID: 
+	TokenNamePLUS	
sessionId	TokenNameIdentifier	 session Id
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
describeKeySpace	TokenNameIdentifier	 describe Key Space
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keySpaceName	TokenNameIdentifier	 key Space Name
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
NodeProbe	TokenNameIdentifier	 Node Probe
probe	TokenNameIdentifier	 probe
=	TokenNameEQUAL	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
getNodeProbe	TokenNameIdentifier	 get Node Probe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// getting compaction manager MBean to displaying index building information 	TokenNameCOMMENT_LINE	getting compaction manager MBean to displaying index building information 
CompactionManagerMBean	TokenNameIdentifier	 Compaction Manager M Bean
compactionManagerMBean	TokenNameIdentifier	 compaction Manager M Bean
=	TokenNameEQUAL	
(	TokenNameLPAREN	
probe	TokenNameIdentifier	 probe
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
probe	TokenNameIdentifier	 probe
.	TokenNameDOT	
getCompactionManagerProxy	TokenNameIdentifier	 get Compaction Manager Proxy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Describe and display 	TokenNameCOMMENT_LINE	Describe and display 
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Keyspace: "	TokenNameStringLiteral	Keyspace: 
+	TokenNamePLUS	
keySpaceName	TokenNameIdentifier	 key Space Name
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
KsDef	TokenNameIdentifier	 Ks Def
ks_def	TokenNameIdentifier	 ks def
;	TokenNameSEMICOLON	
ks_def	TokenNameIdentifier	 ks def
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspace	TokenNameIdentifier	 describe keyspace
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
)	TokenNameRPAREN	
:	TokenNameCOLON	
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Replication Strategy: "	TokenNameStringLiteral	 Replication Strategy: 
+	TokenNamePLUS	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
strategy_class	TokenNameIdentifier	 strategy class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Durable Writes: "	TokenNameStringLiteral	 Durable Writes: 
+	TokenNamePLUS	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
durable_writes	TokenNameIdentifier	 durable writes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
options	TokenNameIdentifier	 options
=	TokenNameEQUAL	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
strategy_options	TokenNameIdentifier	 strategy options
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Options: ["	TokenNameStringLiteral	 Options: [
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"]"	TokenNameStringLiteral	]
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Column Families:"	TokenNameStringLiteral	 Column Families:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
,	TokenNameCOMMA	
new	TokenNamenew	
CfDefNamesComparator	TokenNameIdentifier	 Cf Def Names Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cf_def	TokenNameIdentifier	 cf def
:	TokenNameCOLON	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
)	TokenNameRPAREN	
describeColumnFamily	TokenNameIdentifier	 describe Column Family
(	TokenNameLPAREN	
ks_def	TokenNameIdentifier	 ks def
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
,	TokenNameCOMMA	
probe	TokenNameIdentifier	 probe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// compaction manager information 	TokenNameCOMMENT_LINE	compaction manager information 
if	TokenNameif	
(	TokenNameLPAREN	
compactionManagerMBean	TokenNameIdentifier	 compaction Manager M Bean
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
info	TokenNameIdentifier	 info
:	TokenNameCOLON	
compactionManagerMBean	TokenNameIdentifier	 compaction Manager M Bean
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if ongoing compaction type is index build 	TokenNameCOMMENT_LINE	if ongoing compaction type is index build 
if	TokenNameif	
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"taskType"	TokenNameStringLiteral	taskType
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
INDEX_BUILD	TokenNameIdentifier	 INDEX  BUILD
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%nCurrently building index %s, completed %d of %d bytes.%n"	TokenNameStringLiteral	%nCurrently building index %s, completed %d of %d bytes.%n
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"columnfamily"	TokenNameStringLiteral	columnfamily
)	TokenNameRPAREN	
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"bytesComplete"	TokenNameStringLiteral	bytesComplete
)	TokenNameRPAREN	
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
"totalBytes"	TokenNameStringLiteral	totalBytes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// closing JMX connection 	TokenNameCOMMENT_LINE	closing JMX connection 
if	TokenNameif	
(	TokenNameLPAREN	
probe	TokenNameIdentifier	 probe
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
probe	TokenNameIdentifier	 probe
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Invalid request: "	TokenNameStringLiteral	Invalid request: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NotFoundException	TokenNameIdentifier	 Not Found Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Keyspace "	TokenNameStringLiteral	Keyspace 
+	TokenNamePLUS	
keySpaceName	TokenNameIdentifier	 key Space Name
+	TokenNamePLUS	
" could not be found."	TokenNameStringLiteral	 could not be found.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Error while closing JMX connection: "	TokenNameStringLiteral	Error while closing JMX connection: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
describeColumnFamily	TokenNameIdentifier	 describe Column Family
(	TokenNameLPAREN	
KsDef	TokenNameIdentifier	 Ks Def
ks_def	TokenNameIdentifier	 ks def
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cf_def	TokenNameIdentifier	 cf def
,	TokenNameCOMMA	
NodeProbe	TokenNameIdentifier	 Node Probe
probe	TokenNameIdentifier	 probe
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
{	TokenNameLBRACE	
// fetching bean for current column family store 	TokenNameCOMMENT_LINE	fetching bean for current column family store 
ColumnFamilyStoreMBean	TokenNameIdentifier	 Column Family Store M Bean
cfMBean	TokenNameIdentifier	 cf M Bean
=	TokenNameEQUAL	
(	TokenNameLPAREN	
probe	TokenNameIdentifier	 probe
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
probe	TokenNameIdentifier	 probe
.	TokenNameDOT	
getCfsProxy	TokenNameIdentifier	 get Cfs Proxy
(	TokenNameLPAREN	
ks_def	TokenNameIdentifier	 ks def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSuper	TokenNameIdentifier	 is Super
=	TokenNameEQUAL	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" ColumnFamily: %s%s%n"	TokenNameStringLiteral	 ColumnFamily: %s%s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
isSuper	TokenNameIdentifier	 is Super
?	TokenNameQUESTION	
" (Super)"	TokenNameStringLiteral	 (Super)
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" "%s"%n"	TokenNameStringLiteral	 "%s"%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
key_validation_class	TokenNameIdentifier	 key validation class
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Key Validation Class: %s%n"	TokenNameStringLiteral	 Key Validation Class: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
key_validation_class	TokenNameIdentifier	 key validation class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Default column value validator: %s%n"	TokenNameStringLiteral	 Default column value validator: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Columns sorted by: %s%s%n"	TokenNameStringLiteral	 Columns sorted by: %s%s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
?	TokenNameQUESTION	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" GC grace seconds: %s%n"	TokenNameStringLiteral	 GC grace seconds: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
gc_grace_seconds	TokenNameIdentifier	 gc grace seconds
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Compaction min/max thresholds: %s/%s%n"	TokenNameStringLiteral	 Compaction min/max thresholds: %s/%s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
min_compaction_threshold	TokenNameIdentifier	 min compaction threshold
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
max_compaction_threshold	TokenNameIdentifier	 max compaction threshold
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Read repair chance: %s%n"	TokenNameStringLiteral	 Read repair chance: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
read_repair_chance	TokenNameIdentifier	 read repair chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" DC Local Read repair chance: %s%n"	TokenNameStringLiteral	 DC Local Read repair chance: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
dclocal_read_repair_chance	TokenNameIdentifier	 dclocal read repair chance
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Replicate on write: %s%n"	TokenNameStringLiteral	 Replicate on write: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
replicate_on_write	TokenNameIdentifier	 replicate on write
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Caching: %s%n"	TokenNameStringLiteral	 Caching: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
caching	TokenNameIdentifier	 caching
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Bloom Filter FP chance: %s%n"	TokenNameStringLiteral	 Bloom Filter FP chance: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
isSetBloom_filter_fp_chance	TokenNameIdentifier	 is Set Bloom filter fp chance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
bloom_filter_fp_chance	TokenNameIdentifier	 bloom filter fp chance
:	TokenNameCOLON	
"default"	TokenNameStringLiteral	default
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if we have connection to the cfMBean established 	TokenNameCOMMENT_LINE	if we have connection to the cfMBean established 
if	TokenNameif	
(	TokenNameLPAREN	
cfMBean	TokenNameIdentifier	 cf M Bean
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Built indexes: %s%n"	TokenNameStringLiteral	 Built indexes: %s%n
,	TokenNameCOMMA	
cfMBean	TokenNameIdentifier	 cf M Bean
.	TokenNameDOT	
getBuiltIndexes	TokenNameIdentifier	 get Built Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
getColumn_metadataSize	TokenNameIdentifier	 get Column metadata Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
leftSpace	TokenNameIdentifier	 left Space
=	TokenNameEQUAL	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnLeftSpace	TokenNameIdentifier	 column Left Space
=	TokenNameEQUAL	
leftSpace	TokenNameIdentifier	 left Space
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
compareWith	TokenNameIdentifier	 compare With
=	TokenNameEQUAL	
isSuper	TokenNameIdentifier	 is Super
?	TokenNameQUESTION	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
:	TokenNameCOLON	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
columnNameValidator	TokenNameIdentifier	 column Name Validator
=	TokenNameEQUAL	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
compareWith	TokenNameIdentifier	 compare With
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
leftSpace	TokenNameIdentifier	 left Space
+	TokenNamePLUS	
"Column Metadata:"	TokenNameStringLiteral	Column Metadata:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
columnDef	TokenNameIdentifier	 column Def
:	TokenNameCOLON	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
columnNameValidator	TokenNameIdentifier	 column Name Validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnNameValidator	TokenNameIdentifier	 column Name Validator
instanceof	TokenNameinstanceof	
BytesType	TokenNameIdentifier	 Bytes Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
columnString	TokenNameIdentifier	 column String
=	TokenNameEQUAL	
UTF8Type	TokenNameIdentifier	 UT F8 Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnName	TokenNameIdentifier	 column Name
=	TokenNameEQUAL	
columnString	TokenNameIdentifier	 column String
+	TokenNamePLUS	
" ("	TokenNameStringLiteral	 (
+	TokenNamePLUS	
columnName	TokenNameIdentifier	 column Name
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MarshalException	TokenNameIdentifier	 Marshal Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// guess it wasn't a utf8 column name after all 	TokenNameCOMMENT_LINE	guess it wasn't a utf8 column name after all 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
leftSpace	TokenNameIdentifier	 left Space
+	TokenNamePLUS	
" Column Name: "	TokenNameStringLiteral	 Column Name: 
+	TokenNamePLUS	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
columnLeftSpace	TokenNameIdentifier	 column Left Space
+	TokenNamePLUS	
"Validation Class: "	TokenNameStringLiteral	Validation Class: 
+	TokenNamePLUS	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
getValidation_class	TokenNameIdentifier	 get Validation class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
isSetIndex_name	TokenNameIdentifier	 is Set Index name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
columnLeftSpace	TokenNameIdentifier	 column Left Space
+	TokenNamePLUS	
"Index Name: "	TokenNameStringLiteral	Index Name: 
+	TokenNamePLUS	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
getIndex_name	TokenNameIdentifier	 get Index name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
isSetIndex_type	TokenNameIdentifier	 is Set Index type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
columnLeftSpace	TokenNameIdentifier	 column Left Space
+	TokenNamePLUS	
"Index Type: "	TokenNameStringLiteral	Index Type: 
+	TokenNamePLUS	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
getIndex_type	TokenNameIdentifier	 get Index type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
isSetIndex_options	TokenNameIdentifier	 is Set Index options
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
columnLeftSpace	TokenNameIdentifier	 column Left Space
+	TokenNamePLUS	
"Index Options: "	TokenNameStringLiteral	Index Options: 
+	TokenNamePLUS	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
getIndex_options	TokenNameIdentifier	 get Index options
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" Compaction Strategy: %s%n"	TokenNameStringLiteral	 Compaction Strategy: %s%n
,	TokenNameCOMMA	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compaction_strategy	TokenNameIdentifier	 compaction strategy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compaction_strategy_options	TokenNameIdentifier	 compaction strategy options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Compaction Strategy Options:"	TokenNameStringLiteral	 Compaction Strategy Options:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compaction_strategy_options	TokenNameIdentifier	 compaction strategy options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" %s: %s%n"	TokenNameStringLiteral	 %s: %s%n
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Compression Options:"	TokenNameStringLiteral	 Compression Options:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
e	TokenNameIdentifier	 e
:	TokenNameCOLON	
cf_def	TokenNameIdentifier	 cf def
.	TokenNameDOT	
compression_options	TokenNameIdentifier	 compression options
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
" %s: %s%n"	TokenNameStringLiteral	 %s: %s%n
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// DESCRIBE KEYSPACE (<keyspace> | <column_family>)? 	TokenNameCOMMENT_LINE	DESCRIBE KEYSPACE (<keyspace> | <column_family>)? 
private	TokenNameprivate	
void	TokenNamevoid	
executeDescribe	TokenNameIdentifier	 execute Describe
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
throws	TokenNamethrows	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
NotFoundException	TokenNameIdentifier	 Not Found Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
int	TokenNameint	
argCount	TokenNameIdentifier	 arg Count
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
argCount	TokenNameIdentifier	 arg Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Authenticate to a Keyspace, before using `describe` or `describe <column_family>`"	TokenNameStringLiteral	Authenticate to a Keyspace, before using `describe` or `describe <column_family>`
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
KsDef	TokenNameIdentifier	 Ks Def
currentKeySpace	TokenNameIdentifier	 current Key Space
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentKeySpace	TokenNameIdentifier	 current Key Space
=	TokenNameEQUAL	
getKSMetaData	TokenNameIdentifier	 get KS Meta Data
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
argCount	TokenNameIdentifier	 arg Count
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// in case somebody changes Cli grammar 	TokenNameCOMMENT_LINE	in case somebody changes Cli grammar 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"`describe` command take maximum one argument. See `help describe;`"	TokenNameStringLiteral	`describe` command take maximum one argument. See `help describe;`
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
argCount	TokenNameIdentifier	 arg Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentKeySpace	TokenNameIdentifier	 current Key Space
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
describeKeySpace	TokenNameIdentifier	 describe Key Space
(	TokenNameLPAREN	
currentKeySpace	TokenNameIdentifier	 current Key Space
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Authenticate to a Keyspace, before using `describe` or `describe <column_family>`"	TokenNameStringLiteral	Authenticate to a Keyspace, before using `describe` or `describe <column_family>`
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
argCount	TokenNameIdentifier	 arg Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// name of the keyspace or ColumnFamily 	TokenNameCOMMENT_LINE	name of the keyspace or ColumnFamily 
String	TokenNameIdentifier	 String
entityName	TokenNameIdentifier	 entity Name
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KsDef	TokenNameIdentifier	 Ks Def
inputKsDef	TokenNameIdentifier	 input Ks Def
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
getKeySpaceDef	TokenNameIdentifier	 get Key Space Def
(	TokenNameLPAREN	
entityName	TokenNameIdentifier	 entity Name
,	TokenNameCOMMA	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_keyspaces	TokenNameIdentifier	 describe keyspaces
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
inputKsDef	TokenNameIdentifier	 input Ks Def
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
currentKeySpace	TokenNameIdentifier	 current Key Space
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Keyspace with name '%s' wasn't found, "	TokenNameStringLiteral	Keyspace with name '%s' wasn't found, 
+	TokenNamePLUS	
"to lookup ColumnFamily with that name, please, authorize to one "	TokenNameStringLiteral	to lookup ColumnFamily with that name, please, authorize to one 
+	TokenNamePLUS	
"of the keyspaces first."	TokenNameStringLiteral	of the keyspaces first.
,	TokenNameCOMMA	
entityName	TokenNameIdentifier	 entity Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
inputCfDef	TokenNameIdentifier	 input Cf Def
=	TokenNameEQUAL	
(	TokenNameLPAREN	
inputKsDef	TokenNameIdentifier	 input Ks Def
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
currentKeySpace	TokenNameIdentifier	 current Key Space
,	TokenNameCOMMA	
entityName	TokenNameIdentifier	 entity Name
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// no need to lookup CfDef if we know that it was keyspace 	TokenNameCOMMENT_LINE	no need to lookup CfDef if we know that it was keyspace 
if	TokenNameif	
(	TokenNameLPAREN	
inputKsDef	TokenNameIdentifier	 input Ks Def
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
describeKeySpace	TokenNameIdentifier	 describe Key Space
(	TokenNameLPAREN	
inputKsDef	TokenNameIdentifier	 input Ks Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
inputKsDef	TokenNameIdentifier	 input Ks Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inputCfDef	TokenNameIdentifier	 input Cf Def
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeProbe	TokenNameIdentifier	 Node Probe
probe	TokenNameIdentifier	 probe
=	TokenNameEQUAL	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
getNodeProbe	TokenNameIdentifier	 get Node Probe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
describeColumnFamily	TokenNameIdentifier	 describe Column Family
(	TokenNameLPAREN	
currentKeySpace	TokenNameIdentifier	 current Key Space
,	TokenNameCOMMA	
inputCfDef	TokenNameIdentifier	 input Cf Def
,	TokenNameCOMMA	
probe	TokenNameIdentifier	 probe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
probe	TokenNameIdentifier	 probe
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
probe	TokenNameIdentifier	 probe
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Error while closing JMX connection: "	TokenNameStringLiteral	Error while closing JMX connection: 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Sorry, no Keyspace nor ColumnFamily was found with name: "	TokenNameStringLiteral	Sorry, no Keyspace nor ColumnFamily was found with name: 
+	TokenNamePLUS	
entityName	TokenNameIdentifier	 entity Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ^(NODE_DESCRIBE_CLUSTER) or describe: schema_versions, partitioner, snitch 	TokenNameCOMMENT_LINE	^(NODE_DESCRIBE_CLUSTER) or describe: schema_versions, partitioner, snitch 
private	TokenNameprivate	
void	TokenNamevoid	
executeDescribeCluster	TokenNameIdentifier	 execute Describe Cluster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Cluster Information:"	TokenNameStringLiteral	Cluster Information:
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Snitch: "	TokenNameStringLiteral	 Snitch: 
+	TokenNamePLUS	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_snitch	TokenNameIdentifier	 describe snitch
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Partitioner: "	TokenNameStringLiteral	 Partitioner: 
+	TokenNamePLUS	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_partitioner	TokenNameIdentifier	 describe partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" Schema versions: "	TokenNameStringLiteral	 Schema versions: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
versions	TokenNameIdentifier	 versions
=	TokenNameEQUAL	
thriftClient	TokenNameIdentifier	 thrift Client
.	TokenNameDOT	
describe_schema_versions	TokenNameIdentifier	 describe schema versions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
:	TokenNameCOLON	
versions	TokenNameIdentifier	 versions
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
" %s: %s%n"	TokenNameStringLiteral	 %s: %s%n
,	TokenNameCOMMA	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
versions	TokenNameIdentifier	 versions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
instanceof	TokenNameinstanceof	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
.	TokenNameDOT	
getWhy	TokenNameIdentifier	 get Why
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Error retrieving data: "	TokenNameStringLiteral	Error retrieving data: 
+	TokenNamePLUS	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// process a statement of the form: connect hostname/port 	TokenNameCOMMENT_LINE	process a statement of the form: connect hostname/port 
private	TokenNameprivate	
void	TokenNamevoid	
executeConnect	TokenNameIdentifier	 execute Connect
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
statement	TokenNameIdentifier	 statement
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
idList	TokenNameIdentifier	 id List
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
portNumber	TokenNameIdentifier	 port Number
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
parseInt	TokenNameIdentifier	 parse Int
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuilder	TokenNameIdentifier	 String Builder
hostName	TokenNameIdentifier	 host Name
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
idCount	TokenNameIdentifier	 id Count
=	TokenNameEQUAL	
idList	TokenNameIdentifier	 id List
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
<	TokenNameLESS	
idCount	TokenNameIdentifier	 id Count
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hostName	TokenNameIdentifier	 host Name
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
idList	TokenNameIdentifier	 id List
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// disconnect current connection, if any. 	TokenNameCOMMENT_LINE	disconnect current connection, if any. 
// This is a no-op, if you aren't currently connected. 	TokenNameCOMMENT_LINE	This is a no-op, if you aren't currently connected. 
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
disconnect	TokenNameIdentifier	 disconnect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now, connect to the newly specified host name and port 	TokenNameCOMMENT_LINE	now, connect to the newly specified host name and port 
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
hostName	TokenNameIdentifier	 host Name
=	TokenNameEQUAL	
hostName	TokenNameIdentifier	 host Name
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
thriftPort	TokenNameIdentifier	 thrift Port
=	TokenNameEQUAL	
portNumber	TokenNameIdentifier	 port Number
;	TokenNameSEMICOLON	
// if we have user name and password 	TokenNameCOMMENT_LINE	if we have user name and password 
if	TokenNameif	
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
username	TokenNameIdentifier	 username
=	TokenNameEQUAL	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
password	TokenNameIdentifier	 password
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
statement	TokenNameIdentifier	 statement
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
connect	TokenNameIdentifier	 connect
(	TokenNameLPAREN	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
hostName	TokenNameIdentifier	 host Name
,	TokenNameCOMMA	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
thriftPort	TokenNameIdentifier	 thrift Port
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * To get Column Family Definition object from specified keyspace * @param keySpaceName key space name to search for specific column family * @param columnFamilyName column family name * @return CfDef - Column family definition object */	TokenNameCOMMENT_JAVADOC	 To get Column Family Definition object from specified keyspace @param keySpaceName key space name to search for specific column family @param columnFamilyName column family name @return CfDef - Column family definition object 
private	TokenNameprivate	
CfDef	TokenNameIdentifier	 Cf Def
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keySpaceName	TokenNameIdentifier	 key Space Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
KsDef	TokenNameIdentifier	 Ks Def
ksDef	TokenNameIdentifier	 ks Def
=	TokenNameEQUAL	
keyspacesMap	TokenNameIdentifier	 keyspaces Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keySpaceName	TokenNameIdentifier	 key Space Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
ksDef	TokenNameIdentifier	 ks Def
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"No such column family: "	TokenNameStringLiteral	No such column family: 
+	TokenNamePLUS	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cfDef	TokenNameIdentifier	 cf Def
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Uses getCfDef(keySpaceName, columnFamilyName) with current keyspace * @param columnFamilyName column family name to find in specified keyspace * @return CfDef - Column family definition object */	TokenNameCOMMENT_JAVADOC	 Uses getCfDef(keySpaceName, columnFamilyName) with current keyspace @param columnFamilyName column family name to find in specified keyspace @return CfDef - Column family definition object 
private	TokenNameprivate	
CfDef	TokenNameIdentifier	 Cf Def
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CfDef	TokenNameIdentifier	 Cf Def
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
KsDef	TokenNameIdentifier	 Ks Def
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
:	TokenNameCOLON	
keyspace	TokenNameIdentifier	 keyspace
.	TokenNameDOT	
cf_defs	TokenNameIdentifier	 cf defs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
cfDef	TokenNameIdentifier	 cf Def
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
cql3KeyspacesMap	TokenNameIdentifier	 cql3 Keyspaces Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to parse meta tree and compile meta attributes into List<ColumnDef> * @param cfDef - column family definition * @param meta (Tree representing Array of the hashes with metadata attributes) * @return List<ColumnDef> List of the ColumnDef's * * meta is in following format - ^(ARRAY ^(HASH ^(PAIR .. ..) ^(PAIR .. ..)) ^(HASH ...)) */	TokenNameCOMMENT_JAVADOC	 Used to parse meta tree and compile meta attributes into List<ColumnDef> @param cfDef - column family definition @param meta (Tree representing Array of the hashes with metadata attributes) @return List<ColumnDef> List of the ColumnDef's * meta is in following format - ^(ARRAY ^(HASH ^(PAIR .. ..) ^(PAIR .. ..)) ^(HASH ...)) 
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
getCFColumnMetaFromTree	TokenNameIdentifier	 get CF Column Meta From Tree
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
Tree	TokenNameIdentifier	 Tree
meta	TokenNameIdentifier	 meta
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this list will be returned 	TokenNameCOMMENT_LINE	this list will be returned 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
columnDefinitions	TokenNameIdentifier	 column Definitions
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// each child node is a ^(HASH ...) 	TokenNameCOMMENT_LINE	each child node is a ^(HASH ...) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
meta	TokenNameIdentifier	 meta
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
metaHash	TokenNameIdentifier	 meta Hash
=	TokenNameEQUAL	
meta	TokenNameIdentifier	 meta
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnDef	TokenNameIdentifier	 Column Def
columnDefinition	TokenNameIdentifier	 column Definition
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnDef	TokenNameIdentifier	 Column Def
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// each child node is ^(PAIR $key $value) 	TokenNameCOMMENT_LINE	each child node is ^(PAIR $key $value) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
metaHash	TokenNameIdentifier	 meta Hash
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
metaPair	TokenNameIdentifier	 meta Pair
=	TokenNameEQUAL	
metaHash	TokenNameIdentifier	 meta Hash
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// current $key 	TokenNameCOMMENT_LINE	current $key 
String	TokenNameIdentifier	 String
metaKey	TokenNameIdentifier	 meta Key
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
metaPair	TokenNameIdentifier	 meta Pair
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// current $value 	TokenNameCOMMENT_LINE	current $value 
String	TokenNameIdentifier	 String
metaVal	TokenNameIdentifier	 meta Val
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
metaPair	TokenNameIdentifier	 meta Pair
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
metaKey	TokenNameIdentifier	 meta Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"column_name"	TokenNameStringLiteral	column_name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
column_type	TokenNameIdentifier	 column type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"Super"	TokenNameStringLiteral	Super
)	TokenNameRPAREN	
)	TokenNameRPAREN	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setName	TokenNameIdentifier	 set Name
(	TokenNameLPAREN	
subColumnNameAsByteArray	TokenNameIdentifier	 sub Column Name As Byte Array
(	TokenNameLPAREN	
metaVal	TokenNameIdentifier	 meta Val
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setName	TokenNameIdentifier	 set Name
(	TokenNameLPAREN	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
metaVal	TokenNameIdentifier	 meta Val
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
metaKey	TokenNameIdentifier	 meta Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"validation_class"	TokenNameStringLiteral	validation_class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setValidation_class	TokenNameIdentifier	 set Validation class
(	TokenNameLPAREN	
metaVal	TokenNameIdentifier	 meta Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
metaKey	TokenNameIdentifier	 meta Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"index_type"	TokenNameStringLiteral	index_type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setIndex_type	TokenNameIdentifier	 set Index type
(	TokenNameLPAREN	
getIndexTypeFromString	TokenNameIdentifier	 get Index Type From String
(	TokenNameLPAREN	
metaVal	TokenNameIdentifier	 meta Val
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
metaKey	TokenNameIdentifier	 meta Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"index_options"	TokenNameStringLiteral	index_options
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setIndex_options	TokenNameIdentifier	 set Index options
(	TokenNameLPAREN	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
metaPair	TokenNameIdentifier	 meta Pair
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
metaKey	TokenNameIdentifier	 meta Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"index_name"	TokenNameStringLiteral	index_name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
setIndex_name	TokenNameIdentifier	 set Index name
(	TokenNameLPAREN	
metaVal	TokenNameIdentifier	 meta Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Unsupported column_metadata pair given => "	TokenNameStringLiteral	Unsupported column_metadata pair given => 
+	TokenNamePLUS	
metaKey	TokenNameIdentifier	 meta Key
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
metaVal	TokenNameIdentifier	 meta Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// validating columnDef structure, 'name' and 'validation_class' must be set 	TokenNameCOMMENT_LINE	validating columnDef structure, 'name' and 'validation_class' must be set 
try	TokenNametry	
{	TokenNameLBRACE	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
TException	TokenNameIdentifier	 T Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
columnDefinitions	TokenNameIdentifier	 column Definitions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
columnDefinition	TokenNameIdentifier	 column Definition
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
columnDefinitions	TokenNameIdentifier	 column Definitions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Getting IndexType object from indexType string * @param indexTypeAsString - string return by parser corresponding to IndexType * @return IndexType - an IndexType object */	TokenNameCOMMENT_JAVADOC	 Getting IndexType object from indexType string @param indexTypeAsString - string return by parser corresponding to IndexType @return IndexType - an IndexType object 
private	TokenNameprivate	
IndexType	TokenNameIdentifier	 Index Type
getIndexTypeFromString	TokenNameIdentifier	 get Index Type From String
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
indexTypeAsString	TokenNameIdentifier	 index Type As String
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexType	TokenNameIdentifier	 Index Type
indexType	TokenNameIdentifier	 index Type
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
indexType	TokenNameIdentifier	 index Type
=	TokenNameEQUAL	
IndexType	TokenNameIdentifier	 Index Type
.	TokenNameDOT	
findByValue	TokenNameIdentifier	 find By Value
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
indexTypeAsString	TokenNameIdentifier	 index Type As String
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// if this is not an integer lets try to get IndexType by name 	TokenNameCOMMENT_LINE	if this is not an integer lets try to get IndexType by name 
indexType	TokenNameIdentifier	 index Type
=	TokenNameEQUAL	
IndexType	TokenNameIdentifier	 Index Type
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
indexTypeAsString	TokenNameIdentifier	 index Type As String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"IndexType '"	TokenNameStringLiteral	IndexType '
+	TokenNamePLUS	
indexTypeAsString	TokenNameIdentifier	 index Type As String
+	TokenNamePLUS	
"' is unsupported."	TokenNameStringLiteral	' is unsupported.
,	TokenNameCOMMA	
ie	TokenNameIdentifier	 ie
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexType	TokenNameIdentifier	 index Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"IndexType '"	TokenNameStringLiteral	IndexType '
+	TokenNamePLUS	
indexTypeAsString	TokenNameIdentifier	 index Type As String
+	TokenNamePLUS	
"' is unsupported."	TokenNameStringLiteral	' is unsupported.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
indexType	TokenNameIdentifier	 index Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts object represented as string into byte[] according to comparator * @param object - object to covert into byte array * @param comparator - comparator used to convert object * @return byte[] - object in the byte array representation */	TokenNameCOMMENT_JAVADOC	 Converts object represented as string into byte[] according to comparator @param object - object to covert into byte array @param comparator - comparator used to convert object @return byte[] - object in the byte array representation 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
object	TokenNameIdentifier	 object
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
comparator	TokenNameIdentifier	 comparator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
// default comparator is BytesType 	TokenNameCOMMENT_LINE	default comparator is BytesType 
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
BytesType	TokenNameIdentifier	 Bytes Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
object	TokenNameIdentifier	 object
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MarshalException	TokenNameIdentifier	 Marshal Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Converts column name into byte[] according to comparator type * @param column - column name from parser * @param columnFamily - column family name from parser * @return ByteBuffer - bytes into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts column name into byte[] according to comparator type @param column - column name from parser @param columnFamily - column family name from parser @return ByteBuffer - bytes into which column name was converted according to comparator type 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
columnFamilyDef	TokenNameIdentifier	 column Family Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts column name into byte[] according to comparator type * @param column - column name from parser * @param columnFamilyDef - column family from parser * @return ByteBuffer bytes - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts column name into byte[] according to comparator type @param column - column name from parser @param columnFamilyDef - column family from parser @return ByteBuffer bytes - into which column name was converted according to comparator type 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
comparatorClass	TokenNameIdentifier	 comparator Class
=	TokenNameEQUAL	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
comparatorClass	TokenNameIdentifier	 comparator Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts column name into byte[] according to comparator type * @param column - column name from parser * @param columnFamily - column family name from parser * @return bytes[] - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts column name into byte[] according to comparator type @param column - column name from parser @param columnFamily - column family name from parser @return bytes[] - into which column name was converted according to comparator type 
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
TBaseHelper	TokenNameIdentifier	 T Base Helper
.	TokenNameDOT	
byteBufferToByteArray	TokenNameIdentifier	 byte Buffer To Byte Array
(	TokenNameLPAREN	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts column name into byte[] according to comparator type * @param column - column name from parser * @param cfDef - column family from parser * @return bytes[] - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts column name into byte[] according to comparator type @param column - column name from parser @param cfDef - column family from parser @return bytes[] - into which column name was converted according to comparator type 
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnNameAsByteArray	TokenNameIdentifier	 column Name As Byte Array
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
TBaseHelper	TokenNameIdentifier	 T Base Helper
.	TokenNameDOT	
byteBufferToByteArray	TokenNameIdentifier	 byte Buffer To Byte Array
(	TokenNameLPAREN	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts sub-column name into ByteBuffer according to comparator type * @param superColumn - sub-column name from parser * @param columnFamily - column family name from parser * @return ByteBuffer bytes - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts sub-column name into ByteBuffer according to comparator type @param superColumn - sub-column name from parser @param columnFamily - column family name from parser @return ByteBuffer bytes - into which column name was converted according to comparator type 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
subColumnNameAsBytes	TokenNameIdentifier	 sub Column Name As Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
subColumnNameAsBytes	TokenNameIdentifier	 sub Column Name As Bytes
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
columnFamilyDef	TokenNameIdentifier	 column Family Def
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts column name into ByteBuffer according to comparator type * @param superColumn - sub-column name from parser * @param columnFamilyDef - column family from parser * @return ByteBuffer bytes - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts column name into ByteBuffer according to comparator type @param superColumn - sub-column name from parser @param columnFamilyDef - column family from parser @return ByteBuffer bytes - into which column name was converted according to comparator type 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
subColumnNameAsBytes	TokenNameIdentifier	 sub Column Name As Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
comparatorClass	TokenNameIdentifier	 comparator Class
=	TokenNameEQUAL	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
comparatorClass	TokenNameIdentifier	 comparator Class
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Notice: defaulting to BytesType subcomparator for '%s'"	TokenNameStringLiteral	Notice: defaulting to BytesType subcomparator for '%s'
,	TokenNameCOMMA	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
comparatorClass	TokenNameIdentifier	 comparator Class
=	TokenNameEQUAL	
"BytesType"	TokenNameStringLiteral	BytesType
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
comparatorClass	TokenNameIdentifier	 comparator Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts sub-column name into byte[] according to comparator type * @param superColumn - sub-column name from parser * @param cfDef - column family from parser * @return bytes[] - into which column name was converted according to comparator type */	TokenNameCOMMENT_JAVADOC	 Converts sub-column name into byte[] according to comparator type @param superColumn - sub-column name from parser @param cfDef - column family from parser @return bytes[] - into which column name was converted according to comparator type 
private	TokenNameprivate	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
subColumnNameAsByteArray	TokenNameIdentifier	 sub Column Name As Byte Array
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
TBaseHelper	TokenNameIdentifier	 T Base Helper
.	TokenNameDOT	
byteBufferToByteArray	TokenNameIdentifier	 byte Buffer To Byte Array
(	TokenNameLPAREN	
subColumnNameAsBytes	TokenNameIdentifier	 sub Column Name As Bytes
(	TokenNameLPAREN	
superColumn	TokenNameIdentifier	 super Column
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Converts column value into byte[] according to validation class * @param columnName - column name to which value belongs * @param columnFamilyName - column family name * @param columnValue - actual column value * @return value in byte array representation */	TokenNameCOMMENT_JAVADOC	 Converts column value into byte[] according to validation class @param columnName - column name to which value belongs @param columnFamilyName - column family name @param columnValue - actual column value @return value in byte array representation 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnValueAsBytes	TokenNameIdentifier	 column Value As Bytes
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnValue	TokenNameIdentifier	 column Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
columnDefinition	TokenNameIdentifier	 column Definition
:	TokenNameCOLON	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
currentColumnName	TokenNameIdentifier	 current Column Name
=	TokenNameEQUAL	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
currentColumnName	TokenNameIdentifier	 current Column Name
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
validationClass	TokenNameIdentifier	 validation Class
=	TokenNameEQUAL	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
getValidation_class	TokenNameIdentifier	 get Validation class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
columnValue	TokenNameIdentifier	 column Value
,	TokenNameCOMMA	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
defaultValidator	TokenNameIdentifier	 default Validator
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
columnValue	TokenNameIdentifier	 column Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get validator for specific column value * @param cfDef - CfDef object representing column family with metadata * @param columnNameInBytes - column name as byte array * @return AbstractType - validator for column value */	TokenNameCOMMENT_JAVADOC	 Get validator for specific column value @param cfDef - CfDef object representing column family with metadata @param columnNameInBytes - column name as byte array @return AbstractType - validator for column value 
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnNameInBytes	TokenNameIdentifier	 column Name In Bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
columnDefinition	TokenNameIdentifier	 column Definition
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nameInBytes	TokenNameIdentifier	 name In Bytes
=	TokenNameEQUAL	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
nameInBytes	TokenNameIdentifier	 name In Bytes
,	TokenNameCOMMA	
columnNameInBytes	TokenNameIdentifier	 column Name In Bytes
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
columnDefinition	TokenNameIdentifier	 column Definition
.	TokenNameDOT	
getValidation_class	TokenNameIdentifier	 get Validation class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
defaultValidator	TokenNameIdentifier	 default Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
defaultValidator	TokenNameIdentifier	 default Validator
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
defaultValidator	TokenNameIdentifier	 default Validator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to get Map of the provided options by create/update keyspace commands * @param options - tree representing options * @return Map - strategy_options map */	TokenNameCOMMENT_JAVADOC	 Used to get Map of the provided options by create/update keyspace commands @param options - tree representing options @return Map - strategy_options map 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
options	TokenNameIdentifier	 options
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//Check for old [{}] syntax 	TokenNameCOMMENT_LINE	Check for old [{}] syntax 
if	TokenNameif	
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"ARRAY"	TokenNameStringLiteral	ARRAY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"WARNING: [{}] strategy_options syntax is deprecated, please use {}"	TokenNameStringLiteral	WARNING: [{}] strategy_options syntax is deprecated, please use {}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
EMPTY_MAP	TokenNameIdentifier	 EMPTY  MAP
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getStrategyOptionsFromTree	TokenNameIdentifier	 get Strategy Options From Tree
(	TokenNameLPAREN	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this map will be returned 	TokenNameCOMMENT_LINE	this map will be returned 
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
strategyOptions	TokenNameIdentifier	 strategy Options
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// each child node is ^(PAIR $key $value) 	TokenNameCOMMENT_LINE	each child node is ^(PAIR $key $value) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tree	TokenNameIdentifier	 Tree
optionPair	TokenNameIdentifier	 option Pair
=	TokenNameEQUAL	
options	TokenNameIdentifier	 options
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// current $key 	TokenNameCOMMENT_LINE	current $key 
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
optionPair	TokenNameIdentifier	 option Pair
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// current $value 	TokenNameCOMMENT_LINE	current $value 
String	TokenNameIdentifier	 String
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
optionPair	TokenNameIdentifier	 option Pair
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
strategyOptions	TokenNameIdentifier	 strategy Options
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
strategyOptions	TokenNameIdentifier	 strategy Options
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to convert value (function argument, string) into byte[] * calls convertValueByFunction method with "withUpdate" set to false * @param functionCall - tree representing function call ^(FUNCTION_CALL function_name value) * @param columnFamily - column family definition (CfDef) * @param columnName - also updates column family metadata for given column * @return byte[] - string value as byte[] */	TokenNameCOMMENT_JAVADOC	 Used to convert value (function argument, string) into byte[] calls convertValueByFunction method with "withUpdate" set to false @param functionCall - tree representing function call ^(FUNCTION_CALL function_name value) @param columnFamily - column family definition (CfDef) @param columnName - also updates column family metadata for given column @return byte[] - string value as byte[] 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
functionCall	TokenNameIdentifier	 function Call
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
functionCall	TokenNameIdentifier	 function Call
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to convert value (function argument, string) into byte[] * @param functionCall - tree representing function call ^(FUNCTION_CALL function_name value) * @param columnFamily - column family definition (CfDef) * @param columnName - column name as byte[] (used to update CfDef) * @param withUpdate - also updates column family metadata for given column * @return byte[] - string value as byte[] */	TokenNameCOMMENT_JAVADOC	 Used to convert value (function argument, string) into byte[] @param functionCall - tree representing function call ^(FUNCTION_CALL function_name value) @param columnFamily - column family definition (CfDef) @param columnName - column name as byte[] (used to update CfDef) @param withUpdate - also updates column family metadata for given column @return byte[] - string value as byte[] 
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
Tree	TokenNameIdentifier	 Tree
functionCall	TokenNameIdentifier	 function Call
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
boolean	TokenNameboolean	
withUpdate	TokenNameIdentifier	 with Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
functionName	TokenNameIdentifier	 function Name
=	TokenNameEQUAL	
functionCall	TokenNameIdentifier	 function Call
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tree	TokenNameIdentifier	 Tree
argumentTree	TokenNameIdentifier	 argument Tree
=	TokenNameEQUAL	
functionCall	TokenNameIdentifier	 function Call
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
functionArg	TokenNameIdentifier	 function Arg
=	TokenNameEQUAL	
(	TokenNameLPAREN	
argumentTree	TokenNameIdentifier	 argument Tree
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
argumentTree	TokenNameIdentifier	 argument Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getTypeByFunction	TokenNameIdentifier	 get Type By Function
(	TokenNameLPAREN	
functionName	TokenNameIdentifier	 function Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
functionArg	TokenNameIdentifier	 function Arg
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
instanceof	TokenNameinstanceof	
TimeUUIDType	TokenNameIdentifier	 Time UUID Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
UUIDGen	TokenNameIdentifier	 UUID Gen
.	TokenNameDOT	
getTimeUUIDBytes	TokenNameIdentifier	 get Time UUID Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
instanceof	TokenNameinstanceof	
LexicalUUIDType	TokenNameIdentifier	 Lexical UUID Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
UUIDGen	TokenNameIdentifier	 UUID Gen
.	TokenNameDOT	
decompose	TokenNameIdentifier	 decompose
(	TokenNameLPAREN	
UUID	TokenNameIdentifier	 UUID
.	TokenNameDOT	
randomUUID	TokenNameIdentifier	 random UUID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
instanceof	TokenNameinstanceof	
BytesType	TokenNameIdentifier	 Bytes Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
.	TokenNameDOT	
wrap	TokenNameIdentifier	 wrap
(	TokenNameLPAREN	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Argument for '%s' could not be empty."	TokenNameStringLiteral	Argument for '%s' could not be empty.
,	TokenNameCOMMA	
functionName	TokenNameIdentifier	 function Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
functionArg	TokenNameIdentifier	 function Arg
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// performing ColumnDef local validator update 	TokenNameCOMMENT_LINE	performing ColumnDef local validator update 
if	TokenNameif	
(	TokenNameLPAREN	
withUpdate	TokenNameIdentifier	 with Update
)	TokenNameRPAREN	
{	TokenNameLBRACE	
updateColumnMetaData	TokenNameIdentifier	 update Column Meta Data
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get AbstractType by function name * @param functionName - name of the function e.g. utf8, integer, long etc. * @return AbstractType type corresponding to the function name */	TokenNameCOMMENT_JAVADOC	 Get AbstractType by function name @param functionName - name of the function e.g. utf8, integer, long etc. @return AbstractType type corresponding to the function name 
public	TokenNamepublic	
static	TokenNamestatic	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getTypeByFunction	TokenNameIdentifier	 get Type By Function
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
functionName	TokenNameIdentifier	 function Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Function	TokenNameIdentifier	 Function
function	TokenNameIdentifier	 function
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
function	TokenNameIdentifier	 function
=	TokenNameEQUAL	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
functionName	TokenNameIdentifier	 function Name
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
errorMessage	TokenNameIdentifier	 error Message
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
"Function '"	TokenNameStringLiteral	Function '
+	TokenNamePLUS	
functionName	TokenNameIdentifier	 function Name
+	TokenNamePLUS	
"' not found. "	TokenNameStringLiteral	' not found. 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
errorMessage	TokenNameIdentifier	 error Message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"Available functions: "	TokenNameStringLiteral	Available functions: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
errorMessage	TokenNameIdentifier	 error Message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
Function	TokenNameIdentifier	 Function
.	TokenNameDOT	
getFunctionNames	TokenNameIdentifier	 get Function Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
function	TokenNameIdentifier	 function
.	TokenNameDOT	
getValidator	TokenNameIdentifier	 get Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used to locally update column family definition with new column metadata * @param columnFamily - CfDef record * @param columnName - column name represented as byte[] * @param validationClass - value validation class */	TokenNameCOMMENT_JAVADOC	 Used to locally update column family definition with new column metadata @param columnFamily - CfDef record @param columnName - column name represented as byte[] @param validationClass - value validation class 
private	TokenNameprivate	
void	TokenNamevoid	
updateColumnMetaData	TokenNameIdentifier	 update Column Meta Data
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnDef	TokenNameIdentifier	 Column Def
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
getColumnDefByName	TokenNameIdentifier	 get Column Def By Name
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if validation class is the same - no need to modify it 	TokenNameCOMMENT_LINE	if validation class is the same - no need to modify it 
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
getValidation_class	TokenNameIdentifier	 get Validation class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// updating column definition with new validation_class 	TokenNameCOMMENT_LINE	updating column definition with new validation_class 
column	TokenNameIdentifier	 column
.	TokenNameDOT	
setValidation_class	TokenNameIdentifier	 set Validation class
(	TokenNameLPAREN	
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
columnMetaData	TokenNameIdentifier	 column Meta Data
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnDef	TokenNameIdentifier	 Column Def
>	TokenNameGREATER	
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnMetaData	TokenNameIdentifier	 column Meta Data
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
ColumnDef	TokenNameIdentifier	 Column Def
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
,	TokenNameCOMMA	
validationClass	TokenNameIdentifier	 validation Class
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
setColumn_metadata	TokenNameIdentifier	 set Column metadata
(	TokenNameLPAREN	
columnMetaData	TokenNameIdentifier	 column Meta Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get specific ColumnDef in column family meta data by column name * @param columnFamily - CfDef record * @param columnName - column name represented as byte[] * @return ColumnDef - found column definition */	TokenNameCOMMENT_JAVADOC	 Get specific ColumnDef in column family meta data by column name @param columnFamily - CfDef record @param columnName - column name represented as byte[] @return ColumnDef - found column definition 
private	TokenNameprivate	
ColumnDef	TokenNameIdentifier	 Column Def
getColumnDefByName	TokenNameIdentifier	 get Column Def By Name
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDef	TokenNameIdentifier	 Column Def
columnDef	TokenNameIdentifier	 column Def
:	TokenNameCOLON	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
getColumn_metadata	TokenNameIdentifier	 get Column metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
currName	TokenNameIdentifier	 curr Name
=	TokenNameEQUAL	
columnDef	TokenNameIdentifier	 column Def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
currName	TokenNameIdentifier	 curr Name
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
columnDef	TokenNameIdentifier	 column Def
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Prints out KeySlice list * @param columnFamilyDef - column family definition * @param slices - list of the KeySlice's to print out * @throws NotFoundException - column not found * @throws TException - transfer is broken * @throws IllegalAccessException - can't do operation * @throws InstantiationException - can't instantiate a class * @throws NoSuchFieldException - column not found */	TokenNameCOMMENT_JAVADOC	 Prints out KeySlice list @param columnFamilyDef - column family definition @param slices - list of the KeySlice's to print out @throws NotFoundException - column not found @throws TException - transfer is broken @throws IllegalAccessException - can't do operation @throws InstantiationException - can't instantiate a class @throws NoSuchFieldException - column not found 
private	TokenNameprivate	
void	TokenNamevoid	
printSliceList	TokenNameIdentifier	 print Slice List
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
KeySlice	TokenNameIdentifier	 Key Slice
>	TokenNameGREATER	
slices	TokenNameIdentifier	 slices
)	TokenNameRPAREN	
throws	TokenNamethrows	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
,	TokenNameCOMMA	
CharacterCodingException	TokenNameIdentifier	 Character Coding Exception
{	TokenNameLBRACE	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
validator	TokenNameIdentifier	 validator
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
columnFamilyName	TokenNameIdentifier	 column Family Name
=	TokenNameEQUAL	
columnFamilyDef	TokenNameIdentifier	 column Family Def
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
keyComparator	TokenNameIdentifier	 key Comparator
=	TokenNameEQUAL	
getKeyComparatorForCF	TokenNameIdentifier	 get Key Comparator For CF
(	TokenNameLPAREN	
columnFamilyName	TokenNameIdentifier	 column Family Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
KeySlice	TokenNameIdentifier	 Key Slice
ks	TokenNameIdentifier	 ks
:	TokenNameCOLON	
slices	TokenNameIdentifier	 slices
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
keyName	TokenNameIdentifier	 key Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
keyComparator	TokenNameIdentifier	 key Comparator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
string	TokenNameIdentifier	 string
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
:	TokenNameCOLON	
keyComparator	TokenNameIdentifier	 key Comparator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"-------------------%n"	TokenNameStringLiteral	-------------------%n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"RowKey: %s%n"	TokenNameStringLiteral	RowKey: %s%n
,	TokenNameCOMMA	
keyName	TokenNameIdentifier	 key Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
ks	TokenNameIdentifier	 ks
.	TokenNameDOT	
getColumnsIterator	TokenNameIdentifier	 get Columns Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnOrSuperColumn	TokenNameIdentifier	 Column Or Super Column
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
=	TokenNameEQUAL	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
column	TokenNameIdentifier	 column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Column	TokenNameIdentifier	 Column
col	TokenNameIdentifier	 col
=	TokenNameEQUAL	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (column=%s, value=%s, timestamp=%d%s)%n"	TokenNameStringLiteral	=> (column=%s, value=%s, timestamp=%d%s)%n
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
isSetTtl	TokenNameIdentifier	 is Set Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
", ttl=%d"	TokenNameStringLiteral	, ttl=%d
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getTtl	TokenNameIdentifier	 get Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SuperColumn	TokenNameIdentifier	 Super Column
superCol	TokenNameIdentifier	 super Col
=	TokenNameEQUAL	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
super_column	TokenNameIdentifier	 super column
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (super_column=%s,"	TokenNameStringLiteral	=> (super_column=%s,
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
superCol	TokenNameIdentifier	 super Col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Column	TokenNameIdentifier	 Column
col	TokenNameIdentifier	 col
:	TokenNameCOLON	
superCol	TokenNameIdentifier	 super Col
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
validator	TokenNameIdentifier	 validator
=	TokenNameEQUAL	
getValidatorForValue	TokenNameIdentifier	 get Validator For Value
(	TokenNameLPAREN	
columnFamilyDef	TokenNameIdentifier	 column Family Def
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%n (column=%s, value=%s, timestamp=%d%s)"	TokenNameStringLiteral	%n (column=%s, value=%s, timestamp=%d%s)
,	TokenNameCOMMA	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
isSetTtl	TokenNameIdentifier	 is Set Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
", ttl=%d"	TokenNameStringLiteral	, ttl=%d
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
getTtl	TokenNameIdentifier	 get Ttl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CounterColumn	TokenNameIdentifier	 Counter Column
col	TokenNameIdentifier	 col
=	TokenNameEQUAL	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
counter_column	TokenNameIdentifier	 counter column
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (counter=%s, value=%s)%n"	TokenNameStringLiteral	=> (counter=%s, value=%s)%n
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
counter_super_column	TokenNameIdentifier	 counter super column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CounterSuperColumn	TokenNameIdentifier	 Counter Super Column
superCol	TokenNameIdentifier	 super Col
=	TokenNameEQUAL	
columnOrSuperColumn	TokenNameIdentifier	 column Or Super Column
.	TokenNameDOT	
counter_super_column	TokenNameIdentifier	 counter super column
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"=> (super_column=%s,"	TokenNameStringLiteral	=> (super_column=%s,
,	TokenNameCOMMA	
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
superCol	TokenNameIdentifier	 super Col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CounterColumn	TokenNameIdentifier	 Counter Column
col	TokenNameIdentifier	 col
:	TokenNameCOLON	
superCol	TokenNameIdentifier	 super Col
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%n (counter=%s, value=%s)"	TokenNameStringLiteral	%n (counter=%s, value=%s)
,	TokenNameCOMMA	
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
keySpace	TokenNameIdentifier	 key Space
,	TokenNameCOMMA	
columnFamilyName	TokenNameIdentifier	 column Family Name
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
col	TokenNameIdentifier	 col
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
")"	TokenNameStringLiteral	)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
printf	TokenNameIdentifier	 printf
(	TokenNameLPAREN	
"%n%d Row%s Returned.%n"	TokenNameStringLiteral	%n%d Row%s Returned.%n
,	TokenNameCOMMA	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
"s"	TokenNameStringLiteral	s
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// retuns sub-column name in human-readable format 	TokenNameCOMMENT_LINE	retuns sub-column name in human-readable format 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
formatSubcolumnName	TokenNameIdentifier	 format Subcolumn Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
throws	TokenNamethrows	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
.	TokenNameDOT	
subcomparator_type	TokenNameIdentifier	 subcomparator type
)	TokenNameRPAREN	
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// retuns column name in human-readable format 	TokenNameCOMMENT_LINE	retuns column name in human-readable format 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
formatColumnName	TokenNameIdentifier	 format Column Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
throws	TokenNamethrows	
NotFoundException	TokenNameIdentifier	 Not Found Exception
,	TokenNameCOMMA	
TException	TokenNameIdentifier	 T Exception
,	TokenNameCOMMA	
IllegalAccessException	TokenNameIdentifier	 Illegal Access Exception
,	TokenNameCOMMA	
InstantiationException	TokenNameIdentifier	 Instantiation Exception
,	TokenNameCOMMA	
NoSuchFieldException	TokenNameIdentifier	 No Such Field Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
.	TokenNameDOT	
comparator_type	TokenNameIdentifier	 comparator type
)	TokenNameRPAREN	
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getColumnName	TokenNameIdentifier	 get Column Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
Tree	TokenNameIdentifier	 Tree
columnTree	TokenNameIdentifier	 column Tree
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
:	TokenNameCOLON	
columnNameAsBytes	TokenNameIdentifier	 column Name As Bytes
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getSubColumnName	TokenNameIdentifier	 get Sub Column Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
Tree	TokenNameIdentifier	 Tree
columnTree	TokenNameIdentifier	 column Tree
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
?	TokenNameQUESTION	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
:	TokenNameCOLON	
subColumnNameAsBytes	TokenNameIdentifier	 sub Column Name As Bytes
(	TokenNameLPAREN	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
columnTree	TokenNameIdentifier	 column Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getKeyAsBytes	TokenNameIdentifier	 get Key As Bytes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
Tree	TokenNameIdentifier	 Tree
keyTree	TokenNameIdentifier	 key Tree
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyTree	TokenNameIdentifier	 key Tree
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
CliParser	TokenNameIdentifier	 Cli Parser
.	TokenNameDOT	
FUNCTION_CALL	TokenNameIdentifier	 FUNCTION  CALL
)	TokenNameRPAREN	
return	TokenNamereturn	
convertValueByFunction	TokenNameIdentifier	 convert Value By Function
(	TokenNameLPAREN	
keyTree	TokenNameIdentifier	 key Tree
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
CliUtils	TokenNameIdentifier	 Cli Utils
.	TokenNameDOT	
unescapeSQLString	TokenNameIdentifier	 unescape SQL String
(	TokenNameLPAREN	
keyTree	TokenNameIdentifier	 key Tree
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
getBytesAccordingToType	TokenNameIdentifier	 get Bytes According To Type
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
getKeyComparatorForCF	TokenNameIdentifier	 get Key Comparator For CF
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
getKeyComparatorForCF	TokenNameIdentifier	 get Key Comparator For CF
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
keyComparator	TokenNameIdentifier	 key Comparator
=	TokenNameEQUAL	
cfKeysComparators	TokenNameIdentifier	 cf Keys Comparators
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyComparator	TokenNameIdentifier	 key Comparator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
defaultValidationClass	TokenNameIdentifier	 default Validation Class
=	TokenNameEQUAL	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
.	TokenNameDOT	
getKey_validation_class	TokenNameIdentifier	 get Key validation class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
defaultValidationClass	TokenNameIdentifier	 default Validation Class
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
keyComparator	TokenNameIdentifier	 key Comparator
=	TokenNameEQUAL	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
defaultValidationClass	TokenNameIdentifier	 default Validation Class
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
keyComparator	TokenNameIdentifier	 key Comparator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
KsDefNamesComparator	TokenNameIdentifier	 Ks Def Names Comparator
implements	TokenNameimplements	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
KsDef	TokenNameIdentifier	 Ks Def
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
KsDef	TokenNameIdentifier	 Ks Def
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
KsDef	TokenNameIdentifier	 Ks Def
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CfDefNamesComparator	TokenNameIdentifier	 Cf Def Names Comparator
implements	TokenNameimplements	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
CfDef	TokenNameIdentifier	 Cf Def
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
CfDef	TokenNameIdentifier	 Cf Def
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isCounterCF	TokenNameIdentifier	 is Counter CF
(	TokenNameLPAREN	
CfDef	TokenNameIdentifier	 Cf Def
cfdef	TokenNameIdentifier	 cfdef
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
defaultValidator	TokenNameIdentifier	 default Validator
=	TokenNameEQUAL	
cfdef	TokenNameIdentifier	 cfdef
.	TokenNameDOT	
default_validation_class	TokenNameIdentifier	 default validation class
;	TokenNameSEMICOLON	
return	TokenNamereturn	
defaultValidator	TokenNameIdentifier	 default Validator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
defaultValidator	TokenNameIdentifier	 default Validator
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
getFormatType	TokenNameIdentifier	 get Format Type
(	TokenNameLPAREN	
defaultValidator	TokenNameIdentifier	 default Validator
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
CounterColumnType	TokenNameIdentifier	 Counter Column Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Print elapsed time. Print 2 fraction digits if eta is under 10 ms. * @param startTime starting time in nanoseconds */	TokenNameCOMMENT_JAVADOC	 Print elapsed time. Print 2 fraction digits if eta is under 10 ms. @param startTime starting time in nanoseconds 
private	TokenNameprivate	
void	TokenNamevoid	
elapsedTime	TokenNameIdentifier	 elapsed Time
(	TokenNameLPAREN	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** time elapsed in nanoseconds */	TokenNameCOMMENT_JAVADOC	 time elapsed in nanoseconds 
long	TokenNamelong	
eta	TokenNameIdentifier	 eta
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
nanoTime	TokenNameIdentifier	 nano Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Elapsed time: "	TokenNameStringLiteral	Elapsed time: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eta	TokenNameIdentifier	 eta
<	TokenNameLESS	
10000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
round	TokenNameIdentifier	 round
(	TokenNameLPAREN	
eta	TokenNameIdentifier	 eta
/	TokenNameDIVIDE	
10000.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
100.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
round	TokenNameIdentifier	 round
(	TokenNameLPAREN	
eta	TokenNameIdentifier	 eta
/	TokenNameDIVIDE	
1000000.0	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
" msec(s)."	TokenNameStringLiteral	 msec(s).
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
class	TokenNameclass	
CfAssumptions	TokenNameIdentifier	 Cf Assumptions
{	TokenNameLBRACE	
//Map<KeySpace, Map<ColumnFamily, Map<Property, Value>>> 	TokenNameCOMMENT_LINE	Map<KeySpace, Map<ColumnFamily, Map<Property, Value>>> 
private	TokenNameprivate	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
assumptions	TokenNameIdentifier	 assumptions
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
assumptionsChanged	TokenNameIdentifier	 assumptions Changed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
File	TokenNameIdentifier	 File
assumptionDirectory	TokenNameIdentifier	 assumption Directory
;	TokenNameSEMICOLON	
public	TokenNamepublic	
CfAssumptions	TokenNameIdentifier	 Cf Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assumptions	TokenNameIdentifier	 assumptions
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptionsChanged	TokenNameIdentifier	 assumptions Changed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
assumptionDirectory	TokenNameIdentifier	 assumption Directory
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"user.home"	TokenNameStringLiteral	user.home
)	TokenNameRPAREN	
,	TokenNameCOMMA	
".cassandra-cli"	TokenNameStringLiteral	.cassandra-cli
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptionDirectory	TokenNameIdentifier	 assumption Directory
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
addAssumption	TokenNameIdentifier	 add Assumption
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
property	TokenNameIdentifier	 property
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
ksAssumes	TokenNameIdentifier	 ks Assumes
=	TokenNameEQUAL	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ksAssumes	TokenNameIdentifier	 ks Assumes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ksAssumes	TokenNameIdentifier	 ks Assumes
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
ksAssumes	TokenNameIdentifier	 ks Assumes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
cfAssumes	TokenNameIdentifier	 cf Assumes
=	TokenNameEQUAL	
ksAssumes	TokenNameIdentifier	 ks Assumes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfAssumes	TokenNameIdentifier	 cf Assumes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfAssumes	TokenNameIdentifier	 cf Assumes
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ksAssumes	TokenNameIdentifier	 ks Assumes
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
cfAssumes	TokenNameIdentifier	 cf Assumes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
cfAssumes	TokenNameIdentifier	 cf Assumes
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
property	TokenNameIdentifier	 property
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptionsChanged	TokenNameIdentifier	 assumptions Changed
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
replayAssumptions	TokenNameIdentifier	 replay Assumptions
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
CliMain	TokenNameIdentifier	 Cli Main
.	TokenNameDOT	
isConnected	TokenNameIdentifier	 is Connected
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
hasKeySpace	TokenNameIdentifier	 has Key Space
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
cfAssumes	TokenNameIdentifier	 cf Assumes
=	TokenNameEQUAL	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfAssumes	TokenNameIdentifier	 cf Assumes
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
cfEntry	TokenNameIdentifier	 cf Entry
:	TokenNameCOLON	
cfAssumes	TokenNameIdentifier	 cf Assumes
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
cfEntry	TokenNameIdentifier	 cf Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
props	TokenNameIdentifier	 props
=	TokenNameEQUAL	
cfEntry	TokenNameIdentifier	 cf Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
propEntry	TokenNameIdentifier	 prop Entry
:	TokenNameCOLON	
props	TokenNameIdentifier	 props
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
applyAssumption	TokenNameIdentifier	 apply Assumption
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
propEntry	TokenNameIdentifier	 prop Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
propEntry	TokenNameIdentifier	 prop Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
readAssumptions	TokenNameIdentifier	 read Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
assumptionFile	TokenNameIdentifier	 assumption File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
assumptionDirectory	TokenNameIdentifier	 assumption Directory
,	TokenNameCOMMA	
"assumptions.json"	TokenNameStringLiteral	assumptions.json
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionFile	TokenNameIdentifier	 assumption File
.	TokenNameDOT	
isFile	TokenNameIdentifier	 is File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
JsonFactory	TokenNameIdentifier	 Json Factory
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
JsonFactory	TokenNameIdentifier	 Json Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonParser	TokenNameIdentifier	 Json Parser
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
createJsonParser	TokenNameIdentifier	 create Json Parser
(	TokenNameLPAREN	
assumptionFile	TokenNameIdentifier	 assumption File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonToken	TokenNameIdentifier	 Json Token
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
!=	TokenNameNOT_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
END_OBJECT	TokenNameIdentifier	 END  OBJECT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
ksAssumes	TokenNameIdentifier	 ks Assumes
=	TokenNameEQUAL	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ksAssumes	TokenNameIdentifier	 ks Assumes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ksAssumes	TokenNameIdentifier	 ks Assumes
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
ksAssumes	TokenNameIdentifier	 ks Assumes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
!=	TokenNameNOT_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
END_ARRAY	TokenNameIdentifier	 END  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
cfAssumes	TokenNameIdentifier	 cf Assumes
=	TokenNameEQUAL	
ksAssumes	TokenNameIdentifier	 ks Assumes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfAssumes	TokenNameIdentifier	 cf Assumes
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfAssumes	TokenNameIdentifier	 cf Assumes
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ksAssumes	TokenNameIdentifier	 ks Assumes
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
cfAssumes	TokenNameIdentifier	 cf Assumes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
!=	TokenNameNOT_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
END_ARRAY	TokenNameIdentifier	 END  ARRAY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
JsonToken	TokenNameIdentifier	 Json Token
.	TokenNameDOT	
FIELD_NAME	TokenNameIdentifier	 FIELD  NAME
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
prop	TokenNameIdentifier	 prop
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfAssumes	TokenNameIdentifier	 cf Assumes
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
prop	TokenNameIdentifier	 prop
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Column Family assumptions read from "	TokenNameStringLiteral	Column Family assumptions read from 
+	TokenNamePLUS	
assumptionFile	TokenNameIdentifier	 assumption File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Failed reading "	TokenNameStringLiteral	Failed reading 
+	TokenNamePLUS	
assumptionFile	TokenNameIdentifier	 assumption File
+	TokenNamePLUS	
" file"	TokenNameStringLiteral	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
writeAssumptions	TokenNameIdentifier	 write Assumptions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
assumptionsChanged	TokenNameIdentifier	 assumptions Changed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
assumptionFile	TokenNameIdentifier	 assumption File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
assumptionDirectory	TokenNameIdentifier	 assumption Directory
,	TokenNameCOMMA	
"assumptions.json"	TokenNameStringLiteral	assumptions.json
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
JsonFactory	TokenNameIdentifier	 Json Factory
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
new	TokenNamenew	
JsonFactory	TokenNameIdentifier	 Json Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
JsonGenerator	TokenNameIdentifier	 Json Generator
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
.	TokenNameDOT	
createJsonGenerator	TokenNameIdentifier	 create Json Generator
(	TokenNameLPAREN	
assumptionFile	TokenNameIdentifier	 assumption File
,	TokenNameCOMMA	
JsonEncoding	TokenNameIdentifier	 Json Encoding
.	TokenNameDOT	
UTF8	TokenNameIdentifier	 UT F8
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
useDefaultPrettyPrinter	TokenNameIdentifier	 use Default Pretty Printer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartObject	TokenNameIdentifier	 write Start Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
ksEntry	TokenNameIdentifier	 ks Entry
:	TokenNameCOLON	
assumptions	TokenNameIdentifier	 assumptions
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeFieldName	TokenNameIdentifier	 write Field Name
(	TokenNameLPAREN	
ksEntry	TokenNameIdentifier	 ks Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartArray	TokenNameIdentifier	 write Start Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
cfEntry	TokenNameIdentifier	 cf Entry
:	TokenNameCOLON	
ksEntry	TokenNameIdentifier	 ks Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartObject	TokenNameIdentifier	 write Start Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeFieldName	TokenNameIdentifier	 write Field Name
(	TokenNameLPAREN	
cfEntry	TokenNameIdentifier	 cf Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartArray	TokenNameIdentifier	 write Start Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
asEntry	TokenNameIdentifier	 as Entry
:	TokenNameCOLON	
cfEntry	TokenNameIdentifier	 cf Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStartObject	TokenNameIdentifier	 write Start Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeStringField	TokenNameIdentifier	 write String Field
(	TokenNameLPAREN	
asEntry	TokenNameIdentifier	 as Entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
asEntry	TokenNameIdentifier	 as Entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndObject	TokenNameIdentifier	 write End Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndArray	TokenNameIdentifier	 write End Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndObject	TokenNameIdentifier	 write End Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndArray	TokenNameIdentifier	 write End Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
writeEndObject	TokenNameIdentifier	 write End Object
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Column Family assumptions written to "	TokenNameStringLiteral	Column Family assumptions written to 
+	TokenNamePLUS	
assumptionFile	TokenNameIdentifier	 assumption File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assumptionsChanged	TokenNameIdentifier	 assumptions Changed
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sessionState	TokenNameIdentifier	 session State
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Failed writing "	TokenNameStringLiteral	Failed writing 
+	TokenNamePLUS	
assumptionFile	TokenNameIdentifier	 assumption File
+	TokenNamePLUS	
" file"	TokenNameStringLiteral	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
