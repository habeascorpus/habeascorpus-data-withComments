/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
taskdefs	TokenNameIdentifier	 taskdefs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Enumeration	TokenNameIdentifier	 Enumeration
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashSet	TokenNameIdentifier	 Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Task	TokenNameIdentifier	 Task
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
Project	TokenNameIdentifier	 Project
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
BuildException	TokenNameIdentifier	 Build Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Mapper	TokenNameIdentifier	 Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FileSet	TokenNameIdentifier	 File Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FilterSet	TokenNameIdentifier	 Filter Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FilterChain	TokenNameIdentifier	 Filter Chain
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
Resource	TokenNameIdentifier	 Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceCollection	TokenNameIdentifier	 Resource Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
ResourceFactory	TokenNameIdentifier	 Resource Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileProvider	TokenNameIdentifier	 File Provider
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
FileResource	TokenNameIdentifier	 File Resource
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IdentityMapper	TokenNameIdentifier	 Identity Mapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LinkedHashtable	TokenNameIdentifier	 Linked Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ResourceUtils	TokenNameIdentifier	 Resource Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SourceFileScanner	TokenNameIdentifier	 Source File Scanner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
tools	TokenNameIdentifier	 tools
.	TokenNameDOT	
ant	TokenNameIdentifier	 ant
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FlatFileNameMapper	TokenNameIdentifier	 Flat File Name Mapper
;	TokenNameSEMICOLON	
/** * Copies a file or directory to a new file * or directory. Files are only copied if the source file is newer * than the destination file, or when the destination file does not * exist. It is possible to explicitly overwrite existing files.</p> * * <p>This implementation is based on Arnout Kuiper's initial design * document, the following mailing list discussions, and the * copyfile/copydir tasks.</p> * * * @since Ant 1.2 * * @ant.task category="filesystem" */	TokenNameCOMMENT_JAVADOC	 Copies a file or directory to a new file or directory. Files are only copied if the source file is newer than the destination file, or when the destination file does not exist. It is possible to explicitly overwrite existing files.</p> * <p>This implementation is based on Arnout Kuiper's initial design document, the following mailing list discussions, and the copyfile/copydir tasks.</p> * @since Ant 1.2 * @ant.task category="filesystem" 
public	TokenNamepublic	
class	TokenNameclass	
Copy	TokenNameIdentifier	 Copy
extends	TokenNameextends	
Task	TokenNameIdentifier	 Task
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
MSG_WHEN_COPYING_EMPTY_RC_TO_FILE	TokenNameIdentifier	 MSG  WHEN  COPYING  EMPTY  RC  TO  FILE
=	TokenNameEQUAL	
"Cannot perform operation from directory to file."	TokenNameStringLiteral	Cannot perform operation from directory to file.
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
NULL_FILE_PLACEHOLDER	TokenNameIdentifier	 NULL  FILE  PLACEHOLDER
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
"/NULL_FILE"	TokenNameStringLiteral	/NULL_FILE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
LINE_SEPARATOR	TokenNameIdentifier	 LINE  SEPARATOR
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// CheckStyle:VisibilityModifier OFF - bc 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier OFF - bc 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the source file 	TokenNameCOMMENT_LINE	the source file 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the destination file 	TokenNameCOMMENT_LINE	the destination file 
protected	TokenNameprotected	
File	TokenNameIdentifier	 File
destDir	TokenNameIdentifier	 dest Dir
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// the destination directory 	TokenNameCOMMENT_LINE	the destination directory 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
rcs	TokenNameIdentifier	 rcs
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// here to provide API backwards compatibility 	TokenNameCOMMENT_LINE	here to provide API backwards compatibility 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
filesets	TokenNameIdentifier	 filesets
=	TokenNameEQUAL	
rcs	TokenNameIdentifier	 rcs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
filtering	TokenNameIdentifier	 filtering
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
forceOverwrite	TokenNameIdentifier	 force Overwrite
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
flatten	TokenNameIdentifier	 flatten
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
int	TokenNameint	
verbosity	TokenNameIdentifier	 verbosity
=	TokenNameEQUAL	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
includeEmpty	TokenNameIdentifier	 include Empty
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
failonerror	TokenNameIdentifier	 failonerror
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
fileCopyMap	TokenNameIdentifier	 file Copy Map
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashtable	TokenNameIdentifier	 Linked Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
dirCopyMap	TokenNameIdentifier	 dir Copy Map
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashtable	TokenNameIdentifier	 Linked Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
completeDirMap	TokenNameIdentifier	 complete Dir Map
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedHashtable	TokenNameIdentifier	 Linked Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Mapper	TokenNameIdentifier	 Mapper
mapperElement	TokenNameIdentifier	 mapper Element
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
FileUtils	TokenNameIdentifier	 File Utils
fileUtils	TokenNameIdentifier	 file Utils
;	TokenNameSEMICOLON	
//CheckStyle:VisibilityModifier ON 	TokenNameCOMMENT_LINE	CheckStyle:VisibilityModifier ON 
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
filterChains	TokenNameIdentifier	 filter Chains
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Vector	TokenNameIdentifier	 Vector
filterSets	TokenNameIdentifier	 filter Sets
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
inputEncoding	TokenNameIdentifier	 input Encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
outputEncoding	TokenNameIdentifier	 output Encoding
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
long	TokenNamelong	
granularity	TokenNameIdentifier	 granularity
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
force	TokenNameIdentifier	 force
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
quiet	TokenNameIdentifier	 quiet
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// used to store the single non-file resource to copy when the 	TokenNameCOMMENT_LINE	used to store the single non-file resource to copy when the 
// tofile attribute has been used 	TokenNameCOMMENT_LINE	tofile attribute has been used 
private	TokenNameprivate	
Resource	TokenNameIdentifier	 Resource
singleResource	TokenNameIdentifier	 single Resource
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Copy task constructor. */	TokenNameCOMMENT_JAVADOC	 Copy task constructor. 
public	TokenNamepublic	
Copy	TokenNameIdentifier	 Copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fileUtils	TokenNameIdentifier	 file Utils
=	TokenNameEQUAL	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
granularity	TokenNameIdentifier	 granularity
=	TokenNameEQUAL	
fileUtils	TokenNameIdentifier	 file Utils
.	TokenNameDOT	
getFileTimestampGranularity	TokenNameIdentifier	 get File Timestamp Granularity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the FileUtils for this task. * @return the fileutils object. */	TokenNameCOMMENT_JAVADOC	 Get the FileUtils for this task. @return the fileutils object. 
protected	TokenNameprotected	
FileUtils	TokenNameIdentifier	 File Utils
getFileUtils	TokenNameIdentifier	 get File Utils
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fileUtils	TokenNameIdentifier	 file Utils
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set a single source file to copy. * @param file the file to copy. */	TokenNameCOMMENT_JAVADOC	 Set a single source file to copy. @param file the file to copy. 
public	TokenNamepublic	
void	TokenNamevoid	
setFile	TokenNameIdentifier	 set File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the destination file. * @param destFile the file to copy to. */	TokenNameCOMMENT_JAVADOC	 Set the destination file. @param destFile the file to copy to. 
public	TokenNamepublic	
void	TokenNamevoid	
setTofile	TokenNameIdentifier	 set Tofile
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
destFile	TokenNameIdentifier	 dest File
=	TokenNameEQUAL	
destFile	TokenNameIdentifier	 dest File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the destination directory. * @param destDir the destination directory. */	TokenNameCOMMENT_JAVADOC	 Set the destination directory. @param destDir the destination directory. 
public	TokenNamepublic	
void	TokenNamevoid	
setTodir	TokenNameIdentifier	 set Todir
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
destDir	TokenNameIdentifier	 dest Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
destDir	TokenNameIdentifier	 dest Dir
=	TokenNameEQUAL	
destDir	TokenNameIdentifier	 dest Dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a FilterChain. * @return a filter chain object. */	TokenNameCOMMENT_JAVADOC	 Add a FilterChain. @return a filter chain object. 
public	TokenNamepublic	
FilterChain	TokenNameIdentifier	 Filter Chain
createFilterChain	TokenNameIdentifier	 create Filter Chain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FilterChain	TokenNameIdentifier	 Filter Chain
filterChain	TokenNameIdentifier	 filter Chain
=	TokenNameEQUAL	
new	TokenNamenew	
FilterChain	TokenNameIdentifier	 Filter Chain
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filterChains	TokenNameIdentifier	 filter Chains
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
filterChain	TokenNameIdentifier	 filter Chain
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
filterChain	TokenNameIdentifier	 filter Chain
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a filterset. * @return a filter set object. */	TokenNameCOMMENT_JAVADOC	 Add a filterset. @return a filter set object. 
public	TokenNamepublic	
FilterSet	TokenNameIdentifier	 Filter Set
createFilterSet	TokenNameIdentifier	 create Filter Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FilterSet	TokenNameIdentifier	 Filter Set
filterSet	TokenNameIdentifier	 filter Set
=	TokenNameEQUAL	
new	TokenNamenew	
FilterSet	TokenNameIdentifier	 Filter Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filterSets	TokenNameIdentifier	 filter Sets
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
filterSet	TokenNameIdentifier	 filter Set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
filterSet	TokenNameIdentifier	 filter Set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Give the copied files the same last modified time as the original files. * @param preserve a boolean string. * @deprecated since 1.5.x. * setPreserveLastModified(String) has been deprecated and * replaced with setPreserveLastModified(boolean) to * consistently let the Introspection mechanism work. */	TokenNameCOMMENT_JAVADOC	 Give the copied files the same last modified time as the original files. @param preserve a boolean string. @deprecated since 1.5.x. setPreserveLastModified(String) has been deprecated and replaced with setPreserveLastModified(boolean) to consistently let the Introspection mechanism work. 
public	TokenNamepublic	
void	TokenNamevoid	
setPreserveLastModified	TokenNameIdentifier	 set Preserve Last Modified
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
preserve	TokenNameIdentifier	 preserve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setPreserveLastModified	TokenNameIdentifier	 set Preserve Last Modified
(	TokenNameLPAREN	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
toBoolean	TokenNameIdentifier	 to Boolean
(	TokenNameLPAREN	
preserve	TokenNameIdentifier	 preserve
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Give the copied files the same last modified time as the original files. * @param preserve if true preserve the modified time; default is false. */	TokenNameCOMMENT_JAVADOC	 Give the copied files the same last modified time as the original files. @param preserve if true preserve the modified time; default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setPreserveLastModified	TokenNameIdentifier	 set Preserve Last Modified
(	TokenNameLPAREN	
boolean	TokenNameboolean	
preserve	TokenNameIdentifier	 preserve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
=	TokenNameEQUAL	
preserve	TokenNameIdentifier	 preserve
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get whether to give the copied files the same last modified time as * the original files. * @return the whether destination files will inherit the modification * times of the corresponding source files. * @since 1.32, Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Get whether to give the copied files the same last modified time as the original files. @return the whether destination files will inherit the modification times of the corresponding source files. @since 1.32, Ant 1.5 
public	TokenNamepublic	
boolean	TokenNameboolean	
getPreserveLastModified	TokenNameIdentifier	 get Preserve Last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the filtersets being applied to this operation. * * @return a vector of FilterSet objects. */	TokenNameCOMMENT_JAVADOC	 Get the filtersets being applied to this operation. * @return a vector of FilterSet objects. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
getFilterSets	TokenNameIdentifier	 get Filter Sets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
filterSets	TokenNameIdentifier	 filter Sets
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the filterchains being applied to this operation. * * @return a vector of FilterChain objects. */	TokenNameCOMMENT_JAVADOC	 Get the filterchains being applied to this operation. * @return a vector of FilterChain objects. 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
getFilterChains	TokenNameIdentifier	 get Filter Chains
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
filterChains	TokenNameIdentifier	 filter Chains
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set filtering mode. * @param filtering if true enable filtering; default is false. */	TokenNameCOMMENT_JAVADOC	 Set filtering mode. @param filtering if true enable filtering; default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setFiltering	TokenNameIdentifier	 set Filtering
(	TokenNameLPAREN	
boolean	TokenNameboolean	
filtering	TokenNameIdentifier	 filtering
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
filtering	TokenNameIdentifier	 filtering
=	TokenNameEQUAL	
filtering	TokenNameIdentifier	 filtering
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set overwrite mode regarding existing destination file(s). * @param overwrite if true force overwriting of destination file(s) * even if the destination file(s) are younger than * the corresponding source file. Default is false. */	TokenNameCOMMENT_JAVADOC	 Set overwrite mode regarding existing destination file(s). @param overwrite if true force overwriting of destination file(s) even if the destination file(s) are younger than the corresponding source file. Default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setOverwrite	TokenNameIdentifier	 set Overwrite
(	TokenNameLPAREN	
boolean	TokenNameboolean	
overwrite	TokenNameIdentifier	 overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
forceOverwrite	TokenNameIdentifier	 force Overwrite
=	TokenNameEQUAL	
overwrite	TokenNameIdentifier	 overwrite
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether read-only destinations will be overwritten. * * <p>Defaults to false</p> * * @since Ant 1.8.2 */	TokenNameCOMMENT_JAVADOC	 Whether read-only destinations will be overwritten. * <p>Defaults to false</p> * @since Ant 1.8.2 
public	TokenNamepublic	
void	TokenNamevoid	
setForce	TokenNameIdentifier	 set Force
(	TokenNameLPAREN	
boolean	TokenNameboolean	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
force	TokenNameIdentifier	 force
=	TokenNameEQUAL	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Whether read-only destinations will be overwritten. * * @since Ant 1.8.2 */	TokenNameCOMMENT_JAVADOC	 Whether read-only destinations will be overwritten. * @since Ant 1.8.2 
public	TokenNamepublic	
boolean	TokenNameboolean	
getForce	TokenNameIdentifier	 get Force
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
force	TokenNameIdentifier	 force
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether files copied from directory trees will be "flattened" * into a single directory. If there are multiple files with * the same name in the source directory tree, only the first * file will be copied into the "flattened" directory, unless * the forceoverwrite attribute is true. * @param flatten if true flatten the destination directory. Default * is false. */	TokenNameCOMMENT_JAVADOC	 Set whether files copied from directory trees will be "flattened" into a single directory. If there are multiple files with the same name in the source directory tree, only the first file will be copied into the "flattened" directory, unless the forceoverwrite attribute is true. @param flatten if true flatten the destination directory. Default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setFlatten	TokenNameIdentifier	 set Flatten
(	TokenNameLPAREN	
boolean	TokenNameboolean	
flatten	TokenNameIdentifier	 flatten
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
flatten	TokenNameIdentifier	 flatten
=	TokenNameEQUAL	
flatten	TokenNameIdentifier	 flatten
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set verbose mode. Used to force listing of all names of copied files. * @param verbose whether to output the names of copied files. * Default is false. */	TokenNameCOMMENT_JAVADOC	 Set verbose mode. Used to force listing of all names of copied files. @param verbose whether to output the names of copied files. Default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setVerbose	TokenNameIdentifier	 set Verbose
(	TokenNameLPAREN	
boolean	TokenNameboolean	
verbose	TokenNameIdentifier	 verbose
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
verbosity	TokenNameIdentifier	 verbosity
=	TokenNameEQUAL	
verbose	TokenNameIdentifier	 verbose
?	TokenNameQUESTION	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_INFO	TokenNameIdentifier	 MSG  INFO
:	TokenNameCOLON	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether to copy empty directories. * @param includeEmpty if true copy empty directories. Default is true. */	TokenNameCOMMENT_JAVADOC	 Set whether to copy empty directories. @param includeEmpty if true copy empty directories. Default is true. 
public	TokenNamepublic	
void	TokenNamevoid	
setIncludeEmptyDirs	TokenNameIdentifier	 set Include Empty Dirs
(	TokenNameLPAREN	
boolean	TokenNameboolean	
includeEmpty	TokenNameIdentifier	 include Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
includeEmpty	TokenNameIdentifier	 include Empty
=	TokenNameEQUAL	
includeEmpty	TokenNameIdentifier	 include Empty
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set quiet mode. Used to hide messages when a file or directory to be * copied does not exist. * * @param quiet * whether or not to display error messages when a file or * directory does not exist. Default is false. */	TokenNameCOMMENT_JAVADOC	 Set quiet mode. Used to hide messages when a file or directory to be copied does not exist. * @param quiet whether or not to display error messages when a file or directory does not exist. Default is false. 
public	TokenNamepublic	
void	TokenNamevoid	
setQuiet	TokenNameIdentifier	 set Quiet
(	TokenNameLPAREN	
boolean	TokenNameboolean	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
quiet	TokenNameIdentifier	 quiet
=	TokenNameEQUAL	
quiet	TokenNameIdentifier	 quiet
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set method of handling mappers that return multiple * mappings for a given source path. * @param enableMultipleMappings If true the task will * copy to all the mappings for a given source path, if * false, only the first file or directory is * processed. * By default, this setting is false to provide backward * compatibility with earlier releases. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Set method of handling mappers that return multiple mappings for a given source path. @param enableMultipleMappings If true the task will copy to all the mappings for a given source path, if false, only the first file or directory is processed. By default, this setting is false to provide backward compatibility with earlier releases. @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
setEnableMultipleMappings	TokenNameIdentifier	 set Enable Multiple Mappings
(	TokenNameLPAREN	
boolean	TokenNameboolean	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
=	TokenNameEQUAL	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get whether multiple mapping is enabled. * @return true if multiple mapping is enabled; false otherwise. */	TokenNameCOMMENT_JAVADOC	 Get whether multiple mapping is enabled. @return true if multiple mapping is enabled; false otherwise. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isEnableMultipleMapping	TokenNameIdentifier	 is Enable Multiple Mapping
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set whether to fail when errors are encountered. If false, note errors * to the output but keep going. Default is true. * @param failonerror true or false. */	TokenNameCOMMENT_JAVADOC	 Set whether to fail when errors are encountered. If false, note errors to the output but keep going. Default is true. @param failonerror true or false. 
public	TokenNamepublic	
void	TokenNamevoid	
setFailOnError	TokenNameIdentifier	 set Fail On Error
(	TokenNameLPAREN	
boolean	TokenNameboolean	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
failonerror	TokenNameIdentifier	 failonerror
=	TokenNameEQUAL	
failonerror	TokenNameIdentifier	 failonerror
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a set of files to copy. * @param set a set of files to copy. */	TokenNameCOMMENT_JAVADOC	 Add a set of files to copy. @param set a set of files to copy. 
public	TokenNamepublic	
void	TokenNamevoid	
addFileset	TokenNameIdentifier	 add Fileset
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a collection of files to copy. * @param res a resource collection to copy. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Add a collection of files to copy. @param res a resource collection to copy. @since Ant 1.7 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
res	TokenNameIdentifier	 res
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
res	TokenNameIdentifier	 res
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Define the mapper to map source to destination files. * @return a mapper to be configured. * @exception BuildException if more than one mapper is defined. */	TokenNameCOMMENT_JAVADOC	 Define the mapper to map source to destination files. @return a mapper to be configured. @exception BuildException if more than one mapper is defined. 
public	TokenNamepublic	
Mapper	TokenNameIdentifier	 Mapper
createMapper	TokenNameIdentifier	 create Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mapperElement	TokenNameIdentifier	 mapper Element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot define more than one mapper"	TokenNameStringLiteral	Cannot define more than one mapper
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
mapperElement	TokenNameIdentifier	 mapper Element
=	TokenNameEQUAL	
new	TokenNamenew	
Mapper	TokenNameIdentifier	 Mapper
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
mapperElement	TokenNameIdentifier	 mapper Element
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a nested filenamemapper. * @param fileNameMapper the mapper to add. * @since Ant 1.6.3 */	TokenNameCOMMENT_JAVADOC	 Add a nested filenamemapper. @param fileNameMapper the mapper to add. @since Ant 1.6.3 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
fileNameMapper	TokenNameIdentifier	 file Name Mapper
)	TokenNameRPAREN	
{	TokenNameLBRACE	
createMapper	TokenNameIdentifier	 create Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fileNameMapper	TokenNameIdentifier	 file Name Mapper
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the character encoding. * @param encoding the character encoding. * @since 1.32, Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Set the character encoding. @param encoding the character encoding. @since 1.32, Ant 1.5 
public	TokenNamepublic	
void	TokenNamevoid	
setEncoding	TokenNameIdentifier	 set Encoding
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
inputEncoding	TokenNameIdentifier	 input Encoding
=	TokenNameEQUAL	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
outputEncoding	TokenNameIdentifier	 output Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
outputEncoding	TokenNameIdentifier	 output Encoding
=	TokenNameEQUAL	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get the character encoding to be used. * @return the character encoding, <code>null</code> if not set. * * @since 1.32, Ant 1.5 */	TokenNameCOMMENT_JAVADOC	 Get the character encoding to be used. @return the character encoding, <code>null</code> if not set. * @since 1.32, Ant 1.5 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getEncoding	TokenNameIdentifier	 get Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
inputEncoding	TokenNameIdentifier	 input Encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the character encoding for output files. * @param encoding the output character encoding. * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Set the character encoding for output files. @param encoding the output character encoding. @since Ant 1.6 
public	TokenNamepublic	
void	TokenNamevoid	
setOutputEncoding	TokenNameIdentifier	 set Output Encoding
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
outputEncoding	TokenNameIdentifier	 output Encoding
=	TokenNameEQUAL	
encoding	TokenNameIdentifier	 encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the character encoding for output files. * @return the character encoding for output files, * <code>null</code> if not set. * * @since Ant 1.6 */	TokenNameCOMMENT_JAVADOC	 Get the character encoding for output files. @return the character encoding for output files, <code>null</code> if not set. * @since Ant 1.6 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getOutputEncoding	TokenNameIdentifier	 get Output Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
outputEncoding	TokenNameIdentifier	 output Encoding
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Set the number of milliseconds leeway to give before deciding a * target is out of date. * * <p>Default is 1 second, or 2 seconds on DOS systems.</p> * @param granularity the granularity used to decide if a target is out of * date. * @since Ant 1.6.2 */	TokenNameCOMMENT_JAVADOC	 Set the number of milliseconds leeway to give before deciding a target is out of date. * <p>Default is 1 second, or 2 seconds on DOS systems.</p> @param granularity the granularity used to decide if a target is out of date. @since Ant 1.6.2 
public	TokenNamepublic	
void	TokenNamevoid	
setGranularity	TokenNameIdentifier	 set Granularity
(	TokenNameLPAREN	
long	TokenNamelong	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
granularity	TokenNameIdentifier	 granularity
=	TokenNameEQUAL	
granularity	TokenNameIdentifier	 granularity
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Perform the copy operation. * @exception BuildException if an error occurs. */	TokenNameCOMMENT_JAVADOC	 Perform the copy operation. @exception BuildException if an error occurs. 
public	TokenNamepublic	
void	TokenNamevoid	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
savedFile	TokenNameIdentifier	 saved File
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
;	TokenNameSEMICOLON	
// may be altered in validateAttributes 	TokenNameCOMMENT_LINE	may be altered in validateAttributes 
File	TokenNameIdentifier	 File
savedDestFile	TokenNameIdentifier	 saved Dest File
=	TokenNameEQUAL	
destFile	TokenNameIdentifier	 dest File
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
savedDestDir	TokenNameIdentifier	 saved Dest Dir
=	TokenNameEQUAL	
destDir	TokenNameIdentifier	 dest Dir
;	TokenNameSEMICOLON	
ResourceCollection	TokenNameIdentifier	 Resource Collection
savedRc	TokenNameIdentifier	 saved Rc
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
destFile	TokenNameIdentifier	 dest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// will be removed in validateAttributes 	TokenNameCOMMENT_LINE	will be removed in validateAttributes 
savedRc	TokenNameIdentifier	 saved Rc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
)	TokenNameRPAREN	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// make sure we don't have an illegal set of options 	TokenNameCOMMENT_LINE	make sure we don't have an illegal set of options 
try	TokenNametry	
{	TokenNameLBRACE	
validateAttributes	TokenNameIdentifier	 validate Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BuildException	TokenNameIdentifier	 Build Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failonerror	TokenNameIdentifier	 failonerror
||	TokenNameOR_OR	
!	TokenNameNOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
MSG_WHEN_COPYING_EMPTY_RC_TO_FILE	TokenNameIdentifier	 MSG  WHEN  COPYING  EMPTY  RC  TO  FILE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: "	TokenNameStringLiteral	Warning: 
+	TokenNamePLUS	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// deal with the single file 	TokenNameCOMMENT_LINE	deal with the single file 
copySingleFile	TokenNameIdentifier	 copy Single File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// deal with the ResourceCollections 	TokenNameCOMMENT_LINE	deal with the ResourceCollections 
/* for historical and performance reasons we have to do things in a rather complex way. (1) Move is optimized to move directories if a fileset has been included completely, therefore FileSets need a special treatment. This is also required to support the failOnError semantice (skip filesets with broken basedir but handle the remaining collections). (2) We carry around a few protected methods that work on basedirs and arrays of names. To optimize stuff, all resources with the same basedir get collected in separate lists and then each list is handled in one go. */	TokenNameCOMMENT_BLOCK	 for historical and performance reasons we have to do things in a rather complex way. (1) Move is optimized to move directories if a fileset has been included completely, therefore FileSets need a special treatment. This is also required to support the failOnError semantice (skip filesets with broken basedir but handle the remaining collections). (2) We carry around a few protected methods that work on basedirs and arrays of names. To optimize stuff, all resources with the same basedir get collected in separate lists and then each list is handled in one go. 
HashMap	TokenNameIdentifier	 Hash Map
filesByBasedir	TokenNameIdentifier	 files By Basedir
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
HashMap	TokenNameIdentifier	 Hash Map
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
HashSet	TokenNameIdentifier	 Hash Set
baseDirs	TokenNameIdentifier	 base Dirs
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ArrayList	TokenNameIdentifier	 Array List
nonFileResources	TokenNameIdentifier	 non File Resources
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
)	TokenNameRPAREN	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Step (1) - beware of the ZipFileSet 	TokenNameCOMMENT_LINE	Step (1) - beware of the ZipFileSet 
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
instanceof	TokenNameinstanceof	
FileSet	TokenNameIdentifier	 File Set
&&	TokenNameAND_AND	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
isFilesystemOnly	TokenNameIdentifier	 is Filesystem Only
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileSet	TokenNameIdentifier	 File Set
fs	TokenNameIdentifier	 fs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileSet	TokenNameIdentifier	 File Set
)	TokenNameRPAREN	
rc	TokenNameIdentifier	 rc
;	TokenNameSEMICOLON	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
ds	TokenNameIdentifier	 ds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ds	TokenNameIdentifier	 ds
=	TokenNameEQUAL	
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
getDirectoryScanner	TokenNameIdentifier	 get Directory Scanner
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BuildException	TokenNameIdentifier	 Build Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failonerror	TokenNameIdentifier	 failonerror
||	TokenNameOR_OR	
!	TokenNameNOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
DirectoryScanner	TokenNameIdentifier	 Directory Scanner
.	TokenNameDOT	
DOES_NOT_EXIST_POSTFIX	TokenNameIdentifier	 DOES  NOT  EXIST  POSTFIX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: "	TokenNameStringLiteral	Warning: 
+	TokenNamePLUS	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
fromDir	TokenNameIdentifier	 from Dir
=	TokenNameEQUAL	
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
getDir	TokenNameIdentifier	 get Dir
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcFiles	TokenNameIdentifier	 src Files
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getIncludedFiles	TokenNameIdentifier	 get Included Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcDirs	TokenNameIdentifier	 src Dirs
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
getIncludedDirectories	TokenNameIdentifier	 get Included Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
flatten	TokenNameIdentifier	 flatten
&&	TokenNameAND_AND	
mapperElement	TokenNameIdentifier	 mapper Element
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
isEverythingIncluded	TokenNameIdentifier	 is Everything Included
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fs	TokenNameIdentifier	 fs
.	TokenNameDOT	
hasPatterns	TokenNameIdentifier	 has Patterns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
completeDirMap	TokenNameIdentifier	 complete Dir Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
destDir	TokenNameIdentifier	 dest Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
srcFiles	TokenNameIdentifier	 src Files
,	TokenNameCOMMA	
filesByBasedir	TokenNameIdentifier	 files By Basedir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
srcDirs	TokenNameIdentifier	 src Dirs
,	TokenNameCOMMA	
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baseDirs	TokenNameIdentifier	 base Dirs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// not a fileset or contains non-file resources 	TokenNameCOMMENT_LINE	not a fileset or contains non-file resources 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
isFilesystemOnly	TokenNameIdentifier	 is Filesystem Only
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
supportsNonFileResources	TokenNameIdentifier	 supports Non File Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Only FileSystem resources are supported."	TokenNameStringLiteral	Only FileSystem resources are supported.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Iterator	TokenNameIdentifier	 Iterator
resources	TokenNameIdentifier	 resources
=	TokenNameEQUAL	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
resources	TokenNameIdentifier	 resources
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isExists	TokenNameIdentifier	 is Exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
"Warning: Could not find resource "	TokenNameStringLiteral	Warning: Could not find resource 
+	TokenNamePLUS	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
toLongString	TokenNameIdentifier	 to Long String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to copy."	TokenNameStringLiteral	 to copy.
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
=	TokenNameEQUAL	
NULL_FILE_PLACEHOLDER	TokenNameIdentifier	 NULL  FILE  PLACEHOLDER
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileProvider	TokenNameIdentifier	 File Provider
fp	TokenNameIdentifier	 fp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
)	TokenNameRPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
as	TokenNameIdentifier	 as
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileResource	TokenNameIdentifier	 File Resource
fr	TokenNameIdentifier	 fr
=	TokenNameEQUAL	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
asFileResource	TokenNameIdentifier	 as File Resource
(	TokenNameLPAREN	
fp	TokenNameIdentifier	 fp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baseDir	TokenNameIdentifier	 base Dir
=	TokenNameEQUAL	
getKeyFile	TokenNameIdentifier	 get Key File
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getBaseDir	TokenNameIdentifier	 get Base Dir
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getFile	TokenNameIdentifier	 get File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// copying of dirs is trivial and can be done 	TokenNameCOMMENT_LINE	copying of dirs is trivial and can be done 
// for non-file resources as well as for real 	TokenNameCOMMENT_LINE	for non-file resources as well as for real 
// files. 	TokenNameCOMMENT_LINE	files. 
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
fp	TokenNameIdentifier	 fp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
:	TokenNameCOLON	
filesByBasedir	TokenNameIdentifier	 files By Basedir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
baseDirs	TokenNameIdentifier	 base Dirs
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// a not-directory file resource 	TokenNameCOMMENT_LINE	a not-directory file resource 
// needs special treatment 	TokenNameCOMMENT_LINE	needs special treatment 
nonFileResources	TokenNameIdentifier	 non File Resources
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
iterateOverBaseDirs	TokenNameIdentifier	 iterate Over Base Dirs
(	TokenNameLPAREN	
baseDirs	TokenNameIdentifier	 base Dirs
,	TokenNameCOMMA	
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
,	TokenNameCOMMA	
filesByBasedir	TokenNameIdentifier	 files By Basedir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// do all the copy operations now... 	TokenNameCOMMENT_LINE	do all the copy operations now... 
try	TokenNametry	
{	TokenNameLBRACE	
doFileOperations	TokenNameIdentifier	 do File Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BuildException	TokenNameIdentifier	 Build Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: "	TokenNameStringLiteral	Warning: 
+	TokenNamePLUS	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nonFileResources	TokenNameIdentifier	 non File Resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
singleResource	TokenNameIdentifier	 single Resource
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
nonFiles	TokenNameIdentifier	 non Files
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
nonFileResources	TokenNameIdentifier	 non File Resources
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
nonFileResources	TokenNameIdentifier	 non File Resources
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// restrict to out-of-date resources 	TokenNameCOMMENT_LINE	restrict to out-of-date resources 
Map	TokenNameIdentifier	 Map
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
scan	TokenNameIdentifier	 scan
(	TokenNameLPAREN	
nonFiles	TokenNameIdentifier	 non Files
,	TokenNameCOMMA	
destDir	TokenNameIdentifier	 dest Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
singleResource	TokenNameIdentifier	 single Resource
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
singleResource	TokenNameIdentifier	 single Resource
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
destFile	TokenNameIdentifier	 dest File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
doResourceOperations	TokenNameIdentifier	 do Resource Operations
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
BuildException	TokenNameIdentifier	 Build Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Warning: "	TokenNameStringLiteral	Warning: 
+	TokenNamePLUS	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
e	TokenNameIdentifier	 e
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// clean up again, so this instance can be used a second 	TokenNameCOMMENT_LINE	clean up again, so this instance can be used a second 
// time 	TokenNameCOMMENT_LINE	time 
singleResource	TokenNameIdentifier	 single Resource
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
savedFile	TokenNameIdentifier	 saved File
;	TokenNameSEMICOLON	
destFile	TokenNameIdentifier	 dest File
=	TokenNameEQUAL	
savedDestFile	TokenNameIdentifier	 saved Dest File
;	TokenNameSEMICOLON	
destDir	TokenNameIdentifier	 dest Dir
=	TokenNameEQUAL	
savedDestDir	TokenNameIdentifier	 saved Dest Dir
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
savedRc	TokenNameIdentifier	 saved Rc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
insertElementAt	TokenNameIdentifier	 insert Element At
(	TokenNameLPAREN	
savedRc	TokenNameIdentifier	 saved Rc
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dirCopyMap	TokenNameIdentifier	 dir Copy Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
completeDirMap	TokenNameIdentifier	 complete Dir Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/************************************************************************ ** protected and private methods ************************************************************************/	TokenNameCOMMENT_JAVADOC	********************************************************************** ** protected and private methods ***********************************************************************
private	TokenNameprivate	
void	TokenNamevoid	
copySingleFile	TokenNameIdentifier	 copy Single File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// deal with the single file 	TokenNameCOMMENT_LINE	deal with the single file 
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destFile	TokenNameIdentifier	 dest File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destDir	TokenNameIdentifier	 dest Dir
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
forceOverwrite	TokenNameIdentifier	 force Overwrite
||	TokenNameOR_OR	
!	TokenNameNOT	
destFile	TokenNameIdentifier	 dest File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
granularity	TokenNameIdentifier	 granularity
>	TokenNameGREATER	
destFile	TokenNameIdentifier	 dest File
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
destFile	TokenNameIdentifier	 dest File
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
+	TokenNamePLUS	
" omitted as "	TokenNameStringLiteral	 omitted as 
+	TokenNamePLUS	
destFile	TokenNameIdentifier	 dest File
+	TokenNamePLUS	
" is up to date."	TokenNameStringLiteral	 is up to date.
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_VERBOSE	TokenNameIdentifier	 MSG  VERBOSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
"Warning: Could not find file "	TokenNameStringLiteral	Warning: Could not find file 
+	TokenNamePLUS	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to copy."	TokenNameStringLiteral	 to copy.
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
quiet	TokenNameIdentifier	 quiet
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
iterateOverBaseDirs	TokenNameIdentifier	 iterate Over Base Dirs
(	TokenNameLPAREN	
HashSet	TokenNameIdentifier	 Hash Set
baseDirs	TokenNameIdentifier	 base Dirs
,	TokenNameCOMMA	
HashMap	TokenNameIdentifier	 Hash Map
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
,	TokenNameCOMMA	
HashMap	TokenNameIdentifier	 Hash Map
filesByBasedir	TokenNameIdentifier	 files By Basedir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
baseDirs	TokenNameIdentifier	 base Dirs
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
=	TokenNameEQUAL	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
)	TokenNameRPAREN	
filesByBasedir	TokenNameIdentifier	 files By Basedir
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
dirs	TokenNameIdentifier	 dirs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
)	TokenNameRPAREN	
dirsByBasedir	TokenNameIdentifier	 dirs By Basedir
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcFiles	TokenNameIdentifier	 src Files
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcFiles	TokenNameIdentifier	 src Files
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
srcFiles	TokenNameIdentifier	 src Files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcDirs	TokenNameIdentifier	 src Dirs
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
srcDirs	TokenNameIdentifier	 src Dirs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
toArray	TokenNameIdentifier	 to Array
(	TokenNameLPAREN	
srcDirs	TokenNameIdentifier	 src Dirs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
scan	TokenNameIdentifier	 scan
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
==	TokenNameEQUAL_EQUAL	
NULL_FILE_PLACEHOLDER	TokenNameIdentifier	 NULL  FILE  PLACEHOLDER
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
destDir	TokenNameIdentifier	 dest Dir
,	TokenNameCOMMA	
srcFiles	TokenNameIdentifier	 src Files
,	TokenNameCOMMA	
srcDirs	TokenNameIdentifier	 src Dirs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Ensure we have a consistent and legal set of attributes, and set * any internal flags necessary based on different combinations * of attributes. * @exception BuildException if an error occurs. */	TokenNameCOMMENT_JAVADOC	 Ensure we have a consistent and legal set of attributes, and set any internal flags necessary based on different combinations of attributes. @exception BuildException if an error occurs. 
protected	TokenNameprotected	
void	TokenNamevoid	
validateAttributes	TokenNameIdentifier	 validate Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
BuildException	TokenNameIdentifier	 Build Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Specify at least one source--a file or a resource collection."	TokenNameStringLiteral	Specify at least one source--a file or a resource collection.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
destDir	TokenNameIdentifier	 dest Dir
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Only one of tofile and todir may be set."	TokenNameStringLiteral	Only one of tofile and todir may be set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
destDir	TokenNameIdentifier	 dest Dir
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"One of tofile or todir must be set."	TokenNameStringLiteral	One of tofile or todir must be set.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Use a resource collection to copy directories."	TokenNameStringLiteral	Use a resource collection to copy directories.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot concatenate multiple files into a single file."	TokenNameStringLiteral	Cannot concatenate multiple files into a single file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ResourceCollection	TokenNameIdentifier	 Resource Collection
rc	TokenNameIdentifier	 rc
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ResourceCollection	TokenNameIdentifier	 Resource Collection
)	TokenNameRPAREN	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
isFilesystemOnly	TokenNameIdentifier	 is Filesystem Only
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
supportsNonFileResources	TokenNameIdentifier	 supports Non File Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Only FileSystem resources are"	TokenNameStringLiteral	Only FileSystem resources are
+	TokenNamePLUS	
" supported."	TokenNameStringLiteral	 supported.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
MSG_WHEN_COPYING_EMPTY_RC_TO_FILE	TokenNameIdentifier	 MSG  WHEN  COPYING  EMPTY  RC  TO  FILE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
res	TokenNameIdentifier	 res
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
rc	TokenNameIdentifier	 rc
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileProvider	TokenNameIdentifier	 File Provider
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
)	TokenNameRPAREN	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
as	TokenNameIdentifier	 as
(	TokenNameLPAREN	
FileProvider	TokenNameIdentifier	 File Provider
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getFile	TokenNameIdentifier	 get File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
singleResource	TokenNameIdentifier	 single Resource
=	TokenNameEQUAL	
res	TokenNameIdentifier	 res
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
rcs	TokenNameIdentifier	 rcs
.	TokenNameDOT	
removeElementAt	TokenNameIdentifier	 remove Element At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot concatenate multiple files into a single file."	TokenNameStringLiteral	Cannot concatenate multiple files into a single file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Cannot concatenate multiple files into a single file."	TokenNameStringLiteral	Cannot concatenate multiple files into a single file.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
destFile	TokenNameIdentifier	 dest File
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destDir	TokenNameIdentifier	 dest Dir
=	TokenNameEQUAL	
destFile	TokenNameIdentifier	 dest File
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Compares source files to destination files to see if they should be * copied. * * @param fromDir The source directory. * @param toDir The destination directory. * @param files A list of files to copy. * @param dirs A list of directories to copy. */	TokenNameCOMMENT_JAVADOC	 Compares source files to destination files to see if they should be copied. * @param fromDir The source directory. @param toDir The destination directory. @param files A list of files to copy. @param dirs A list of directories to copy. 
protected	TokenNameprotected	
void	TokenNamevoid	
scan	TokenNameIdentifier	 scan
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dirs	TokenNameIdentifier	 dirs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
mapper	TokenNameIdentifier	 mapper
=	TokenNameEQUAL	
getMapper	TokenNameIdentifier	 get Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
buildMap	TokenNameIdentifier	 build Map
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
fileCopyMap	TokenNameIdentifier	 file Copy Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeEmpty	TokenNameIdentifier	 include Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buildMap	TokenNameIdentifier	 build Map
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
dirs	TokenNameIdentifier	 dirs
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
dirCopyMap	TokenNameIdentifier	 dir Copy Map
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Compares source resources to destination files to see if they * should be copied. * * @param fromResources The source resources. * @param toDir The destination directory. * * @return a Map with the out-of-date resources as keys and an * array of target file names as values. * * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Compares source resources to destination files to see if they should be copied. * @param fromResources The source resources. @param toDir The destination directory. * @return a Map with the out-of-date resources as keys and an array of target file names as values. * @since Ant 1.7 
protected	TokenNameprotected	
Map	TokenNameIdentifier	 Map
scan	TokenNameIdentifier	 scan
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fromResources	TokenNameIdentifier	 from Resources
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
toDir	TokenNameIdentifier	 to Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
buildMap	TokenNameIdentifier	 build Map
(	TokenNameLPAREN	
fromResources	TokenNameIdentifier	 from Resources
,	TokenNameCOMMA	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
getMapper	TokenNameIdentifier	 get Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add to a map of files/directories to copy. * * @param fromDir the source directory. * @param toDir the destination directory. * @param names a list of filenames. * @param mapper a <code>FileNameMapper</code> value. * @param map a map of source file to array of destination files. */	TokenNameCOMMENT_JAVADOC	 Add to a map of files/directories to copy. * @param fromDir the source directory. @param toDir the destination directory. @param names a list of filenames. @param mapper a <code>FileNameMapper</code> value. @param map a map of source file to array of destination files. 
protected	TokenNameprotected	
void	TokenNamevoid	
buildMap	TokenNameIdentifier	 build Map
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
names	TokenNameIdentifier	 names
,	TokenNameCOMMA	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
Hashtable	TokenNameIdentifier	 Hashtable
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mapper	TokenNameIdentifier	 mapper
.	TokenNameDOT	
mapFileName	TokenNameIdentifier	 map File Name
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
SourceFileScanner	TokenNameIdentifier	 Source File Scanner
ds	TokenNameIdentifier	 ds
=	TokenNameEQUAL	
new	TokenNamenew	
SourceFileScanner	TokenNameIdentifier	 Source File Scanner
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
.	TokenNameDOT	
restrict	TokenNameIdentifier	 restrict
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
,	TokenNameCOMMA	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toCopy	TokenNameIdentifier	 to Copy
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
fromDir	TokenNameIdentifier	 from Dir
,	TokenNameCOMMA	
toCopy	TokenNameIdentifier	 to Copy
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
mappedFiles	TokenNameIdentifier	 mapped Files
=	TokenNameEQUAL	
mapper	TokenNameIdentifier	 mapper
.	TokenNameDOT	
mapFileName	TokenNameIdentifier	 map File Name
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// reuse the array created by the mapper 	TokenNameCOMMENT_LINE	reuse the array created by the mapper 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
mappedFiles	TokenNameIdentifier	 mapped Files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Create a map of resources to copy. * * @param fromResources The source resources. * @param toDir the destination directory. * @param mapper a <code>FileNameMapper</code> value. * @return a map of source resource to array of destination files. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Create a map of resources to copy. * @param fromResources The source resources. @param toDir the destination directory. @param mapper a <code>FileNameMapper</code> value. @return a map of source resource to array of destination files. @since Ant 1.7 
protected	TokenNameprotected	
Map	TokenNameIdentifier	 Map
buildMap	TokenNameIdentifier	 build Map
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fromResources	TokenNameIdentifier	 from Resources
,	TokenNameCOMMA	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
mapper	TokenNameIdentifier	 mapper
)	TokenNameRPAREN	
{	TokenNameLBRACE	
HashMap	TokenNameIdentifier	 Hash Map
map	TokenNameIdentifier	 map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
forceOverwrite	TokenNameIdentifier	 force Overwrite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fromResources	TokenNameIdentifier	 from Resources
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mapper	TokenNameIdentifier	 mapper
.	TokenNameDOT	
mapFileName	TokenNameIdentifier	 map File Name
(	TokenNameLPAREN	
fromResources	TokenNameIdentifier	 from Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fromResources	TokenNameIdentifier	 from Resources
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
new	TokenNamenew	
Resource	TokenNameIdentifier	 Resource
[	TokenNameLBRACKET	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
v	TokenNameIdentifier	 v
.	TokenNameDOT	
copyInto	TokenNameIdentifier	 copy Into
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
toCopy	TokenNameIdentifier	 to Copy
=	TokenNameEQUAL	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
selectOutOfDateSources	TokenNameIdentifier	 select Out Of Date Sources
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
fromResources	TokenNameIdentifier	 from Resources
,	TokenNameCOMMA	
mapper	TokenNameIdentifier	 mapper
,	TokenNameCOMMA	
new	TokenNamenew	
ResourceFactory	TokenNameIdentifier	 Resource Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Resource	TokenNameIdentifier	 Resource
getResource	TokenNameIdentifier	 get Resource
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
,	TokenNameCOMMA	
granularity	TokenNameIdentifier	 granularity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toCopy	TokenNameIdentifier	 to Copy
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
mappedFiles	TokenNameIdentifier	 mapped Files
=	TokenNameEQUAL	
mapper	TokenNameIdentifier	 mapper
.	TokenNameDOT	
mapFileName	TokenNameIdentifier	 map File Name
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
mappedFiles	TokenNameIdentifier	 mapped Files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
"Can't copy a resource without a"	TokenNameStringLiteral	Can't copy a resource without a
+	TokenNamePLUS	
" name if the mapper doesn't"	TokenNameStringLiteral	 name if the mapper doesn't
+	TokenNamePLUS	
" provide one."	TokenNameStringLiteral	 provide one.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
enableMultipleMappings	TokenNameIdentifier	 enable Multiple Mappings
)	TokenNameRPAREN	
{	TokenNameLBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// reuse the array created by the mapper 	TokenNameCOMMENT_LINE	reuse the array created by the mapper 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
mappedFiles	TokenNameIdentifier	 mapped Files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toDir	TokenNameIdentifier	 to Dir
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
toCopy	TokenNameIdentifier	 to Copy
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
mappedFiles	TokenNameIdentifier	 mapped Files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
map	TokenNameIdentifier	 map
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Actually does the file (and possibly empty directory) copies. * This is a good method for subclasses to override. */	TokenNameCOMMENT_JAVADOC	 Actually does the file (and possibly empty directory) copies. This is a good method for subclasses to override. 
protected	TokenNameprotected	
void	TokenNamevoid	
doFileOperations	TokenNameIdentifier	 do File Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Copying "	TokenNameStringLiteral	Copying 
+	TokenNamePLUS	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" file"	TokenNameStringLiteral	 file
+	TokenNamePLUS	
(	TokenNameLPAREN	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
"s"	TokenNameStringLiteral	s
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
destDir	TokenNameIdentifier	 dest Dir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
fromFile	TokenNameIdentifier	 from File
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toFiles	TokenNameIdentifier	 to Files
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
fileCopyMap	TokenNameIdentifier	 file Copy Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fromFile	TokenNameIdentifier	 from File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toFiles	TokenNameIdentifier	 to Files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
toFile	TokenNameIdentifier	 to File
=	TokenNameEQUAL	
toFiles	TokenNameIdentifier	 to Files
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fromFile	TokenNameIdentifier	 from File
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Skipping self-copy of "	TokenNameStringLiteral	Skipping self-copy of 
+	TokenNamePLUS	
fromFile	TokenNameIdentifier	 from File
,	TokenNameCOMMA	
verbosity	TokenNameIdentifier	 verbosity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Copying "	TokenNameStringLiteral	Copying 
+	TokenNamePLUS	
fromFile	TokenNameIdentifier	 from File
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
,	TokenNameCOMMA	
verbosity	TokenNameIdentifier	 verbosity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
executionFilters	TokenNameIdentifier	 execution Filters
=	TokenNameEQUAL	
new	TokenNamenew	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filtering	TokenNameIdentifier	 filtering
)	TokenNameRPAREN	
{	TokenNameLBRACE	
executionFilters	TokenNameIdentifier	 execution Filters
.	TokenNameDOT	
addFilterSet	TokenNameIdentifier	 add Filter Set
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getGlobalFilterSet	TokenNameIdentifier	 get Global Filter Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
filterEnum	TokenNameIdentifier	 filter Enum
=	TokenNameEQUAL	
filterSets	TokenNameIdentifier	 filter Sets
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filterEnum	TokenNameIdentifier	 filter Enum
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
executionFilters	TokenNameIdentifier	 execution Filters
.	TokenNameDOT	
addFilterSet	TokenNameIdentifier	 add Filter Set
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FilterSet	TokenNameIdentifier	 Filter Set
)	TokenNameRPAREN	
filterEnum	TokenNameIdentifier	 filter Enum
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fileUtils	TokenNameIdentifier	 file Utils
.	TokenNameDOT	
copyFile	TokenNameIdentifier	 copy File
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
fromFile	TokenNameIdentifier	 from File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
executionFilters	TokenNameIdentifier	 execution Filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
forceOverwrite	TokenNameIdentifier	 force Overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
/* append: */	TokenNameCOMMENT_BLOCK	 append: 
false	TokenNamefalse	
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getForce	TokenNameIdentifier	 get Force
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
"Failed to copy "	TokenNameStringLiteral	Failed to copy 
+	TokenNamePLUS	
fromFile	TokenNameIdentifier	 from File
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
+	TokenNamePLUS	
" due to "	TokenNameStringLiteral	 due to 
+	TokenNamePLUS	
getDueTo	TokenNameIdentifier	 get Due To
(	TokenNameLPAREN	
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
targetFile	TokenNameIdentifier	 target File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
targetFile	TokenNameIdentifier	 target File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
targetFile	TokenNameIdentifier	 target File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
+=	TokenNamePLUS_EQUAL	
" and I couldn't delete the corrupt "	TokenNameStringLiteral	 and I couldn't delete the corrupt 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includeEmpty	TokenNameIdentifier	 include Empty
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Enumeration	TokenNameIdentifier	 Enumeration
e	TokenNameIdentifier	 e
=	TokenNameEQUAL	
dirCopyMap	TokenNameIdentifier	 dir Copy Map
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
createCount	TokenNameIdentifier	 create Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dirs	TokenNameIdentifier	 dirs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
dirs	TokenNameIdentifier	 dirs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
d	TokenNameIdentifier	 d
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dirs	TokenNameIdentifier	 dirs
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Unable to create directory "	TokenNameStringLiteral	Unable to create directory 
+	TokenNamePLUS	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
createCount	TokenNameIdentifier	 create Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
createCount	TokenNameIdentifier	 create Count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Copied "	TokenNameStringLiteral	Copied 
+	TokenNamePLUS	
dirCopyMap	TokenNameIdentifier	 dir Copy Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" empty director"	TokenNameStringLiteral	 empty director
+	TokenNamePLUS	
(	TokenNameLPAREN	
dirCopyMap	TokenNameIdentifier	 dir Copy Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
"y"	TokenNameStringLiteral	y
:	TokenNameCOLON	
"ies"	TokenNameStringLiteral	ies
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
createCount	TokenNameIdentifier	 create Count
+	TokenNamePLUS	
" empty director"	TokenNameStringLiteral	 empty director
+	TokenNamePLUS	
(	TokenNameLPAREN	
createCount	TokenNameIdentifier	 create Count
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
"y"	TokenNameStringLiteral	y
:	TokenNameCOLON	
"ies"	TokenNameStringLiteral	ies
)	TokenNameRPAREN	
+	TokenNamePLUS	
" under "	TokenNameStringLiteral	 under 
+	TokenNamePLUS	
destDir	TokenNameIdentifier	 dest Dir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Actually does the resource copies. * This is a good method for subclasses to override. * @param map a map of source resource to array of destination files. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Actually does the resource copies. This is a good method for subclasses to override. @param map a map of source resource to array of destination files. @since Ant 1.7 
protected	TokenNameprotected	
void	TokenNamevoid	
doResourceOperations	TokenNameIdentifier	 do Resource Operations
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
map	TokenNameIdentifier	 map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Copying "	TokenNameStringLiteral	Copying 
+	TokenNamePLUS	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" resource"	TokenNameStringLiteral	 resource
+	TokenNamePLUS	
(	TokenNameLPAREN	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
"s"	TokenNameStringLiteral	s
)	TokenNameRPAREN	
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
destDir	TokenNameIdentifier	 dest Dir
.	TokenNameDOT	
getAbsolutePath	TokenNameIdentifier	 get Absolute Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Resource	TokenNameIdentifier	 Resource
fromResource	TokenNameIdentifier	 from Resource
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Resource	TokenNameIdentifier	 Resource
)	TokenNameRPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
toFiles	TokenNameIdentifier	 to Files
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
map	TokenNameIdentifier	 map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fromResource	TokenNameIdentifier	 from Resource
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
toFiles	TokenNameIdentifier	 to Files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
toFile	TokenNameIdentifier	 to File
=	TokenNameEQUAL	
toFiles	TokenNameIdentifier	 to Files
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
"Copying "	TokenNameStringLiteral	Copying 
+	TokenNamePLUS	
fromResource	TokenNameIdentifier	 from Resource
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
,	TokenNameCOMMA	
verbosity	TokenNameIdentifier	 verbosity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
executionFilters	TokenNameIdentifier	 execution Filters
=	TokenNameEQUAL	
new	TokenNamenew	
FilterSetCollection	TokenNameIdentifier	 Filter Set Collection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filtering	TokenNameIdentifier	 filtering
)	TokenNameRPAREN	
{	TokenNameLBRACE	
executionFilters	TokenNameIdentifier	 execution Filters
.	TokenNameDOT	
addFilterSet	TokenNameIdentifier	 add Filter Set
(	TokenNameLPAREN	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getGlobalFilterSet	TokenNameIdentifier	 get Global Filter Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Enumeration	TokenNameIdentifier	 Enumeration
filterEnum	TokenNameIdentifier	 filter Enum
=	TokenNameEQUAL	
filterSets	TokenNameIdentifier	 filter Sets
.	TokenNameDOT	
elements	TokenNameIdentifier	 elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
filterEnum	TokenNameIdentifier	 filter Enum
.	TokenNameDOT	
hasMoreElements	TokenNameIdentifier	 has More Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
executionFilters	TokenNameIdentifier	 execution Filters
.	TokenNameDOT	
addFilterSet	TokenNameIdentifier	 add Filter Set
(	TokenNameLPAREN	
(	TokenNameLPAREN	
FilterSet	TokenNameIdentifier	 Filter Set
)	TokenNameRPAREN	
filterEnum	TokenNameIdentifier	 filter Enum
.	TokenNameDOT	
nextElement	TokenNameIdentifier	 next Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ResourceUtils	TokenNameIdentifier	 Resource Utils
.	TokenNameDOT	
copyResource	TokenNameIdentifier	 copy Resource
(	TokenNameLPAREN	
fromResource	TokenNameIdentifier	 from Resource
,	TokenNameCOMMA	
new	TokenNamenew	
FileResource	TokenNameIdentifier	 File Resource
(	TokenNameLPAREN	
destDir	TokenNameIdentifier	 dest Dir
,	TokenNameCOMMA	
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
,	TokenNameCOMMA	
executionFilters	TokenNameIdentifier	 execution Filters
,	TokenNameCOMMA	
filterChains	TokenNameIdentifier	 filter Chains
,	TokenNameCOMMA	
forceOverwrite	TokenNameIdentifier	 force Overwrite
,	TokenNameCOMMA	
preserveLastModified	TokenNameIdentifier	 preserve Last Modified
,	TokenNameCOMMA	
/* append: */	TokenNameCOMMENT_BLOCK	 append: 
false	TokenNamefalse	
,	TokenNameCOMMA	
inputEncoding	TokenNameIdentifier	 input Encoding
,	TokenNameCOMMA	
outputEncoding	TokenNameIdentifier	 output Encoding
,	TokenNameCOMMA	
getProject	TokenNameIdentifier	 get Project
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getForce	TokenNameIdentifier	 get Force
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
"Failed to copy "	TokenNameStringLiteral	Failed to copy 
+	TokenNamePLUS	
fromResource	TokenNameIdentifier	 from Resource
+	TokenNamePLUS	
" to "	TokenNameStringLiteral	 to 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
+	TokenNamePLUS	
" due to "	TokenNameStringLiteral	 due to 
+	TokenNamePLUS	
getDueTo	TokenNameIdentifier	 get Due To
(	TokenNameLPAREN	
ioe	TokenNameIdentifier	 ioe
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
targetFile	TokenNameIdentifier	 target File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
toFile	TokenNameIdentifier	 to File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
targetFile	TokenNameIdentifier	 target File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
targetFile	TokenNameIdentifier	 target File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
msg	TokenNameIdentifier	 msg
+=	TokenNamePLUS_EQUAL	
" and I couldn't delete the corrupt "	TokenNameStringLiteral	 and I couldn't delete the corrupt 
+	TokenNamePLUS	
toFile	TokenNameIdentifier	 to File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failonerror	TokenNameIdentifier	 failonerror
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
BuildException	TokenNameIdentifier	 Build Exception
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
ioe	TokenNameIdentifier	 ioe
,	TokenNameCOMMA	
getLocation	TokenNameIdentifier	 get Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
log	TokenNameIdentifier	 log
(	TokenNameLPAREN	
msg	TokenNameIdentifier	 msg
,	TokenNameCOMMA	
Project	TokenNameIdentifier	 Project
.	TokenNameDOT	
MSG_ERR	TokenNameIdentifier	 MSG  ERR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Whether this task can deal with non-file resources. * * <p>&lt;copy&gt; can while &lt;move&gt; can't since we don't * know how to remove non-file resources.</p> * * <p>This implementation returns true only if this task is * &lt;copy&gt;. Any subclass of this class that also wants to * support non-file resources needs to override this method. We * need to do so for backwards compatibility reasons since we * can't expect subclasses to support resources.</p> * @return true if this task supports non file resources. * @since Ant 1.7 */	TokenNameCOMMENT_JAVADOC	 Whether this task can deal with non-file resources. * <p>&lt;copy&gt; can while &lt;move&gt; can't since we don't know how to remove non-file resources.</p> * <p>This implementation returns true only if this task is &lt;copy&gt;. Any subclass of this class that also wants to support non-file resources needs to override this method. We need to do so for backwards compatibility reasons since we can't expect subclasses to support resources.</p> @return true if this task supports non file resources. @since Ant 1.7 
protected	TokenNameprotected	
boolean	TokenNameboolean	
supportsNonFileResources	TokenNameIdentifier	 supports Non File Resources
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Copy	TokenNameIdentifier	 Copy
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Adds the given strings to a list contained in the given map. * The file is the key into the map. */	TokenNameCOMMENT_JAVADOC	 Adds the given strings to a list contained in the given map. The file is the key into the map. 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
names	TokenNameIdentifier	 names
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
m	TokenNameIdentifier	 m
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
baseDir	TokenNameIdentifier	 base Dir
=	TokenNameEQUAL	
getKeyFile	TokenNameIdentifier	 get Key File
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
)	TokenNameRPAREN	
m	TokenNameIdentifier	 m
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
l	TokenNameIdentifier	 l
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
addAll	TokenNameIdentifier	 add All
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Adds the given string to a list contained in the given map. * The file is the key into the map. */	TokenNameCOMMENT_JAVADOC	 Adds the given string to a list contained in the given map. The file is the key into the map. 
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
m	TokenNameIdentifier	 m
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
baseDir	TokenNameIdentifier	 base Dir
,	TokenNameCOMMA	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
}	TokenNameRBRACE	
,	TokenNameCOMMA	
m	TokenNameIdentifier	 m
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Either returns its argument or a plaeholder if the argument is null. */	TokenNameCOMMENT_JAVADOC	 Either returns its argument or a plaeholder if the argument is null. 
private	TokenNameprivate	
static	TokenNamestatic	
File	TokenNameIdentifier	 File
getKeyFile	TokenNameIdentifier	 get Key File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
f	TokenNameIdentifier	 f
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
NULL_FILE_PLACEHOLDER	TokenNameIdentifier	 NULL  FILE  PLACEHOLDER
:	TokenNameCOLON	
f	TokenNameIdentifier	 f
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * returns the mapper to use based on nested elements or the * flatten attribute. */	TokenNameCOMMENT_JAVADOC	 returns the mapper to use based on nested elements or the flatten attribute. 
private	TokenNameprivate	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
getMapper	TokenNameIdentifier	 get Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileNameMapper	TokenNameIdentifier	 File Name Mapper
mapper	TokenNameIdentifier	 mapper
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
mapperElement	TokenNameIdentifier	 mapper Element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mapper	TokenNameIdentifier	 mapper
=	TokenNameEQUAL	
mapperElement	TokenNameIdentifier	 mapper Element
.	TokenNameDOT	
getImplementation	TokenNameIdentifier	 get Implementation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
flatten	TokenNameIdentifier	 flatten
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mapper	TokenNameIdentifier	 mapper
=	TokenNameEQUAL	
new	TokenNamenew	
FlatFileNameMapper	TokenNameIdentifier	 Flat File Name Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
mapper	TokenNameIdentifier	 mapper
=	TokenNameEQUAL	
new	TokenNamenew	
IdentityMapper	TokenNameIdentifier	 Identity Mapper
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
mapper	TokenNameIdentifier	 mapper
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Handle getMessage() for exceptions. * @param ex the exception to handle * @return ex.getMessage() if ex.getMessage() is not null * otherwise return ex.toString() */	TokenNameCOMMENT_JAVADOC	 Handle getMessage() for exceptions. @param ex the exception to handle @return ex.getMessage() if ex.getMessage() is not null otherwise return ex.toString() 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns a reason for failure based on * the exception thrown. * If the exception is not IOException output the class name, * output the message * if the exception is MalformedInput add a little note. */	TokenNameCOMMENT_JAVADOC	 Returns a reason for failure based on the exception thrown. If the exception is not IOException output the class name, output the message if the exception is MalformedInput add a little note. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getDueTo	TokenNameIdentifier	 get Due To
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
baseIOException	TokenNameIdentifier	 base IO Exception
=	TokenNameEQUAL	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
IOException	TokenNameIdentifier	 IO Exception
.	TokenNameDOT	
class	TokenNameclass	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
baseIOException	TokenNameIdentifier	 base IO Exception
||	TokenNameOR_OR	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
baseIOException	TokenNameIdentifier	 base IO Exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ex	TokenNameIdentifier	 ex
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
"MalformedInput"	TokenNameStringLiteral	MalformedInput
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
LINE_SEPARATOR	TokenNameIdentifier	 LINE  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"This is normally due to the input file containing invalid"	TokenNameStringLiteral	This is normally due to the input file containing invalid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
LINE_SEPARATOR	TokenNameIdentifier	 LINE  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"bytes for the character encoding used : "	TokenNameStringLiteral	bytes for the character encoding used : 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
inputEncoding	TokenNameIdentifier	 input Encoding
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
fileUtils	TokenNameIdentifier	 file Utils
.	TokenNameDOT	
getDefaultEncoding	TokenNameIdentifier	 get Default Encoding
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
inputEncoding	TokenNameIdentifier	 input Encoding
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
LINE_SEPARATOR	TokenNameIdentifier	 LINE  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
message	TokenNameIdentifier	 message
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
