/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
flow	TokenNameIdentifier	 flow
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Point2D	TokenNameIdentifier	 Point2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
gvt	TokenNameIdentifier	 gvt
.	TokenNameDOT	
font	TokenNameIdentifier	 font
.	TokenNameDOT	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
;	TokenNameSEMICOLON	
/** * One line Class Desc * * Complete Class Desc * * @author <a href="mailto:deweese@apache.org">deweese</a> * @version $Id: LineInfo.java 478188 2006-11-22 15:19:17Z dvholten $ */	TokenNameCOMMENT_JAVADOC	 One line Class Desc * Complete Class Desc * @author <a href="mailto:deweese@apache.org">deweese</a> @version $Id: LineInfo.java 478188 2006-11-22 15:19:17Z dvholten $ 
public	TokenNamepublic	
class	TokenNameclass	
LineInfo	TokenNameIdentifier	 Line Info
{	TokenNameLBRACE	
FlowRegions	TokenNameIdentifier	 Flow Regions
fr	TokenNameIdentifier	 fr
;	TokenNameSEMICOLON	
double	TokenNamedouble	
lineHeight	TokenNameIdentifier	 line Height
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
ascent	TokenNameIdentifier	 ascent
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
descent	TokenNameIdentifier	 descent
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
hLeading	TokenNameIdentifier	 h Leading
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
baseline	TokenNameIdentifier	 baseline
;	TokenNameSEMICOLON	
int	TokenNameint	
numGlyphs	TokenNameIdentifier	 num Glyphs
;	TokenNameSEMICOLON	
int	TokenNameint	
words	TokenNameIdentifier	 words
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ggis	TokenNameIdentifier	 ggis
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newGGIS	TokenNameIdentifier	 new GGIS
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
numRanges	TokenNameIdentifier	 num Ranges
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rangeAdv	TokenNameIdentifier	 range Adv
;	TokenNameSEMICOLON	
BlockInfo	TokenNameIdentifier	 Block Info
bi	TokenNameIdentifier	 bi
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
paraStart	TokenNameIdentifier	 para Start
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
paraEnd	TokenNameIdentifier	 para End
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FULL_WORD	TokenNameIdentifier	 FULL  WORD
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
FULL_ADV	TokenNameIdentifier	 FULL  ADV
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
LineInfo	TokenNameIdentifier	 Line Info
(	TokenNameLPAREN	
FlowRegions	TokenNameIdentifier	 Flow Regions
fr	TokenNameIdentifier	 fr
,	TokenNameCOMMA	
BlockInfo	TokenNameIdentifier	 Block Info
bi	TokenNameIdentifier	 bi
,	TokenNameCOMMA	
boolean	TokenNameboolean	
paraStart	TokenNameIdentifier	 para Start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fr	TokenNameIdentifier	 fr
=	TokenNameEQUAL	
fr	TokenNameIdentifier	 fr
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bi	TokenNameIdentifier	 bi
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
lineHeight	TokenNameIdentifier	 line Height
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getLineHeight	TokenNameIdentifier	 get Line Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ascent	TokenNameIdentifier	 ascent
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
descent	TokenNameIdentifier	 descent
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
hLeading	TokenNameIdentifier	 h Leading
=	TokenNameEQUAL	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
-	TokenNameMINUS	
(	TokenNameLPAREN	
ascent	TokenNameIdentifier	 ascent
+	TokenNamePLUS	
descent	TokenNameIdentifier	 descent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
baseline	TokenNameIdentifier	 baseline
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getCurrentY	TokenNameIdentifier	 get Current Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
hLeading	TokenNameIdentifier	 h Leading
+	TokenNamePLUS	
ascent	TokenNameIdentifier	 ascent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
paraStart	TokenNameIdentifier	 para Start
=	TokenNameEQUAL	
paraStart	TokenNameIdentifier	 para Start
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
paraEnd	TokenNameIdentifier	 para End
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
newLineHeight	TokenNameIdentifier	 new Line Height
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
updateRangeInfo	TokenNameIdentifier	 update Range Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setParaEnd	TokenNameIdentifier	 set Para End
(	TokenNameLPAREN	
boolean	TokenNameboolean	
paraEnd	TokenNameIdentifier	 para End
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
paraEnd	TokenNameIdentifier	 para End
=	TokenNameEQUAL	
paraEnd	TokenNameIdentifier	 para End
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
addWord	TokenNameIdentifier	 add Word
(	TokenNameLPAREN	
WordInfo	TokenNameIdentifier	 Word Info
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
nlh	TokenNameIdentifier	 nlh
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getLineHeight	TokenNameIdentifier	 get Line Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nlh	TokenNameIdentifier	 nlh
<=	TokenNameLESS_EQUAL	
lineHeight	TokenNameIdentifier	 line Height
)	TokenNameRPAREN	
return	TokenNamereturn	
insertWord	TokenNameIdentifier	 insert Word
(	TokenNameLPAREN	
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
newLineHeight	TokenNameIdentifier	 new Line Height
(	TokenNameLPAREN	
nlh	TokenNameIdentifier	 nlh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
updateRangeInfo	TokenNameIdentifier	 update Range Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// restore old LH 	TokenNameCOMMENT_LINE	restore old LH 
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
newLineHeight	TokenNameIdentifier	 new Line Height
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
insertWord	TokenNameIdentifier	 insert Word
(	TokenNameLPAREN	
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// Failure, restore old line Height. 	TokenNameCOMMENT_LINE	Failure, restore old line Height. 
setLineHeight	TokenNameIdentifier	 set Line Height
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Success, word fits on line. 	TokenNameCOMMENT_LINE	Success, word fits on line. 
lineHeight	TokenNameIdentifier	 line Height
=	TokenNameEQUAL	
nlh	TokenNameIdentifier	 nlh
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
ascent	TokenNameIdentifier	 ascent
)	TokenNameRPAREN	
ascent	TokenNameIdentifier	 ascent
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getAscent	TokenNameIdentifier	 get Ascent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
descent	TokenNameIdentifier	 descent
)	TokenNameRPAREN	
descent	TokenNameIdentifier	 descent
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getDescent	TokenNameIdentifier	 get Descent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hLeading	TokenNameIdentifier	 h Leading
=	TokenNameEQUAL	
(	TokenNameLPAREN	
nlh	TokenNameIdentifier	 nlh
-	TokenNameMINUS	
(	TokenNameLPAREN	
ascent	TokenNameIdentifier	 ascent
+	TokenNamePLUS	
descent	TokenNameIdentifier	 descent
)	TokenNameRPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
baseline	TokenNameIdentifier	 baseline
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getCurrentY	TokenNameIdentifier	 get Current Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
hLeading	TokenNameIdentifier	 h Leading
+	TokenNamePLUS	
ascent	TokenNameIdentifier	 ascent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
insertWord	TokenNameIdentifier	 insert Word
(	TokenNameLPAREN	
WordInfo	TokenNameIdentifier	 Word Info
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Merge wi's glyph groups into the current GGI's. 	TokenNameCOMMENT_LINE	Merge wi's glyph groups into the current GGI's. 
// This puts them into newGGIS, so if it fails we can 	TokenNameCOMMENT_LINE	This puts them into newGGIS, so if it fails we can 
// retain to the old ggis array. 	TokenNameCOMMENT_LINE	retain to the old ggis array. 
mergeGlyphGroups	TokenNameIdentifier	 merge Glyph Groups
(	TokenNameLPAREN	
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
assignGlyphGroupRanges	TokenNameIdentifier	 assign Glyph Group Ranges
(	TokenNameLPAREN	
newSize	TokenNameIdentifier	 new Size
,	TokenNameCOMMA	
newGGIS	TokenNameIdentifier	 new GGIS
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Swap in to GG info. 	TokenNameCOMMENT_LINE	Swap in to GG info. 
swapGlyphGroupInfo	TokenNameIdentifier	 swap Glyph Group Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
float	TokenNamefloat	
MAX_COMPRESS	TokenNameIdentifier	 MAX  COMPRESS
=	TokenNameEQUAL	
0.1f	TokenNameFloatingPointLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
float	TokenNamefloat	
COMRESS_SCALE	TokenNameIdentifier	 COMRESS  SCALE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
boolean	TokenNameboolean	
assignGlyphGroupRanges	TokenNameIdentifier	 assign Glyph Group Ranges
(	TokenNameLPAREN	
int	TokenNameint	
ggSz	TokenNameIdentifier	 gg Sz
,	TokenNameCOMMA	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ggis	TokenNameIdentifier	 ggis
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
<	TokenNameLESS	
numRanges	TokenNameIdentifier	 num Ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
r	TokenNameIdentifier	 r
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
adv	TokenNameIdentifier	 adv
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
rangeAdvance	TokenNameIdentifier	 range Advance
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
ggSz	TokenNameIdentifier	 gg Sz
)	TokenNameRPAREN	
{	TokenNameLBRACE	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
setRange	TokenNameIdentifier	 set Range
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
adv	TokenNameIdentifier	 adv
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getAdvance	TokenNameIdentifier	 get Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
-	TokenNameMINUS	
(	TokenNameLPAREN	
rangeAdvance	TokenNameIdentifier	 range Advance
+	TokenNamePLUS	
adv	TokenNameIdentifier	 adv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
rangeAdvance	TokenNameIdentifier	 range Advance
+=	TokenNamePLUS_EQUAL	
adv	TokenNameIdentifier	 adv
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check last glyphGroup anyways... 	TokenNameCOMMENT_LINE	Check last glyphGroup anyways... 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
ggSz	TokenNameIdentifier	 gg Sz
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
rangeAdvance	TokenNameIdentifier	 range Advance
-=	TokenNameMINUS_EQUAL	
adv	TokenNameIdentifier	 adv
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
ladv	TokenNameIdentifier	 ladv
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getLastAdvance	TokenNameIdentifier	 get Last Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
rangeAdvance	TokenNameIdentifier	 range Advance
+	TokenNamePLUS	
ladv	TokenNameIdentifier	 ladv
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// "i" can't fit in this region see if "i-1" can. 	TokenNameCOMMENT_LINE	"i" can't fit in this region see if "i-1" can. 
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
ladv	TokenNameIdentifier	 ladv
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getRange	TokenNameIdentifier	 get Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// Not from this range nothing fits. 	TokenNameCOMMENT_LINE	Not from this range nothing fits. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
rangeAdvance	TokenNameIdentifier	 range Advance
-=	TokenNameMINUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getAdvance	TokenNameIdentifier	 get Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ladv	TokenNameIdentifier	 ladv
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getLastAdvance	TokenNameIdentifier	 get Last Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
rangeAdv	TokenNameIdentifier	 range Adv
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
rangeAdvance	TokenNameIdentifier	 range Advance
+	TokenNamePLUS	
ladv	TokenNameIdentifier	 ladv
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
ggSz	TokenNameIdentifier	 gg Sz
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This method updates the line height and recalculates * the available flow ranges for the line. */	TokenNameCOMMENT_JAVADOC	 This method updates the line height and recalculates the available flow ranges for the line. 
public	TokenNamepublic	
boolean	TokenNameboolean	
setLineHeight	TokenNameIdentifier	 set Line Height
(	TokenNameLPAREN	
double	TokenNamedouble	
lh	TokenNameIdentifier	 lh
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
newLineHeight	TokenNameIdentifier	 new Line Height
(	TokenNameLPAREN	
lh	TokenNameIdentifier	 lh
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
updateRangeInfo	TokenNameIdentifier	 update Range Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lineHeight	TokenNameIdentifier	 line Height
=	TokenNameEQUAL	
lh	TokenNameIdentifier	 lh
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// restore line height. 	TokenNameCOMMENT_LINE	restore line height. 
if	TokenNameif	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
newLineHeight	TokenNameIdentifier	 new Line Height
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getCurrentY	TokenNameIdentifier	 get Current Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getCurrentY	TokenNameIdentifier	 get Current Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
gotoY	TokenNameIdentifier	 goto Y
(	TokenNameLPAREN	
double	TokenNamedouble	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
gotoY	TokenNameIdentifier	 goto Y
(	TokenNameLPAREN	
y	TokenNameIdentifier	 y
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lineHeight	TokenNameIdentifier	 line Height
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
updateRangeInfo	TokenNameIdentifier	 update Range Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
baseline	TokenNameIdentifier	 baseline
=	TokenNameEQUAL	
(	TokenNameLPAREN	
float	TokenNamefloat	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getCurrentY	TokenNameIdentifier	 get Current Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
hLeading	TokenNameIdentifier	 h Leading
+	TokenNamePLUS	
ascent	TokenNameIdentifier	 ascent
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
updateRangeInfo	TokenNameIdentifier	 update Range Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
resetRange	TokenNameIdentifier	 reset Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nr	TokenNameIdentifier	 nr
=	TokenNameEQUAL	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
getNumRangeOnLine	TokenNameIdentifier	 get Num Range On Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nr	TokenNameIdentifier	 nr
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
numRanges	TokenNameIdentifier	 num Ranges
=	TokenNameEQUAL	
nr	TokenNameIdentifier	 nr
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rangeAdv	TokenNameIdentifier	 range Adv
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
numRanges	TokenNameIdentifier	 num Ranges
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
numRanges	TokenNameIdentifier	 num Ranges
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
numRanges	TokenNameIdentifier	 num Ranges
>	TokenNameGREATER	
rangeAdv	TokenNameIdentifier	 range Adv
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
sz	TokenNameIdentifier	 sz
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
rangeAdv	TokenNameIdentifier	 range Adv
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
<	TokenNameLESS	
numRanges	TokenNameIdentifier	 num Ranges
)	TokenNameRPAREN	
sz	TokenNameIdentifier	 sz
=	TokenNameEQUAL	
numRanges	TokenNameIdentifier	 num Ranges
;	TokenNameSEMICOLON	
rangeAdv	TokenNameIdentifier	 range Adv
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
sz	TokenNameIdentifier	 sz
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
double	TokenNamedouble	
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
sz	TokenNameIdentifier	 sz
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
<	TokenNameLESS	
numRanges	TokenNameIdentifier	 num Ranges
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rangeBounds	TokenNameIdentifier	 range Bounds
=	TokenNameEQUAL	
fr	TokenNameIdentifier	 fr
.	TokenNameDOT	
nextRange	TokenNameIdentifier	 next Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.err.println("RG["+r+"]: [" + 	TokenNameCOMMENT_LINE	System.err.println("RG["+r+"]: [" + 
// rangeBounds[0] + "," + rangeBounds[1] +"]"); 	TokenNameCOMMENT_LINE	rangeBounds[0] + "," + rangeBounds[1] +"]"); 
double	TokenNamedouble	
r0	TokenNameIdentifier	 r0
=	TokenNameEQUAL	
rangeBounds	TokenNameIdentifier	 range Bounds
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getLeftMargin	TokenNameIdentifier	 get Left Margin
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
paraStart	TokenNameIdentifier	 para Start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
double	TokenNamedouble	
indent	TokenNameIdentifier	 indent
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getIndent	TokenNameIdentifier	 get Indent
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Limit indent to the amount of margin we have. 	TokenNameCOMMENT_LINE	Limit indent to the amount of margin we have. 
if	TokenNameif	
(	TokenNameLPAREN	
delta	TokenNameIdentifier	 delta
<	TokenNameLESS	
-	TokenNameMINUS	
indent	TokenNameIdentifier	 indent
)	TokenNameRPAREN	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
delta	TokenNameIdentifier	 delta
+=	TokenNamePLUS_EQUAL	
indent	TokenNameIdentifier	 indent
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
r0	TokenNameIdentifier	 r0
+=	TokenNamePLUS_EQUAL	
delta	TokenNameIdentifier	 delta
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
double	TokenNamedouble	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
rangeBounds	TokenNameIdentifier	 range Bounds
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
==	TokenNameEQUAL_EQUAL	
numRanges	TokenNameIdentifier	 num Ranges
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
r1	TokenNameIdentifier	 r1
-=	TokenNameMINUS_EQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getRightMargin	TokenNameIdentifier	 get Right Margin
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r0	TokenNameIdentifier	 r0
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
r	TokenNameIdentifier	 r
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
swapGlyphGroupInfo	TokenNameIdentifier	 swap Glyph Group Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tmp	TokenNameIdentifier	 tmp
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
;	TokenNameSEMICOLON	
ggis	TokenNameIdentifier	 ggis
=	TokenNameEQUAL	
newGGIS	TokenNameIdentifier	 new GGIS
;	TokenNameSEMICOLON	
newGGIS	TokenNameIdentifier	 new GGIS
=	TokenNameEQUAL	
tmp	TokenNameIdentifier	 tmp
;	TokenNameSEMICOLON	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
newSize	TokenNameIdentifier	 new Size
;	TokenNameSEMICOLON	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This function merges the glyph groups from <tt>wi<tt/> * into the glyph groups that are already on this line. * It does no fit checking, just adds them in the * proper place in the <tt>newGGIS</tt> data member. */	TokenNameCOMMENT_JAVADOC	 This function merges the glyph groups from <tt>wi<tt/> into the glyph groups that are already on this line. It does no fit checking, just adds them in the proper place in the <tt>newGGIS</tt> data member. 
protected	TokenNameprotected	
void	TokenNamevoid	
mergeGlyphGroups	TokenNameIdentifier	 merge Glyph Groups
(	TokenNameLPAREN	
WordInfo	TokenNameIdentifier	 Word Info
wi	TokenNameIdentifier	 wi
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numGG	TokenNameIdentifier	 num GG
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getNumGlyphGroups	TokenNameIdentifier	 get Num Glyph Groups
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ggis	TokenNameIdentifier	 ggis
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first glyph group on line just add them. 	TokenNameCOMMENT_LINE	first glyph group on line just add them. 
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
numGG	TokenNameIdentifier	 num GG
;	TokenNameSEMICOLON	
newGGIS	TokenNameIdentifier	 new GGIS
=	TokenNameEQUAL	
new	TokenNamenew	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
numGG	TokenNameIdentifier	 num GG
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGG	TokenNameIdentifier	 num GG
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
newGGIS	TokenNameIdentifier	 new GGIS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getGlyphGroup	TokenNameIdentifier	 get Glyph Group
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// We need to merge the new glyph groups with the 	TokenNameCOMMENT_LINE	We need to merge the new glyph groups with the 
// existing glyph Groups. 	TokenNameCOMMENT_LINE	existing glyph Groups. 
int	TokenNameint	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
nggi	TokenNameIdentifier	 nggi
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getGlyphGroup	TokenNameIdentifier	 get Glyph Group
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nStart	TokenNameIdentifier	 n Start
=	TokenNameEQUAL	
nggi	TokenNameIdentifier	 nggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
oggi	TokenNameIdentifier	 oggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
oStart	TokenNameIdentifier	 o Start
=	TokenNameEQUAL	
oggi	TokenNameIdentifier	 oggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newGGIS	TokenNameIdentifier	 new GGIS
=	TokenNameEQUAL	
assureSize	TokenNameIdentifier	 assure Size
(	TokenNameLPAREN	
newGGIS	TokenNameIdentifier	 new GGIS
,	TokenNameCOMMA	
size	TokenNameIdentifier	 size
+	TokenNamePLUS	
numGG	TokenNameIdentifier	 num GG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nStart	TokenNameIdentifier	 n Start
<	TokenNameLESS	
oStart	TokenNameIdentifier	 o Start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oggi	TokenNameIdentifier	 oggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
oStart	TokenNameIdentifier	 o Start
=	TokenNameEQUAL	
oggi	TokenNameIdentifier	 oggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGG	TokenNameIdentifier	 num GG
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nStart	TokenNameIdentifier	 n Start
<	TokenNameLESS	
oStart	TokenNameIdentifier	 o Start
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newGGIS	TokenNameIdentifier	 new GGIS
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
nggi	TokenNameIdentifier	 nggi
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGG	TokenNameIdentifier	 num GG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nggi	TokenNameIdentifier	 nggi
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getGlyphGroup	TokenNameIdentifier	 get Glyph Group
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nStart	TokenNameIdentifier	 n Start
=	TokenNameEQUAL	
nggi	TokenNameIdentifier	 nggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
newGGIS	TokenNameIdentifier	 new GGIS
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
oggi	TokenNameIdentifier	 oggi
;	TokenNameSEMICOLON	
s	TokenNameIdentifier	 s
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oggi	TokenNameIdentifier	 oggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
oStart	TokenNameIdentifier	 o Start
=	TokenNameEQUAL	
oggi	TokenNameIdentifier	 oggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
<	TokenNameLESS	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newGGIS	TokenNameIdentifier	 new GGIS
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
s	TokenNameIdentifier	 s
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
numGG	TokenNameIdentifier	 num GG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
newGGIS	TokenNameIdentifier	 new GGIS
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
wi	TokenNameIdentifier	 wi
.	TokenNameDOT	
getGlyphGroup	TokenNameIdentifier	 get Glyph Group
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for (int i=0; i<newSize; i++) { 	TokenNameCOMMENT_LINE	for (int i=0; i<newSize; i++) { 
// System.err.println("GGIS["+i+"]: " + newGGIS[i].start + " -> " + 	TokenNameCOMMENT_LINE	System.err.println("GGIS["+i+"]: " + newGGIS[i].start + " -> " + 
// newGGIS[i].end); 	TokenNameCOMMENT_LINE	newGGIS[i].end); 
// } 	TokenNameCOMMENT_LINE	} 
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
layout	TokenNameIdentifier	 layout
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// This is needed because we know that in most cases 	TokenNameCOMMENT_LINE	This is needed because we know that in most cases 
// the addition of the last word failed. In the case of 	TokenNameCOMMENT_LINE	the addition of the last word failed. In the case of 
// BIDI this will mess up region assignments. 	TokenNameCOMMENT_LINE	BIDI this will mess up region assignments. 
// If one wanted to you could check on BIDI, and/or 	TokenNameCOMMENT_LINE	If one wanted to you could check on BIDI, and/or 
// lastPara. 	TokenNameCOMMENT_LINE	lastPara. 
assignGlyphGroupRanges	TokenNameIdentifier	 assign Glyph Group Ranges
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
,	TokenNameCOMMA	
ggis	TokenNameIdentifier	 ggis
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GVTGlyphVector	TokenNameIdentifier	 GVT Glyph Vector
gv	TokenNameIdentifier	 gv
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
.	TokenNameDOT	
getGlyphVector	TokenNameIdentifier	 get Glyph Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
justType	TokenNameIdentifier	 just Type
=	TokenNameEQUAL	
FULL_WORD	TokenNameIdentifier	 FULL  WORD
;	TokenNameSEMICOLON	
double	TokenNamedouble	
ggAdv	TokenNameIdentifier	 gg Adv
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
gAdv	TokenNameIdentifier	 g Adv
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Calculate the number of Glyph Groups and the number 	TokenNameCOMMENT_LINE	Calculate the number of Glyph Groups and the number 
// of glpyhs in each range for use with full justification. 	TokenNameCOMMENT_LINE	of glpyhs in each range for use with full justification. 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rangeGG	TokenNameIdentifier	 range GG
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numRanges	TokenNameIdentifier	 num Ranges
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rangeG	TokenNameIdentifier	 range G
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numRanges	TokenNameIdentifier	 num Ranges
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
rangeLastGGI	TokenNameIdentifier	 range Last GGI
=	TokenNameEQUAL	
new	TokenNamenew	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
numRanges	TokenNameIdentifier	 num Ranges
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getRange	TokenNameIdentifier	 get Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangeGG	TokenNameIdentifier	 range GG
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
rangeG	TokenNameIdentifier	 range G
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
+=	TokenNamePLUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getRange	TokenNameIdentifier	 get Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rangeLastGGI	TokenNameIdentifier	 range Last GGI
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
rangeLastGGI	TokenNameIdentifier	 range Last GGI
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
.	TokenNameDOT	
getHideLast	TokenNameIdentifier	 get Hide Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
rangeGG	TokenNameIdentifier	 range GG
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
rangeLastGGI	TokenNameIdentifier	 range Last GGI
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
;	TokenNameSEMICOLON	
rangeG	TokenNameIdentifier	 range G
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
+=	TokenNamePLUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
pggi	TokenNameIdentifier	 pggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
pr	TokenNameIdentifier	 pr
=	TokenNameEQUAL	
pggi	TokenNameIdentifier	 pggi
.	TokenNameDOT	
getRange	TokenNameIdentifier	 get Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
pr	TokenNameIdentifier	 pr
)	TokenNameRPAREN	
rangeG	TokenNameIdentifier	 range G
[	TokenNameLBRACKET	
pr	TokenNameIdentifier	 pr
]	TokenNameRBRACKET	
+=	TokenNamePLUS_EQUAL	
pggi	TokenNameIdentifier	 pggi
.	TokenNameDOT	
getLastGlyphCount	TokenNameIdentifier	 get Last Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
pggi	TokenNameIdentifier	 pggi
.	TokenNameDOT	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
rangeG	TokenNameIdentifier	 range G
[	TokenNameLBRACKET	
r	TokenNameIdentifier	 r
]	TokenNameRBRACKET	
+=	TokenNamePLUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getLastGlyphCount	TokenNameIdentifier	 get Last Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getGlyphCount	TokenNameIdentifier	 get Glyph Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
currRange	TokenNameIdentifier	 curr Range
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
rAdv	TokenNameIdentifier	 r Adv
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
pggi	TokenNameIdentifier	 pggi
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
;	TokenNameSEMICOLON	
int	TokenNameint	
prevRange	TokenNameIdentifier	 prev Range
=	TokenNameEQUAL	
currRange	TokenNameIdentifier	 curr Range
;	TokenNameSEMICOLON	
ggi	TokenNameIdentifier	 ggi
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
currRange	TokenNameIdentifier	 curr Range
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getRange	TokenNameIdentifier	 get Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currRange	TokenNameIdentifier	 curr Range
!=	TokenNameNOT_EQUAL	
prevRange	TokenNameIdentifier	 prev Range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
locX	TokenNameIdentifier	 loc X
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
currRange	TokenNameIdentifier	 curr Range
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
currRange	TokenNameIdentifier	 curr Range
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
-	TokenNameMINUS	
locX	TokenNameIdentifier	 loc X
;	TokenNameSEMICOLON	
rAdv	TokenNameIdentifier	 r Adv
=	TokenNameEQUAL	
rangeAdv	TokenNameIdentifier	 range Adv
[	TokenNameLBRACKET	
currRange	TokenNameIdentifier	 curr Range
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
textAlign	TokenNameIdentifier	 text Align
=	TokenNameEQUAL	
bi	TokenNameIdentifier	 bi
.	TokenNameDOT	
getTextAlignment	TokenNameIdentifier	 get Text Alignment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
paraEnd	TokenNameIdentifier	 para End
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
textAlign	TokenNameIdentifier	 text Align
==	TokenNameEQUAL_EQUAL	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_FULL	TokenNameIdentifier	 ALIGN  FULL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
textAlign	TokenNameIdentifier	 text Align
=	TokenNameEQUAL	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_START	TokenNameIdentifier	 ALIGN  START
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
textAlign	TokenNameIdentifier	 text Align
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
case	TokenNamecase	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_FULL	TokenNameIdentifier	 ALIGN  FULL
:	TokenNameCOLON	
{	TokenNameLBRACE	
double	TokenNamedouble	
delta	TokenNameIdentifier	 delta
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
-	TokenNameMINUS	
rAdv	TokenNameIdentifier	 r Adv
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
justType	TokenNameIdentifier	 just Type
==	TokenNameEQUAL_EQUAL	
FULL_WORD	TokenNameIdentifier	 FULL  WORD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
numSp	TokenNameIdentifier	 num Sp
=	TokenNameEQUAL	
rangeGG	TokenNameIdentifier	 range GG
[	TokenNameLBRACKET	
currRange	TokenNameIdentifier	 curr Range
]	TokenNameRBRACKET	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numSp	TokenNameIdentifier	 num Sp
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ggAdv	TokenNameIdentifier	 gg Adv
=	TokenNameEQUAL	
delta	TokenNameIdentifier	 delta
/	TokenNameDIVIDE	
numSp	TokenNameIdentifier	 num Sp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
numSp	TokenNameIdentifier	 num Sp
=	TokenNameEQUAL	
rangeG	TokenNameIdentifier	 range G
[	TokenNameLBRACKET	
currRange	TokenNameIdentifier	 curr Range
]	TokenNameRBRACKET	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
numSp	TokenNameIdentifier	 num Sp
>=	TokenNameGREATER_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
gAdv	TokenNameIdentifier	 g Adv
=	TokenNameEQUAL	
delta	TokenNameIdentifier	 delta
/	TokenNameDIVIDE	
numSp	TokenNameIdentifier	 num Sp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_START	TokenNameIdentifier	 ALIGN  START
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_MIDDLE	TokenNameIdentifier	 ALIGN  MIDDLE
:	TokenNameCOLON	
locX	TokenNameIdentifier	 loc X
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
-	TokenNameMINUS	
rAdv	TokenNameIdentifier	 r Adv
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
BlockInfo	TokenNameIdentifier	 Block Info
.	TokenNameDOT	
ALIGN_END	TokenNameIdentifier	 ALIGN  END
:	TokenNameCOLON	
locX	TokenNameIdentifier	 loc X
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
-	TokenNameMINUS	
rAdv	TokenNameIdentifier	 r Adv
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
pggi	TokenNameIdentifier	 pggi
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
pggi	TokenNameIdentifier	 pggi
.	TokenNameDOT	
getHideLast	TokenNameIdentifier	 get Hide Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Hide last glyph from prev glyph group (soft hyphen etc). 	TokenNameCOMMENT_LINE	Hide last glyph from prev glyph group (soft hyphen etc). 
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
pggi	TokenNameIdentifier	 pggi
.	TokenNameDOT	
getEnd	TokenNameIdentifier	 get End
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getStart	TokenNameIdentifier	 get Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getEnd	TokenNameIdentifier	 get End
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hide	TokenNameIdentifier	 hide
=	TokenNameEQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getHide	TokenNameIdentifier	 get Hide
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Point2D	TokenNameIdentifier	 Point2 D
p2d	TokenNameIdentifier	 p2d
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
deltaX	TokenNameIdentifier	 delta X
=	TokenNameEQUAL	
p2d	TokenNameIdentifier	 p2d
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
advAdj	TokenNameIdentifier	 adv Adj
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
start	TokenNameIdentifier	 start
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
<=	TokenNameLESS_EQUAL	
end	TokenNameIdentifier	 end
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Point2D	TokenNameIdentifier	 Point2 D
np2d	TokenNameIdentifier	 np2d
=	TokenNameEQUAL	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
getGlyphPosition	TokenNameIdentifier	 get Glyph Position
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hide	TokenNameIdentifier	 hide
[	TokenNameLBRACKET	
g	TokenNameIdentifier	 g
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
advAdj	TokenNameIdentifier	 adv Adj
+=	TokenNamePLUS_EQUAL	
np2d	TokenNameIdentifier	 np2d
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
p2d	TokenNameIdentifier	 p2d
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphVisible	TokenNameIdentifier	 set Glyph Visible
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
p2d	TokenNameIdentifier	 p2d
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
p2d	TokenNameIdentifier	 p2d
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
deltaX	TokenNameIdentifier	 delta X
-	TokenNameMINUS	
advAdj	TokenNameIdentifier	 adv Adj
+	TokenNamePLUS	
locX	TokenNameIdentifier	 loc X
,	TokenNameCOMMA	
p2d	TokenNameIdentifier	 p2d
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
baseline	TokenNameIdentifier	 baseline
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gv	TokenNameIdentifier	 gv
.	TokenNameDOT	
setGlyphPosition	TokenNameIdentifier	 set Glyph Position
(	TokenNameLPAREN	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
p2d	TokenNameIdentifier	 p2d
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p2d	TokenNameIdentifier	 p2d
=	TokenNameEQUAL	
np2d	TokenNameIdentifier	 np2d
;	TokenNameSEMICOLON	
advAdj	TokenNameIdentifier	 adv Adj
-=	TokenNameMINUS_EQUAL	
gAdv	TokenNameIdentifier	 g Adv
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getHideLast	TokenNameIdentifier	 get Hide Last
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
locX	TokenNameIdentifier	 loc X
+=	TokenNamePLUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getAdvance	TokenNameIdentifier	 get Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
advAdj	TokenNameIdentifier	 adv Adj
;	TokenNameSEMICOLON	
else	TokenNameelse	
locX	TokenNameIdentifier	 loc X
+=	TokenNamePLUS_EQUAL	
ggi	TokenNameIdentifier	 ggi
.	TokenNameDOT	
getAdvance	TokenNameIdentifier	 get Advance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
advAdj	TokenNameIdentifier	 adv Adj
+	TokenNamePLUS	
ggAdv	TokenNameIdentifier	 gg Adv
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
assureSize	TokenNameIdentifier	 assure Size
(	TokenNameLPAREN	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ggis	TokenNameIdentifier	 ggis
,	TokenNameCOMMA	
int	TokenNameint	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ggis	TokenNameIdentifier	 ggis
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
<	TokenNameLESS	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
sz	TokenNameIdentifier	 sz
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
sz	TokenNameIdentifier	 sz
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sz	TokenNameIdentifier	 sz
<=	TokenNameLESS_EQUAL	
ggis	TokenNameIdentifier	 ggis
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
return	TokenNamereturn	
ggis	TokenNameIdentifier	 ggis
;	TokenNameSEMICOLON	
int	TokenNameint	
nsz	TokenNameIdentifier	 nsz
=	TokenNameEQUAL	
ggis	TokenNameIdentifier	 ggis
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nsz	TokenNameIdentifier	 nsz
<	TokenNameLESS	
sz	TokenNameIdentifier	 sz
)	TokenNameRPAREN	
nsz	TokenNameIdentifier	 nsz
=	TokenNameEQUAL	
sz	TokenNameIdentifier	 sz
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
GlyphGroupInfo	TokenNameIdentifier	 Glyph Group Info
[	TokenNameLBRACKET	
nsz	TokenNameIdentifier	 nsz
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
