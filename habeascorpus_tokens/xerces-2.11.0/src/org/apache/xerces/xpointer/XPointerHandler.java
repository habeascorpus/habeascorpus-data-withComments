/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xpointer	TokenNameIdentifier	 xpointer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xinclude	TokenNameIdentifier	 xinclude
.	TokenNameDOT	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xinclude	TokenNameIdentifier	 xinclude
.	TokenNameDOT	
XIncludeNamespaceSupport	TokenNameIdentifier	 X Include Namespace Support
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLAttributes	TokenNameIdentifier	 XML Attributes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
;	TokenNameSEMICOLON	
/** * <p> * This is a pipeline component which extends the XIncludeHandler to perform * XPointer specific processing specified in the W3C XPointerFramework and * element() Scheme Recommendations. * </p> * * <p> * This component analyzes each event in the pipeline, looking for an element * that matches a PointerPart in the parent XInclude element's xpointer attribute * value. If the match succeeds, all children are passed by this component. * </p> * * <p> * See the <a href="http://www.w3.org/TR/xptr-framework//">XPointer Framework Recommendation</a> for * more information on the XPointer Framework and ShortHand Pointers. * See the <a href="http://www.w3.org/TR/xptr-element/">XPointer element() Scheme Recommendation</a> for * more information on the XPointer element() Scheme. * </p> * * @xerces.internal * * @version $Id: XPointerHandler.java 603808 2007-12-13 03:44:48Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 <p> This is a pipeline component which extends the XIncludeHandler to perform XPointer specific processing specified in the W3C XPointerFramework and element() Scheme Recommendations. </p> * <p> This component analyzes each event in the pipeline, looking for an element that matches a PointerPart in the parent XInclude element's xpointer attribute value. If the match succeeds, all children are passed by this component. </p> * <p> See the <a href="http://www.w3.org/TR/xptr-framework//">XPointer Framework Recommendation</a> for more information on the XPointer Framework and ShortHand Pointers. See the <a href="http://www.w3.org/TR/xptr-element/">XPointer element() Scheme Recommendation</a> for more information on the XPointer element() Scheme. </p> * @xerces.internal * @version $Id: XPointerHandler.java 603808 2007-12-13 03:44:48Z mrglavas $ 
public	TokenNamepublic	
final	TokenNamefinal	
class	TokenNameclass	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
extends	TokenNameextends	
XIncludeHandler	TokenNameIdentifier	 X Include Handler
implements	TokenNameimplements	
XPointerProcessor	TokenNameIdentifier	 X Pointer Processor
{	TokenNameLBRACE	
// Fields 	TokenNameCOMMENT_LINE	Fields 
// An ArrayList of XPointerParts 	TokenNameCOMMENT_LINE	An ArrayList of XPointerParts 
protected	TokenNameprotected	
ArrayList	TokenNameIdentifier	 Array List
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// The current XPointerPart 	TokenNameCOMMENT_LINE	The current XPointerPart 
protected	TokenNameprotected	
XPointerPart	TokenNameIdentifier	 X Pointer Part
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Has the fXPointerPart resolved successfully 	TokenNameCOMMENT_LINE	Has the fXPointerPart resolved successfully 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fFoundMatchingPtrPart	TokenNameIdentifier	 f Found Matching Ptr Part
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The XPointer Error reporter 	TokenNameCOMMENT_LINE	The XPointer Error reporter 
protected	TokenNameprotected	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
;	TokenNameSEMICOLON	
// The XPointer Error Handler 	TokenNameCOMMENT_LINE	The XPointer Error Handler 
protected	TokenNameprotected	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
fErrorHandler	TokenNameIdentifier	 f Error Handler
;	TokenNameSEMICOLON	
// XPointerFramework symbol table 	TokenNameCOMMENT_LINE	XPointerFramework symbol table 
protected	TokenNameprotected	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Supported schemes 	TokenNameCOMMENT_LINE	Supported schemes 
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ELEMENT_SCHEME_NAME	TokenNameIdentifier	 ELEMENT  SCHEME  NAME
=	TokenNameEQUAL	
"element"	TokenNameStringLiteral	element
;	TokenNameSEMICOLON	
// Has the XPointer resolved the subresource 	TokenNameCOMMENT_LINE	Has the XPointer resolved the subresource 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Fixup xml:base and xml:lang attributes 	TokenNameCOMMENT_LINE	Fixup xml:base and xml:lang attributes 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fFixupBase	TokenNameIdentifier	 f Fixup Base
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fFixupLang	TokenNameIdentifier	 f Fixup Lang
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
/** * */	TokenNameCOMMENT_JAVADOC	 
public	TokenNamepublic	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
new	TokenNamenew	
SymbolTable	TokenNameIdentifier	 Symbol Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
XPointerHandler	TokenNameIdentifier	 X Pointer Handler
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
errorHandler	TokenNameIdentifier	 error Handler
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
fErrorHandler	TokenNameIdentifier	 f Error Handler
=	TokenNameEQUAL	
errorHandler	TokenNameIdentifier	 error Handler
;	TokenNameSEMICOLON	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
=	TokenNameEQUAL	
errorReporter	TokenNameIdentifier	 error Reporter
;	TokenNameSEMICOLON	
//fErrorReporter = errorReporter; // The XInclude ErrorReporter 	TokenNameCOMMENT_LINE	fErrorReporter = errorReporter; // The XInclude ErrorReporter 
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
handler	TokenNameIdentifier	 handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
=	TokenNameEQUAL	
handler	TokenNameIdentifier	 handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
// Implementation of the XPointerProcessor interface. 	TokenNameCOMMENT_LINE	Implementation of the XPointerProcessor interface. 
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
/** * Parses the XPointer framework expression and delegates scheme specific parsing. * * @see org.apache.xerces.xpointer.XPointerProcessor#parseXPointer(java.lang.String) */	TokenNameCOMMENT_JAVADOC	 Parses the XPointer framework expression and delegates scheme specific parsing. * @see org.apache.xerces.xpointer.XPointerProcessor#parseXPointer(java.lang.String) 
public	TokenNamepublic	
void	TokenNamevoid	
parseXPointer	TokenNameIdentifier	 parse X Pointer
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
xpointer	TokenNameIdentifier	 xpointer
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// Initialize 	TokenNameCOMMENT_LINE	Initialize 
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// tokens 	TokenNameCOMMENT_LINE	tokens 
final	TokenNamefinal	
Tokens	TokenNameIdentifier	 Tokens
tokens	TokenNameIdentifier	 tokens
=	TokenNameEQUAL	
new	TokenNamenew	
Tokens	TokenNameIdentifier	 Tokens
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// scanner 	TokenNameCOMMENT_LINE	scanner 
Scanner	TokenNameIdentifier	 Scanner
scanner	TokenNameIdentifier	 scanner
=	TokenNameEQUAL	
new	TokenNamenew	
Scanner	TokenNameIdentifier	 Scanner
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
Tokens	TokenNameIdentifier	 Tokens
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
int	TokenNameint	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_OPEN_PAREN	TokenNameIdentifier	 XPTRTOKEN  OPEN  PAREN
||	TokenNameOR_OR	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_CLOSE_PAREN	TokenNameIdentifier	 XPTRTOKEN  CLOSE  PAREN
||	TokenNameOR_OR	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SCHEMENAME	TokenNameIdentifier	 XPTRTOKEN  SCHEMENAME
||	TokenNameOR_OR	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SCHEMEDATA	TokenNameIdentifier	 XPTRTOKEN  SCHEMEDATA
||	TokenNameOR_OR	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidXPointerToken"	TokenNameStringLiteral	InvalidXPointerToken
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// scan the XPointer expression 	TokenNameCOMMENT_LINE	scan the XPointer expression 
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
xpointer	TokenNameIdentifier	 xpointer
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
success	TokenNameIdentifier	 success
=	TokenNameEQUAL	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
scanExpr	TokenNameIdentifier	 scan Expr
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
xpointer	TokenNameIdentifier	 xpointer
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
success	TokenNameIdentifier	 success
)	TokenNameRPAREN	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidXPointerExpression"	TokenNameStringLiteral	InvalidXPointerExpression
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
hasMore	TokenNameIdentifier	 has More
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
:	TokenNameCOLON	
{	TokenNameLBRACE	
// The shortHand name 	TokenNameCOMMENT_LINE	The shortHand name 
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
shortHandPointerName	TokenNameIdentifier	 short Hand Pointer Name
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
shortHandPointerName	TokenNameIdentifier	 short Hand Pointer Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidXPointerExpression"	TokenNameStringLiteral	InvalidXPointerExpression
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XPointerPart	TokenNameIdentifier	 X Pointer Part
shortHandPointer	TokenNameIdentifier	 short Hand Pointer
=	TokenNameEQUAL	
new	TokenNamenew	
ShortHandPointer	TokenNameIdentifier	 Short Hand Pointer
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
shortHandPointer	TokenNameIdentifier	 short Hand Pointer
.	TokenNameDOT	
setSchemeName	TokenNameIdentifier	 set Scheme Name
(	TokenNameLPAREN	
shortHandPointerName	TokenNameIdentifier	 short Hand Pointer Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
shortHandPointer	TokenNameIdentifier	 short Hand Pointer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SCHEMENAME	TokenNameIdentifier	 XPTRTOKEN  SCHEMENAME
:	TokenNameCOLON	
{	TokenNameLBRACE	
// Retreive the local name and prefix to form the scheme name 	TokenNameCOMMENT_LINE	Retreive the local name and prefix to form the scheme name 
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemeName	TokenNameIdentifier	 scheme Name
=	TokenNameEQUAL	
prefix	TokenNameIdentifier	 prefix
+	TokenNamePLUS	
localName	TokenNameIdentifier	 local Name
;	TokenNameSEMICOLON	
// The next character should be an open parenthesis 	TokenNameCOMMENT_LINE	The next character should be an open parenthesis 
int	TokenNameint	
openParenCount	TokenNameIdentifier	 open Paren Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
closeParenCount	TokenNameIdentifier	 close Paren Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
openParen	TokenNameIdentifier	 open Paren
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
openParen	TokenNameIdentifier	 open Paren
!=	TokenNameNOT_EQUAL	
"XPTRTOKEN_OPEN_PAREN"	TokenNameStringLiteral	XPTRTOKEN_OPEN_PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// can not have more than one ShortHand Pointer 	TokenNameCOMMENT_LINE	can not have more than one ShortHand Pointer 
if	TokenNameif	
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
==	TokenNameEQUAL_EQUAL	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"MultipleShortHandPointers"	TokenNameStringLiteral	MultipleShortHandPointers
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidXPointerExpression"	TokenNameStringLiteral	InvalidXPointerExpression
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
openParenCount	TokenNameIdentifier	 open Paren Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// followed by zero or more ( and the schemeData 	TokenNameCOMMENT_LINE	followed by zero or more ( and the schemeData 
String	TokenNameIdentifier	 String
schemeData	TokenNameIdentifier	 scheme Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
hasMore	TokenNameIdentifier	 has More
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemeData	TokenNameIdentifier	 scheme Data
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
schemeData	TokenNameIdentifier	 scheme Data
!=	TokenNameNOT_EQUAL	
"XPTRTOKEN_OPEN_PAREN"	TokenNameStringLiteral	XPTRTOKEN_OPEN_PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
openParenCount	TokenNameIdentifier	 open Paren Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
schemeData	TokenNameIdentifier	 scheme Data
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// followed by the same number of ) 	TokenNameCOMMENT_LINE	followed by the same number of ) 
token	TokenNameIdentifier	 token
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
closeParen	TokenNameIdentifier	 close Paren
=	TokenNameEQUAL	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
closeParen	TokenNameIdentifier	 close Paren
!=	TokenNameNOT_EQUAL	
"XPTRTOKEN_CLOSE_PAREN"	TokenNameStringLiteral	XPTRTOKEN_CLOSE_PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"SchemeDataNotFollowedByCloseParenthesis"	TokenNameStringLiteral	SchemeDataNotFollowedByCloseParenthesis
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
closeParenCount	TokenNameIdentifier	 close Paren Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
hasMore	TokenNameIdentifier	 has More
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
peekToken	TokenNameIdentifier	 peek Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
"XPTRTOKEN_OPEN_PAREN"	TokenNameStringLiteral	XPTRTOKEN_OPEN_PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
closeParenCount	TokenNameIdentifier	 close Paren Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check if the number of open parenthesis are equal to the number of close parenthesis 	TokenNameCOMMENT_LINE	check if the number of open parenthesis are equal to the number of close parenthesis 
if	TokenNameif	
(	TokenNameLPAREN	
openParenCount	TokenNameIdentifier	 open Paren Count
!=	TokenNameNOT_EQUAL	
closeParenCount	TokenNameIdentifier	 close Paren Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"UnbalancedParenthesisInXPointerExpression"	TokenNameStringLiteral	UnbalancedParenthesisInXPointerExpression
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
,	TokenNameCOMMA	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
openParenCount	TokenNameIdentifier	 open Paren Count
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
closeParenCount	TokenNameIdentifier	 close Paren Count
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Perform scheme specific parsing of the pointer part 	TokenNameCOMMENT_LINE	Perform scheme specific parsing of the pointer part 
if	TokenNameif	
(	TokenNameLPAREN	
schemeName	TokenNameIdentifier	 scheme Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ELEMENT_SCHEME_NAME	TokenNameIdentifier	 ELEMENT  SCHEME  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPointerPart	TokenNameIdentifier	 X Pointer Part
elementSchemePointer	TokenNameIdentifier	 element Scheme Pointer
=	TokenNameEQUAL	
new	TokenNamenew	
ElementSchemePointer	TokenNameIdentifier	 Element Scheme Pointer
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
,	TokenNameCOMMA	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementSchemePointer	TokenNameIdentifier	 element Scheme Pointer
.	TokenNameDOT	
setSchemeName	TokenNameIdentifier	 set Scheme Name
(	TokenNameLPAREN	
schemeName	TokenNameIdentifier	 scheme Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
elementSchemePointer	TokenNameIdentifier	 element Scheme Pointer
.	TokenNameDOT	
setSchemeData	TokenNameIdentifier	 set Scheme Data
(	TokenNameLPAREN	
schemeData	TokenNameIdentifier	 scheme Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If an exception occurs while parsing the element() scheme expression 	TokenNameCOMMENT_LINE	If an exception occurs while parsing the element() scheme expression 
// ignore it and move on to the next pointer part 	TokenNameCOMMENT_LINE	ignore it and move on to the next pointer part 
try	TokenNametry	
{	TokenNameLBRACE	
elementSchemePointer	TokenNameIdentifier	 element Scheme Pointer
.	TokenNameDOT	
parseXPointer	TokenNameIdentifier	 parse X Pointer
(	TokenNameLPAREN	
schemeData	TokenNameIdentifier	 scheme Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
elementSchemePointer	TokenNameIdentifier	 element Scheme Pointer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XNIException	TokenNameIdentifier	 XNI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Re-throw the XPointer element() scheme syntax error. 	TokenNameCOMMENT_LINE	Re-throw the XPointer element() scheme syntax error. 
throw	TokenNamethrow	
new	TokenNamenew	
XNIException	TokenNameIdentifier	 XNI Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// ???? 	TokenNameCOMMENT_LINE	???? 
reportWarning	TokenNameIdentifier	 report Warning
(	TokenNameLPAREN	
"SchemeUnsupported"	TokenNameStringLiteral	SchemeUnsupported
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
schemeName	TokenNameIdentifier	 scheme Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidXPointerExpression"	TokenNameStringLiteral	InvalidXPointerExpression
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
xpointer	TokenNameIdentifier	 xpointer
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * * @see org.apache.xerces.xpointer.XPointerProcessor#resolveXPointer(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations, int event) */	TokenNameCOMMENT_JAVADOC	 * @see org.apache.xerces.xpointer.XPointerProcessor#resolveXPointer(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations, int event) 
public	TokenNamepublic	
boolean	TokenNameboolean	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
int	TokenNameint	
event	TokenNameIdentifier	 event
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
resolved	TokenNameIdentifier	 resolved
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The result of the first pointer part whose evaluation identifies 	TokenNameCOMMENT_LINE	The result of the first pointer part whose evaluation identifies 
// one or more subresources is reported by the XPointer processor as the 	TokenNameCOMMENT_LINE	one or more subresources is reported by the XPointer processor as the 
// result of the pointer as a whole, and evaluation stops. 	TokenNameCOMMENT_LINE	result of the pointer as a whole, and evaluation stops. 
// In our implementation, typically the first xpointer scheme that 	TokenNameCOMMENT_LINE	In our implementation, typically the first xpointer scheme that 
// matches an element is the document is considered. 	TokenNameCOMMENT_LINE	matches an element is the document is considered. 
// If the pointer part resolved then use it, else search for the fragment 	TokenNameCOMMENT_LINE	If the pointer part resolved then use it, else search for the fragment 
// using next pointer part from lef-right. 	TokenNameCOMMENT_LINE	using next pointer part from lef-right. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fFoundMatchingPtrPart	TokenNameIdentifier	 f Found Matching Ptr Part
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for each element, attempt to resolve it against each pointer part 	TokenNameCOMMENT_LINE	for each element, attempt to resolve it against each pointer part 
// in the XPointer expression until a matching element is found. 	TokenNameCOMMENT_LINE	in the XPointer expression until a matching element is found. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XPointerPart	TokenNameIdentifier	 X Pointer Part
)	TokenNameRPAREN	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
.	TokenNameDOT	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
event	TokenNameIdentifier	 event
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFoundMatchingPtrPart	TokenNameIdentifier	 f Found Matching Ptr Part
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
resolved	TokenNameIdentifier	 resolved
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
.	TokenNameDOT	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
event	TokenNameIdentifier	 event
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resolved	TokenNameIdentifier	 resolved
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
=	TokenNameEQUAL	
resolved	TokenNameIdentifier	 resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
resolved	TokenNameIdentifier	 resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the Node fragment is resolved. * * @see org.apache.xerces.xpointer.XPointerProcessor#isFragmentResolved() */	TokenNameCOMMENT_JAVADOC	 Returns true if the Node fragment is resolved. * @see org.apache.xerces.xpointer.XPointerProcessor#isFragmentResolved() 
public	TokenNamepublic	
boolean	TokenNameboolean	
isFragmentResolved	TokenNameIdentifier	 is Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
resolved	TokenNameIdentifier	 resolved
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
.	TokenNameDOT	
isFragmentResolved	TokenNameIdentifier	 is Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
=	TokenNameEQUAL	
resolved	TokenNameIdentifier	 resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
resolved	TokenNameIdentifier	 resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the XPointer expression resolves to a non-element child * of the current resource fragment. * * @see org.apache.xerces.xpointer.XPointerPart#isChildFragmentResolved() * */	TokenNameCOMMENT_JAVADOC	 Returns true if the XPointer expression resolves to a non-element child of the current resource fragment. * @see org.apache.xerces.xpointer.XPointerPart#isChildFragmentResolved() 
public	TokenNamepublic	
boolean	TokenNameboolean	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
boolean	TokenNameboolean	
resolved	TokenNameIdentifier	 resolved
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
.	TokenNameDOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
resolved	TokenNameIdentifier	 resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the XPointer successfully found a sub-resource . * * @see org.apache.xerces.xpointer.XPointerProcessor#isFragmentResolved() */	TokenNameCOMMENT_JAVADOC	 Returns true if the XPointer successfully found a sub-resource . * @see org.apache.xerces.xpointer.XPointerProcessor#isFragmentResolved() 
public	TokenNamepublic	
boolean	TokenNameboolean	
isXPointerResolved	TokenNameIdentifier	 is X Pointer Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the pointer part used to resolve the document fragment. * * @return String - The pointer part used to resolve the document fragment. */	TokenNameCOMMENT_JAVADOC	 Returns the pointer part used to resolve the document fragment. * @return String - The pointer part used to resolve the document fragment. 
public	TokenNamepublic	
XPointerPart	TokenNameIdentifier	 X Pointer Part
getXPointerPart	TokenNameIdentifier	 get X Pointer Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Reports XPointer Errors * */	TokenNameCOMMENT_JAVADOC	 Reports XPointer Errors 
private	TokenNameprivate	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arguments	TokenNameIdentifier	 arguments
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
/* fXPointerErrorReporter.reportError( XPointerMessageFormatter.XPOINTER_DOMAIN, key, arguments, XMLErrorReporter.SEVERITY_ERROR); */	TokenNameCOMMENT_BLOCK	 fXPointerErrorReporter.reportError( XPointerMessageFormatter.XPOINTER_DOMAIN, key, arguments, XMLErrorReporter.SEVERITY_ERROR); 
throw	TokenNamethrow	
new	TokenNamenew	
XNIException	TokenNameIdentifier	 XNI Exception
(	TokenNameLPAREN	
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getMessageFormatter	TokenNameIdentifier	 get Message Formatter
(	TokenNameLPAREN	
XPointerMessageFormatter	TokenNameIdentifier	 X Pointer Message Formatter
.	TokenNameDOT	
XPOINTER_DOMAIN	TokenNameIdentifier	 XPOINTER  DOMAIN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
arguments	TokenNameIdentifier	 arguments
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Reports XPointer Warnings * */	TokenNameCOMMENT_JAVADOC	 Reports XPointer Warnings 
private	TokenNameprivate	
void	TokenNamevoid	
reportWarning	TokenNameIdentifier	 report Warning
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arguments	TokenNameIdentifier	 arguments
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XPointerMessageFormatter	TokenNameIdentifier	 X Pointer Message Formatter
.	TokenNameDOT	
XPOINTER_DOMAIN	TokenNameIdentifier	 XPOINTER  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Initializes error handling objects * */	TokenNameCOMMENT_JAVADOC	 Initializes error handling objects 
protected	TokenNameprotected	
void	TokenNamevoid	
initErrorReporter	TokenNameIdentifier	 init Error Reporter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
=	TokenNameEQUAL	
new	TokenNamenew	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fErrorHandler	TokenNameIdentifier	 f Error Handler
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorHandler	TokenNameIdentifier	 f Error Handler
=	TokenNameEQUAL	
new	TokenNamenew	
XPointerErrorHandler	TokenNameIdentifier	 X Pointer Error Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* fXPointerErrorReporter.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY, fErrorHandler); */	TokenNameCOMMENT_BLOCK	 fXPointerErrorReporter.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY, fErrorHandler); 
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
.	TokenNameDOT	
putMessageFormatter	TokenNameIdentifier	 put Message Formatter
(	TokenNameLPAREN	
XPointerMessageFormatter	TokenNameIdentifier	 X Pointer Message Formatter
.	TokenNameDOT	
XPOINTER_DOMAIN	TokenNameIdentifier	 XPOINTER  DOMAIN
,	TokenNameCOMMA	
new	TokenNamenew	
XPointerMessageFormatter	TokenNameIdentifier	 X Pointer Message Formatter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Initializes the XPointer Processor; */	TokenNameCOMMENT_JAVADOC	 Initializes the XPointer Processor; 
protected	TokenNameprotected	
void	TokenNamevoid	
init	TokenNameIdentifier	 init
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXPointerPart	TokenNameIdentifier	 f X Pointer Part
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fFoundMatchingPtrPart	TokenNameIdentifier	 f Found Matching Ptr Part
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fIsXPointerResolved	TokenNameIdentifier	 f Is X Pointer Resolved
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
//fFixupBase = false; 	TokenNameCOMMENT_LINE	fFixupBase = false; 
//fFixupLang = false; 	TokenNameCOMMENT_LINE	fFixupLang = false; 
initErrorReporter	TokenNameIdentifier	 init Error Reporter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns an ArrayList of XPointerPart objects * * @return An ArrayList of XPointerPart objects. */	TokenNameCOMMENT_JAVADOC	 Returns an ArrayList of XPointerPart objects * @return An ArrayList of XPointerPart objects. 
public	TokenNamepublic	
ArrayList	TokenNameIdentifier	 Array List
getPointerParts	TokenNameIdentifier	 get Pointer Parts
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fXPointerParts	TokenNameIdentifier	 f X Pointer Parts
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * List of XPointer Framework tokens. * * @xerces.internal * */	TokenNameCOMMENT_JAVADOC	 List of XPointer Framework tokens. * @xerces.internal 
private	TokenNameprivate	
final	TokenNamefinal	
class	TokenNameclass	
Tokens	TokenNameIdentifier	 Tokens
{	TokenNameLBRACE	
/** * XPointer Framework tokens * [1] Pointer ::= Shorthand | SchemeBased * [2] Shorthand ::= NCName * [3] SchemeBased ::= PointerPart (S? PointerPart)* * [4] PointerPart ::= SchemeName '(' SchemeData ')' * [5] SchemeName ::= QName * [6] SchemeData ::= EscapedData* * [7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' * [8] NormalChar ::= UnicodeChar - [()^] * [9] UnicodeChar ::= [#x0-#x10FFFF] * */	TokenNameCOMMENT_JAVADOC	 XPointer Framework tokens [1] Pointer ::= Shorthand | SchemeBased [2] Shorthand ::= NCName [3] SchemeBased ::= PointerPart (S? PointerPart)* [4] PointerPart ::= SchemeName '(' SchemeData ')' [5] SchemeName ::= QName [6] SchemeData ::= EscapedData* [7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' [8] NormalChar ::= UnicodeChar - [()^] [9] UnicodeChar ::= [#x0-#x10FFFF] 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
XPTRTOKEN_OPEN_PAREN	TokenNameIdentifier	 XPTRTOKEN  OPEN  PAREN
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
XPTRTOKEN_CLOSE_PAREN	TokenNameIdentifier	 XPTRTOKEN  CLOSE  PAREN
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
XPTRTOKEN_SCHEMENAME	TokenNameIdentifier	 XPTRTOKEN  SCHEMENAME
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
XPTRTOKEN_SCHEMEDATA	TokenNameIdentifier	 XPTRTOKEN  SCHEMEDATA
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Token names 	TokenNameCOMMENT_LINE	Token names 
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fgTokenNames	TokenNameIdentifier	 fg Token Names
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"XPTRTOKEN_OPEN_PAREN"	TokenNameStringLiteral	XPTRTOKEN_OPEN_PAREN
,	TokenNameCOMMA	
"XPTRTOKEN_CLOSE_PAREN"	TokenNameStringLiteral	XPTRTOKEN_CLOSE_PAREN
,	TokenNameCOMMA	
"XPTRTOKEN_SHORTHAND"	TokenNameStringLiteral	XPTRTOKEN_SHORTHAND
,	TokenNameCOMMA	
"XPTRTOKEN_SCHEMENAME"	TokenNameStringLiteral	XPTRTOKEN_SCHEMENAME
,	TokenNameCOMMA	
"XPTRTOKEN_SCHEMEDATA"	TokenNameStringLiteral	XPTRTOKEN_SCHEMEDATA
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// Token count 	TokenNameCOMMENT_LINE	Token count 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INITIAL_TOKEN_COUNT	TokenNameIdentifier	 INITIAL  TOKEN  COUNT
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
<<	TokenNameLEFT_SHIFT	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fTokens	TokenNameIdentifier	 f Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_TOKEN_COUNT	TokenNameIdentifier	 INITIAL  TOKEN  COUNT
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fTokenCount	TokenNameIdentifier	 f Token Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Current token position 	TokenNameCOMMENT_LINE	Current token position 
private	TokenNameprivate	
int	TokenNameint	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
private	TokenNameprivate	
HashMap	TokenNameIdentifier	 Hash Map
fTokenNames	TokenNameIdentifier	 f Token Names
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Constructor * * @param symbolTable SymbolTable */	TokenNameCOMMENT_JAVADOC	 Constructor * @param symbolTable SymbolTable 
private	TokenNameprivate	
Tokens	TokenNameIdentifier	 Tokens
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XPTRTOKEN_OPEN_PAREN	TokenNameIdentifier	 XPTRTOKEN  OPEN  PAREN
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"XPTRTOKEN_OPEN_PAREN"	TokenNameStringLiteral	XPTRTOKEN_OPEN_PAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XPTRTOKEN_CLOSE_PAREN	TokenNameIdentifier	 XPTRTOKEN  CLOSE  PAREN
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"XPTRTOKEN_CLOSE_PAREN"	TokenNameStringLiteral	XPTRTOKEN_CLOSE_PAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"XPTRTOKEN_SHORTHAND"	TokenNameStringLiteral	XPTRTOKEN_SHORTHAND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XPTRTOKEN_SCHEMENAME	TokenNameIdentifier	 XPTRTOKEN  SCHEMENAME
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"XPTRTOKEN_SCHEMENAME"	TokenNameStringLiteral	XPTRTOKEN_SCHEMENAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
XPTRTOKEN_SCHEMEDATA	TokenNameIdentifier	 XPTRTOKEN  SCHEMEDATA
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"XPTRTOKEN_SCHEMEDATA"	TokenNameStringLiteral	XPTRTOKEN_SCHEMEDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the token String * @param token The index of the token * @return String The token string */	TokenNameCOMMENT_JAVADOC	 Returns the token String @param token The index of the token @return String The token string 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
int	TokenNameint	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add the specified string as a token * * @param token The token string */	TokenNameCOMMENT_JAVADOC	 Add the specified string as a token * @param token The token string 
private	TokenNameprivate	
void	TokenNamevoid	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tokenStr	TokenNameIdentifier	 token Str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Integer	TokenNameIdentifier	 Integer
tokenInt	TokenNameIdentifier	 token Int
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
tokenStr	TokenNameIdentifier	 token Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenInt	TokenNameIdentifier	 token Int
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
tokenInt	TokenNameIdentifier	 token Int
=	TokenNameEQUAL	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokenNames	TokenNameIdentifier	 f Token Names
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
tokenInt	TokenNameIdentifier	 token Int
,	TokenNameCOMMA	
tokenStr	TokenNameIdentifier	 token Str
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokenInt	TokenNameIdentifier	 token Int
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add the specified int token * * @param token The int specifying the token */	TokenNameCOMMENT_JAVADOC	 Add the specified int token * @param token The int specifying the token 
private	TokenNameprivate	
void	TokenNamevoid	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
int	TokenNameint	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fTokens	TokenNameIdentifier	 f Tokens
[	TokenNameLBRACKET	
fTokenCount	TokenNameIdentifier	 f Token Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ArrayIndexOutOfBoundsException	TokenNameIdentifier	 Array Index Out Of Bounds Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
oldList	TokenNameIdentifier	 old List
=	TokenNameEQUAL	
fTokens	TokenNameIdentifier	 f Tokens
;	TokenNameSEMICOLON	
fTokens	TokenNameIdentifier	 f Tokens
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fTokenCount	TokenNameIdentifier	 f Token Count
<<	TokenNameLEFT_SHIFT	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
oldList	TokenNameIdentifier	 old List
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fTokens	TokenNameIdentifier	 f Tokens
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fTokenCount	TokenNameIdentifier	 f Token Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTokens	TokenNameIdentifier	 f Tokens
[	TokenNameLBRACKET	
fTokenCount	TokenNameIdentifier	 f Token Count
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
token	TokenNameIdentifier	 token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fTokenCount	TokenNameIdentifier	 f Token Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Resets the current position to the head of the token list. */	TokenNameCOMMENT_JAVADOC	 Resets the current position to the head of the token list. 
private	TokenNameprivate	
void	TokenNamevoid	
rewind	TokenNameIdentifier	 rewind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the {@link #getNextToken()} method * returns a valid token. */	TokenNameCOMMENT_JAVADOC	 Returns true if the {@link #getNextToken()} method returns a valid token. 
private	TokenNameprivate	
boolean	TokenNameboolean	
hasMore	TokenNameIdentifier	 has More
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
<	TokenNameLESS	
fTokenCount	TokenNameIdentifier	 f Token Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Obtains the token at the current position, then advance * the current position by one. * * throws If there's no such next token, this method throws * <tt>new XNIException("XPointerProcessingError");</tt>. */	TokenNameCOMMENT_JAVADOC	 Obtains the token at the current position, then advance the current position by one. * throws If there's no such next token, this method throws <tt>new XNIException("XPointerProcessingError");</tt>. 
private	TokenNameprivate	
int	TokenNameint	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
==	TokenNameEQUAL_EQUAL	
fTokenCount	TokenNameIdentifier	 f Token Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"XPointerProcessingError"	TokenNameStringLiteral	XPointerProcessingError
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fTokens	TokenNameIdentifier	 f Tokens
[	TokenNameLBRACKET	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Obtains the token at the current position, without advancing * the current position. * * If there's no such next token, this method throws * <tt>new XNIException("XPointerProcessingError");</tt>. */	TokenNameCOMMENT_JAVADOC	 Obtains the token at the current position, without advancing the current position. * If there's no such next token, this method throws <tt>new XNIException("XPointerProcessingError");</tt>. 
private	TokenNameprivate	
int	TokenNameint	
peekToken	TokenNameIdentifier	 peek Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
==	TokenNameEQUAL_EQUAL	
fTokenCount	TokenNameIdentifier	 f Token Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"XPointerProcessingError"	TokenNameStringLiteral	XPointerProcessingError
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fTokens	TokenNameIdentifier	 f Tokens
[	TokenNameLBRACKET	
fCurrentTokenIndex	TokenNameIdentifier	 f Current Token Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Obtains the token at the current position as a String. * * If there's no current token or if the current token * is not a string token, this method throws * If there's no such next token, this method throws * <tt>new XNIException("XPointerProcessingError");</tt>. */	TokenNameCOMMENT_JAVADOC	 Obtains the token at the current position as a String. * If there's no current token or if the current token is not a string token, this method throws If there's no such next token, this method throws <tt>new XNIException("XPointerProcessingError");</tt>. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
nextTokenAsString	TokenNameIdentifier	 next Token As String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
tokenStrint	TokenNameIdentifier	 token Strint
=	TokenNameEQUAL	
getTokenString	TokenNameIdentifier	 get Token String
(	TokenNameLPAREN	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tokenStrint	TokenNameIdentifier	 token Strint
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"XPointerProcessingError"	TokenNameStringLiteral	XPointerProcessingError
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
tokenStrint	TokenNameIdentifier	 token Strint
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * * The XPointer expression scanner. Scans the XPointer framework expression. * * @xerces.internal * */	TokenNameCOMMENT_JAVADOC	 * The XPointer expression scanner. Scans the XPointer framework expression. * @xerces.internal 
private	TokenNameprivate	
class	TokenNameclass	
Scanner	TokenNameIdentifier	 Scanner
{	TokenNameLBRACE	
/** * 7-bit ASCII subset * * 0 1 2 3 4 5 6 7 8 9 A B C D E F * 0, 0, 0, 0, 0, 0, 0, 0, 0, HT, LF, 0, 0, CR, 0, 0, // 0 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1 * SP, !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, // 2 * 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, :, ;, <, =, >, ?, // 3 * @, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, // 4 * P, Q, R, S, T, U, V, W, X, Y, Z, [, \, ], ^, _, // 5 * `, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, // 6 * p, q, r, s, t, u, v, w, x, y, z, {, |, }, ~, DEL // 7 */	TokenNameCOMMENT_JAVADOC	 7-bit ASCII subset * 0 1 2 3 4 5 6 7 8 9 A B C D E F 0, 0, 0, 0, 0, 0, 0, 0, 0, HT, LF, 0, 0, CR, 0, 0, // 0 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1 SP, !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, // 2 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, :, ;, <, =, >, ?, // 3 @, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, // 4 P, Q, R, S, T, U, V, W, X, Y, Z, [, \, ], ^, _, // 5 `, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, // 6 p, q, r, s, t, u, v, w, x, y, z, {, |, }, ~, DEL // 7 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
byte	TokenNamebyte	
CHARTYPE_INVALID	TokenNameIdentifier	 CHARTYPE  INVALID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// invalid XML character 	TokenNameCOMMENT_LINE	invalid XML character 
CHARTYPE_OTHER	TokenNameIdentifier	 CHARTYPE  OTHER
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// not special - one of "#%&;?\`{}~" or DEL 	TokenNameCOMMENT_LINE	not special - one of "#%&;?\`{}~" or DEL 
CHARTYPE_WHITESPACE	TokenNameIdentifier	 CHARTYPE  WHITESPACE
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// one of "\t\n\r " (0x09, 0x0A, 0x0D, 0x20) 	TokenNameCOMMENT_LINE	one of "\t\n\r " (0x09, 0x0A, 0x0D, 0x20) 
CHARTYPE_CARRET	TokenNameIdentifier	 CHARTYPE  CARRET
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// ^ 	TokenNameCOMMENT_LINE	^ 
CHARTYPE_OPEN_PAREN	TokenNameIdentifier	 CHARTYPE  OPEN  PAREN
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '(' (0x28) 	TokenNameCOMMENT_LINE	'(' (0x28) 
CHARTYPE_CLOSE_PAREN	TokenNameIdentifier	 CHARTYPE  CLOSE  PAREN
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// ')' (0x29) 	TokenNameCOMMENT_LINE	')' (0x29) 
CHARTYPE_MINUS	TokenNameIdentifier	 CHARTYPE  MINUS
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '-' (0x2D) 	TokenNameCOMMENT_LINE	'-' (0x2D) 
CHARTYPE_PERIOD	TokenNameIdentifier	 CHARTYPE  PERIOD
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '.' (0x2E) 	TokenNameCOMMENT_LINE	'.' (0x2E) 
CHARTYPE_SLASH	TokenNameIdentifier	 CHARTYPE  SLASH
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '/' (0x2F) 	TokenNameCOMMENT_LINE	'/' (0x2F) 
CHARTYPE_DIGIT	TokenNameIdentifier	 CHARTYPE  DIGIT
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '0'-'9' (0x30 to 0x39) 	TokenNameCOMMENT_LINE	'0'-'9' (0x30 to 0x39) 
CHARTYPE_COLON	TokenNameIdentifier	 CHARTYPE  COLON
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// ':' (0x3A) 	TokenNameCOMMENT_LINE	':' (0x3A) 
CHARTYPE_EQUAL	TokenNameIdentifier	 CHARTYPE  EQUAL
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '=' (0x3D) 	TokenNameCOMMENT_LINE	'=' (0x3D) 
CHARTYPE_LETTER	TokenNameIdentifier	 CHARTYPE  LETTER
=	TokenNameEQUAL	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// 'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A) 	TokenNameCOMMENT_LINE	'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A) 
CHARTYPE_UNDERSCORE	TokenNameIdentifier	 CHARTYPE  UNDERSCORE
=	TokenNameEQUAL	
13	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
// '_' (0x5F) 	TokenNameCOMMENT_LINE	'_' (0x5F) 
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
=	TokenNameEQUAL	
14	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Non-ASCII Unicode codepoint (>= 0x80) 	TokenNameCOMMENT_LINE	Non-ASCII Unicode codepoint (>= 0x80) 
private	TokenNameprivate	
final	TokenNamefinal	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
13	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Symbol table. */	TokenNameCOMMENT_JAVADOC	 Symbol table. 
private	TokenNameprivate	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
/** * Constructs an XPointer Framework expression scanner. * * @param symbolTable SymbolTable */	TokenNameCOMMENT_JAVADOC	 Constructs an XPointer Framework expression scanner. * @param symbolTable SymbolTable 
private	TokenNameprivate	
Scanner	TokenNameIdentifier	 Scanner
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// save pool and tokens 	TokenNameCOMMENT_LINE	save pool and tokens 
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>(SymbolTable) 	TokenNameCOMMENT_LINE	<init>(SymbolTable) 
/** * Scans the XPointer Expression * */	TokenNameCOMMENT_JAVADOC	 Scans the XPointer Expression 
private	TokenNameprivate	
boolean	TokenNameboolean	
scanExpr	TokenNameIdentifier	 scan Expr
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
int	TokenNameint	
currentOffset	TokenNameIdentifier	 current Offset
,	TokenNameCOMMA	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
int	TokenNameint	
openParen	TokenNameIdentifier	 open Paren
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
closeParen	TokenNameIdentifier	 close Paren
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
nameOffset	TokenNameIdentifier	 name Offset
,	TokenNameCOMMA	
dataOffset	TokenNameIdentifier	 data Offset
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isQName	TokenNameIdentifier	 is Q Name
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
schemeData	TokenNameIdentifier	 scheme Data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
schemeDataBuff	TokenNameIdentifier	 scheme Data Buff
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
while	TokenNamewhile	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
' '	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0x0A	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0x09	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
0x0D	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// [1] Pointer ::= Shorthand | SchemeBased 	TokenNameCOMMENT_LINE	[1] Pointer ::= Shorthand | SchemeBased 
// [2] Shorthand ::= NCName 	TokenNameCOMMENT_LINE	[2] Shorthand ::= NCName 
// [3] SchemeBased ::= PointerPart (S? PointerPart)* 	TokenNameCOMMENT_LINE	[3] SchemeBased ::= PointerPart (S? PointerPart)* 
// [4] PointerPart ::= SchemeName '(' SchemeData ')' 	TokenNameCOMMENT_LINE	[4] PointerPart ::= SchemeName '(' SchemeData ')' 
// [5] SchemeName ::= QName 	TokenNameCOMMENT_LINE	[5] SchemeName ::= QName 
// [6] SchemeData ::= EscapedData* 	TokenNameCOMMENT_LINE	[6] SchemeData ::= EscapedData* 
// [7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' 	TokenNameCOMMENT_LINE	[7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' 
// [8] NormalChar ::= UnicodeChar - [()^] 	TokenNameCOMMENT_LINE	[8] NormalChar ::= UnicodeChar - [()^] 
// [9] UnicodeChar ::= [#x0-#x10FFFF] 	TokenNameCOMMENT_LINE	[9] UnicodeChar ::= [#x0-#x10FFFF] 
// [?] QName ::= (NCName ':')? NCName 	TokenNameCOMMENT_LINE	[?] QName ::= (NCName ':')? NCName 
// [?] NCName ::= (Letter | '_') (NCNameChar)* 	TokenNameCOMMENT_LINE	[?] NCName ::= (Letter | '_') (NCNameChar)* 
// [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_' (ascii subset of 'NCNameChar') 	TokenNameCOMMENT_LINE	[?] NCNameChar ::= Letter | Digit | '.' | '-' | '_' (ascii subset of 'NCNameChar') 
// [?] Letter ::= [A-Za-z] (ascii subset of 'Letter') 	TokenNameCOMMENT_LINE	[?] Letter ::= [A-Za-z] (ascii subset of 'Letter') 
// [?] Digit ::= [0-9] (ascii subset of 'Digit') 	TokenNameCOMMENT_LINE	[?] Digit ::= [0-9] (ascii subset of 'Digit') 
// 	TokenNameCOMMENT_LINE	 
byte	TokenNamebyte	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
:	TokenNameCOLON	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
CHARTYPE_OPEN_PAREN	TokenNameIdentifier	 CHARTYPE  OPEN  PAREN
:	TokenNameCOLON	
// '(' 	TokenNameCOMMENT_LINE	'(' 
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_OPEN_PAREN	TokenNameIdentifier	 XPTRTOKEN  OPEN  PAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
openParen	TokenNameIdentifier	 open Paren
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CHARTYPE_CLOSE_PAREN	TokenNameIdentifier	 CHARTYPE  CLOSE  PAREN
:	TokenNameCOLON	
// ')' 	TokenNameCOMMENT_LINE	')' 
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_CLOSE_PAREN	TokenNameIdentifier	 XPTRTOKEN  CLOSE  PAREN
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
closeParen	TokenNameIdentifier	 close Paren
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CHARTYPE_CARRET	TokenNameIdentifier	 CHARTYPE  CARRET
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_COLON	TokenNameIdentifier	 CHARTYPE  COLON
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_DIGIT	TokenNameIdentifier	 CHARTYPE  DIGIT
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_EQUAL	TokenNameIdentifier	 CHARTYPE  EQUAL
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_LETTER	TokenNameIdentifier	 CHARTYPE  LETTER
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_MINUS	TokenNameIdentifier	 CHARTYPE  MINUS
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_OTHER	TokenNameIdentifier	 CHARTYPE  OTHER
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_PERIOD	TokenNameIdentifier	 CHARTYPE  PERIOD
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_SLASH	TokenNameIdentifier	 CHARTYPE  SLASH
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_UNDERSCORE	TokenNameIdentifier	 CHARTYPE  UNDERSCORE
:	TokenNameCOLON	
case	TokenNamecase	
CHARTYPE_WHITESPACE	TokenNameIdentifier	 CHARTYPE  WHITESPACE
:	TokenNameCOLON	
// Scanning SchemeName | Shorthand 	TokenNameCOMMENT_LINE	Scanning SchemeName | Shorthand 
if	TokenNameif	
(	TokenNameLPAREN	
openParen	TokenNameIdentifier	 open Paren
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nameOffset	TokenNameIdentifier	 name Offset
=	TokenNameEQUAL	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
currentOffset	TokenNameIdentifier	 current Offset
=	TokenNameEQUAL	
scanNCName	TokenNameIdentifier	 scan NC Name
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
nameOffset	TokenNameIdentifier	 name Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidShortHandPointer"	TokenNameStringLiteral	InvalidShortHandPointer
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
<	TokenNameLESS	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
nameOffset	TokenNameIdentifier	 name Offset
,	TokenNameCOMMA	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
;	TokenNameSEMICOLON	
// The name is a QName => a SchemeName 	TokenNameCOMMENT_LINE	The name is a QName => a SchemeName 
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
':'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
prefix	TokenNameIdentifier	 prefix
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
nameOffset	TokenNameIdentifier	 name Offset
=	TokenNameEQUAL	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
currentOffset	TokenNameIdentifier	 current Offset
=	TokenNameEQUAL	
scanNCName	TokenNameIdentifier	 scan NC Name
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
nameOffset	TokenNameIdentifier	 name Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
<	TokenNameLESS	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
isQName	TokenNameIdentifier	 is Q Name
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
nameOffset	TokenNameIdentifier	 name Offset
,	TokenNameCOMMA	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT: 	TokenNameCOMMENT_LINE	REVISIT: 
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
!=	TokenNameNOT_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SCHEMENAME	TokenNameIdentifier	 XPTRTOKEN  SCHEMENAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isQName	TokenNameIdentifier	 is Q Name
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// NCName => Shorthand 	TokenNameCOMMENT_LINE	NCName => Shorthand 
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SHORTHAND	TokenNameIdentifier	 XPTRTOKEN  SHORTHAND
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isQName	TokenNameIdentifier	 is Q Name
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset open/close paren for the next pointer part 	TokenNameCOMMENT_LINE	reset open/close paren for the next pointer part 
closeParen	TokenNameIdentifier	 close Paren
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
openParen	TokenNameIdentifier	 open Paren
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
closeParen	TokenNameIdentifier	 close Paren
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Scanning SchemeData 	TokenNameCOMMENT_LINE	Scanning SchemeData 
dataOffset	TokenNameIdentifier	 data Offset
=	TokenNameEQUAL	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
currentOffset	TokenNameIdentifier	 current Offset
=	TokenNameEQUAL	
scanData	TokenNameIdentifier	 scan Data
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
schemeDataBuff	TokenNameIdentifier	 scheme Data Buff
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
dataOffset	TokenNameIdentifier	 data Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
"InvalidSchemeDataInXPointer"	TokenNameStringLiteral	InvalidSchemeDataInXPointer
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
data	TokenNameIdentifier	 data
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
<	TokenNameLESS	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
schemeData	TokenNameIdentifier	 scheme Data
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
.	TokenNameDOT	
addSymbol	TokenNameIdentifier	 add Symbol
(	TokenNameLPAREN	
schemeDataBuff	TokenNameIdentifier	 scheme Data Buff
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
Tokens	TokenNameIdentifier	 Tokens
.	TokenNameDOT	
XPTRTOKEN_SCHEMEDATA	TokenNameIdentifier	 XPTRTOKEN  SCHEMEDATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
schemeData	TokenNameIdentifier	 scheme Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// reset open/close paren for the next pointer part 	TokenNameCOMMENT_LINE	reset open/close paren for the next pointer part 
openParen	TokenNameIdentifier	 open Paren
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
schemeDataBuff	TokenNameIdentifier	 scheme Data Buff
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
schemeDataBuff	TokenNameIdentifier	 scheme Data Buff
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// ex. schemeName() 	TokenNameCOMMENT_LINE	ex. schemeName() 
// Should we throw an exception with a more suitable message instead?? 	TokenNameCOMMENT_LINE	Should we throw an exception with a more suitable message instead?? 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end while 	TokenNameCOMMENT_LINE	end while 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Scans a NCName. * From Namespaces in XML * [5] NCName ::= (Letter | '_') (NCNameChar)* * [6] NCNameChar ::= Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender * * @param data A String containing the XPointer expression * @param endOffset The int XPointer expression length * @param currentOffset An int representing the current position of the XPointer expression pointer */	TokenNameCOMMENT_JAVADOC	 Scans a NCName. From Namespaces in XML [5] NCName ::= (Letter | '_') (NCNameChar)* [6] NCNameChar ::= Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender * @param data A String containing the XPointer expression @param endOffset The int XPointer expression length @param currentOffset An int representing the current position of the XPointer expression pointer 
private	TokenNameprivate	
int	TokenNameint	
scanNCName	TokenNameIdentifier	 scan NC Name
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
int	TokenNameint	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isNameStart	TokenNameIdentifier	 is Name Start
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
byte	TokenNamebyte	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_LETTER	TokenNameIdentifier	 CHARTYPE  LETTER
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_UNDERSCORE	TokenNameIdentifier	 CHARTYPE  UNDERSCORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//while (currentOffset++ < endOffset) { 	TokenNameCOMMENT_LINE	while (currentOffset++ < endOffset) { 
while	TokenNamewhile	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
<	TokenNameLESS	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isName	TokenNameIdentifier	 is Name
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
byte	TokenNamebyte	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_LETTER	TokenNameIdentifier	 CHARTYPE  LETTER
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_DIGIT	TokenNameIdentifier	 CHARTYPE  DIGIT
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_PERIOD	TokenNameIdentifier	 CHARTYPE  PERIOD
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_MINUS	TokenNameIdentifier	 CHARTYPE  MINUS
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_UNDERSCORE	TokenNameIdentifier	 CHARTYPE  UNDERSCORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Scans the SchemeData. * [6] SchemeData ::= EscapedData* * [7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' * [8] NormalChar ::= UnicodeChar - [()^] * [9] UnicodeChar ::= [#x0-#x10FFFF] * */	TokenNameCOMMENT_JAVADOC	 Scans the SchemeData. [6] SchemeData ::= EscapedData* [7] EscapedData ::= NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')' [8] NormalChar ::= UnicodeChar - [()^] [9] UnicodeChar ::= [#x0-#x10FFFF] 
private	TokenNameprivate	
int	TokenNameint	
scanData	TokenNameIdentifier	 scan Data
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
StringBuffer	TokenNameIdentifier	 String Buffer
schemeData	TokenNameIdentifier	 scheme Data
,	TokenNameCOMMA	
int	TokenNameint	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
int	TokenNameint	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
byte	TokenNamebyte	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
:	TokenNameCOLON	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
==	TokenNameEQUAL_EQUAL	
CHARTYPE_OPEN_PAREN	TokenNameIdentifier	 CHARTYPE  OPEN  PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
schemeData	TokenNameIdentifier	 scheme Data
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//schemeData.append(Tokens.XPTRTOKEN_OPEN_PAREN); 	TokenNameCOMMENT_LINE	schemeData.append(Tokens.XPTRTOKEN_OPEN_PAREN); 
currentOffset	TokenNameIdentifier	 current Offset
=	TokenNameEQUAL	
scanData	TokenNameIdentifier	 scan Data
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
schemeData	TokenNameIdentifier	 scheme Data
,	TokenNameCOMMA	
endOffset	TokenNameIdentifier	 end Offset
,	TokenNameCOMMA	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
==	TokenNameEQUAL_EQUAL	
endOffset	TokenNameIdentifier	 end Offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
:	TokenNameCOLON	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_CLOSE_PAREN	TokenNameIdentifier	 CHARTYPE  CLOSE  PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
endOffset	TokenNameIdentifier	 end Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
schemeData	TokenNameIdentifier	 scheme Data
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
==	TokenNameEQUAL_EQUAL	
CHARTYPE_CLOSE_PAREN	TokenNameIdentifier	 CHARTYPE  CLOSE  PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
==	TokenNameEQUAL_EQUAL	
CHARTYPE_CARRET	TokenNameIdentifier	 CHARTYPE  CARRET
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
chartype	TokenNameIdentifier	 chartype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
>=	TokenNameGREATER_EQUAL	
0x80	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
CHARTYPE_NONASCII	TokenNameIdentifier	 CHARTYPE  NONASCII
:	TokenNameCOLON	
fASCIICharMap	TokenNameIdentifier	 f ASCII Char Map
[	TokenNameLBRACKET	
ch	TokenNameIdentifier	 ch
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_CARRET	TokenNameIdentifier	 CHARTYPE  CARRET
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_OPEN_PAREN	TokenNameIdentifier	 CHARTYPE  OPEN  PAREN
&&	TokenNameAND_AND	
chartype	TokenNameIdentifier	 chartype
!=	TokenNameNOT_EQUAL	
CHARTYPE_CLOSE_PAREN	TokenNameIdentifier	 CHARTYPE  CLOSE  PAREN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
schemeData	TokenNameIdentifier	 scheme Data
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
schemeData	TokenNameIdentifier	 scheme Data
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
char	TokenNamechar	
)	TokenNameRPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
currentOffset	TokenNameIdentifier	 current Offset
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Protected methods 	TokenNameCOMMENT_LINE	Protected methods 
// 	TokenNameCOMMENT_LINE	 
/** * This method adds the specified token to the token list. By * default, this method allows all tokens. However, subclasses * of the XPathExprScanner can override this method in order * to disallow certain tokens from being used in the scanned * XPath expression. This is a convenient way of allowing only * a subset of XPath. */	TokenNameCOMMENT_JAVADOC	 This method adds the specified token to the token list. By default, this method allows all tokens. However, subclasses of the XPathExprScanner can override this method in order to disallow certain tokens from being used in the scanned XPath expression. This is a convenient way of allowing only a subset of XPath. 
protected	TokenNameprotected	
void	TokenNamevoid	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
Tokens	TokenNameIdentifier	 Tokens
tokens	TokenNameIdentifier	 tokens
,	TokenNameCOMMA	
int	TokenNameint	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
tokens	TokenNameIdentifier	 tokens
.	TokenNameDOT	
addToken	TokenNameIdentifier	 add Token
(	TokenNameLPAREN	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// addToken(int) 	TokenNameCOMMENT_LINE	addToken(int) 
}	TokenNameRBRACE	
// class Scanner 	TokenNameCOMMENT_LINE	class Scanner 
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
// Overridden XMLDocumentHandler methods 	TokenNameCOMMENT_LINE	Overridden XMLDocumentHandler methods 
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
/** * If the comment is a child of a matched element, then pass else return. * * @param text The text in the comment. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by application to signal an error. */	TokenNameCOMMENT_JAVADOC	 If the comment is a child of a matched element, then pass else return. * @param text The text in the comment. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by application to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A processing instruction. Processing instructions consist of a * target name and, optionally, text data. The data is only meaningful * to the application. * <p> * Typically, a processing instruction's data will contain a series * of pseudo-attributes. These pseudo-attributes follow the form of * element attributes but are <strong>not</strong> parsed or presented * to the application as anything other than text. The application is * responsible for parsing the data. * * @param target The target. * @param data The data or null if none specified. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A processing instruction. Processing instructions consist of a target name and, optionally, text data. The data is only meaningful to the application. <p> Typically, a processing instruction's data will contain a series of pseudo-attributes. These pseudo-attributes follow the form of element attributes but are <strong>not</strong> parsed or presented to the application as anything other than text. The application is responsible for parsing the data. * @param target The target. @param data The data or null if none specified. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The start of an element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of an element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
XPointerPart	TokenNameIdentifier	 X Pointer Part
.	TokenNameDOT	
EVENT_ELEMENT_START	TokenNameIdentifier	 EVENT  ELEMENT  START
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// xml:base and xml:lang processing 	TokenNameCOMMENT_LINE	xml:base and xml:lang processing 
if	TokenNameif	
(	TokenNameLPAREN	
fFixupBase	TokenNameIdentifier	 f Fixup Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLBaseAttributes	TokenNameIdentifier	 process XML Base Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFixupLang	TokenNameIdentifier	 f Fixup Lang
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLLangAttributes	TokenNameIdentifier	 process XML Lang Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// set the context invalid if the element till an element from the result infoset is included 	TokenNameCOMMENT_LINE	set the context invalid if the element till an element from the result infoset is included 
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
setContextInvalid	TokenNameIdentifier	 set Context Invalid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * An empty element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An empty element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
XPointerPart	TokenNameIdentifier	 X Pointer Part
.	TokenNameDOT	
EVENT_ELEMENT_EMPTY	TokenNameIdentifier	 EVENT  ELEMENT  EMPTY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// xml:base and xml:lang processing 	TokenNameCOMMENT_LINE	xml:base and xml:lang processing 
if	TokenNameif	
(	TokenNameLPAREN	
fFixupBase	TokenNameIdentifier	 f Fixup Base
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLBaseAttributes	TokenNameIdentifier	 process XML Base Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFixupLang	TokenNameIdentifier	 f Fixup Lang
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processXMLLangAttributes	TokenNameIdentifier	 process XML Lang Attributes
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// no need to restore restoreBaseURI() for xml:base and xml:lang processing 	TokenNameCOMMENT_LINE	no need to restore restoreBaseURI() for xml:base and xml:lang processing 
// set the context invalid if the element till an element from the result infoset is included 	TokenNameCOMMENT_LINE	set the context invalid if the element till an element from the result infoset is included 
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
.	TokenNameDOT	
setContextInvalid	TokenNameIdentifier	 set Context Invalid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Character content. * * @param text The content. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Character content. * @param text The content. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Ignorable whitespace. For this method to be called, the document * source must have some way of determining that the text containing * only whitespace characters should be considered ignorable. For * example, the validator can determine if a length of whitespace * characters in the document are ignorable based on the element * content model. * * @param text The ignorable whitespace. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Ignorable whitespace. For this method to be called, the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable. For example, the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model. * @param text The ignorable whitespace. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The end of an element. * * @param element The name of the element. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of an element. * @param element The name of the element. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
resolveXPointer	TokenNameIdentifier	 resolve X Pointer
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
,	TokenNameCOMMA	
XPointerPart	TokenNameIdentifier	 X Pointer Part
.	TokenNameDOT	
EVENT_ELEMENT_END	TokenNameIdentifier	 EVENT  ELEMENT  END
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no need to restore restoreBaseURI() for xml:base and xml:lang processing 	TokenNameCOMMENT_LINE	no need to restore restoreBaseURI() for xml:base and xml:lang processing 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The start of a CDATA section. * * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of a CDATA section. * @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The end of a CDATA section. * * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a CDATA section. * @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isChildFragmentResolved	TokenNameIdentifier	 is Child Fragment Resolved
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
// Overridden XMLComponent methods 	TokenNameCOMMENT_LINE	Overridden XMLComponent methods 
// ************************************************************************ 	TokenNameCOMMENT_LINE	************************************************************************ 
/** * <p> * Sets the value of a property. This method is called by the component * manager any time after reset when a property changes value. * </p> * <strong>Note:</strong> Components should silently ignore properties * that do not affect the operation of the component. * * @param propertyId The property identifier. * @param value The value of the property. * * @throws XMLConfigurationException Thrown for configuration error. * In general, components should * only throw this exception if * it is <strong>really</strong> * a critical error. */	TokenNameCOMMENT_JAVADOC	 <p> Sets the value of a property. This method is called by the component manager any time after reset when a property changes value. </p> <strong>Note:</strong> Components should silently ignore properties that do not affect the operation of the component. * @param propertyId The property identifier. @param value The value of the property. * @throws XMLConfigurationException Thrown for configuration error. In general, components should only throw this exception if it is <strong>really</strong> a critical error. 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
// Error reporter 	TokenNameCOMMENT_LINE	Error reporter 
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
==	TokenNameEQUAL_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fXPointerErrorReporter	TokenNameIdentifier	 f X Pointer Error Reporter
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Error handler 	TokenNameCOMMENT_LINE	Error handler 
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
==	TokenNameEQUAL_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_HANDLER_PROPERTY	TokenNameIdentifier	 ERROR  HANDLER  PROPERTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorHandler	TokenNameIdentifier	 f Error Handler
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLErrorHandler	TokenNameIdentifier	 XML Error Handler
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fErrorHandler	TokenNameIdentifier	 f Error Handler
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// xml:lang 	TokenNameCOMMENT_LINE	xml:lang 
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
==	TokenNameEQUAL_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XINCLUDE_FIXUP_LANGUAGE_FEATURE	TokenNameIdentifier	 XINCLUDE  FIXUP  LANGUAGE  FEATURE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFixupLang	TokenNameIdentifier	 f Fixup Lang
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fFixupLang	TokenNameIdentifier	 f Fixup Lang
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// xml:base 	TokenNameCOMMENT_LINE	xml:base 
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
==	TokenNameEQUAL_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XINCLUDE_FIXUP_BASE_URIS_FEATURE	TokenNameIdentifier	 XINCLUDE  FIXUP  BASE  URIS  FEATURE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFixupBase	TokenNameIdentifier	 f Fixup Base
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
.	TokenNameDOT	
booleanValue	TokenNameIdentifier	 boolean Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fFixupBase	TokenNameIdentifier	 f Fixup Base
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
==	TokenNameEQUAL_EQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_CONTEXT_PROPERTY	TokenNameIdentifier	 NAMESPACE  CONTEXT  PROPERTY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaceContext	TokenNameIdentifier	 f Namespace Context
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XIncludeNamespaceSupport	TokenNameIdentifier	 X Include Namespace Support
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
