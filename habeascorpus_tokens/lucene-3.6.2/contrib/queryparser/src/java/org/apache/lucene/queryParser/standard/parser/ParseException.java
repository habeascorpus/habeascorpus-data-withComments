/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 
/* JavaCCOptions:KEEP_LINE_COL=null */	TokenNameCOMMENT_BLOCK	 JavaCCOptions:KEEP_LINE_COL=null 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
standard	TokenNameIdentifier	 standard
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
Message	TokenNameIdentifier	 Message
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
MessageImpl	TokenNameIdentifier	 Message Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
.	TokenNameDOT	
core	TokenNameIdentifier	 core
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
/** * This exception is thrown when parse errors are encountered. * You can explicitly create objects of this exception type by * calling the method generateParseException in the generated * parser. * * You can modify this class to customize your error reporting * mechanisms so long as you retain the public fields. */	TokenNameCOMMENT_JAVADOC	 This exception is thrown when parse errors are encountered. You can explicitly create objects of this exception type by calling the method generateParseException in the generated parser. * You can modify this class to customize your error reporting mechanisms so long as you retain the public fields. 
public	TokenNamepublic	
class	TokenNameclass	
ParseException	TokenNameIdentifier	 Parse Exception
extends	TokenNameextends	
QueryNodeParseException	TokenNameIdentifier	 Query Node Parse Exception
{	TokenNameLBRACE	
/** * This constructor is used by the method "generateParseException" * in the generated parser. Calling this constructor generates * a new object of this type with the fields "currentToken", * "expectedTokenSequences", and "tokenImage" set. The boolean * flag "specialConstructor" is also set to true to indicate that * this constructor was used to create this object. * This constructor calls its super class with the empty string * to force the "toString" method of parent class "Throwable" to * print the error message in the form: * ParseException: <result of getMessage> */	TokenNameCOMMENT_JAVADOC	 This constructor is used by the method "generateParseException" in the generated parser. Calling this constructor generates a new object of this type with the fields "currentToken", "expectedTokenSequences", and "tokenImage" set. The boolean flag "specialConstructor" is also set to true to indicate that this constructor was used to create this object. This constructor calls its super class with the empty string to force the "toString" method of parent class "Throwable" to print the error message in the form: ParseException: <result of getMessage> 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
currentTokenVal	TokenNameIdentifier	 current Token Val
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
expectedTokenSequencesVal	TokenNameIdentifier	 expected Token Sequences Val
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tokenImageVal	TokenNameIdentifier	 token Image Val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
new	TokenNamenew	
MessageImpl	TokenNameIdentifier	 Message Impl
(	TokenNameLPAREN	
QueryParserMessages	TokenNameIdentifier	 Query Parser Messages
.	TokenNameDOT	
INVALID_SYNTAX	TokenNameIdentifier	 INVALID  SYNTAX
,	TokenNameCOMMA	
initialise	TokenNameIdentifier	 initialise
(	TokenNameLPAREN	
currentTokenVal	TokenNameIdentifier	 current Token Val
,	TokenNameCOMMA	
expectedTokenSequencesVal	TokenNameIdentifier	 expected Token Sequences Val
,	TokenNameCOMMA	
tokenImageVal	TokenNameIdentifier	 token Image Val
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
currentToken	TokenNameIdentifier	 current Token
=	TokenNameEQUAL	
currentTokenVal	TokenNameIdentifier	 current Token Val
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
=	TokenNameEQUAL	
expectedTokenSequencesVal	TokenNameIdentifier	 expected Token Sequences Val
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
tokenImage	TokenNameIdentifier	 token Image
=	TokenNameEQUAL	
tokenImageVal	TokenNameIdentifier	 token Image Val
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The following constructors are for use by you for whatever * purpose you can think of. Constructing the exception in this * manner makes the exception behave in the normal way - i.e., as * documented in the class "Throwable". The fields "errorToken", * "expectedTokenSequences", and "tokenImage" do not contain * relevant information. The JavaCC generated code does not use * these constructors. */	TokenNameCOMMENT_JAVADOC	 The following constructors are for use by you for whatever purpose you can think of. Constructing the exception in this manner makes the exception behave in the normal way - i.e., as documented in the class "Throwable". The fields "errorToken", "expectedTokenSequences", and "tokenImage" do not contain relevant information. The JavaCC generated code does not use these constructors. 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
new	TokenNamenew	
MessageImpl	TokenNameIdentifier	 Message Impl
(	TokenNameLPAREN	
QueryParserMessages	TokenNameIdentifier	 Query Parser Messages
.	TokenNameDOT	
INVALID_SYNTAX	TokenNameIdentifier	 INVALID  SYNTAX
,	TokenNameCOMMA	
"Error"	TokenNameStringLiteral	Error
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor with message. */	TokenNameCOMMENT_JAVADOC	 Constructor with message. 
public	TokenNamepublic	
ParseException	TokenNameIdentifier	 Parse Exception
(	TokenNameLPAREN	
Message	TokenNameIdentifier	 Message
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This variable determines which constructor was used to create * this object and thereby affects the semantics of the * "getMessage" method (see below). */	TokenNameCOMMENT_JAVADOC	 This variable determines which constructor was used to create this object and thereby affects the semantics of the "getMessage" method (see below). 
protected	TokenNameprotected	
boolean	TokenNameboolean	
specialConstructor	TokenNameIdentifier	 special Constructor
;	TokenNameSEMICOLON	
/** * This is the last token that has been consumed successfully. If * this object has been created due to a parse error, the token * followng this token will (therefore) be the first error token. */	TokenNameCOMMENT_JAVADOC	 This is the last token that has been consumed successfully. If this object has been created due to a parse error, the token followng this token will (therefore) be the first error token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
currentToken	TokenNameIdentifier	 current Token
;	TokenNameSEMICOLON	
/** * Each entry in this array is an array of integers. Each array * of integers represents a sequence of tokens (by their ordinal * values) that is expected at this point of the parse. */	TokenNameCOMMENT_JAVADOC	 Each entry in this array is an array of integers. Each array of integers represents a sequence of tokens (by their ordinal values) that is expected at this point of the parse. 
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
;	TokenNameSEMICOLON	
/** * This is a reference to the "tokenImage" array of the generated * parser within which the parse error occurred. This array is * defined in the generated ...Constants interface. */	TokenNameCOMMENT_JAVADOC	 This is a reference to the "tokenImage" array of the generated parser within which the parse error occurred. This array is defined in the generated ...Constants interface. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tokenImage	TokenNameIdentifier	 token Image
;	TokenNameSEMICOLON	
/** * This method has the standard behavior when this object has been * created using the standard constructors. Otherwise, it uses * "currentToken" and "expectedTokenSequences" to generate a parse * error message and returns it. If this object has been created * due to a parse error, and you do not catch it (it gets thrown * from the parser), then this method is called during the printing * of the final stack trace, and hence the correct error message * gets displayed. */	TokenNameCOMMENT_JAVADOC	 This method has the standard behavior when this object has been created using the standard constructors. Otherwise, it uses "currentToken" and "expectedTokenSequences" to generate a parse error message and returns it. If this object has been created due to a parse error, and you do not catch it (it gets thrown from the parser), then this method is called during the printing of the final stack trace, and hence the correct error message gets displayed. 
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
initialise	TokenNameIdentifier	 initialise
(	TokenNameLPAREN	
Token	TokenNameIdentifier	 Token
currentToken	TokenNameIdentifier	 current Token
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
tokenImage	TokenNameIdentifier	 token Image
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
eol	TokenNameIdentifier	 eol
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
,	TokenNameCOMMA	
"n"	TokenNameStringLiteral	n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StringBuffer	TokenNameIdentifier	 String Buffer
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
maxSize	TokenNameIdentifier	 max Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxSize	TokenNameIdentifier	 max Size
<	TokenNameLESS	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxSize	TokenNameIdentifier	 max Size
=	TokenNameEQUAL	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tokenImage	TokenNameIdentifier	 token Image
[	TokenNameLBRACKET	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
' '	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"..."	TokenNameStringLiteral	...
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
eol	TokenNameIdentifier	 eol
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
retval	TokenNameIdentifier	 retval
=	TokenNameEQUAL	
"Encountered ""	TokenNameStringLiteral	Encountered "
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
currentToken	TokenNameIdentifier	 current Token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
maxSize	TokenNameIdentifier	 max Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
tokenImage	TokenNameIdentifier	 token Image
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
" "	TokenNameStringLiteral	 
+	TokenNamePLUS	
tokenImage	TokenNameIdentifier	 token Image
[	TokenNameLBRACKET	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
" ""	TokenNameStringLiteral	 "
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
add_escapes	TokenNameIdentifier	 add escapes
(	TokenNameLPAREN	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
image	TokenNameIdentifier	 image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
" ""	TokenNameStringLiteral	 "
;	TokenNameSEMICOLON	
tok	TokenNameIdentifier	 tok
=	TokenNameEQUAL	
tok	TokenNameIdentifier	 tok
.	TokenNameDOT	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
"" at line "	TokenNameStringLiteral	" at line 
+	TokenNamePLUS	
currentToken	TokenNameIdentifier	 current Token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
beginLine	TokenNameIdentifier	 begin Line
+	TokenNamePLUS	
", column "	TokenNameStringLiteral	, column 
+	TokenNamePLUS	
currentToken	TokenNameIdentifier	 current Token
.	TokenNameDOT	
next	TokenNameIdentifier	 next
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
"."	TokenNameStringLiteral	.
+	TokenNamePLUS	
eol	TokenNameIdentifier	 eol
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
expectedTokenSequences	TokenNameIdentifier	 expected Token Sequences
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
"Was expecting:"	TokenNameStringLiteral	Was expecting:
+	TokenNamePLUS	
eol	TokenNameIdentifier	 eol
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
"Was expecting one of:"	TokenNameStringLiteral	Was expecting one of:
+	TokenNamePLUS	
eol	TokenNameIdentifier	 eol
+	TokenNamePLUS	
" "	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
retval	TokenNameIdentifier	 retval
+=	TokenNamePLUS_EQUAL	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
retval	TokenNameIdentifier	 retval
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The end of line string for this machine. */	TokenNameCOMMENT_JAVADOC	 The end of line string for this machine. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
eol	TokenNameIdentifier	 eol
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"line.separator"	TokenNameStringLiteral	line.separator
,	TokenNameCOMMA	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Used to convert raw characters to their escaped version * when these raw version cannot be used as part of an ASCII * string literal. */	TokenNameCOMMENT_JAVADOC	 Used to convert raw characters to their escaped version when these raw version cannot be used as part of an ASCII string literal. 
static	TokenNamestatic	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
add_escapes	TokenNameIdentifier	 add escapes
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
retval	TokenNameIdentifier	 retval
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
ch	TokenNameIdentifier	 ch
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\b'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\b"	TokenNameStringLiteral	\b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\t'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\t"	TokenNameStringLiteral	\t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\n'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\n"	TokenNameStringLiteral	\n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\f'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\f"	TokenNameStringLiteral	\f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\r'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\r"	TokenNameStringLiteral	\r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\"'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\""	TokenNameStringLiteral	\"
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\''	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\'"	TokenNameStringLiteral	\'
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'\\'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\\"	TokenNameStringLiteral	\\
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
0x20	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
ch	TokenNameIdentifier	 ch
>	TokenNameGREATER	
0x7e	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
"0000"	TokenNameStringLiteral	0000
+	TokenNamePLUS	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"\u"	TokenNameStringLiteral	\u
+	TokenNamePLUS	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ch	TokenNameIdentifier	 ch
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* JavaCC - OriginalChecksum=38bce846fe6c8482993969f741c0323e (do not edit this line) */	TokenNameCOMMENT_BLOCK	 JavaCC - OriginalChecksum=38bce846fe6c8482993969f741c0323e (do not edit this line) 
