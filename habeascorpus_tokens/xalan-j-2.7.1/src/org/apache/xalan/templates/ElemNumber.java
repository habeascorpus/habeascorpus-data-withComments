/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/* * $Id: ElemNumber.java 468643 2006-10-28 06:56:03Z minchau $ */	TokenNameCOMMENT_BLOCK	 $Id: ElemNumber.java 468643 2006-10-28 06:56:03Z minchau $ 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
templates	TokenNameIdentifier	 templates
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
DecimalFormat	TokenNameIdentifier	 Decimal Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
DecimalFormatSymbols	TokenNameIdentifier	 Decimal Format Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
NumberFormat	TokenNameIdentifier	 Number Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
CountersTable	TokenNameIdentifier	 Counters Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xalan	TokenNameIdentifier	 xalan
.	TokenNameDOT	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
DTM	TokenNameIdentifier	 DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
NodeVector	TokenNameIdentifier	 Node Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
PrefixResolver	TokenNameIdentifier	 Prefix Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
IntArrayWrapper	TokenNameIdentifier	 Int Array Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
LongArrayWrapper	TokenNameIdentifier	 Long Array Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
StringArrayWrapper	TokenNameIdentifier	 String Array Wrapper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
XPath	TokenNameIdentifier	 X Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
XPathContext	TokenNameIdentifier	 X Path Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xpath	TokenNameIdentifier	 xpath
.	TokenNameDOT	
objects	TokenNameIdentifier	 objects
.	TokenNameDOT	
XObject	TokenNameIdentifier	 X Object
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
sax	TokenNameIdentifier	 sax
.	TokenNameDOT	
SAXException	TokenNameIdentifier	 SAX Exception
;	TokenNameSEMICOLON	
// import org.apache.xalan.dtm.*; 	TokenNameCOMMENT_LINE	import org.apache.xalan.dtm.*; 
/** * Implement xsl:number. * <pre> * <!ELEMENT xsl:number EMPTY> * <!ATTLIST xsl:number * level (single|multiple|any) "single" * count %pattern; #IMPLIED * from %pattern; #IMPLIED * value %expr; #IMPLIED * format %avt; '1' * lang %avt; #IMPLIED * letter-value %avt; #IMPLIED * grouping-separator %avt; #IMPLIED * grouping-size %avt; #IMPLIED * > * </pre> * @see <a href="http://www.w3.org/TR/xslt#number">number in XSLT Specification</a> * @xsl.usage advanced */	TokenNameCOMMENT_JAVADOC	 Implement xsl:number. <pre> <!ELEMENT xsl:number EMPTY> <!ATTLIST xsl:number level (single|multiple|any) "single" count %pattern; #IMPLIED from %pattern; #IMPLIED value %expr; #IMPLIED format %avt; '1' lang %avt; #IMPLIED letter-value %avt; #IMPLIED grouping-separator %avt; #IMPLIED grouping-size %avt; #IMPLIED > </pre> @see <a href="http://www.w3.org/TR/xslt#number">number in XSLT Specification</a> @xsl.usage advanced 
public	TokenNamepublic	
class	TokenNameclass	
ElemNumber	TokenNameIdentifier	 Elem Number
extends	TokenNameextends	
ElemTemplateElement	TokenNameIdentifier	 Elem Template Element
{	TokenNameLBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
8118472298274407610L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** * Chars for converting integers into alpha counts. * @see TransformerImpl#int2alphaCount */	TokenNameCOMMENT_JAVADOC	 Chars for converting integers into alpha counts. @see TransformerImpl#int2alphaCount 
private	TokenNameprivate	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
class	TokenNameclass	
MyPrefixResolver	TokenNameIdentifier	 My Prefix Resolver
implements	TokenNameimplements	
PrefixResolver	TokenNameIdentifier	 Prefix Resolver
{	TokenNameLBRACE	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
int	TokenNameint	
handle	TokenNameIdentifier	 handle
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
handleNullPrefix	TokenNameIdentifier	 handle Null Prefix
;	TokenNameSEMICOLON	
/** * Constructor for MyPrefixResolver. * @param xpathExpressionContext */	TokenNameCOMMENT_JAVADOC	 Constructor for MyPrefixResolver. @param xpathExpressionContext 
public	TokenNamepublic	
MyPrefixResolver	TokenNameIdentifier	 My Prefix Resolver
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
xpathExpressionContext	TokenNameIdentifier	 xpath Expression Context
,	TokenNameCOMMA	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
int	TokenNameint	
handle	TokenNameIdentifier	 handle
,	TokenNameCOMMA	
boolean	TokenNameboolean	
handleNullPrefix	TokenNameIdentifier	 handle Null Prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
handle	TokenNameIdentifier	 handle
=	TokenNameEQUAL	
handle	TokenNameIdentifier	 handle
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
handleNullPrefix	TokenNameIdentifier	 handle Null Prefix
=	TokenNameEQUAL	
handleNullPrefix	TokenNameIdentifier	 handle Null Prefix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see PrefixResolver#getNamespaceForPrefix(String, Node) */	TokenNameCOMMENT_JAVADOC	 @see PrefixResolver#getNamespaceForPrefix(String, Node) 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceForPrefix	TokenNameIdentifier	 get Namespace For Prefix
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
handle	TokenNameIdentifier	 handle
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see PrefixResolver#getNamespaceForPrefix(String, Node) * this shouldn't get called. */	TokenNameCOMMENT_JAVADOC	 @see PrefixResolver#getNamespaceForPrefix(String, Node) this shouldn't get called. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNamespaceForPrefix	TokenNameIdentifier	 get Namespace For Prefix
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
prefix	TokenNameIdentifier	 prefix
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNamespaceForPrefix	TokenNameIdentifier	 get Namespace For Prefix
(	TokenNameLPAREN	
prefix	TokenNameIdentifier	 prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see PrefixResolver#getBaseIdentifier() */	TokenNameCOMMENT_JAVADOC	 @see PrefixResolver#getBaseIdentifier() 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getBaseIdentifier	TokenNameIdentifier	 get Base Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
ElemNumber	TokenNameIdentifier	 Elem Number
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
getBaseIdentifier	TokenNameIdentifier	 get Base Identifier
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @see PrefixResolver#handlesNullPrefixes() */	TokenNameCOMMENT_JAVADOC	 @see PrefixResolver#handlesNullPrefixes() 
public	TokenNamepublic	
boolean	TokenNameboolean	
handlesNullPrefixes	TokenNameIdentifier	 handles Null Prefixes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
handleNullPrefix	TokenNameIdentifier	 handle Null Prefix
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Only nodes are counted that match this pattern. * @serial */	TokenNameCOMMENT_JAVADOC	 Only nodes are counted that match this pattern. @serial 
private	TokenNameprivate	
XPath	TokenNameIdentifier	 X Path
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "count" attribute. * The count attribute is a pattern that specifies what nodes * should be counted at those levels. If count attribute is not * specified, then it defaults to the pattern that matches any * node with the same node type as the current node and, if the * current node has an expanded-name, with the same expanded-name * as the current node. * * @param v Value to set for "count" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "count" attribute. The count attribute is a pattern that specifies what nodes should be counted at those levels. If count attribute is not specified, then it defaults to the pattern that matches any node with the same node type as the current node and, if the current node has an expanded-name, with the same expanded-name as the current node. * @param v Value to set for "count" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setCount	TokenNameIdentifier	 set Count
(	TokenNameLPAREN	
XPath	TokenNameIdentifier	 X Path
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "count" attribute. * The count attribute is a pattern that specifies what nodes * should be counted at those levels. If count attribute is not * specified, then it defaults to the pattern that matches any * node with the same node type as the current node and, if the * current node has an expanded-name, with the same expanded-name * as the current node. * * @return Value of "count" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "count" attribute. The count attribute is a pattern that specifies what nodes should be counted at those levels. If count attribute is not specified, then it defaults to the pattern that matches any node with the same node type as the current node and, if the current node has an expanded-name, with the same expanded-name as the current node. * @return Value of "count" attribute. 
public	TokenNamepublic	
XPath	TokenNameIdentifier	 X Path
getCount	TokenNameIdentifier	 get Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Specifies where to count from. * For level="single" or level="multiple": * Only ancestors that are searched are * those that are descendants of the nearest ancestor that matches * the from pattern. * For level="any: * Only nodes after the first node before the * current node that match the from pattern are considered. * @serial */	TokenNameCOMMENT_JAVADOC	 Specifies where to count from. For level="single" or level="multiple": Only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern. For level="any: Only nodes after the first node before the current node that match the from pattern are considered. @serial 
private	TokenNameprivate	
XPath	TokenNameIdentifier	 X Path
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "from" attribute. Specifies where to count from. * For level="single" or level="multiple": * Only ancestors that are searched are * those that are descendants of the nearest ancestor that matches * the from pattern. * For level="any: * Only nodes after the first node before the * current node that match the from pattern are considered. * * @param v Value to set for "from" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "from" attribute. Specifies where to count from. For level="single" or level="multiple": Only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern. For level="any: Only nodes after the first node before the current node that match the from pattern are considered. * @param v Value to set for "from" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setFrom	TokenNameIdentifier	 set From
(	TokenNameLPAREN	
XPath	TokenNameIdentifier	 X Path
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "from" attribute. * For level="single" or level="multiple": * Only ancestors that are searched are * those that are descendants of the nearest ancestor that matches * the from pattern. * For level="any: * Only nodes after the first node before the * current node that match the from pattern are considered. * * @return Value of "from" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "from" attribute. For level="single" or level="multiple": Only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern. For level="any: Only nodes after the first node before the current node that match the from pattern are considered. * @return Value of "from" attribute. 
public	TokenNamepublic	
XPath	TokenNameIdentifier	 X Path
getFrom	TokenNameIdentifier	 get From
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * When level="single", it goes up to the first node in the ancestor-or-self axis * that matches the count pattern, and constructs a list of length one containing * one plus the number of preceding siblings of that ancestor that match the count * pattern. If there is no such ancestor, it constructs an empty list. If the from * attribute is specified, then the only ancestors that are searched are those * that are descendants of the nearest ancestor that matches the from pattern. * Preceding siblings has the same meaning here as with the preceding-sibling axis. * * When level="multiple", it constructs a list of all ancestors of the current node * in document order followed by the element itself; it then selects from the list * those nodes that match the count pattern; it then maps each node in the list to * one plus the number of preceding siblings of that node that match the count pattern. * If the from attribute is specified, then the only ancestors that are searched are * those that are descendants of the nearest ancestor that matches the from pattern. * Preceding siblings has the same meaning here as with the preceding-sibling axis. * * When level="any", it constructs a list of length one containing the number of * nodes that match the count pattern and belong to the set containing the current * node and all nodes at any level of the document that are before the current node * in document order, excluding any namespace and attribute nodes (in other words * the union of the members of the preceding and ancestor-or-self axes). If the * from attribute is specified, then only nodes after the first node before the * current node that match the from pattern are considered. * @serial */	TokenNameCOMMENT_JAVADOC	 When level="single", it goes up to the first node in the ancestor-or-self axis that matches the count pattern, and constructs a list of length one containing one plus the number of preceding siblings of that ancestor that match the count pattern. If there is no such ancestor, it constructs an empty list. If the from attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern. Preceding siblings has the same meaning here as with the preceding-sibling axis. * When level="multiple", it constructs a list of all ancestors of the current node in document order followed by the element itself; it then selects from the list those nodes that match the count pattern; it then maps each node in the list to one plus the number of preceding siblings of that node that match the count pattern. If the from attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern. Preceding siblings has the same meaning here as with the preceding-sibling axis. * When level="any", it constructs a list of length one containing the number of nodes that match the count pattern and belong to the set containing the current node and all nodes at any level of the document that are before the current node in document order, excluding any namespace and attribute nodes (in other words the union of the members of the preceding and ancestor-or-self axes). If the from attribute is specified, then only nodes after the first node before the current node that match the from pattern are considered. @serial 
private	TokenNameprivate	
int	TokenNameint	
m_level	TokenNameIdentifier	 m level
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NUMBERLEVEL_SINGLE	TokenNameIdentifier	 NUMBERLEVEL  SINGLE
;	TokenNameSEMICOLON	
/** * Set the "level" attribute. * The level attribute specifies what levels of the source tree should * be considered; it has the values single, multiple or any. The default * is single. * * @param v Value to set for "level" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "level" attribute. The level attribute specifies what levels of the source tree should be considered; it has the values single, multiple or any. The default is single. * @param v Value to set for "level" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setLevel	TokenNameIdentifier	 set Level
(	TokenNameLPAREN	
int	TokenNameint	
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_level	TokenNameIdentifier	 m level
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "level" attribute. * The level attribute specifies what levels of the source tree should * be considered; it has the values single, multiple or any. The default * is single. * * @return Value of "level" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "level" attribute. The level attribute specifies what levels of the source tree should be considered; it has the values single, multiple or any. The default is single. * @return Value of "level" attribute. 
public	TokenNamepublic	
int	TokenNameint	
getLevel	TokenNameIdentifier	 get Level
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_level	TokenNameIdentifier	 m level
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The value attribute contains an expression. The expression is evaluated * and the resulting object is converted to a number as if by a call to the * number function. * @serial */	TokenNameCOMMENT_JAVADOC	 The value attribute contains an expression. The expression is evaluated and the resulting object is converted to a number as if by a call to the number function. @serial 
private	TokenNameprivate	
XPath	TokenNameIdentifier	 X Path
m_valueExpr	TokenNameIdentifier	 m value Expr
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "value" attribute. * The value attribute contains an expression. The expression is evaluated * and the resulting object is converted to a number as if by a call to the * number function. * * @param v Value to set for "value" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "value" attribute. The value attribute contains an expression. The expression is evaluated and the resulting object is converted to a number as if by a call to the number function. * @param v Value to set for "value" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
XPath	TokenNameIdentifier	 X Path
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_valueExpr	TokenNameIdentifier	 m value Expr
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "value" attribute. * The value attribute contains an expression. The expression is evaluated * and the resulting object is converted to a number as if by a call to the * number function. * * @return Value of "value" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "value" attribute. The value attribute contains an expression. The expression is evaluated and the resulting object is converted to a number as if by a call to the number function. * @return Value of "value" attribute. 
public	TokenNamepublic	
XPath	TokenNameIdentifier	 X Path
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_valueExpr	TokenNameIdentifier	 m value Expr
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The "format" attribute is used to control conversion of a list of * numbers into a string. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @serial */	TokenNameCOMMENT_JAVADOC	 The "format" attribute is used to control conversion of a list of numbers into a string. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> @serial 
private	TokenNameprivate	
AVT	TokenNameIdentifier	 AVT
m_format_avt	TokenNameIdentifier	 m format avt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "format" attribute. * The "format" attribute is used to control conversion of a list of * numbers into a string. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @param v Value to set for "format" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "format" attribute. The "format" attribute is used to control conversion of a list of numbers into a string. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @param v Value to set for "format" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setFormat	TokenNameIdentifier	 set Format
(	TokenNameLPAREN	
AVT	TokenNameIdentifier	 AVT
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_format_avt	TokenNameIdentifier	 m format avt
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "format" attribute. * The "format" attribute is used to control conversion of a list of * numbers into a string. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @return Value of "format" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "format" attribute. The "format" attribute is used to control conversion of a list of numbers into a string. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @return Value of "format" attribute. 
public	TokenNamepublic	
AVT	TokenNameIdentifier	 AVT
getFormat	TokenNameIdentifier	 get Format
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_format_avt	TokenNameIdentifier	 m format avt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * When numbering with an alphabetic sequence, the lang attribute * specifies which language's alphabet is to be used. * @serial */	TokenNameCOMMENT_JAVADOC	 When numbering with an alphabetic sequence, the lang attribute specifies which language's alphabet is to be used. @serial 
private	TokenNameprivate	
AVT	TokenNameIdentifier	 AVT
m_lang_avt	TokenNameIdentifier	 m lang avt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "lang" attribute. * When numbering with an alphabetic sequence, the lang attribute * specifies which language's alphabet is to be used; it has the same * range of values as xml:lang [XML]; if no lang value is specified, * the language should be determined from the system environment. * Implementers should document for which languages they support numbering. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @param v Value to set for "lang" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "lang" attribute. When numbering with an alphabetic sequence, the lang attribute specifies which language's alphabet is to be used; it has the same range of values as xml:lang [XML]; if no lang value is specified, the language should be determined from the system environment. Implementers should document for which languages they support numbering. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @param v Value to set for "lang" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setLang	TokenNameIdentifier	 set Lang
(	TokenNameLPAREN	
AVT	TokenNameIdentifier	 AVT
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_lang_avt	TokenNameIdentifier	 m lang avt
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "lang" attribute. * When numbering with an alphabetic sequence, the lang attribute * specifies which language's alphabet is to be used; it has the same * range of values as xml:lang [XML]; if no lang value is specified, * the language should be determined from the system environment. * Implementers should document for which languages they support numbering. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @return Value ofr "lang" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "lang" attribute. When numbering with an alphabetic sequence, the lang attribute specifies which language's alphabet is to be used; it has the same range of values as xml:lang [XML]; if no lang value is specified, the language should be determined from the system environment. Implementers should document for which languages they support numbering. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @return Value ofr "lang" attribute. 
public	TokenNamepublic	
AVT	TokenNameIdentifier	 AVT
getLang	TokenNameIdentifier	 get Lang
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_lang_avt	TokenNameIdentifier	 m lang avt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The letter-value attribute disambiguates between numbering * sequences that use letters. * @serial */	TokenNameCOMMENT_JAVADOC	 The letter-value attribute disambiguates between numbering sequences that use letters. @serial 
private	TokenNameprivate	
AVT	TokenNameIdentifier	 AVT
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "letter-value" attribute. * The letter-value attribute disambiguates between numbering sequences * that use letters. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @param v Value to set for "letter-value" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "letter-value" attribute. The letter-value attribute disambiguates between numbering sequences that use letters. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @param v Value to set for "letter-value" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setLetterValue	TokenNameIdentifier	 set Letter Value
(	TokenNameLPAREN	
AVT	TokenNameIdentifier	 AVT
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "letter-value" attribute. * The letter-value attribute disambiguates between numbering sequences * that use letters. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @return Value to set for "letter-value" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "letter-value" attribute. The letter-value attribute disambiguates between numbering sequences that use letters. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @return Value to set for "letter-value" attribute. 
public	TokenNamepublic	
AVT	TokenNameIdentifier	 AVT
getLetterValue	TokenNameIdentifier	 get Letter Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The grouping-separator attribute gives the separator * used as a grouping (e.g. thousands) separator in decimal * numbering sequences. * @serial */	TokenNameCOMMENT_JAVADOC	 The grouping-separator attribute gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences. @serial 
private	TokenNameprivate	
AVT	TokenNameIdentifier	 AVT
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "grouping-separator" attribute. * The grouping-separator attribute gives the separator * used as a grouping (e.g. thousands) separator in decimal * numbering sequences. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @param v Value to set for "grouping-separator" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "grouping-separator" attribute. The grouping-separator attribute gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @param v Value to set for "grouping-separator" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setGroupingSeparator	TokenNameIdentifier	 set Grouping Separator
(	TokenNameLPAREN	
AVT	TokenNameIdentifier	 AVT
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "grouping-separator" attribute. * The grouping-separator attribute gives the separator * used as a grouping (e.g. thousands) separator in decimal * numbering sequences. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @return Value of "grouping-separator" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "grouping-separator" attribute. The grouping-separator attribute gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @return Value of "grouping-separator" attribute. 
public	TokenNamepublic	
AVT	TokenNameIdentifier	 AVT
getGroupingSeparator	TokenNameIdentifier	 get Grouping Separator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The optional grouping-size specifies the size (normally 3) of the grouping. * @serial */	TokenNameCOMMENT_JAVADOC	 The optional grouping-size specifies the size (normally 3) of the grouping. @serial 
private	TokenNameprivate	
AVT	TokenNameIdentifier	 AVT
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Set the "grouping-size" attribute. * The optional grouping-size specifies the size (normally 3) of the grouping. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @param v Value to set for "grouping-size" attribute. */	TokenNameCOMMENT_JAVADOC	 Set the "grouping-size" attribute. The optional grouping-size specifies the size (normally 3) of the grouping. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @param v Value to set for "grouping-size" attribute. 
public	TokenNamepublic	
void	TokenNamevoid	
setGroupingSize	TokenNameIdentifier	 set Grouping Size
(	TokenNameLPAREN	
AVT	TokenNameIdentifier	 AVT
v	TokenNameIdentifier	 v
)	TokenNameRPAREN	
{	TokenNameLBRACE	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
=	TokenNameEQUAL	
v	TokenNameIdentifier	 v
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the "grouping-size" attribute. * The optional grouping-size specifies the size (normally 3) of the grouping. * @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * * @return Value of "grouping-size" attribute. */	TokenNameCOMMENT_JAVADOC	 Get the "grouping-size" attribute. The optional grouping-size specifies the size (normally 3) of the grouping. @see <a href="http://www.w3.org/TR/xslt#convert">convert in XSLT Specification</a> * @return Value of "grouping-size" attribute. 
public	TokenNamepublic	
AVT	TokenNameIdentifier	 AVT
getGroupingSize	TokenNameIdentifier	 get Grouping Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Shouldn't this be in the transformer? Big worries about threads... */	TokenNameCOMMENT_JAVADOC	 Shouldn't this be in the transformer? Big worries about threads... 
// private XResourceBundle thisBundle; 	TokenNameCOMMENT_LINE	private XResourceBundle thisBundle; 
/** * Table to help in converting decimals to roman numerals. * @see org.apache.xalan.transformer.DecimalToRoman */	TokenNameCOMMENT_JAVADOC	 Table to help in converting decimals to roman numerals. @see org.apache.xalan.transformer.DecimalToRoman 
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
{	TokenNameLBRACE	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
1000	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
"M"	TokenNameStringLiteral	M
,	TokenNameCOMMA	
900	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
"CM"	TokenNameStringLiteral	CM
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
500	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
"D"	TokenNameStringLiteral	D
,	TokenNameCOMMA	
400	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
"CD"	TokenNameStringLiteral	CD
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
100L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"C"	TokenNameStringLiteral	C
,	TokenNameCOMMA	
90L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"XC"	TokenNameStringLiteral	XC
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
50L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"L"	TokenNameStringLiteral	L
,	TokenNameCOMMA	
40L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"XL"	TokenNameStringLiteral	XL
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
10L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"X"	TokenNameStringLiteral	X
,	TokenNameCOMMA	
9L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"IX"	TokenNameStringLiteral	IX
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
5L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"V"	TokenNameStringLiteral	V
,	TokenNameCOMMA	
4L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"IV"	TokenNameStringLiteral	IV
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
DecimalToRoman	TokenNameIdentifier	 Decimal To Roman
(	TokenNameLPAREN	
1L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"I"	TokenNameStringLiteral	I
,	TokenNameCOMMA	
1L	TokenNameLongLiteral	
,	TokenNameCOMMA	
"I"	TokenNameStringLiteral	I
)	TokenNameRPAREN	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * This function is called after everything else has been * recomposed, and allows the template to set remaining * values that may be based on some other property that * depends on recomposition. */	TokenNameCOMMENT_JAVADOC	 This function is called after everything else has been recomposed, and allows the template to set remaining values that may be based on some other property that depends on recomposition. 
public	TokenNamepublic	
void	TokenNamevoid	
compose	TokenNameIdentifier	 compose
(	TokenNameLPAREN	
StylesheetRoot	TokenNameIdentifier	 Stylesheet Root
sroot	TokenNameIdentifier	 sroot
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
compose	TokenNameIdentifier	 compose
(	TokenNameLPAREN	
sroot	TokenNameIdentifier	 sroot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StylesheetRoot	TokenNameIdentifier	 Stylesheet Root
.	TokenNameDOT	
ComposeState	TokenNameIdentifier	 Compose State
cstate	TokenNameIdentifier	 cstate
=	TokenNameEQUAL	
sroot	TokenNameIdentifier	 sroot
.	TokenNameDOT	
getComposeState	TokenNameIdentifier	 get Compose State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
vnames	TokenNameIdentifier	 vnames
=	TokenNameEQUAL	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getVariableNames	TokenNameIdentifier	 get Variable Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
)	TokenNameRPAREN	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_format_avt	TokenNameIdentifier	 m format avt
)	TokenNameRPAREN	
m_format_avt	TokenNameIdentifier	 m format avt
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
)	TokenNameRPAREN	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
)	TokenNameRPAREN	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
)	TokenNameRPAREN	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_lang_avt	TokenNameIdentifier	 m lang avt
)	TokenNameRPAREN	
m_lang_avt	TokenNameIdentifier	 m lang avt
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
)	TokenNameRPAREN	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_valueExpr	TokenNameIdentifier	 m value Expr
)	TokenNameRPAREN	
m_valueExpr	TokenNameIdentifier	 m value Expr
.	TokenNameDOT	
fixupVariables	TokenNameIdentifier	 fixup Variables
(	TokenNameLPAREN	
vnames	TokenNameIdentifier	 vnames
,	TokenNameCOMMA	
cstate	TokenNameIdentifier	 cstate
.	TokenNameDOT	
getGlobalsSize	TokenNameIdentifier	 get Globals Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get an int constant identifying the type of element. * @see org.apache.xalan.templates.Constants * * @return The token ID for this element */	TokenNameCOMMENT_JAVADOC	 Get an int constant identifying the type of element. @see org.apache.xalan.templates.Constants * @return The token ID for this element 
public	TokenNamepublic	
int	TokenNameint	
getXSLToken	TokenNameIdentifier	 get XSL Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ELEMNAME_NUMBER	TokenNameIdentifier	 ELEMNAME  NUMBER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the node name. * * @return The element's name */	TokenNameCOMMENT_JAVADOC	 Return the node name. * @return The element's name 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ELEMNAME_NUMBER_STRING	TokenNameIdentifier	 ELEMNAME  NUMBER  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Execute an xsl:number instruction. The xsl:number element is * used to insert a formatted number into the result tree. * * @param transformer non-null reference to the the current transform-time state. * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Execute an xsl:number instruction. The xsl:number element is used to insert a formatted number into the result tree. * @param transformer non-null reference to the the current transform-time state. * @throws TransformerException 
public	TokenNamepublic	
void	TokenNamevoid	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getDebug	TokenNameIdentifier	 get Debug
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getTraceManager	TokenNameIdentifier	 get Trace Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fireTraceEvent	TokenNameIdentifier	 fire Trace Event
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
sourceNode	TokenNameIdentifier	 source Node
=	TokenNameEQUAL	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCurrentNode	TokenNameIdentifier	 get Current Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
countString	TokenNameIdentifier	 count String
=	TokenNameEQUAL	
getCountString	TokenNameIdentifier	 get Count String
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getResultTreeHandler	TokenNameIdentifier	 get Result Tree Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
countString	TokenNameIdentifier	 count String
.	TokenNameDOT	
toCharArray	TokenNameIdentifier	 to Char Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
countString	TokenNameIdentifier	 count String
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
SAXException	TokenNameIdentifier	 SAX Exception
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TransformerException	TokenNameIdentifier	 Transformer Exception
(	TokenNameLPAREN	
se	TokenNameIdentifier	 se
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getDebug	TokenNameIdentifier	 get Debug
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getTraceManager	TokenNameIdentifier	 get Trace Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fireTraceEndEvent	TokenNameIdentifier	 fire Trace End Event
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Add a child to the child list. * * @param newChild Child to add to child list * * @return Child just added to child list * * @throws DOMException */	TokenNameCOMMENT_JAVADOC	 Add a child to the child list. * @param newChild Child to add to child list * @return Child just added to child list * @throws DOMException 
public	TokenNamepublic	
ElemTemplateElement	TokenNameIdentifier	 Elem Template Element
appendChild	TokenNameIdentifier	 append Child
(	TokenNameLPAREN	
ElemTemplateElement	TokenNameIdentifier	 Elem Template Element
newChild	TokenNameIdentifier	 new Child
)	TokenNameRPAREN	
{	TokenNameLBRACE	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_CANNOT_ADD	TokenNameIdentifier	 ER  CANNOT  ADD
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
newChild	TokenNameIdentifier	 new Child
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Can not add " +((ElemTemplateElement)newChild).m_elemName + 	TokenNameCOMMENT_LINE	"Can not add " +((ElemTemplateElement)newChild).m_elemName + 
//" to " + this.m_elemName); 	TokenNameCOMMENT_LINE	" to " + this.m_elemName); 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a 'from' pattern (ala xsl:number), a match pattern * and a context, find the first ancestor that matches the * pattern (including the context handed in). * * @param xctxt The XPath runtime state for this. * @param fromMatchPattern The ancestor must match this pattern. * @param countMatchPattern The ancestor must also match this pattern. * @param context The node that "." expresses. * @param namespaceContext The context in which namespaces in the * queries are supposed to be expanded. * * @return the first ancestor that matches the given pattern * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Given a 'from' pattern (ala xsl:number), a match pattern and a context, find the first ancestor that matches the pattern (including the context handed in). * @param xctxt The XPath runtime state for this. @param fromMatchPattern The ancestor must match this pattern. @param countMatchPattern The ancestor must also match this pattern. @param context The node that "." expresses. @param namespaceContext The context in which namespaces in the queries are supposed to be expanded. * @return the first ancestor that matches the given pattern * @throws javax.xml.transform.TransformerException 
int	TokenNameint	
findAncestor	TokenNameIdentifier	 find Ancestor
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
,	TokenNameCOMMA	
int	TokenNameint	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ElemNumber	TokenNameIdentifier	 Elem Number
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//context = null; 	TokenNameCOMMENT_LINE	context = null; 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
context	TokenNameIdentifier	 context
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given a 'from' pattern (ala xsl:number), a match pattern * and a context, find the first ancestor that matches the * pattern (including the context handed in). * @param xctxt The XPath runtime state for this. * @param fromMatchPattern The ancestor must match this pattern. * @param countMatchPattern The ancestor must also match this pattern. * @param context The node that "." expresses. * @param namespaceContext The context in which namespaces in the * queries are supposed to be expanded. * * @return the first preceding, ancestor or self node that * matches the given pattern * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Given a 'from' pattern (ala xsl:number), a match pattern and a context, find the first ancestor that matches the pattern (including the context handed in). @param xctxt The XPath runtime state for this. @param fromMatchPattern The ancestor must match this pattern. @param countMatchPattern The ancestor must also match this pattern. @param context The node that "." expresses. @param namespaceContext The context in which namespaces in the queries are supposed to be expanded. * @return the first preceding, ancestor or self node that matches the given pattern * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
int	TokenNameint	
findPrecedingOrAncestorOrSelf	TokenNameIdentifier	 find Preceding Or Ancestor Or Self
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
,	TokenNameCOMMA	
int	TokenNameint	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
ElemNumber	TokenNameIdentifier	 Elem Number
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
prevSibling	TokenNameIdentifier	 prev Sibling
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getPreviousSibling	TokenNameIdentifier	 get Previous Sibling
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
prevSibling	TokenNameIdentifier	 prev Sibling
)	TokenNameRPAREN	
{	TokenNameLBRACE	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Now go down the chain of children of this sibling 	TokenNameCOMMENT_LINE	Now go down the chain of children of this sibling 
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getLastChild	TokenNameIdentifier	 get Last Child
(	TokenNameLPAREN	
prevSibling	TokenNameIdentifier	 prev Sibling
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
)	TokenNameRPAREN	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
prevSibling	TokenNameIdentifier	 prev Sibling
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
context	TokenNameIdentifier	 context
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the count match pattern, or a default value. * * @param support The XPath runtime state for this. * @param contextNode The node that "." expresses. * * @return the count match pattern, or a default value. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the count match pattern, or a default value. * @param support The XPath runtime state for this. @param contextNode The node that "." expresses. * @return the count match pattern, or a default value. * @throws javax.xml.transform.TransformerException 
XPath	TokenNameIdentifier	 X Path
getCountMatchPattern	TokenNameIdentifier	 get Count Match Pattern
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
support	TokenNameIdentifier	 support
,	TokenNameCOMMA	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
;	TokenNameSEMICOLON	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
:	TokenNameCOLON	
MyPrefixResolver	TokenNameIdentifier	 My Prefix Resolver
resolver	TokenNameIdentifier	 resolver
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resolver	TokenNameIdentifier	 resolver
=	TokenNameEQUAL	
new	TokenNamenew	
MyPrefixResolver	TokenNameIdentifier	 My Prefix Resolver
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
resolver	TokenNameIdentifier	 resolver
=	TokenNameEQUAL	
new	TokenNamenew	
MyPrefixResolver	TokenNameIdentifier	 My Prefix Resolver
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dtm	TokenNameIdentifier	 dtm
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
resolver	TokenNameIdentifier	 resolver
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
:	TokenNameCOLON	
// countMatchPattern = m_stylesheet.createMatchPattern("@"+contextNode.getNodeName(), this); 	TokenNameCOMMENT_LINE	countMatchPattern = m_stylesheet.createMatchPattern("@"+contextNode.getNodeName(), this); 
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
"@"	TokenNameStringLiteral	@
+	TokenNamePLUS	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
CDATA_SECTION_NODE	TokenNameIdentifier	 CDATA  SECTION  NODE
:	TokenNameCOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
:	TokenNameCOLON	
// countMatchPattern = m_stylesheet.createMatchPattern("text()", this); 	TokenNameCOMMENT_LINE	countMatchPattern = m_stylesheet.createMatchPattern("text()", this); 
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
"text()"	TokenNameStringLiteral	text()
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
COMMENT_NODE	TokenNameIdentifier	 COMMENT  NODE
:	TokenNameCOLON	
// countMatchPattern = m_stylesheet.createMatchPattern("comment()", this); 	TokenNameCOMMENT_LINE	countMatchPattern = m_stylesheet.createMatchPattern("comment()", this); 
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
"comment()"	TokenNameStringLiteral	comment()
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
:	TokenNameCOLON	
// countMatchPattern = m_stylesheet.createMatchPattern("/", this); 	TokenNameCOMMENT_LINE	countMatchPattern = m_stylesheet.createMatchPattern("/", this); 
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
"/"	TokenNameStringLiteral	/
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
PROCESSING_INSTRUCTION_NODE	TokenNameIdentifier	 PROCESSING  INSTRUCTION  NODE
:	TokenNameCOLON	
// countMatchPattern = m_stylesheet.createMatchPattern("pi("+contextNode.getNodeName()+")", this); 	TokenNameCOMMENT_LINE	countMatchPattern = m_stylesheet.createMatchPattern("pi("+contextNode.getNodeName()+")", this); 
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
new	TokenNamenew	
XPath	TokenNameIdentifier	 X Path
(	TokenNameLPAREN	
"pi("	TokenNameStringLiteral	pi(
+	TokenNamePLUS	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH	TokenNameIdentifier	 MATCH
,	TokenNameCOMMA	
support	TokenNameIdentifier	 support
.	TokenNameDOT	
getErrorListener	TokenNameIdentifier	 get Error Listener
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Given an XML source node, get the count according to the * parameters set up by the xsl:number attributes. * @param transformer non-null reference to the the current transform-time state. * @param sourceNode The source node being counted. * * @return The count of nodes * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Given an XML source node, get the count according to the parameters set up by the xsl:number attributes. @param transformer non-null reference to the the current transform-time state. @param sourceNode The source node being counted. * @return The count of nodes * @throws TransformerException 
String	TokenNameIdentifier	 String
getCountString	TokenNameIdentifier	 get Count String
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
int	TokenNameint	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CountersTable	TokenNameIdentifier	 Counters Table
ctable	TokenNameIdentifier	 ctable
=	TokenNameEQUAL	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getCountersTable	TokenNameIdentifier	 get Counters Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_valueExpr	TokenNameIdentifier	 m value Expr
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XObject	TokenNameIdentifier	 X Object
countObj	TokenNameIdentifier	 count Obj
=	TokenNameEQUAL	
m_valueExpr	TokenNameIdentifier	 m value Expr
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//According to Errata E24 	TokenNameCOMMENT_LINE	According to Errata E24 
double	TokenNamedouble	
d_count	TokenNameIdentifier	 d count
=	TokenNameEQUAL	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
floor	TokenNameIdentifier	 floor
(	TokenNameLPAREN	
countObj	TokenNameIdentifier	 count Obj
.	TokenNameDOT	
num	TokenNameIdentifier	 num
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
0.5	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
isNaN	TokenNameIdentifier	 is Na N
(	TokenNameLPAREN	
d_count	TokenNameIdentifier	 d count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
"NaN"	TokenNameStringLiteral	NaN
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
d_count	TokenNameIdentifier	 d count
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
isInfinite	TokenNameIdentifier	 is Infinite
(	TokenNameLPAREN	
d_count	TokenNameIdentifier	 d count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
"-Infinity"	TokenNameStringLiteral	-Infinity
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
Double	TokenNameIdentifier	 Double
.	TokenNameDOT	
isInfinite	TokenNameIdentifier	 is Infinite
(	TokenNameLPAREN	
d_count	TokenNameIdentifier	 d count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
"Infinity"	TokenNameStringLiteral	Infinity
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
d_count	TokenNameIdentifier	 d count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
"0"	TokenNameStringLiteral	0
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
long	TokenNamelong	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
d_count	TokenNameIdentifier	 d count
;	TokenNameSEMICOLON	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NUMBERLEVEL_ANY	TokenNameIdentifier	 NUMBERLEVEL  ANY
==	TokenNameEQUAL_EQUAL	
m_level	TokenNameIdentifier	 m level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ctable	TokenNameIdentifier	 ctable
.	TokenNameDOT	
countNode	TokenNameIdentifier	 count Node
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
NodeVector	TokenNameIdentifier	 Node Vector
ancestors	TokenNameIdentifier	 ancestors
=	TokenNameEQUAL	
getMatchingAncestors	TokenNameIdentifier	 get Matching Ancestors
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
,	TokenNameCOMMA	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NUMBERLEVEL_SINGLE	TokenNameIdentifier	 NUMBERLEVEL  SINGLE
==	TokenNameEQUAL_EQUAL	
m_level	TokenNameIdentifier	 m level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
lastIndex	TokenNameIdentifier	 last Index
=	TokenNameEQUAL	
ancestors	TokenNameIdentifier	 ancestors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lastIndex	TokenNameIdentifier	 last Index
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
list	TokenNameIdentifier	 list
=	TokenNameEQUAL	
new	TokenNamenew	
long	TokenNamelong	
[	TokenNameLBRACKET	
lastIndex	TokenNameIdentifier	 last Index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
lastIndex	TokenNameIdentifier	 last Index
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
ancestors	TokenNameIdentifier	 ancestors
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
lastIndex	TokenNameIdentifier	 last Index
-	TokenNameMINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
ctable	TokenNameIdentifier	 ctable
.	TokenNameDOT	
countNode	TokenNameIdentifier	 count Node
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
this	TokenNamethis	
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
?	TokenNameQUESTION	
formatNumberList	TokenNameIdentifier	 format Number List
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
list	TokenNameIdentifier	 list
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the previous node to be counted. * * @param xctxt The XPath runtime state for this. * @param pos The current node * * @return the previous node to be counted. * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the previous node to be counted. * @param xctxt The XPath runtime state for this. @param pos The current node * @return the previous node to be counted. * @throws TransformerException 
public	TokenNamepublic	
int	TokenNameint	
getPreviousNode	TokenNameIdentifier	 get Previous Node
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
getCountMatchPattern	TokenNameIdentifier	 get Count Match Pattern
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NUMBERLEVEL_ANY	TokenNameIdentifier	 NUMBERLEVEL  ANY
==	TokenNameEQUAL_EQUAL	
m_level	TokenNameIdentifier	 m level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPath	TokenNameIdentifier	 X Path
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
=	TokenNameEQUAL	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
;	TokenNameSEMICOLON	
// Do a backwards document-order walk 'till a node is found that matches 	TokenNameCOMMENT_LINE	Do a backwards document-order walk 'till a node is found that matches 
// the 'from' pattern, or a node is found that matches the 'count' pattern, 	TokenNameCOMMENT_LINE	the 'from' pattern, or a node is found that matches the 'count' pattern, 
// or the top of the tree is found. 	TokenNameCOMMENT_LINE	or the top of the tree is found. 
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get the previous sibling, if there is no previous sibling, 	TokenNameCOMMENT_LINE	Get the previous sibling, if there is no previous sibling, 
// then count the parent, but if there is a previous sibling, 	TokenNameCOMMENT_LINE	then count the parent, but if there is a previous sibling, 
// dive down to the lowest right-hand (last) child of that sibling. 	TokenNameCOMMENT_LINE	dive down to the lowest right-hand (last) child of that sibling. 
int	TokenNameint	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getPreviousSibling	TokenNameIdentifier	 get Previous Sibling
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
==	TokenNameEQUAL_EQUAL	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
{	TokenNameLBRACE	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fromMatchPattern	TokenNameIdentifier	 from Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
// return null from function. 	TokenNameCOMMENT_LINE	return null from function. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// from while loop 	TokenNameCOMMENT_LINE	from while loop 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// dive down to the lowest right child. 	TokenNameCOMMENT_LINE	dive down to the lowest right child. 
int	TokenNameint	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
{	TokenNameLBRACE	
child	TokenNameIdentifier	 child
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getLastChild	TokenNameIdentifier	 get Last Child
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
child	TokenNameIdentifier	 child
)	TokenNameRPAREN	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
child	TokenNameIdentifier	 child
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
// NUMBERLEVEL_MULTI or NUMBERLEVEL_SINGLE 	TokenNameCOMMENT_LINE	NUMBERLEVEL_MULTI or NUMBERLEVEL_SINGLE 
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getPreviousSibling	TokenNameIdentifier	 get Previous Sibling
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the target node that will be counted.. * * @param xctxt The XPath runtime state for this. * @param sourceNode non-null reference to the <a href="http://www.w3.org/TR/xslt#dt-current-node">current source node</a>. * * @return the target node that will be counted * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the target node that will be counted.. * @param xctxt The XPath runtime state for this. @param sourceNode non-null reference to the <a href="http://www.w3.org/TR/xslt#dt-current-node">current source node</a>. * @return the target node that will be counted * @throws TransformerException 
public	TokenNamepublic	
int	TokenNameint	
getTargetNode	TokenNameIdentifier	 get Target Node
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
int	TokenNameint	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
int	TokenNameint	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
;	TokenNameSEMICOLON	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
getCountMatchPattern	TokenNameIdentifier	 get Count Match Pattern
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NUMBERLEVEL_ANY	TokenNameIdentifier	 NUMBERLEVEL  ANY
==	TokenNameEQUAL_EQUAL	
m_level	TokenNameIdentifier	 m level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
findPrecedingOrAncestorOrSelf	TokenNameIdentifier	 find Preceding Or Ancestor Or Self
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
,	TokenNameCOMMA	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
findAncestor	TokenNameIdentifier	 find Ancestor
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
,	TokenNameCOMMA	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
,	TokenNameCOMMA	
sourceNode	TokenNameIdentifier	 source Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
target	TokenNameIdentifier	 target
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the ancestors, up to the root, that match the * pattern. * * @param xctxt The XPath runtime state for this. * @param node Count this node and it's ancestors. * @param stopAtFirstFound Flag indicating to stop after the * first node is found (difference between level = single * or multiple) * @return The number of ancestors that match the pattern. * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the ancestors, up to the root, that match the pattern. * @param xctxt The XPath runtime state for this. @param node Count this node and it's ancestors. @param stopAtFirstFound Flag indicating to stop after the first node is found (difference between level = single or multiple) @return The number of ancestors that match the pattern. * @throws javax.xml.transform.TransformerException 
NodeVector	TokenNameIdentifier	 Node Vector
getMatchingAncestors	TokenNameIdentifier	 get Matching Ancestors
(	TokenNameLPAREN	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
int	TokenNameint	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
boolean	TokenNameboolean	
stopAtFirstFound	TokenNameIdentifier	 stop At First Found
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
ancestors	TokenNameIdentifier	 ancestors
=	TokenNameEQUAL	
new	TokenNamenew	
NodeSetDTM	TokenNameIdentifier	 Node Set DTM
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTMManager	TokenNameIdentifier	 get DTM Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XPath	TokenNameIdentifier	 X Path
countMatchPattern	TokenNameIdentifier	 count Match Pattern
=	TokenNameEQUAL	
getCountMatchPattern	TokenNameIdentifier	 get Count Match Pattern
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DTM	TokenNameIdentifier	 DTM
dtm	TokenNameIdentifier	 dtm
=	TokenNameEQUAL	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
DTM	TokenNameIdentifier	 DTM
.	TokenNameDOT	
NULL	TokenNameIdentifier	 NULL
!=	TokenNameNOT_EQUAL	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// The following if statement gives level="single" different 	TokenNameCOMMENT_LINE	The following if statement gives level="single" different 
// behavior from level="multiple", which seems incorrect according 	TokenNameCOMMENT_LINE	behavior from level="multiple", which seems incorrect according 
// to the XSLT spec. For now we are leaving this in to replicate 	TokenNameCOMMENT_LINE	to the XSLT spec. For now we are leaving this in to replicate 
// the same behavior in XT, but, for all intents and purposes we 	TokenNameCOMMENT_LINE	the same behavior in XT, but, for all intents and purposes we 
// think this is a bug, or there is something about level="single" 	TokenNameCOMMENT_LINE	think this is a bug, or there is something about level="single" 
// that we still don't understand. 	TokenNameCOMMENT_LINE	that we still don't understand. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
stopAtFirstFound	TokenNameIdentifier	 stop At First Found
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"Programmers error! countMatchPattern should never be null!"	TokenNameStringLiteral	Programmers error! countMatchPattern should never be null!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
countMatchPattern	TokenNameIdentifier	 count Match Pattern
.	TokenNameDOT	
getMatchScore	TokenNameIdentifier	 get Match Score
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XPath	TokenNameIdentifier	 X Path
.	TokenNameDOT	
MATCH_SCORE_NONE	TokenNameIdentifier	 MATCH  SCORE  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ancestors	TokenNameIdentifier	 ancestors
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stopAtFirstFound	TokenNameIdentifier	 stop At First Found
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
dtm	TokenNameIdentifier	 dtm
.	TokenNameDOT	
getParent	TokenNameIdentifier	 get Parent
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ancestors	TokenNameIdentifier	 ancestors
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end getMatchingAncestors method 	TokenNameCOMMENT_LINE	end getMatchingAncestors method 
/** * Get the locale we should be using. * * @param transformer non-null reference to the the current transform-time state. * @param contextNode The node that "." expresses. * * @return The locale to use. May be specified by "lang" attribute, * but if not, use default locale on the system. * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the locale we should be using. * @param transformer non-null reference to the the current transform-time state. @param contextNode The node that "." expresses. * @return The locale to use. May be specified by "lang" attribute, but if not, use default locale on the system. * @throws TransformerException 
Locale	TokenNameIdentifier	 Locale
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_lang_avt	TokenNameIdentifier	 m lang avt
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathContext	TokenNameIdentifier	 X Path Context
xctxt	TokenNameIdentifier	 xctxt
=	TokenNameEQUAL	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
langValue	TokenNameIdentifier	 lang Value
=	TokenNameEQUAL	
m_lang_avt	TokenNameIdentifier	 m lang avt
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
xctxt	TokenNameIdentifier	 xctxt
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
langValue	TokenNameIdentifier	 lang Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Not really sure what to do about the country code, so I use the 	TokenNameCOMMENT_LINE	Not really sure what to do about the country code, so I use the 
// default from the system. 	TokenNameCOMMENT_LINE	default from the system. 
// TODO: fix xml:lang handling. 	TokenNameCOMMENT_LINE	TODO: fix xml:lang handling. 
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
langValue	TokenNameIdentifier	 lang Value
.	TokenNameDOT	
toUpperCase	TokenNameIdentifier	 to Upper Case
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//Locale.getDefault().getDisplayCountry()); 	TokenNameCOMMENT_LINE	Locale.getDefault().getDisplayCountry()); 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
{	TokenNameLBRACE	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getMsgMgr	TokenNameIdentifier	 get Msg Mgr
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
xctxt	TokenNameIdentifier	 xctxt
.	TokenNameDOT	
getDTM	TokenNameIdentifier	 get DTM
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
.	TokenNameDOT	
getNode	TokenNameIdentifier	 get Node
(	TokenNameLPAREN	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
,	TokenNameCOMMA	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
WG_LOCALE_NOT_FOUND	TokenNameIdentifier	 WG  LOCALE  NOT  FOUND
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
langValue	TokenNameIdentifier	 lang Value
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//"Warning: Could not find locale for xml:lang="+langValue); 	TokenNameCOMMENT_LINE	"Warning: Could not find locale for xml:lang="+langValue); 
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
Locale	TokenNameIdentifier	 Locale
.	TokenNameDOT	
getDefault	TokenNameIdentifier	 get Default
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
locale	TokenNameIdentifier	 locale
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get the number formatter to be used the format the numbers * * @param transformer non-null reference to the the current transform-time state. * @param contextNode The node that "." expresses. * * ($objectName$) @return The number formatter to be used * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Get the number formatter to be used the format the numbers * @param transformer non-null reference to the the current transform-time state. @param contextNode The node that "." expresses. * ($objectName$) @return The number formatter to be used * @throws TransformerException 
private	TokenNameprivate	
DecimalFormat	TokenNameIdentifier	 Decimal Format
getNumberFormatter	TokenNameIdentifier	 get Number Formatter
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
// Patch from Steven Serocki 	TokenNameCOMMENT_LINE	Patch from Steven Serocki 
// Maybe we really want to do the clone in getLocale() and return 	TokenNameCOMMENT_LINE	Maybe we really want to do the clone in getLocale() and return 
// a clone of the default Locale?? 	TokenNameCOMMENT_LINE	a clone of the default Locale?? 
Locale	TokenNameIdentifier	 Locale
locale	TokenNameIdentifier	 locale
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Locale	TokenNameIdentifier	 Locale
)	TokenNameRPAREN	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Helper to format local specific numbers to strings. 	TokenNameCOMMENT_LINE	Helper to format local specific numbers to strings. 
DecimalFormat	TokenNameIdentifier	 Decimal Format
formatter	TokenNameIdentifier	 formatter
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
//synchronized (locale) 	TokenNameCOMMENT_LINE	synchronized (locale) 
//{ 	TokenNameCOMMENT_LINE	{ 
// formatter = (DecimalFormat) NumberFormat.getNumberInstance(locale); 	TokenNameCOMMENT_LINE	formatter = (DecimalFormat) NumberFormat.getNumberInstance(locale); 
//} 	TokenNameCOMMENT_LINE	} 
String	TokenNameIdentifier	 String
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
)	TokenNameRPAREN	
?	TokenNameQUESTION	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Validate grouping separator if an AVT was used; otherwise this was 	TokenNameCOMMENT_LINE	Validate grouping separator if an AVT was used; otherwise this was 
// validated statically in XSLTAttributeDef.java. 	TokenNameCOMMENT_LINE	validated statically in XSLTAttributeDef.java. 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
.	TokenNameDOT	
isSimple	TokenNameIdentifier	 is Simple
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getMsgMgr	TokenNameIdentifier	 get Msg Mgr
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
WG_ILLEGAL_ATTRIBUTE_VALUE	TokenNameIdentifier	 WG  ILLEGAL  ATTRIBUTE  VALUE
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRNAME_NAME	TokenNameIdentifier	 ATTRNAME  NAME
,	TokenNameCOMMA	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
nDigitsPerGroupValue	TokenNameIdentifier	 n Digits Per Group Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
)	TokenNameRPAREN	
?	TokenNameQUESTION	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// TODO: Handle digit-group attributes 	TokenNameCOMMENT_LINE	TODO: Handle digit-group attributes 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
nDigitsPerGroupValue	TokenNameIdentifier	 n Digits Per Group Value
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
// Ignore if separation value is empty string 	TokenNameCOMMENT_LINE	Ignore if separation value is empty string 
(	TokenNameLPAREN	
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
formatter	TokenNameIdentifier	 formatter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DecimalFormat	TokenNameIdentifier	 Decimal Format
)	TokenNameRPAREN	
NumberFormat	TokenNameIdentifier	 Number Format
.	TokenNameDOT	
getNumberInstance	TokenNameIdentifier	 get Number Instance
(	TokenNameLPAREN	
locale	TokenNameIdentifier	 locale
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
setGroupingSize	TokenNameIdentifier	 set Grouping Size
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
nDigitsPerGroupValue	TokenNameIdentifier	 n Digits Per Group Value
)	TokenNameRPAREN	
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DecimalFormatSymbols	TokenNameIdentifier	 Decimal Format Symbols
symbols	TokenNameIdentifier	 symbols
=	TokenNameEQUAL	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
getDecimalFormatSymbols	TokenNameIdentifier	 get Decimal Format Symbols
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
symbols	TokenNameIdentifier	 symbols
.	TokenNameDOT	
setGroupingSeparator	TokenNameIdentifier	 set Grouping Separator
(	TokenNameLPAREN	
digitGroupSepValue	TokenNameIdentifier	 digit Group Sep Value
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
setDecimalFormatSymbols	TokenNameIdentifier	 set Decimal Format Symbols
(	TokenNameLPAREN	
symbols	TokenNameIdentifier	 symbols
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
setGroupingUsed	TokenNameIdentifier	 set Grouping Used
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
NumberFormatException	TokenNameIdentifier	 Number Format Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
setGroupingUsed	TokenNameIdentifier	 set Grouping Used
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
formatter	TokenNameIdentifier	 formatter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Format a vector of numbers into a formatted string. * * @param transformer non-null reference to the the current transform-time state. * @param list Array of one or more long integer numbers. * @param contextNode The node that "." expresses. * @return String that represents list according to * %conversion-atts; attributes. * TODO: Optimize formatNumberList so that it caches the last count and * reuses that info for the next count. * * @throws TransformerException */	TokenNameCOMMENT_JAVADOC	 Format a vector of numbers into a formatted string. * @param transformer non-null reference to the the current transform-time state. @param list Array of one or more long integer numbers. @param contextNode The node that "." expresses. @return String that represents list according to %conversion-atts; attributes. TODO: Optimize formatNumberList so that it caches the last count and reuses that info for the next count. * @throws TransformerException 
String	TokenNameIdentifier	 String
formatNumberList	TokenNameIdentifier	 format Number List
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
list	TokenNameIdentifier	 list
,	TokenNameCOMMA	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
throws	TokenNamethrows	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
numStr	TokenNameIdentifier	 num Str
;	TokenNameSEMICOLON	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
formattedNumber	TokenNameIdentifier	 formatted Number
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
int	TokenNameint	
nNumbers	TokenNameIdentifier	 n Numbers
=	TokenNameEQUAL	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
numberWidth	TokenNameIdentifier	 number Width
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
char	TokenNamechar	
numberType	TokenNameIdentifier	 number Type
=	TokenNameEQUAL	
'1'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
formatToken	TokenNameIdentifier	 format Token
,	TokenNameCOMMA	
lastSepString	TokenNameIdentifier	 last Sep String
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
formatTokenString	TokenNameIdentifier	 format Token String
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// If a seperator hasn't been specified, then use "." 	TokenNameCOMMENT_LINE	If a seperator hasn't been specified, then use "." 
// as a default separator. 	TokenNameCOMMENT_LINE	as a default separator. 
// For instance: [2][1][5] with a format value of "1 " 	TokenNameCOMMENT_LINE	For instance: [2][1][5] with a format value of "1 " 
// should format to "2.1.5 " (I think). 	TokenNameCOMMENT_LINE	should format to "2.1.5 " (I think). 
// Otherwise, use the seperator specified in the format string. 	TokenNameCOMMENT_LINE	Otherwise, use the seperator specified in the format string. 
// For instance: [2][1][5] with a format value of "01-001. " 	TokenNameCOMMENT_LINE	For instance: [2][1][5] with a format value of "01-001. " 
// should format to "02-001-005 ". 	TokenNameCOMMENT_LINE	should format to "02-001-005 ". 
String	TokenNameIdentifier	 String
lastSep	TokenNameIdentifier	 last Sep
=	TokenNameEQUAL	
"."	TokenNameStringLiteral	.
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isFirstToken	TokenNameIdentifier	 is First Token
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// true if first token 	TokenNameCOMMENT_LINE	true if first token 
String	TokenNameIdentifier	 String
formatValue	TokenNameIdentifier	 format Value
=	TokenNameEQUAL	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_format_avt	TokenNameIdentifier	 m format avt
)	TokenNameRPAREN	
?	TokenNameQUESTION	
m_format_avt	TokenNameIdentifier	 m format avt
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
formatValue	TokenNameIdentifier	 format Value
)	TokenNameRPAREN	
formatValue	TokenNameIdentifier	 format Value
=	TokenNameEQUAL	
"1"	TokenNameStringLiteral	1
;	TokenNameSEMICOLON	
NumberFormatStringTokenizer	TokenNameIdentifier	 Number Format String Tokenizer
formatTokenizer	TokenNameIdentifier	 format Tokenizer
=	TokenNameEQUAL	
new	TokenNamenew	
NumberFormatStringTokenizer	TokenNameIdentifier	 Number Format String Tokenizer
(	TokenNameLPAREN	
formatValue	TokenNameIdentifier	 format Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// int sepCount = 0; // keep track of seperators 	TokenNameCOMMENT_LINE	int sepCount = 0; // keep track of seperators 
// Loop through all the numbers in the list. 	TokenNameCOMMENT_LINE	Loop through all the numbers in the list. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nNumbers	TokenNameIdentifier	 n Numbers
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Loop to the next digit, letter, or separator. 	TokenNameCOMMENT_LINE	Loop to the next digit, letter, or separator. 
if	TokenNameif	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatToken	TokenNameIdentifier	 format Token
=	TokenNameEQUAL	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the first character of this token is a character or digit, then 	TokenNameCOMMENT_LINE	If the first character of this token is a character or digit, then 
// it is a number format directive. 	TokenNameCOMMENT_LINE	it is a number format directive. 
if	TokenNameif	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
numberWidth	TokenNameIdentifier	 number Width
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
numberType	TokenNameIdentifier	 number Type
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
numberWidth	TokenNameIdentifier	 number Width
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If there is a number format directive ahead, 	TokenNameCOMMENT_LINE	If there is a number format directive ahead, 
// then append the formatToken. 	TokenNameCOMMENT_LINE	then append the formatToken. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
isLetterOrDigitAhead	TokenNameIdentifier	 is Letter Or Digit Ahead
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatTokenString	TokenNameIdentifier	 format Token String
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
;	TokenNameSEMICOLON	
// Append the formatToken string... 	TokenNameCOMMENT_LINE	Append the formatToken string... 
// For instance [2][1][5] with a format value of "1--1. " 	TokenNameCOMMENT_LINE	For instance [2][1][5] with a format value of "1--1. " 
// should format to "2--1--5. " (I guess). 	TokenNameCOMMENT_LINE	should format to "2--1--5. " (I guess). 
while	TokenNamewhile	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextIsSep	TokenNameIdentifier	 next Is Sep
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatToken	TokenNameIdentifier	 format Token
=	TokenNameEQUAL	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formatTokenString	TokenNameIdentifier	 format Token String
+=	TokenNamePLUS_EQUAL	
formatToken	TokenNameIdentifier	 format Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Record this separator, so it can be used as the 	TokenNameCOMMENT_LINE	Record this separator, so it can be used as the 
// next separator, if the next is the last. 	TokenNameCOMMENT_LINE	next separator, if the next is the last. 
// For instance: [2][1][5] with a format value of "1-1 " 	TokenNameCOMMENT_LINE	For instance: [2][1][5] with a format value of "1-1 " 
// should format to "2-1-5 ". 	TokenNameCOMMENT_LINE	should format to "2-1-5 ". 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isFirstToken	TokenNameIdentifier	 is First Token
)	TokenNameRPAREN	
lastSep	TokenNameIdentifier	 last Sep
=	TokenNameEQUAL	
formatTokenString	TokenNameIdentifier	 format Token String
;	TokenNameSEMICOLON	
// Since we know the next is a number or digit, we get it now. 	TokenNameCOMMENT_LINE	Since we know the next is a number or digit, we get it now. 
formatToken	TokenNameIdentifier	 format Token
=	TokenNameEQUAL	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
numberWidth	TokenNameIdentifier	 number Width
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
numberType	TokenNameIdentifier	 number Type
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
numberWidth	TokenNameIdentifier	 number Width
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
// only separators left 	TokenNameCOMMENT_LINE	only separators left 
{	TokenNameLBRACE	
// Set up the string for the trailing characters after 	TokenNameCOMMENT_LINE	Set up the string for the trailing characters after 
// the last number is formatted (i.e. after the loop). 	TokenNameCOMMENT_LINE	the last number is formatted (i.e. after the loop). 
lastSepString	TokenNameIdentifier	 last Sep String
=	TokenNameEQUAL	
formatToken	TokenNameIdentifier	 format Token
;	TokenNameSEMICOLON	
// And append any remaining characters to the lastSepString. 	TokenNameCOMMENT_LINE	And append any remaining characters to the lastSepString. 
while	TokenNamewhile	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatToken	TokenNameIdentifier	 format Token
=	TokenNameEQUAL	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastSepString	TokenNameIdentifier	 last Sep String
+=	TokenNamePLUS_EQUAL	
formatToken	TokenNameIdentifier	 format Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// else 	TokenNameCOMMENT_LINE	else 
}	TokenNameRBRACE	
// end if(formatTokenizer.hasMoreTokens()) 	TokenNameCOMMENT_LINE	end if(formatTokenizer.hasMoreTokens()) 
// if this is the first token and there was a prefix 	TokenNameCOMMENT_LINE	if this is the first token and there was a prefix 
// append the prefix else, append the separator 	TokenNameCOMMENT_LINE	append the prefix else, append the separator 
// For instance, [2][1][5] with a format value of "(1-1.) " 	TokenNameCOMMENT_LINE	For instance, [2][1][5] with a format value of "(1-1.) " 
// should format to "(2-1-5.) " (I guess). 	TokenNameCOMMENT_LINE	should format to "(2-1-5.) " (I guess). 
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
formatTokenString	TokenNameIdentifier	 format Token String
&&	TokenNameAND_AND	
isFirstToken	TokenNameIdentifier	 is First Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
formatTokenString	TokenNameIdentifier	 format Token String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
lastSep	TokenNameIdentifier	 last Sep
&&	TokenNameAND_AND	
!	TokenNameNOT	
isFirstToken	TokenNameIdentifier	 is First Token
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
lastSep	TokenNameIdentifier	 last Sep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
getFormattedNumber	TokenNameIdentifier	 get Formatted Number
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
numberType	TokenNameIdentifier	 number Type
,	TokenNameCOMMA	
numberWidth	TokenNameIdentifier	 number Width
,	TokenNameCOMMA	
list	TokenNameIdentifier	 list
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isFirstToken	TokenNameIdentifier	 is First Token
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// After the first pass, this should be false 	TokenNameCOMMENT_LINE	After the first pass, this should be false 
}	TokenNameRBRACE	
// end for loop 	TokenNameCOMMENT_LINE	end for loop 
// Check to see if we finished up the format string... 	TokenNameCOMMENT_LINE	Check to see if we finished up the format string... 
// Skip past all remaining letters or digits 	TokenNameCOMMENT_LINE	Skip past all remaining letters or digits 
while	TokenNamewhile	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
isLetterOrDigitAhead	TokenNameIdentifier	 is Letter Or Digit Ahead
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lastSepString	TokenNameIdentifier	 last Sep String
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
lastSepString	TokenNameIdentifier	 last Sep String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formatToken	TokenNameIdentifier	 format Token
=	TokenNameEQUAL	
formatTokenizer	TokenNameIdentifier	 format Tokenizer
.	TokenNameDOT	
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
formatToken	TokenNameIdentifier	 format Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
numStr	TokenNameIdentifier	 num Str
=	TokenNameEQUAL	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
numStr	TokenNameIdentifier	 num Str
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end formatNumberList method 	TokenNameCOMMENT_LINE	end formatNumberList method 
/* * Get Formatted number */	TokenNameCOMMENT_BLOCK	 Get Formatted number 
/** * Format the given number and store it in the given buffer * * * @param transformer non-null reference to the the current transform-time state. * @param contextNode The node that "." expresses. * @param numberType Type to format to * @param numberWidth Maximum length of formatted number * @param listElement Number to format * @param formattedNumber Buffer to store formatted number * * @throws javax.xml.transform.TransformerException */	TokenNameCOMMENT_JAVADOC	 Format the given number and store it in the given buffer * @param transformer non-null reference to the the current transform-time state. @param contextNode The node that "." expresses. @param numberType Type to format to @param numberWidth Maximum length of formatted number @param listElement Number to format @param formattedNumber Buffer to store formatted number * @throws javax.xml.transform.TransformerException 
private	TokenNameprivate	
void	TokenNamevoid	
getFormattedNumber	TokenNameIdentifier	 get Formatted Number
(	TokenNameLPAREN	
TransformerImpl	TokenNameIdentifier	 Transformer Impl
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
int	TokenNameint	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
char	TokenNamechar	
numberType	TokenNameIdentifier	 number Type
,	TokenNameCOMMA	
int	TokenNameint	
numberWidth	TokenNameIdentifier	 number Width
,	TokenNameCOMMA	
long	TokenNamelong	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
throws	TokenNamethrows	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
transform	TokenNameIdentifier	 transform
.	TokenNameDOT	
TransformerException	TokenNameIdentifier	 Transformer Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
letterVal	TokenNameIdentifier	 letter Val
=	TokenNameEQUAL	
(	TokenNameLPAREN	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
.	TokenNameDOT	
evaluate	TokenNameIdentifier	 evaluate
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
.	TokenNameDOT	
getXPathContext	TokenNameIdentifier	 get X Path Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Wrapper of Chars for converting integers into alpha counts. */	TokenNameCOMMENT_JAVADOC	 Wrapper of Chars for converting integers into alpha counts. 
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
alphaCountTable	TokenNameIdentifier	 alpha Count Table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
numberType	TokenNameIdentifier	 number Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
'A'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'a'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
==	TokenNameEQUAL_EQUAL	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
stringBuf	TokenNameIdentifier	 string Buf
=	TokenNameEQUAL	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
m_alphaCountTable	TokenNameIdentifier	 m alpha Count Table
,	TokenNameCOMMA	
stringBuf	TokenNameIdentifier	 string Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
stringBuf	TokenNameIdentifier	 string Buf
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
StringBufferPool	TokenNameIdentifier	 String Buffer Pool
.	TokenNameDOT	
free	TokenNameIdentifier	 free
(	TokenNameLPAREN	
stringBuf	TokenNameIdentifier	 string Buf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'I'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
long2roman	TokenNameIdentifier	 long2roman
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
'i'	TokenNameCharacterLiteral	
:	TokenNameCOLON	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
long2roman	TokenNameIdentifier	 long2roman
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
.	TokenNameDOT	
toLowerCase	TokenNameIdentifier	 to Lower Case
(	TokenNameLPAREN	
getLocale	TokenNameIdentifier	 get Locale
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
0x3042	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"ja"	TokenNameStringLiteral	ja
,	TokenNameCOMMA	
"JP"	TokenNameStringLiteral	JP
,	TokenNameCOMMA	
"HA"	TokenNameStringLiteral	HA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
int2singlealphaCount	TokenNameIdentifier	 int2singlealpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x3044	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"ja"	TokenNameStringLiteral	ja
,	TokenNameCOMMA	
"JP"	TokenNameStringLiteral	JP
,	TokenNameCOMMA	
"HI"	TokenNameStringLiteral	HI
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
int2singlealphaCount	TokenNameIdentifier	 int2singlealpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x30A2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"ja"	TokenNameStringLiteral	ja
,	TokenNameCOMMA	
"JP"	TokenNameStringLiteral	JP
,	TokenNameCOMMA	
"A"	TokenNameStringLiteral	A
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
int2singlealphaCount	TokenNameIdentifier	 int2singlealpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x30A4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"ja"	TokenNameStringLiteral	ja
,	TokenNameCOMMA	
"JP"	TokenNameStringLiteral	JP
,	TokenNameCOMMA	
"I"	TokenNameStringLiteral	I
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
int2singlealphaCount	TokenNameIdentifier	 int2singlealpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x4E00	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"zh"	TokenNameStringLiteral	zh
,	TokenNameCOMMA	
"CN"	TokenNameStringLiteral	CN
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x58F9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"zh"	TokenNameStringLiteral	zh
,	TokenNameCOMMA	
"TW"	TokenNameStringLiteral	TW
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x0E51	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"th"	TokenNameStringLiteral	th
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x05D0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"he"	TokenNameStringLiteral	he
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x10D0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"ka"	TokenNameStringLiteral	ka
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x03B1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"el"	TokenNameStringLiteral	el
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
0x0430	TokenNameIntegerLiteral	
:	TokenNameCOLON	
{	TokenNameLBRACE	
thisBundle	TokenNameIdentifier	 this Bundle
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
)	TokenNameRPAREN	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
loadResourceBundle	TokenNameIdentifier	 load Resource Bundle
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_BUNDLE_NAME	TokenNameIdentifier	 LANG  BUNDLE  NAME
,	TokenNameCOMMA	
new	TokenNamenew	
Locale	TokenNameIdentifier	 Locale
(	TokenNameLPAREN	
"cy"	TokenNameStringLiteral	cy
,	TokenNameCOMMA	
""	TokenNameStringLiteral	 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
letterVal	TokenNameIdentifier	 letter Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
letterVal	TokenNameIdentifier	 letter Val
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRVAL_TRADITIONAL	TokenNameIdentifier	 ATTRVAL  TRADITIONAL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
//if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 	TokenNameCOMMENT_LINE	if (m_lettervalue_avt != null && m_lettervalue_avt.equals(Constants.ATTRVAL_ALPHABETIC)) 
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
,	TokenNameCOMMA	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_ALPHABET	TokenNameIdentifier	 LANG  ALPHABET
)	TokenNameRPAREN	
,	TokenNameCOMMA	
formattedNumber	TokenNameIdentifier	 formatted Number
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
// "1" 	TokenNameCOMMENT_LINE	"1" 
DecimalFormat	TokenNameIdentifier	 Decimal Format
formatter	TokenNameIdentifier	 formatter
=	TokenNameEQUAL	
getNumberFormatter	TokenNameIdentifier	 get Number Formatter
(	TokenNameLPAREN	
transformer	TokenNameIdentifier	 transformer
,	TokenNameCOMMA	
contextNode	TokenNameIdentifier	 context Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
padString	TokenNameIdentifier	 pad String
=	TokenNameEQUAL	
formatter	TokenNameIdentifier	 formatter
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
numString	TokenNameIdentifier	 num String
=	TokenNameEQUAL	
formatter	TokenNameIdentifier	 formatter
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
)	TokenNameRPAREN	
:	TokenNameCOLON	
formatter	TokenNameIdentifier	 formatter
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
listElement	TokenNameIdentifier	 list Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
nPadding	TokenNameIdentifier	 n Padding
=	TokenNameEQUAL	
numberWidth	TokenNameIdentifier	 number Width
-	TokenNameMINUS	
numString	TokenNameIdentifier	 num String
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
nPadding	TokenNameIdentifier	 n Padding
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
padString	TokenNameIdentifier	 pad String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
formattedNumber	TokenNameIdentifier	 formatted Number
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
numString	TokenNameIdentifier	 num String
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Get a string value for zero, which is not really defined by the 1.0 spec, * thought I think it might be cleared up by the erreta. */	TokenNameCOMMENT_JAVADOC	 Get a string value for zero, which is not really defined by the 1.0 spec, thought I think it might be cleared up by the erreta. 
String	TokenNameIdentifier	 String
getZeroString	TokenNameIdentifier	 get Zero String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
+	TokenNamePLUS	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convert a long integer into alphabetic counting, in other words * count using the sequence A B C ... Z. * * @param val Value to convert -- must be greater than zero. * @param table a table containing one character for each digit in the radix * @return String representing alpha count of number. * @see TransformerImpl#DecimalToRoman * * Note that the radix of the conversion is inferred from the size * of the table. */	TokenNameCOMMENT_JAVADOC	 Convert a long integer into alphabetic counting, in other words count using the sequence A B C ... Z. * @param val Value to convert -- must be greater than zero. @param table a table containing one character for each digit in the radix @return String representing alpha count of number. @see TransformerImpl#DecimalToRoman * Note that the radix of the conversion is inferred from the size of the table. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
int2singlealphaCount	TokenNameIdentifier	 int2singlealpha Count
(	TokenNameLPAREN	
long	TokenNamelong	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
radix	TokenNameIdentifier	 radix
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: throw error on out of range input 	TokenNameCOMMENT_LINE	TODO: throw error on out of range input 
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>	TokenNameGREATER	
radix	TokenNameIdentifier	 radix
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getZeroString	TokenNameIdentifier	 get Zero String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
(	TokenNameLPAREN	
new	TokenNamenew	
Character	TokenNameIdentifier	 Character
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
val	TokenNameIdentifier	 val
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// index into table is off one, starts at 0 	TokenNameCOMMENT_LINE	index into table is off one, starts at 0 
}	TokenNameRBRACE	
/** * Convert a long integer into alphabetic counting, in other words * count using the sequence A B C ... Z AA AB AC.... etc. * * @param val Value to convert -- must be greater than zero. * @param table a table containing one character for each digit in the radix * @param aTable Array of alpha characters representing numbers * @param stringBuf Buffer where to save the string representing alpha count of number. * * @see TransformerImpl#DecimalToRoman * * Note that the radix of the conversion is inferred from the size * of the table. */	TokenNameCOMMENT_JAVADOC	 Convert a long integer into alphabetic counting, in other words count using the sequence A B C ... Z AA AB AC.... etc. * @param val Value to convert -- must be greater than zero. @param table a table containing one character for each digit in the radix @param aTable Array of alpha characters representing numbers @param stringBuf Buffer where to save the string representing alpha count of number. * @see TransformerImpl#DecimalToRoman * Note that the radix of the conversion is inferred from the size of the table. 
protected	TokenNameprotected	
void	TokenNamevoid	
int2alphaCount	TokenNameIdentifier	 int2alpha Count
(	TokenNameLPAREN	
long	TokenNamelong	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
aTable	TokenNameIdentifier	 a Table
,	TokenNameCOMMA	
FastStringBuffer	TokenNameIdentifier	 Fast String Buffer
stringBuf	TokenNameIdentifier	 string Buf
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
radix	TokenNameIdentifier	 radix
=	TokenNameEQUAL	
aTable	TokenNameIdentifier	 a Table
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
radix	TokenNameIdentifier	 radix
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// start table at 1, add last char at index 0. Reason explained above and below. 	TokenNameCOMMENT_LINE	start table at 1, add last char at index 0. Reason explained above and below. 
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
radix	TokenNameIdentifier	 radix
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
aTable	TokenNameIdentifier	 a Table
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
aTable	TokenNameIdentifier	 a Table
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Create a buffer to hold the result 	TokenNameCOMMENT_LINE	Create a buffer to hold the result 
// TODO: size of the table can be detereined by computing 	TokenNameCOMMENT_LINE	TODO: size of the table can be detereined by computing 
// logs of the radix. For now, we fake it. 	TokenNameCOMMENT_LINE	logs of the radix. For now, we fake it. 
char	TokenNamechar	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
100	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//some languages go left to right(ie. english), right to left (ie. Hebrew), 	TokenNameCOMMENT_LINE	some languages go left to right(ie. english), right to left (ie. Hebrew), 
//top to bottom (ie.Japanese), etc... Handle them differently 	TokenNameCOMMENT_LINE	top to bottom (ie.Japanese), etc... Handle them differently 
//String orientation = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_ORIENTATION); 	TokenNameCOMMENT_LINE	String orientation = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_ORIENTATION); 
// next character to set in the buffer 	TokenNameCOMMENT_LINE	next character to set in the buffer 
int	TokenNameint	
charPos	TokenNameIdentifier	 char Pos
;	TokenNameSEMICOLON	
charPos	TokenNameIdentifier	 char Pos
=	TokenNameEQUAL	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// work backward through buf[] 	TokenNameCOMMENT_LINE	work backward through buf[] 
// index in table of the last character that we stored 	TokenNameCOMMENT_LINE	index in table of the last character that we stored 
int	TokenNameint	
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// start off with anything other than zero to make correction work 	TokenNameCOMMENT_LINE	start off with anything other than zero to make correction work 
// Correction number 	TokenNameCOMMENT_LINE	Correction number 
// 	TokenNameCOMMENT_LINE	 
// Correction can take on exactly two values: 	TokenNameCOMMENT_LINE	Correction can take on exactly two values: 
// 	TokenNameCOMMENT_LINE	 
// 0 if the next character is to be emitted is usual 	TokenNameCOMMENT_LINE	0 if the next character is to be emitted is usual 
// 	TokenNameCOMMENT_LINE	 
// radix - 1 	TokenNameCOMMENT_LINE	radix - 1 
// if the next char to be emitted should be one less than 	TokenNameCOMMENT_LINE	if the next char to be emitted should be one less than 
// you would expect 	TokenNameCOMMENT_LINE	you would expect 
// 	TokenNameCOMMENT_LINE	 
// For example, consider radix 10, where 1="A" and 10="J" 	TokenNameCOMMENT_LINE	For example, consider radix 10, where 1="A" and 10="J" 
// 	TokenNameCOMMENT_LINE	 
// In this scheme, we count: A, B, C ... H, I, J (not A0 and certainly 	TokenNameCOMMENT_LINE	In this scheme, we count: A, B, C ... H, I, J (not A0 and certainly 
// not AJ), A1 	TokenNameCOMMENT_LINE	not AJ), A1 
// 	TokenNameCOMMENT_LINE	 
// So, how do we keep from emitting AJ for 10? After correctly emitting the 	TokenNameCOMMENT_LINE	So, how do we keep from emitting AJ for 10? After correctly emitting the 
// J, lookupIndex is zero. We now compute a correction number of 9 (radix-1). 	TokenNameCOMMENT_LINE	J, lookupIndex is zero. We now compute a correction number of 9 (radix-1). 
// In the following line, we'll compute (val+correction) % radix, which is, 	TokenNameCOMMENT_LINE	In the following line, we'll compute (val+correction) % radix, which is, 
// (val+9)/10. By this time, val is 1, so we compute (1+9) % 10, which 	TokenNameCOMMENT_LINE	(val+9)/10. By this time, val is 1, so we compute (1+9) % 10, which 
// is 10 % 10 or zero. So, we'll prepare to emit "JJ", but then we'll 	TokenNameCOMMENT_LINE	is 10 % 10 or zero. So, we'll prepare to emit "JJ", but then we'll 
// later suppress the leading J as representing zero (in the mod system, 	TokenNameCOMMENT_LINE	later suppress the leading J as representing zero (in the mod system, 
// it can represent either 10 or zero). In summary, the correction value of 	TokenNameCOMMENT_LINE	it can represent either 10 or zero). In summary, the correction value of 
// "radix-1" acts like "-1" when run through the mod operator, but with the 	TokenNameCOMMENT_LINE	"radix-1" acts like "-1" when run through the mod operator, but with the 
// desireable characteristic that it never produces a negative number. 	TokenNameCOMMENT_LINE	desireable characteristic that it never produces a negative number. 
long	TokenNamelong	
correction	TokenNameIdentifier	 correction
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// TODO: throw error on out of range input 	TokenNameCOMMENT_LINE	TODO: throw error on out of range input 
do	TokenNamedo	
{	TokenNameLBRACE	
// most of the correction calculation is explained above, the reason for the 	TokenNameCOMMENT_LINE	most of the correction calculation is explained above, the reason for the 
// term after the "|| " is that it correctly propagates carries across 	TokenNameCOMMENT_LINE	term after the "|| " is that it correctly propagates carries across 
// multiple columns. 	TokenNameCOMMENT_LINE	multiple columns. 
correction	TokenNameIdentifier	 correction
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
correction	TokenNameIdentifier	 correction
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
radix	TokenNameIdentifier	 radix
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
radix	TokenNameIdentifier	 radix
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// index in "table" of the next char to emit 	TokenNameCOMMENT_LINE	index in "table" of the next char to emit 
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
+	TokenNamePLUS	
correction	TokenNameIdentifier	 correction
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
radix	TokenNameIdentifier	 radix
;	TokenNameSEMICOLON	
// shift input by one "column" 	TokenNameCOMMENT_LINE	shift input by one "column" 
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
/	TokenNameDIVIDE	
radix	TokenNameIdentifier	 radix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if the next value we'd put out would be a leading zero, we're done. 	TokenNameCOMMENT_LINE	if the next value we'd put out would be a leading zero, we're done. 
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
val	TokenNameIdentifier	 val
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// put out the next character of output 	TokenNameCOMMENT_LINE	put out the next character of output 
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
--	TokenNameMINUS_MINUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
lookupIndex	TokenNameIdentifier	 lookup Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// left to right or top to bottom 	TokenNameCOMMENT_LINE	left to right or top to bottom 
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stringBuf	TokenNameIdentifier	 string Buf
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
,	TokenNameCOMMA	
charPos	TokenNameIdentifier	 char Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
charPos	TokenNameIdentifier	 char Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convert a long integer into traditional alphabetic counting, in other words * count using the traditional numbering. * * @param val Value to convert -- must be greater than zero. * @param thisBundle Resource bundle to use * * @return String representing alpha count of number. * @see XSLProcessor#DecimalToRoman * * Note that the radix of the conversion is inferred from the size * of the table. */	TokenNameCOMMENT_JAVADOC	 Convert a long integer into traditional alphabetic counting, in other words count using the traditional numbering. * @param val Value to convert -- must be greater than zero. @param thisBundle Resource bundle to use * @return String representing alpha count of number. @see XSLProcessor#DecimalToRoman * Note that the radix of the conversion is inferred from the size of the table. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
tradAlphaCount	TokenNameIdentifier	 trad Alpha Count
(	TokenNameLPAREN	
long	TokenNamelong	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
thisBundle	TokenNameIdentifier	 this Bundle
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if this number is larger than the largest number we can represent, error! 	TokenNameCOMMENT_LINE	if this number is larger than the largest number we can represent, error! 
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>	TokenNameGREATER	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ER_NUMBER_TOO_BIG	TokenNameIdentifier	 ER  NUMBER  TOO  BIG
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ERROR_STRING	TokenNameIdentifier	 ERROR  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
char	TokenNamechar	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// index in table of the last character that we stored 	TokenNameCOMMENT_LINE	index in table of the last character that we stored 
int	TokenNameint	
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// start off with anything other than zero to make correction work 	TokenNameCOMMENT_LINE	start off with anything other than zero to make correction work 
// Create a buffer to hold the result 	TokenNameCOMMENT_LINE	Create a buffer to hold the result 
// TODO: size of the table can be detereined by computing 	TokenNameCOMMENT_LINE	TODO: size of the table can be detereined by computing 
// logs of the radix. For now, we fake it. 	TokenNameCOMMENT_LINE	logs of the radix. For now, we fake it. 
char	TokenNamechar	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
100	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//some languages go left to right(ie. english), right to left (ie. Hebrew), 	TokenNameCOMMENT_LINE	some languages go left to right(ie. english), right to left (ie. Hebrew), 
//top to bottom (ie.Japanese), etc... Handle them differently 	TokenNameCOMMENT_LINE	top to bottom (ie.Japanese), etc... Handle them differently 
//String orientation = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_ORIENTATION); 	TokenNameCOMMENT_LINE	String orientation = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_ORIENTATION); 
// next character to set in the buffer 	TokenNameCOMMENT_LINE	next character to set in the buffer 
int	TokenNameint	
charPos	TokenNameIdentifier	 char Pos
;	TokenNameSEMICOLON	
charPos	TokenNameIdentifier	 char Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//start at 0 	TokenNameCOMMENT_LINE	start at 0 
// array of number groups: ie.1000, 100, 10, 1 	TokenNameCOMMENT_LINE	array of number groups: ie.1000, 100, 10, 1 
IntArrayWrapper	TokenNameIdentifier	 Int Array Wrapper
groups	TokenNameIdentifier	 groups
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IntArrayWrapper	TokenNameIdentifier	 Int Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_NUMBERGROUPS	TokenNameIdentifier	 LANG  NUMBERGROUPS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// array of tables of hundreds, tens, digits... 	TokenNameCOMMENT_LINE	array of tables of hundreds, tens, digits... 
StringArrayWrapper	TokenNameIdentifier	 String Array Wrapper
tables	TokenNameIdentifier	 tables
=	TokenNameEQUAL	
(	TokenNameLPAREN	
StringArrayWrapper	TokenNameIdentifier	 String Array Wrapper
)	TokenNameRPAREN	
(	TokenNameLPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_NUM_TABLES	TokenNameIdentifier	 LANG  NUM  TABLES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//some languages have additive alphabetical notation, 	TokenNameCOMMENT_LINE	some languages have additive alphabetical notation, 
//some multiplicative-additive, etc... Handle them differently. 	TokenNameCOMMENT_LINE	some multiplicative-additive, etc... Handle them differently. 
String	TokenNameIdentifier	 String
numbering	TokenNameIdentifier	 numbering
=	TokenNameEQUAL	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_NUMBERING	TokenNameIdentifier	 LANG  NUMBERING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// do multiplicative part first 	TokenNameCOMMENT_LINE	do multiplicative part first 
if	TokenNameif	
(	TokenNameLPAREN	
numbering	TokenNameIdentifier	 numbering
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_MULT_ADD	TokenNameIdentifier	 LANG  MULT  ADD
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
mult_order	TokenNameIdentifier	 mult order
=	TokenNameEQUAL	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
MULT_ORDER	TokenNameIdentifier	 MULT  ORDER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LongArrayWrapper	TokenNameIdentifier	 Long Array Wrapper
multiplier	TokenNameIdentifier	 multiplier
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LongArrayWrapper	TokenNameIdentifier	 Long Array Wrapper
)	TokenNameRPAREN	
(	TokenNameLPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_MULTIPLIER	TokenNameIdentifier	 LANG  MULTIPLIER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
zeroChar	TokenNameIdentifier	 zero Char
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
"zero"	TokenNameStringLiteral	zero
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// skip to correct multiplier 	TokenNameCOMMENT_LINE	skip to correct multiplier 
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
val	TokenNameIdentifier	 val
<	TokenNameLESS	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLong	TokenNameIdentifier	 get Long
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
//number is smaller than multipliers 	TokenNameCOMMENT_LINE	number is smaller than multipliers 
// some languages (ie chinese) put a zero character (and only one) when 	TokenNameCOMMENT_LINE	some languages (ie chinese) put a zero character (and only one) when 
// the multiplier is multiplied by zero. (ie, 1001 is 1X1000 + 0X100 + 0X10 + 1) 	TokenNameCOMMENT_LINE	the multiplier is multiplied by zero. (ie, 1001 is 1X1000 + 0X100 + 0X10 + 1) 
// 0X100 is replaced by the zero character, we don't need one for 0X10 	TokenNameCOMMENT_LINE	0X100 is replaced by the zero character, we don't need one for 0X10 
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
<	TokenNameLESS	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLong	TokenNameIdentifier	 get Long
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
zeroChar	TokenNameIdentifier	 zero Char
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
zeroChar	TokenNameIdentifier	 zero Char
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
zeroChar	TokenNameIdentifier	 zero Char
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>=	TokenNameGREATER_EQUAL	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLong	TokenNameIdentifier	 get Long
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
mult	TokenNameIdentifier	 mult
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
/	TokenNameDIVIDE	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLong	TokenNameIdentifier	 get Long
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
%	TokenNameREMAINDER	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLong	TokenNameIdentifier	 get Long
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// save this. 	TokenNameCOMMENT_LINE	save this. 
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// initialize for each table 	TokenNameCOMMENT_LINE	initialize for each table 
if	TokenNameif	
(	TokenNameLPAREN	
mult	TokenNameIdentifier	 mult
/	TokenNameDIVIDE	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getInt	TokenNameIdentifier	 get Int
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// look for right table 	TokenNameCOMMENT_LINE	look for right table 
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
// get the table 	TokenNameCOMMENT_LINE	get the table 
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
THEletters	TokenNameIdentifier	 TH Eletters
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
tables	TokenNameIdentifier	 tables
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
THEletters	TokenNameIdentifier	 TH Eletters
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
THEletters	TokenNameIdentifier	 TH Eletters
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
THEletters	TokenNameIdentifier	 TH Eletters
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
THEletters	TokenNameIdentifier	 TH Eletters
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// don't need this 	TokenNameCOMMENT_LINE	don't need this 
// index in "table" of the next char to emit 	TokenNameCOMMENT_LINE	index in "table" of the next char to emit 
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
mult	TokenNameIdentifier	 mult
/	TokenNameDIVIDE	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getInt	TokenNameIdentifier	 get Int
(	TokenNameLPAREN	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//this should not happen 	TokenNameCOMMENT_LINE	this should not happen 
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
mult	TokenNameIdentifier	 mult
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
char	TokenNamechar	
multiplierChar	TokenNameIdentifier	 multiplier Char
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
(	TokenNameLPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
LANG_MULTIPLIER_CHAR	TokenNameIdentifier	 LANG  MULTIPLIER  CHAR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// put out the next character of output 	TokenNameCOMMENT_LINE	put out the next character of output 
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
<	TokenNameLESS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mult_order	TokenNameIdentifier	 mult order
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
res	TokenNameIdentifier	 res
.	TokenNameDOT	
XResourceBundle	TokenNameIdentifier	 X Resource Bundle
.	TokenNameDOT	
MULT_PRECEDES	TokenNameIdentifier	 MULT  PRECEDES
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
multiplierChar	TokenNameIdentifier	 multiplier Char
;	TokenNameSEMICOLON	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
lookupIndex	TokenNameIdentifier	 lookup Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// don't put out 1 (ie 1X10 is just 10) 	TokenNameCOMMENT_LINE	don't put out 1 (ie 1X10 is just 10) 
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
lookupIndex	TokenNameIdentifier	 lookup Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
multiplierChar	TokenNameIdentifier	 multiplier Char
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// all done! 	TokenNameCOMMENT_LINE	all done! 
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ERROR_STRING	TokenNameIdentifier	 ERROR  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//end else 	TokenNameCOMMENT_LINE	end else 
}	TokenNameRBRACE	
// end while 	TokenNameCOMMENT_LINE	end while 
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end else if 	TokenNameCOMMENT_LINE	end else if 
}	TokenNameRBRACE	
// end do while 	TokenNameCOMMENT_LINE	end do while 
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
multiplier	TokenNameIdentifier	 multiplier
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now do additive part... 	TokenNameCOMMENT_LINE	Now do additive part... 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
tableName	TokenNameIdentifier	 table Name
;	TokenNameSEMICOLON	
// do this for each table of hundreds, tens, digits... 	TokenNameCOMMENT_LINE	do this for each table of hundreds, tens, digits... 
while	TokenNamewhile	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
/	TokenNameDIVIDE	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getInt	TokenNameIdentifier	 get Int
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// look for correct table 	TokenNameCOMMENT_LINE	look for correct table 
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
theletters	TokenNameIdentifier	 theletters
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CharArrayWrapper	TokenNameIdentifier	 Char Array Wrapper
)	TokenNameRPAREN	
thisBundle	TokenNameIdentifier	 this Bundle
.	TokenNameDOT	
getObject	TokenNameIdentifier	 get Object
(	TokenNameLPAREN	
tables	TokenNameIdentifier	 tables
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
theletters	TokenNameIdentifier	 theletters
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
// need to start filling the table up at index 1 	TokenNameCOMMENT_LINE	need to start filling the table up at index 1 
for	TokenNamefor	
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
theletters	TokenNameIdentifier	 theletters
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
theletters	TokenNameIdentifier	 theletters
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
theletters	TokenNameIdentifier	 theletters
.	TokenNameDOT	
getChar	TokenNameIdentifier	 get Char
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// don't need this 	TokenNameCOMMENT_LINE	don't need this 
// index in "table" of the next char to emit 	TokenNameCOMMENT_LINE	index in "table" of the next char to emit 
lookupIndex	TokenNameIdentifier	 lookup Index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
val	TokenNameIdentifier	 val
/	TokenNameDIVIDE	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getInt	TokenNameIdentifier	 get Int
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// shift input by one "column" 	TokenNameCOMMENT_LINE	shift input by one "column" 
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
val	TokenNameIdentifier	 val
%	TokenNameREMAINDER	
groups	TokenNameIdentifier	 groups
.	TokenNameDOT	
getInt	TokenNameIdentifier	 get Int
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this should not happen 	TokenNameCOMMENT_LINE	this should not happen 
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
val	TokenNameIdentifier	 val
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lookupIndex	TokenNameIdentifier	 lookup Index
<	TokenNameLESS	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// put out the next character of output 	TokenNameCOMMENT_LINE	put out the next character of output 
buf	TokenNameIdentifier	 buf
[	TokenNameLBRACKET	
charPos	TokenNameIdentifier	 char Pos
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
table	TokenNameIdentifier	 table
[	TokenNameLBRACKET	
lookupIndex	TokenNameIdentifier	 lookup Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// left to right or top to bottom 	TokenNameCOMMENT_LINE	left to right or top to bottom 
}	TokenNameRBRACE	
else	TokenNameelse	
return	TokenNamereturn	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ERROR_STRING	TokenNameIdentifier	 ERROR  STRING
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end while 	TokenNameCOMMENT_LINE	end while 
// String s = new String(buf, 0, charPos); 	TokenNameCOMMENT_LINE	String s = new String(buf, 0, charPos); 
return	TokenNamereturn	
new	TokenNamenew	
String	TokenNameIdentifier	 String
(	TokenNameLPAREN	
buf	TokenNameIdentifier	 buf
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
charPos	TokenNameIdentifier	 char Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Convert a long integer into roman numerals. * @param val Value to convert. * @param prefixesAreOK true_ to enable prefix notation (e.g. 4 = "IV"), * false_ to disable prefix notation (e.g. 4 = "IIII"). * @return Roman numeral string. * @see DecimalToRoman * @see m_romanConvertTable */	TokenNameCOMMENT_JAVADOC	 Convert a long integer into roman numerals. @param val Value to convert. @param prefixesAreOK true_ to enable prefix notation (e.g. 4 = "IV"), false_ to disable prefix notation (e.g. 4 = "IIII"). @return Roman numeral string. @see DecimalToRoman @see m_romanConvertTable 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
long2roman	TokenNameIdentifier	 long2roman
(	TokenNameLPAREN	
long	TokenNamelong	
val	TokenNameIdentifier	 val
,	TokenNameCOMMA	
boolean	TokenNameboolean	
prefixesAreOK	TokenNameIdentifier	 prefixes Are OK
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getZeroString	TokenNameIdentifier	 get Zero String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
String	TokenNameIdentifier	 String
roman	TokenNameIdentifier	 roman
=	TokenNameEQUAL	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
int	TokenNameint	
place	TokenNameIdentifier	 place
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
<=	TokenNameLESS_EQUAL	
3999L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>=	TokenNameGREATER_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_postValue	TokenNameIdentifier	 m post Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
roman	TokenNameIdentifier	 roman
+=	TokenNamePLUS_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_postLetter	TokenNameIdentifier	 m post Letter
;	TokenNameSEMICOLON	
val	TokenNameIdentifier	 val
-=	TokenNameMINUS_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_postValue	TokenNameIdentifier	 m post Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
prefixesAreOK	TokenNameIdentifier	 prefixes Are OK
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>=	TokenNameGREATER_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_preValue	TokenNameIdentifier	 m pre Value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
roman	TokenNameIdentifier	 roman
+=	TokenNamePLUS_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_preLetter	TokenNameIdentifier	 m pre Letter
;	TokenNameSEMICOLON	
val	TokenNameIdentifier	 val
-=	TokenNameMINUS_EQUAL	
m_romanConvertTable	TokenNameIdentifier	 m roman Convert Table
[	TokenNameLBRACKET	
place	TokenNameIdentifier	 place
]	TokenNameRBRACKET	
.	TokenNameDOT	
m_preValue	TokenNameIdentifier	 m pre Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
place	TokenNameIdentifier	 place
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
roman	TokenNameIdentifier	 roman
=	TokenNameEQUAL	
XSLTErrorResources	TokenNameIdentifier	 XSLT Error Resources
.	TokenNameDOT	
ERROR_STRING	TokenNameIdentifier	 ERROR  STRING
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
roman	TokenNameIdentifier	 roman
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end long2roman 	TokenNameCOMMENT_LINE	end long2roman 
/** * Call the children visitors. * @param visitor The visitor whose appropriate method will be called. */	TokenNameCOMMENT_JAVADOC	 Call the children visitors. @param visitor The visitor whose appropriate method will be called. 
public	TokenNamepublic	
void	TokenNamevoid	
callChildVisitors	TokenNameIdentifier	 call Child Visitors
(	TokenNameLPAREN	
XSLTVisitor	TokenNameIdentifier	 XSLT Visitor
visitor	TokenNameIdentifier	 visitor
,	TokenNameCOMMA	
boolean	TokenNameboolean	
callAttrs	TokenNameIdentifier	 call Attrs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
callAttrs	TokenNameIdentifier	 call Attrs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
)	TokenNameRPAREN	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
.	TokenNameDOT	
getExpression	TokenNameIdentifier	 get Expression
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
m_countMatchPattern	TokenNameIdentifier	 m count Match Pattern
,	TokenNameCOMMA	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
)	TokenNameRPAREN	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
.	TokenNameDOT	
getExpression	TokenNameIdentifier	 get Expression
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
m_fromMatchPattern	TokenNameIdentifier	 m from Match Pattern
,	TokenNameCOMMA	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_valueExpr	TokenNameIdentifier	 m value Expr
)	TokenNameRPAREN	
m_valueExpr	TokenNameIdentifier	 m value Expr
.	TokenNameDOT	
getExpression	TokenNameIdentifier	 get Expression
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
m_valueExpr	TokenNameIdentifier	 m value Expr
,	TokenNameCOMMA	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_format_avt	TokenNameIdentifier	 m format avt
)	TokenNameRPAREN	
m_format_avt	TokenNameIdentifier	 m format avt
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
)	TokenNameRPAREN	
m_groupingSeparator_avt	TokenNameIdentifier	 m grouping Separator avt
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
)	TokenNameRPAREN	
m_groupingSize_avt	TokenNameIdentifier	 m grouping Size avt
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_lang_avt	TokenNameIdentifier	 m lang avt
)	TokenNameRPAREN	
m_lang_avt	TokenNameIdentifier	 m lang avt
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
null	TokenNamenull	
!=	TokenNameNOT_EQUAL	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
)	TokenNameRPAREN	
m_lettervalue_avt	TokenNameIdentifier	 m lettervalue avt
.	TokenNameDOT	
callVisitors	TokenNameIdentifier	 call Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
callChildVisitors	TokenNameIdentifier	 call Child Visitors
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
,	TokenNameCOMMA	
callAttrs	TokenNameIdentifier	 call Attrs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This class returns tokens using non-alphanumberic * characters as delimiters. */	TokenNameCOMMENT_JAVADOC	 This class returns tokens using non-alphanumberic characters as delimiters. 
class	TokenNameclass	
NumberFormatStringTokenizer	TokenNameIdentifier	 Number Format String Tokenizer
{	TokenNameLBRACE	
/** Current position in the format string */	TokenNameCOMMENT_JAVADOC	 Current position in the format string 
private	TokenNameprivate	
int	TokenNameint	
currentPosition	TokenNameIdentifier	 current Position
;	TokenNameSEMICOLON	
/** Index of last character in the format string */	TokenNameCOMMENT_JAVADOC	 Index of last character in the format string 
private	TokenNameprivate	
int	TokenNameint	
maxPosition	TokenNameIdentifier	 max Position
;	TokenNameSEMICOLON	
/** Format string to be tokenized */	TokenNameCOMMENT_JAVADOC	 Format string to be tokenized 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
;	TokenNameSEMICOLON	
/** * Construct a NumberFormatStringTokenizer. * * @param str Format string to be tokenized */	TokenNameCOMMENT_JAVADOC	 Construct a NumberFormatStringTokenizer. * @param str Format string to be tokenized 
public	TokenNamepublic	
NumberFormatStringTokenizer	TokenNameIdentifier	 Number Format String Tokenizer
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
str	TokenNameIdentifier	 str
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
str	TokenNameIdentifier	 str
;	TokenNameSEMICOLON	
maxPosition	TokenNameIdentifier	 max Position
=	TokenNameEQUAL	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Reset tokenizer so that nextToken() starts from the beginning. */	TokenNameCOMMENT_JAVADOC	 Reset tokenizer so that nextToken() starts from the beginning. 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPosition	TokenNameIdentifier	 current Position
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the next token from this string tokenizer. * * @return the next token from this string tokenizer. * @throws NoSuchElementException if there are no more tokens in this * tokenizer's string. */	TokenNameCOMMENT_JAVADOC	 Returns the next token from this string tokenizer. * @return the next token from this string tokenizer. @throws NoSuchElementException if there are no more tokens in this tokenizer's string. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
nextToken	TokenNameIdentifier	 next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
>=	TokenNameGREATER_EQUAL	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
NoSuchElementException	TokenNameIdentifier	 No Such Element Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
currentPosition	TokenNameIdentifier	 current Position
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
<	TokenNameLESS	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPosition	TokenNameIdentifier	 current Position
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
==	TokenNameEQUAL_EQUAL	
currentPosition	TokenNameIdentifier	 current Position
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPosition	TokenNameIdentifier	 current Position
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
currentPosition	TokenNameIdentifier	 current Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tells if there is a digit or a letter character ahead. * * @return true if there is a number or character ahead. */	TokenNameCOMMENT_JAVADOC	 Tells if there is a digit or a letter character ahead. * @return true if there is a number or character ahead. 
public	TokenNamepublic	
boolean	TokenNameboolean	
isLetterOrDigitAhead	TokenNameIdentifier	 is Letter Or Digit Ahead
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
currentPosition	TokenNameIdentifier	 current Position
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
<	TokenNameLESS	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tells if there is a digit or a letter character ahead. * * @return true if there is a number or character ahead. */	TokenNameCOMMENT_JAVADOC	 Tells if there is a digit or a letter character ahead. * @return true if there is a number or character ahead. 
public	TokenNamepublic	
boolean	TokenNameboolean	
nextIsSep	TokenNameIdentifier	 next Is Sep
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tells if <code>nextToken</code> will throw an exception * if it is called. * * @return true if <code>nextToken</code> can be called * without throwing an exception. */	TokenNameCOMMENT_JAVADOC	 Tells if <code>nextToken</code> will throw an exception if it is called. * @return true if <code>nextToken</code> can be called without throwing an exception. 
public	TokenNamepublic	
boolean	TokenNameboolean	
hasMoreTokens	TokenNameIdentifier	 has More Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
currentPosition	TokenNameIdentifier	 current Position
>=	TokenNameGREATER_EQUAL	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
?	TokenNameQUESTION	
false	TokenNamefalse	
:	TokenNameCOLON	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates the number of times that this tokenizer's * <code>nextToken</code> method can be called before it generates an * exception. * * @return the number of tokens remaining in the string using the current * delimiter set. * @see java.util.StringTokenizer#nextToken() */	TokenNameCOMMENT_JAVADOC	 Calculates the number of times that this tokenizer's <code>nextToken</code> method can be called before it generates an exception. * @return the number of tokens remaining in the string using the current delimiter set. @see java.util.StringTokenizer#nextToken() 
public	TokenNamepublic	
int	TokenNameint	
countTokens	TokenNameIdentifier	 count Tokens
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
currpos	TokenNameIdentifier	 currpos
=	TokenNameEQUAL	
currentPosition	TokenNameIdentifier	 current Position
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
currpos	TokenNameIdentifier	 currpos
<	TokenNameLESS	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
currpos	TokenNameIdentifier	 currpos
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
currpos	TokenNameIdentifier	 currpos
<	TokenNameLESS	
maxPosition	TokenNameIdentifier	 max Position
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currpos	TokenNameIdentifier	 currpos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currpos	TokenNameIdentifier	 currpos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
==	TokenNameEQUAL_EQUAL	
currpos	TokenNameIdentifier	 currpos
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
Character	TokenNameIdentifier	 Character
.	TokenNameDOT	
isLetterOrDigit	TokenNameIdentifier	 is Letter Or Digit
(	TokenNameLPAREN	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
currpos	TokenNameIdentifier	 currpos
)	TokenNameRPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currpos	TokenNameIdentifier	 currpos
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
count	TokenNameIdentifier	 count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end NumberFormatStringTokenizer 	TokenNameCOMMENT_LINE	end NumberFormatStringTokenizer 
}	TokenNameRBRACE	
