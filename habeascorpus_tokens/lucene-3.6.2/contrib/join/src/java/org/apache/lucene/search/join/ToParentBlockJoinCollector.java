package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
join	TokenNameIdentifier	 join
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Arrays	TokenNameIdentifier	 Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriter	TokenNameIdentifier	 Index Writer
;	TokenNameSEMICOLON	
// javadocs 	TokenNameCOMMENT_LINE	javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Collector	TokenNameIdentifier	 Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FieldComparator	TokenNameIdentifier	 Field Comparator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FieldValueHitQueue	TokenNameIdentifier	 Field Value Hit Queue
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
ScoreCachingWrappingScorer	TokenNameIdentifier	 Score Caching Wrapping Scorer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Scorer	TokenNameIdentifier	 Scorer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Sort	TokenNameIdentifier	 Sort
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopDocs	TokenNameIdentifier	 Top Docs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopDocsCollector	TokenNameIdentifier	 Top Docs Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Weight	TokenNameIdentifier	 Weight
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
grouping	TokenNameIdentifier	 grouping
.	TokenNameDOT	
GroupDocs	TokenNameIdentifier	 Group Docs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
grouping	TokenNameIdentifier	 grouping
.	TokenNameDOT	
TopGroups	TokenNameIdentifier	 Top Groups
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
/** Collects parent document hits for a Query containing one more more * BlockJoinQuery clauses, sorted by the * specified parent Sort. Note that this cannot perform * arbitrary joins; rather, it requires that all joined * documents are indexed as a doc block (using {@link * IndexWriter#addDocuments} or {@link * IndexWriter#updateDocuments}). Ie, the join is computed * at index time. * * <p>The parent Sort must only use * fields from the parent documents; sorting by field in * the child documents is not supported.</p> * * <p>You should only use this * collector if one or more of the clauses in the query is * a {@link ToParentBlockJoinQuery}. This collector will find those query * clauses and record the matching child documents for the * top scoring parent documents.</p> * * <p>Multiple joins (star join) and nested joins and a mix * of the two are allowed, as long as in all cases the * documents corresponding to a single row of each joined * parent table were indexed as a doc block.</p> * * <p>For the simple star join you can retrieve the * {@link TopGroups} instance containing each {@link ToParentBlockJoinQuery}'s * matching child documents for the top parent groups, * using {@link #getTopGroups}. Ie, * a single query, which will contain two or more * {@link ToParentBlockJoinQuery}'s as clauses representing the star join, * can then retrieve two or more {@link TopGroups} instances.</p> * * <p>For nested joins, the query will run correctly (ie, * match the right parent and child documents), however, * because TopGroups is currently unable to support nesting * (each group is not able to hold another TopGroups), you * are only able to retrieve the TopGroups of the first * join. The TopGroups of the nested joins will not be * correct. * * See {@link org.apache.lucene.search.join} for a code * sample. * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Collects parent document hits for a Query containing one more more BlockJoinQuery clauses, sorted by the specified parent Sort. Note that this cannot perform arbitrary joins; rather, it requires that all joined documents are indexed as a doc block (using {@link IndexWriter#addDocuments} or {@link IndexWriter#updateDocuments}). Ie, the join is computed at index time. * <p>The parent Sort must only use fields from the parent documents; sorting by field in the child documents is not supported.</p> * <p>You should only use this collector if one or more of the clauses in the query is a {@link ToParentBlockJoinQuery}. This collector will find those query clauses and record the matching child documents for the top scoring parent documents.</p> * <p>Multiple joins (star join) and nested joins and a mix of the two are allowed, as long as in all cases the documents corresponding to a single row of each joined parent table were indexed as a doc block.</p> * <p>For the simple star join you can retrieve the {@link TopGroups} instance containing each {@link ToParentBlockJoinQuery}'s matching child documents for the top parent groups, using {@link #getTopGroups}. Ie, a single query, which will contain two or more {@link ToParentBlockJoinQuery}'s as clauses representing the star join, can then retrieve two or more {@link TopGroups} instances.</p> * <p>For nested joins, the query will run correctly (ie, match the right parent and child documents), however, because TopGroups is currently unable to support nesting (each group is not able to hold another TopGroups), you are only able to retrieve the TopGroups of the first join. The TopGroups of the nested joins will not be correct. * See {@link org.apache.lucene.search.join} for a code sample. * @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
ToParentBlockJoinCollector	TokenNameIdentifier	 To Parent Block Join Collector
extends	TokenNameextends	
Collector	TokenNameIdentifier	 Collector
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
;	TokenNameSEMICOLON	
// Maps each BlockJoinQuery instance to its "slot" in 	TokenNameCOMMENT_LINE	Maps each BlockJoinQuery instance to its "slot" in 
// joinScorers and in OneGroup's cached doc/scores/count: 	TokenNameCOMMENT_LINE	joinScorers and in OneGroup's cached doc/scores/count: 
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
joinQueryID	TokenNameIdentifier	 join Query ID
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
numParentHits	TokenNameIdentifier	 num Parent Hits
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FieldValueHitQueue	TokenNameIdentifier	 Field Value Hit Queue
<	TokenNameLESS	
OneGroup	TokenNameIdentifier	 One Group
>	TokenNameGREATER	
queue	TokenNameIdentifier	 queue
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FieldComparator	TokenNameIdentifier	 Field Comparator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
comparators	TokenNameIdentifier	 comparators
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
reverseMul	TokenNameIdentifier	 reverse Mul
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
compEnd	TokenNameIdentifier	 comp End
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
trackMaxScore	TokenNameIdentifier	 track Max Score
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
trackScores	TokenNameIdentifier	 track Scores
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
joinScorers	TokenNameIdentifier	 join Scorers
=	TokenNameEQUAL	
new	TokenNamenew	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IndexReader	TokenNameIdentifier	 Index Reader
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
queueFull	TokenNameIdentifier	 queue Full
;	TokenNameSEMICOLON	
private	TokenNameprivate	
OneGroup	TokenNameIdentifier	 One Group
bottom	TokenNameIdentifier	 bottom
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
totalHitCount	TokenNameIdentifier	 total Hit Count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
/* Creates a ToParentBlockJoinCollector. The provided sort must * not be null. If you pass true trackScores, all * ToParentBlockQuery instances must not use * ScoreMode.None. */	TokenNameCOMMENT_BLOCK	 Creates a ToParentBlockJoinCollector. The provided sort must not be null. If you pass true trackScores, all ToParentBlockQuery instances must not use ScoreMode.None. 
public	TokenNamepublic	
ToParentBlockJoinCollector	TokenNameIdentifier	 To Parent Block Join Collector
(	TokenNameLPAREN	
Sort	TokenNameIdentifier	 Sort
sort	TokenNameIdentifier	 sort
,	TokenNameCOMMA	
int	TokenNameint	
numParentHits	TokenNameIdentifier	 num Parent Hits
,	TokenNameCOMMA	
boolean	TokenNameboolean	
trackScores	TokenNameIdentifier	 track Scores
,	TokenNameCOMMA	
boolean	TokenNameboolean	
trackMaxScore	TokenNameIdentifier	 track Max Score
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// TODO: allow null sort to be specialized to relevance 	TokenNameCOMMENT_LINE	TODO: allow null sort to be specialized to relevance 
// only collector 	TokenNameCOMMENT_LINE	only collector 
this	TokenNamethis	
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
=	TokenNameEQUAL	
sort	TokenNameIdentifier	 sort
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
trackMaxScore	TokenNameIdentifier	 track Max Score
=	TokenNameEQUAL	
trackMaxScore	TokenNameIdentifier	 track Max Score
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
trackScores	TokenNameIdentifier	 track Scores
=	TokenNameEQUAL	
trackScores	TokenNameIdentifier	 track Scores
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
numParentHits	TokenNameIdentifier	 num Parent Hits
=	TokenNameEQUAL	
numParentHits	TokenNameIdentifier	 num Parent Hits
;	TokenNameSEMICOLON	
queue	TokenNameIdentifier	 queue
=	TokenNameEQUAL	
FieldValueHitQueue	TokenNameIdentifier	 Field Value Hit Queue
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sort	TokenNameIdentifier	 sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
numParentHits	TokenNameIdentifier	 num Parent Hits
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
comparators	TokenNameIdentifier	 comparators
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
getComparators	TokenNameIdentifier	 get Comparators
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reverseMul	TokenNameIdentifier	 reverse Mul
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
getReverseMul	TokenNameIdentifier	 get Reverse Mul
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compEnd	TokenNameIdentifier	 comp End
=	TokenNameEQUAL	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
OneGroup	TokenNameIdentifier	 One Group
extends	TokenNameextends	
FieldValueHitQueue	TokenNameIdentifier	 Field Value Hit Queue
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
{	TokenNameLBRACE	
public	TokenNamepublic	
OneGroup	TokenNameIdentifier	 One Group
(	TokenNameLPAREN	
int	TokenNameint	
comparatorSlot	TokenNameIdentifier	 comparator Slot
,	TokenNameCOMMA	
int	TokenNameint	
parentDoc	TokenNameIdentifier	 parent Doc
,	TokenNameCOMMA	
float	TokenNamefloat	
parentScore	TokenNameIdentifier	 parent Score
,	TokenNameCOMMA	
int	TokenNameint	
numJoins	TokenNameIdentifier	 num Joins
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doScores	TokenNameIdentifier	 do Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
comparatorSlot	TokenNameIdentifier	 comparator Slot
,	TokenNameCOMMA	
parentDoc	TokenNameIdentifier	 parent Doc
,	TokenNameCOMMA	
parentScore	TokenNameIdentifier	 parent Score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numJoins	TokenNameIdentifier	 num Joins
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
joinID	TokenNameIdentifier	 join ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
joinID	TokenNameIdentifier	 join ID
<	TokenNameLESS	
numJoins	TokenNameIdentifier	 num Joins
;	TokenNameSEMICOLON	
joinID	TokenNameIdentifier	 join ID
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
docs	TokenNameIdentifier	 docs
[	TokenNameLBRACKET	
joinID	TokenNameIdentifier	 join ID
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
doScores	TokenNameIdentifier	 do Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scores	TokenNameIdentifier	 scores
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
numJoins	TokenNameIdentifier	 num Joins
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
joinID	TokenNameIdentifier	 join ID
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
joinID	TokenNameIdentifier	 join ID
<	TokenNameLESS	
numJoins	TokenNameIdentifier	 num Joins
;	TokenNameSEMICOLON	
joinID	TokenNameIdentifier	 join ID
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
scores	TokenNameIdentifier	 scores
[	TokenNameLBRACKET	
joinID	TokenNameIdentifier	 join ID
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
counts	TokenNameIdentifier	 counts
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
numJoins	TokenNameIdentifier	 num Joins
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
docs	TokenNameIdentifier	 docs
;	TokenNameSEMICOLON	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
scores	TokenNameIdentifier	 scores
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
counts	TokenNameIdentifier	 counts
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
int	TokenNameint	
parentDoc	TokenNameIdentifier	 parent Doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("C parentDoc=" + parentDoc); 	TokenNameCOMMENT_LINE	System.out.println("C parentDoc=" + parentDoc); 
totalHitCount	TokenNameIdentifier	 total Hit Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
NaN	TokenNameIdentifier	 Na N
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
trackMaxScore	TokenNameIdentifier	 track Max Score
)	TokenNameRPAREN	
{	TokenNameLBRACE	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
score	TokenNameIdentifier	 score
>	TokenNameGREATER	
maxScore	TokenNameIdentifier	 max Score
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// TODO: we could sweep all joinScorers here and 	TokenNameCOMMENT_LINE	TODO: we could sweep all joinScorers here and 
// aggregate total child hit count, so we can fill this 	TokenNameCOMMENT_LINE	aggregate total child hit count, so we can fill this 
// in getTopGroups (we wire it to 0 now) 	TokenNameCOMMENT_LINE	in getTopGroups (we wire it to 0 now) 
if	TokenNameif	
(	TokenNameLPAREN	
queueFull	TokenNameIdentifier	 queue Full
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" queueFull"); 	TokenNameCOMMENT_LINE	System.out.println(" queueFull"); 
// Fastmatch: return if this hit is not competitive 	TokenNameCOMMENT_LINE	Fastmatch: return if this hit is not competitive 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
reverseMul	TokenNameIdentifier	 reverse Mul
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
*	TokenNameMULTIPLY	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
compareBottom	TokenNameIdentifier	 compare Bottom
(	TokenNameLPAREN	
parentDoc	TokenNameIdentifier	 parent Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely not competitive. 	TokenNameCOMMENT_LINE	Definitely not competitive. 
//System.out.println(" skip"); 	TokenNameCOMMENT_LINE	System.out.println(" skip"); 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Definitely competitive. 	TokenNameCOMMENT_LINE	Definitely competitive. 
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
compEnd	TokenNameIdentifier	 comp End
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Here c=0. If we're at the last comparator, this doc is not 	TokenNameCOMMENT_LINE	Here c=0. If we're at the last comparator, this doc is not 
// competitive, since docs are visited in doc Id order, which means 	TokenNameCOMMENT_LINE	competitive, since docs are visited in doc Id order, which means 
// this doc cannot compete with any other document in the queue. 	TokenNameCOMMENT_LINE	this doc cannot compete with any other document in the queue. 
//System.out.println(" skip"); 	TokenNameCOMMENT_LINE	System.out.println(" skip"); 
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//System.out.println(" competes! doc=" + (docBase + parentDoc)); 	TokenNameCOMMENT_LINE	System.out.println(" competes! doc=" + (docBase + parentDoc)); 
// This hit is competitive - replace bottom element in queue & adjustTop 	TokenNameCOMMENT_LINE	This hit is competitive - replace bottom element in queue & adjustTop 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
slot	TokenNameIdentifier	 slot
,	TokenNameCOMMA	
parentDoc	TokenNameIdentifier	 parent Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
trackMaxScore	TokenNameIdentifier	 track Max Score
&&	TokenNameAND_AND	
trackScores	TokenNameIdentifier	 track Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
parentDoc	TokenNameIdentifier	 parent Doc
;	TokenNameSEMICOLON	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
copyGroups	TokenNameIdentifier	 copy Groups
(	TokenNameLPAREN	
bottom	TokenNameIdentifier	 bottom
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bottom	TokenNameIdentifier	 bottom
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
updateTop	TokenNameIdentifier	 update Top
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
slot	TokenNameIdentifier	 slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Startup transient: queue is not yet full: 	TokenNameCOMMENT_LINE	Startup transient: queue is not yet full: 
final	TokenNamefinal	
int	TokenNameint	
comparatorSlot	TokenNameIdentifier	 comparator Slot
=	TokenNameEQUAL	
totalHitCount	TokenNameIdentifier	 total Hit Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Copy hit into queue 	TokenNameCOMMENT_LINE	Copy hit into queue 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
comparatorSlot	TokenNameIdentifier	 comparator Slot
,	TokenNameCOMMA	
parentDoc	TokenNameIdentifier	 parent Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" startup: new OG doc=" + (docBase+parentDoc)); 	TokenNameCOMMENT_LINE	System.out.println(" startup: new OG doc=" + (docBase+parentDoc)); 
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
=	TokenNameEQUAL	
new	TokenNamenew	
OneGroup	TokenNameIdentifier	 One Group
(	TokenNameLPAREN	
comparatorSlot	TokenNameIdentifier	 comparator Slot
,	TokenNameCOMMA	
docBase	TokenNameIdentifier	 doc Base
+	TokenNamePLUS	
parentDoc	TokenNameIdentifier	 parent Doc
,	TokenNameCOMMA	
score	TokenNameIdentifier	 score
,	TokenNameCOMMA	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
,	TokenNameCOMMA	
trackScores	TokenNameIdentifier	 track Scores
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
=	TokenNameEQUAL	
currentReader	TokenNameIdentifier	 current Reader
;	TokenNameSEMICOLON	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
copyGroups	TokenNameIdentifier	 copy Groups
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bottom	TokenNameIdentifier	 bottom
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
queueFull	TokenNameIdentifier	 queue Full
=	TokenNameEQUAL	
totalHitCount	TokenNameIdentifier	 total Hit Count
==	TokenNameEQUAL_EQUAL	
numParentHits	TokenNameIdentifier	 num Parent Hits
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
queueFull	TokenNameIdentifier	 queue Full
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// End of startup transient: queue just filled up: 	TokenNameCOMMENT_LINE	End of startup transient: queue just filled up: 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
setBottom	TokenNameIdentifier	 set Bottom
(	TokenNameLPAREN	
bottom	TokenNameIdentifier	 bottom
.	TokenNameDOT	
slot	TokenNameIdentifier	 slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Pulls out child doc and scores for all join queries: 	TokenNameCOMMENT_LINE	Pulls out child doc and scores for all join queries: 
private	TokenNameprivate	
void	TokenNamevoid	
copyGroups	TokenNameIdentifier	 copy Groups
(	TokenNameLPAREN	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// While rare, it's possible top arrays could be too 	TokenNameCOMMENT_LINE	While rare, it's possible top arrays could be too 
// short if join query had null scorer on first 	TokenNameCOMMENT_LINE	short if join query had null scorer on first 
// segment(s) but then became non-null on later segments 	TokenNameCOMMENT_LINE	segment(s) but then became non-null on later segments 
final	TokenNamefinal	
int	TokenNameint	
numSubScorers	TokenNameIdentifier	 num Sub Scorers
=	TokenNameEQUAL	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
numSubScorers	TokenNameIdentifier	 num Sub Scorers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// While rare, this could happen if join query had 	TokenNameCOMMENT_LINE	While rare, this could happen if join query had 
// null scorer on first segment(s) but then became 	TokenNameCOMMENT_LINE	null scorer on first segment(s) but then became 
// non-null on later segments 	TokenNameCOMMENT_LINE	non-null on later segments 
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
numSubScorers	TokenNameIdentifier	 num Sub Scorers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
trackScores	TokenNameIdentifier	 track Scores
&&	TokenNameAND_AND	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
numSubScorers	TokenNameIdentifier	 num Sub Scorers
)	TokenNameRPAREN	
{	TokenNameLBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println("copyGroups parentDoc=" + og.doc); 	TokenNameCOMMENT_LINE	System.out.println("copyGroups parentDoc=" + og.doc); 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
scorerIDX	TokenNameIdentifier	 scorer IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
scorerIDX	TokenNameIdentifier	 scorer IDX
<	TokenNameLESS	
numSubScorers	TokenNameIdentifier	 num Sub Scorers
;	TokenNameSEMICOLON	
scorerIDX	TokenNameIdentifier	 scorer IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
joinScorer	TokenNameIdentifier	 join Scorer
=	TokenNameEQUAL	
joinScorers	TokenNameIdentifier	 join Scorers
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
//System.out.println(" scorer=" + joinScorer); 	TokenNameCOMMENT_LINE	System.out.println(" scorer=" + joinScorer); 
if	TokenNameif	
(	TokenNameLPAREN	
joinScorer	TokenNameIdentifier	 join Scorer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
joinScorer	TokenNameIdentifier	 join Scorer
.	TokenNameDOT	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" count=" + og.counts[scorerIDX]); 	TokenNameCOMMENT_LINE	System.out.println(" count=" + og.counts[scorerIDX]); 
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
joinScorer	TokenNameIdentifier	 join Scorer
.	TokenNameDOT	
swapChildDocs	TokenNameIdentifier	 swap Child Docs
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* for(int idx=0;idx<og.counts[scorerIDX];idx++) { System.out.println(" docs[" + idx + "]=" + og.docs[scorerIDX][idx]); } */	TokenNameCOMMENT_BLOCK	 for(int idx=0;idx<og.counts[scorerIDX];idx++) { System.out.println(" docs[" + idx + "]=" + og.docs[scorerIDX][idx]); } 
if	TokenNameif	
(	TokenNameLPAREN	
trackScores	TokenNameIdentifier	 track Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
joinScorer	TokenNameIdentifier	 join Scorer
.	TokenNameDOT	
swapChildScores	TokenNameIdentifier	 swap Child Scores
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
[	TokenNameLBRACKET	
scorerIDX	TokenNameIdentifier	 scorer IDX
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
int	TokenNameint	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
currentReader	TokenNameIdentifier	 current Reader
=	TokenNameEQUAL	
reader	TokenNameIdentifier	 reader
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
=	TokenNameEQUAL	
docBase	TokenNameIdentifier	 doc Base
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
compIDX	TokenNameIdentifier	 comp IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
acceptsDocsOutOfOrder	TokenNameIdentifier	 accepts Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
enroll	TokenNameIdentifier	 enroll
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
slot	TokenNameIdentifier	 slot
=	TokenNameEQUAL	
joinQueryID	TokenNameIdentifier	 join Query ID
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
slot	TokenNameIdentifier	 slot
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
joinQueryID	TokenNameIdentifier	 join Query ID
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("found JQ: " + query + " slot=" + joinScorers.length); 	TokenNameCOMMENT_LINE	System.out.println("found JQ: " + query + " slot=" + joinScorers.length); 
final	TokenNamefinal	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArray	TokenNameIdentifier	 new Array
=	TokenNameEQUAL	
new	TokenNamenew	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
+	TokenNamePLUS	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
joinScorers	TokenNameIdentifier	 join Scorers
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
joinScorers	TokenNameIdentifier	 join Scorers
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
;	TokenNameSEMICOLON	
joinScorers	TokenNameIdentifier	 join Scorers
[	TokenNameLBRACKET	
joinScorers	TokenNameIdentifier	 join Scorers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
joinScorers	TokenNameIdentifier	 join Scorers
[	TokenNameLBRACKET	
slot	TokenNameIdentifier	 slot
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
scorer	TokenNameIdentifier	 scorer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("C.setScorer scorer=" + scorer); 	TokenNameCOMMENT_LINE	System.out.println("C.setScorer scorer=" + scorer); 
// Since we invoke .score(), and the comparators likely 	TokenNameCOMMENT_LINE	Since we invoke .score(), and the comparators likely 
// do as well, cache it so it's only "really" computed 	TokenNameCOMMENT_LINE	do as well, cache it so it's only "really" computed 
// once: 	TokenNameCOMMENT_LINE	once: 
this	TokenNamethis	
.	TokenNameDOT	
scorer	TokenNameIdentifier	 scorer
=	TokenNameEQUAL	
new	TokenNamenew	
ScoreCachingWrappingScorer	TokenNameIdentifier	 Score Caching Wrapping Scorer
(	TokenNameLPAREN	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
compIDX	TokenNameIdentifier	 comp IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
compIDX	TokenNameIdentifier	 comp IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
compIDX	TokenNameIdentifier	 comp IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
fill	TokenNameIdentifier	 fill
(	TokenNameLPAREN	
joinScorers	TokenNameIdentifier	 join Scorers
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Find any BlockJoinScorers out there: 	TokenNameCOMMENT_LINE	Find any BlockJoinScorers out there: 
scorer	TokenNameIdentifier	 scorer
.	TokenNameDOT	
visitScorers	TokenNameIdentifier	 visit Scorers
(	TokenNameLPAREN	
new	TokenNamenew	
Scorer	TokenNameIdentifier	 Scorer
.	TokenNameDOT	
ScorerVisitor	TokenNameIdentifier	 Scorer Visitor
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
visitOptional	TokenNameIdentifier	 visit Optional
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("visitOpt"); 	TokenNameCOMMENT_LINE	System.out.println("visitOpt"); 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
instanceof	TokenNameinstanceof	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enroll	TokenNameIdentifier	 enroll
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
)	TokenNameRPAREN	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
visitRequired	TokenNameIdentifier	 visit Required
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("visitReq parent=" + parent + " child=" + child + " scorer=" + scorer); 	TokenNameCOMMENT_LINE	System.out.println("visitReq parent=" + parent + " child=" + child + " scorer=" + scorer); 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
instanceof	TokenNameinstanceof	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enroll	TokenNameIdentifier	 enroll
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
)	TokenNameRPAREN	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
visitProhibited	TokenNameIdentifier	 visit Prohibited
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println("visitProh"); 	TokenNameCOMMENT_LINE	System.out.println("visitProh"); 
if	TokenNameif	
(	TokenNameLPAREN	
child	TokenNameIdentifier	 child
instanceof	TokenNameinstanceof	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
enroll	TokenNameIdentifier	 enroll
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
child	TokenNameIdentifier	 child
,	TokenNameCOMMA	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
.	TokenNameDOT	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
)	TokenNameRPAREN	
scorer	TokenNameIdentifier	 scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
FakeScorer	TokenNameIdentifier	 Fake Scorer
extends	TokenNameextends	
Scorer	TokenNameIdentifier	 Scorer
{	TokenNameLBRACE	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
public	TokenNamepublic	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
)	TokenNameRPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
score	TokenNameIdentifier	 score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
int	TokenNameint	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
OneGroup	TokenNameIdentifier	 One Group
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sortedGroups	TokenNameIdentifier	 sorted Groups
;	TokenNameSEMICOLON	
private	TokenNameprivate	
void	TokenNamevoid	
sortQueue	TokenNameIdentifier	 sort Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sortedGroups	TokenNameIdentifier	 sorted Groups
=	TokenNameEQUAL	
new	TokenNamenew	
OneGroup	TokenNameIdentifier	 One Group
[	TokenNameLBRACKET	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
downTo	TokenNameIdentifier	 down To
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
downTo	TokenNameIdentifier	 down To
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sortedGroups	TokenNameIdentifier	 sorted Groups
[	TokenNameLBRACKET	
downTo	TokenNameIdentifier	 down To
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Return the TopGroups for the specified * BlockJoinQuery. The groupValue of each GroupDocs will * be the parent docID for that group. Note that the * {@link GroupDocs#totalHits}, which would be the * total number of child documents matching that parent, * is not computed (will always be 0). Returns null if * no groups matched. */	TokenNameCOMMENT_JAVADOC	 Return the TopGroups for the specified BlockJoinQuery. The groupValue of each GroupDocs will be the parent docID for that group. Note that the {@link GroupDocs#totalHits}, which would be the total number of child documents matching that parent, is not computed (will always be 0). Returns null if no groups matched. 
@	TokenNameAT	
SuppressWarnings	TokenNameIdentifier	 Suppress Warnings
(	TokenNameLPAREN	
"unchecked"	TokenNameStringLiteral	unchecked
)	TokenNameRPAREN	
public	TokenNamepublic	
TopGroups	TokenNameIdentifier	 Top Groups
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
getTopGroups	TokenNameIdentifier	 get Top Groups
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
query	TokenNameIdentifier	 query
,	TokenNameCOMMA	
Sort	TokenNameIdentifier	 Sort
withinGroupSort	TokenNameIdentifier	 within Group Sort
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
int	TokenNameint	
withinGroupOffset	TokenNameIdentifier	 within Group Offset
,	TokenNameCOMMA	
boolean	TokenNameboolean	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
Integer	TokenNameIdentifier	 Integer
_slot	TokenNameIdentifier	 slot
=	TokenNameEQUAL	
joinQueryID	TokenNameIdentifier	 join Query ID
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
query	TokenNameIdentifier	 query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
_slot	TokenNameIdentifier	 slot
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
totalHitCount	TokenNameIdentifier	 total Hit Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"the Query did not contain the provided BlockJoinQuery"	TokenNameStringLiteral	the Query did not contain the provided BlockJoinQuery
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// unbox once 	TokenNameCOMMENT_LINE	unbox once 
final	TokenNamefinal	
int	TokenNameint	
slot	TokenNameIdentifier	 slot
=	TokenNameEQUAL	
_slot	TokenNameIdentifier	 slot
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sortedGroups	TokenNameIdentifier	 sorted Groups
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
>=	TokenNameGREATER_EQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sortQueue	TokenNameIdentifier	 sort Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
offset	TokenNameIdentifier	 offset
>	TokenNameGREATER	
sortedGroups	TokenNameIdentifier	 sorted Groups
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
FakeScorer	TokenNameIdentifier	 Fake Scorer
fakeScorer	TokenNameIdentifier	 fake Scorer
=	TokenNameEQUAL	
new	TokenNamenew	
FakeScorer	TokenNameIdentifier	 Fake Scorer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
GroupDocs	TokenNameIdentifier	 Group Docs
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
groups	TokenNameIdentifier	 groups
=	TokenNameEQUAL	
new	TokenNamenew	
GroupDocs	TokenNameIdentifier	 Group Docs
[	TokenNameLBRACKET	
sortedGroups	TokenNameIdentifier	 sorted Groups
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
groupIDX	TokenNameIdentifier	 group IDX
=	TokenNameEQUAL	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
groupIDX	TokenNameIdentifier	 group IDX
<	TokenNameLESS	
sortedGroups	TokenNameIdentifier	 sorted Groups
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
groupIDX	TokenNameIdentifier	 group IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
OneGroup	TokenNameIdentifier	 One Group
og	TokenNameIdentifier	 og
=	TokenNameEQUAL	
sortedGroups	TokenNameIdentifier	 sorted Groups
[	TokenNameLBRACKET	
groupIDX	TokenNameIdentifier	 group IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// At this point we hold all docs w/ in each group, 	TokenNameCOMMENT_LINE	At this point we hold all docs w/ in each group, 
// unsorted; we now sort them: 	TokenNameCOMMENT_LINE	unsorted; we now sort them: 
final	TokenNamefinal	
TopDocsCollector	TokenNameIdentifier	 Top Docs Collector
collector	TokenNameIdentifier	 collector
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
withinGroupSort	TokenNameIdentifier	 within Group Sort
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sort by score 	TokenNameCOMMENT_LINE	Sort by score 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
trackScores	TokenNameIdentifier	 track Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"cannot sort by relevance within group: trackScores=false"	TokenNameStringLiteral	cannot sort by relevance within group: trackScores=false
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopScoreDocCollector	TokenNameIdentifier	 Top Score Doc Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Sort by fields 	TokenNameCOMMENT_LINE	Sort by fields 
collector	TokenNameIdentifier	 collector
=	TokenNameEQUAL	
TopFieldCollector	TokenNameIdentifier	 Top Field Collector
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
withinGroupSort	TokenNameIdentifier	 within Group Sort
,	TokenNameCOMMA	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
,	TokenNameCOMMA	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
,	TokenNameCOMMA	
trackScores	TokenNameIdentifier	 track Scores
,	TokenNameCOMMA	
trackMaxScore	TokenNameIdentifier	 track Max Score
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
setScorer	TokenNameIdentifier	 set Scorer
(	TokenNameLPAREN	
fakeScorer	TokenNameIdentifier	 fake Scorer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
setNextReader	TokenNameIdentifier	 set Next Reader
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docBase	TokenNameIdentifier	 doc Base
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
numChildDocs	TokenNameIdentifier	 num Child Docs
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
[	TokenNameLBRACKET	
slot	TokenNameIdentifier	 slot
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
docIDX	TokenNameIdentifier	 doc IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
docIDX	TokenNameIdentifier	 doc IDX
<	TokenNameLESS	
numChildDocs	TokenNameIdentifier	 num Child Docs
;	TokenNameSEMICOLON	
docIDX	TokenNameIdentifier	 doc IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
docs	TokenNameIdentifier	 docs
[	TokenNameLBRACKET	
slot	TokenNameIdentifier	 slot
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
docIDX	TokenNameIdentifier	 doc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
=	TokenNameEQUAL	
doc	TokenNameIdentifier	 doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
trackScores	TokenNameIdentifier	 track Scores
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fakeScorer	TokenNameIdentifier	 fake Scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
=	TokenNameEQUAL	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
scores	TokenNameIdentifier	 scores
[	TokenNameLBRACKET	
slot	TokenNameIdentifier	 slot
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
docIDX	TokenNameIdentifier	 doc IDX
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
(	TokenNameLPAREN	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
+=	TokenNamePLUS_EQUAL	
numChildDocs	TokenNameIdentifier	 num Child Docs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
groupSortValues	TokenNameIdentifier	 group Sort Values
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fillSortFields	TokenNameIdentifier	 fill Sort Fields
)	TokenNameRPAREN	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
<	TokenNameLESS	
comparators	TokenNameIdentifier	 comparators
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
[	TokenNameLBRACKET	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
comparators	TokenNameIdentifier	 comparators
[	TokenNameLBRACKET	
sortFieldIDX	TokenNameIdentifier	 sort Field IDX
]	TokenNameRBRACKET	
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
slot	TokenNameIdentifier	 slot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
groupSortValues	TokenNameIdentifier	 group Sort Values
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
TopDocs	TokenNameIdentifier	 Top Docs
topDocs	TokenNameIdentifier	 top Docs
=	TokenNameEQUAL	
collector	TokenNameIdentifier	 collector
.	TokenNameDOT	
topDocs	TokenNameIdentifier	 top Docs
(	TokenNameLPAREN	
withinGroupOffset	TokenNameIdentifier	 within Group Offset
,	TokenNameCOMMA	
maxDocsPerGroup	TokenNameIdentifier	 max Docs Per Group
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
groups	TokenNameIdentifier	 groups
[	TokenNameLBRACKET	
groupIDX	TokenNameIdentifier	 group IDX
-	TokenNameMINUS	
offset	TokenNameIdentifier	 offset
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
GroupDocs	TokenNameIdentifier	 Group Docs
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
getMaxScore	TokenNameIdentifier	 get Max Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
counts	TokenNameIdentifier	 counts
[	TokenNameLBRACKET	
slot	TokenNameIdentifier	 slot
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
topDocs	TokenNameIdentifier	 top Docs
.	TokenNameDOT	
scoreDocs	TokenNameIdentifier	 score Docs
,	TokenNameCOMMA	
og	TokenNameIdentifier	 og
.	TokenNameDOT	
doc	TokenNameIdentifier	 doc
,	TokenNameCOMMA	
groupSortValues	TokenNameIdentifier	 group Sort Values
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TopGroups	TokenNameIdentifier	 Top Groups
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
new	TokenNamenew	
TopGroups	TokenNameIdentifier	 Top Groups
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
(	TokenNameLPAREN	
sort	TokenNameIdentifier	 sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
withinGroupSort	TokenNameIdentifier	 within Group Sort
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
withinGroupSort	TokenNameIdentifier	 within Group Sort
.	TokenNameDOT	
getSort	TokenNameIdentifier	 get Sort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
totalGroupedHitCount	TokenNameIdentifier	 total Grouped Hit Count
,	TokenNameCOMMA	
groups	TokenNameIdentifier	 groups
)	TokenNameRPAREN	
,	TokenNameCOMMA	
totalHitCount	TokenNameIdentifier	 total Hit Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
