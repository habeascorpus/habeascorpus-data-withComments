/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cql3	TokenNameIdentifier	 cql3
.	TokenNameDOT	
statements	TokenNameIdentifier	 statements
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutionException	TokenNameIdentifier	 Execution Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
auth	TokenNameIdentifier	 auth
.	TokenNameDOT	
Permission	TokenNameIdentifier	 Permission
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cql3	TokenNameIdentifier	 cql3
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
transport	TokenNameIdentifier	 transport
.	TokenNameDOT	
messages	TokenNameIdentifier	 messages
.	TokenNameDOT	
ResultMessage	TokenNameIdentifier	 Result Message
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
ColumnDefinition	TokenNameIdentifier	 Column Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
CounterContext	TokenNameIdentifier	 Counter Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
exceptions	TokenNameIdentifier	 exceptions
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
ClientState	TokenNameIdentifier	 Client State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
QueryState	TokenNameIdentifier	 Query State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
RangeSliceVerbHandler	TokenNameIdentifier	 Range Slice Verb Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageProxy	TokenNameIdentifier	 Storage Proxy
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
IndexExpression	TokenNameIdentifier	 Index Expression
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
IndexOperator	TokenNameIdentifier	 Index Operator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
ThriftValidation	TokenNameIdentifier	 Thrift Validation
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
FBUtilities	TokenNameIdentifier	 FB Utilities
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
/** * Encapsulates a completely parsed SELECT query, including the target * column family, expression, result count, and ordering clause. * */	TokenNameCOMMENT_JAVADOC	 Encapsulates a completely parsed SELECT query, including the target column family, expression, result count, and ordering clause. 
public	TokenNamepublic	
class	TokenNameclass	
SelectStatement	TokenNameIdentifier	 Select Statement
implements	TokenNameimplements	
CQLStatement	TokenNameIdentifier	 CQL Statement
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
SelectStatement	TokenNameIdentifier	 Select Statement
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
boundTerms	TokenNameIdentifier	 bound Terms
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
CFDefinition	TokenNameIdentifier	 CF Definition
cfDef	TokenNameIdentifier	 cf Def
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
Parameters	TokenNameIdentifier	 Parameters
parameters	TokenNameIdentifier	 parameters
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selectedNames	TokenNameIdentifier	 selected Names
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// empty => wildcard 	TokenNameCOMMENT_LINE	empty => wildcard 
private	TokenNameprivate	
final	TokenNamefinal	
Restriction	TokenNameIdentifier	 Restriction
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyRestrictions	TokenNameIdentifier	 key Restrictions
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Restriction	TokenNameIdentifier	 Restriction
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
columnRestrictions	TokenNameIdentifier	 column Restrictions
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
>	TokenNameGREATER	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Restriction	TokenNameIdentifier	 Restriction
sliceRestriction	TokenNameIdentifier	 slice Restriction
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isReversed	TokenNameIdentifier	 is Reversed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
onToken	TokenNameIdentifier	 on Token
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
isKeyRange	TokenNameIdentifier	 is Key Range
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
enum	TokenNameenum	
Bound	TokenNameIdentifier	 Bound
{	TokenNameLBRACE	
START	TokenNameIdentifier	 START
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
END	TokenNameIdentifier	 END
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
Bound	TokenNameIdentifier	 Bound
(	TokenNameLPAREN	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Bound	TokenNameIdentifier	 Bound
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
b	TokenNameIdentifier	 b
==	TokenNameEQUAL_EQUAL	
START	TokenNameIdentifier	 START
?	TokenNameQUESTION	
END	TokenNameIdentifier	 END
:	TokenNameCOLON	
START	TokenNameIdentifier	 START
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SelectStatement	TokenNameIdentifier	 Select Statement
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
int	TokenNameint	
boundTerms	TokenNameIdentifier	 bound Terms
,	TokenNameCOMMA	
Parameters	TokenNameIdentifier	 Parameters
parameters	TokenNameIdentifier	 parameters
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
boundTerms	TokenNameIdentifier	 bound Terms
=	TokenNameEQUAL	
boundTerms	TokenNameIdentifier	 bound Terms
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
=	TokenNameEQUAL	
new	TokenNamenew	
Restriction	TokenNameIdentifier	 Restriction
[	TokenNameLBRACKET	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
=	TokenNameEQUAL	
new	TokenNamenew	
Restriction	TokenNameIdentifier	 Restriction
[	TokenNameLBRACKET	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
=	TokenNameEQUAL	
parameters	TokenNameIdentifier	 parameters
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getBoundsTerms	TokenNameIdentifier	 get Bounds Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
boundTerms	TokenNameIdentifier	 bound Terms
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
checkAccess	TokenNameIdentifier	 check Access
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
,	TokenNameCOMMA	
UnauthorizedException	TokenNameIdentifier	 Unauthorized Exception
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
.	TokenNameDOT	
hasColumnFamilyAccess	TokenNameIdentifier	 has Column Family Access
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Permission	TokenNameIdentifier	 Permission
.	TokenNameDOT	
SELECT	TokenNameIdentifier	 SELECT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
ClientState	TokenNameIdentifier	 Client State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
// Nothing to do, all validation has been done by RawStatement.prepare() 	TokenNameCOMMENT_LINE	Nothing to do, all validation has been done by RawStatement.prepare() 
}	TokenNameRBRACE	
public	TokenNamepublic	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
Rows	TokenNameIdentifier	 Rows
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
ConsistencyLevel	TokenNameIdentifier	 Consistency Level
cl	TokenNameIdentifier	 cl
,	TokenNameCOMMA	
QueryState	TokenNameIdentifier	 Query State
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestExecutionException	TokenNameIdentifier	 Request Execution Exception
,	TokenNameCOMMA	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cl	TokenNameIdentifier	 cl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Invalid empty consistency level"	TokenNameStringLiteral	Invalid empty consistency level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cl	TokenNameIdentifier	 cl
.	TokenNameDOT	
validateForRead	TokenNameIdentifier	 validate For Read
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
isKeyRange	TokenNameIdentifier	 is Key Range
?	TokenNameQUESTION	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
getRangeSlice	TokenNameIdentifier	 get Range Slice
(	TokenNameLPAREN	
getRangeCommand	TokenNameIdentifier	 get Range Command
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cl	TokenNameIdentifier	 cl
)	TokenNameRPAREN	
:	TokenNameCOLON	
StorageProxy	TokenNameIdentifier	 Storage Proxy
.	TokenNameDOT	
read	TokenNameIdentifier	 read
(	TokenNameLPAREN	
getSliceCommands	TokenNameIdentifier	 get Slice Commands
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cl	TokenNameIdentifier	 cl
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
processResults	TokenNameIdentifier	 process Results
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
Rows	TokenNameIdentifier	 Rows
processResults	TokenNameIdentifier	 process Results
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
// Even for count, we need to process the result as it'll group some column together in sparse column families 	TokenNameCOMMENT_LINE	Even for count, we need to process the result as it'll group some column together in sparse column families 
ResultSet	TokenNameIdentifier	 Result Set
rset	TokenNameIdentifier	 rset
=	TokenNameEQUAL	
process	TokenNameIdentifier	 process
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rset	TokenNameIdentifier	 rset
=	TokenNameEQUAL	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
isCount	TokenNameIdentifier	 is Count
?	TokenNameQUESTION	
rset	TokenNameIdentifier	 rset
.	TokenNameDOT	
makeCountResult	TokenNameIdentifier	 make Count Result
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
rset	TokenNameIdentifier	 rset
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
Rows	TokenNameIdentifier	 Rows
(	TokenNameLPAREN	
rset	TokenNameIdentifier	 rset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
readLocally	TokenNameIdentifier	 read Locally
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
cmds	TokenNameIdentifier	 cmds
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
cmds	TokenNameIdentifier	 cmds
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ReadCommand	TokenNameIdentifier	 Read Command
cmd	TokenNameIdentifier	 cmd
:	TokenNameCOLON	
cmds	TokenNameIdentifier	 cmds
)	TokenNameRPAREN	
rows	TokenNameIdentifier	 rows
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cmd	TokenNameIdentifier	 cmd
.	TokenNameDOT	
getRow	TokenNameIdentifier	 get Row
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rows	TokenNameIdentifier	 rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ResultMessage	TokenNameIdentifier	 Result Message
.	TokenNameDOT	
Rows	TokenNameIdentifier	 Rows
executeInternal	TokenNameIdentifier	 execute Internal
(	TokenNameLPAREN	
QueryState	TokenNameIdentifier	 Query State
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestExecutionException	TokenNameIdentifier	 Request Execution Exception
,	TokenNameCOMMA	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
=	TokenNameEQUAL	
isKeyRange	TokenNameIdentifier	 is Key Range
?	TokenNameQUESTION	
RangeSliceVerbHandler	TokenNameIdentifier	 Range Slice Verb Handler
.	TokenNameDOT	
executeLocally	TokenNameIdentifier	 execute Locally
(	TokenNameLPAREN	
getRangeCommand	TokenNameIdentifier	 get Range Command
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
readLocally	TokenNameIdentifier	 read Locally
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getSliceCommands	TokenNameIdentifier	 get Slice Commands
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
processResults	TokenNameIdentifier	 process Results
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ExecutionException	TokenNameIdentifier	 Execution Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
ResultSet	TokenNameIdentifier	 Result Set
process	TokenNameIdentifier	 process
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
isCount	TokenNameIdentifier	 is Count
;	TokenNameSEMICOLON	
// not yet needed 	TokenNameCOMMENT_LINE	not yet needed 
return	TokenNamereturn	
process	TokenNameIdentifier	 process
(	TokenNameLPAREN	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
ksName	TokenNameIdentifier	 ks Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
cfName	TokenNameIdentifier	 cf Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
getSliceCommands	TokenNameIdentifier	 get Slice Commands
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
QueryPath	TokenNameIdentifier	 Query Path
queryPath	TokenNameIdentifier	 query Path
=	TokenNameEQUAL	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
commands	TokenNameIdentifier	 commands
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ReadCommand	TokenNameIdentifier	 Read Command
>	TokenNameGREATER	
(	TokenNameLPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ...a range (slice) of column names 	TokenNameCOMMENT_LINE	...a range (slice) of column names 
if	TokenNameif	
(	TokenNameLPAREN	
isColumnRange	TokenNameIdentifier	 is Column Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Note that we use the total limit for every key. This is 	TokenNameCOMMENT_LINE	Note that we use the total limit for every key. This is 
// potentially inefficient, but then again, IN + LIMIT is not a 	TokenNameCOMMENT_LINE	potentially inefficient, but then again, IN + LIMIT is not a 
// very sensible choice 	TokenNameCOMMENT_LINE	very sensible choice 
for	TokenNamefor	
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryProcessor	TokenNameIdentifier	 Query Processor
.	TokenNameDOT	
validateKey	TokenNameIdentifier	 validate Key
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Note that we should not share the slice filter amongst the command, due to SliceQueryFilter not 	TokenNameCOMMENT_LINE	Note that we should not share the slice filter amongst the command, due to SliceQueryFilter not 
// being immutable due to its columnCounter used by the lastCounted() method 	TokenNameCOMMENT_LINE	being immutable due to its columnCounter used by the lastCounted() method 
// (this is fairly ugly and we should change that but that's probably not a tiny refactor to do that cleanly) 	TokenNameCOMMENT_LINE	(this is fairly ugly and we should change that but that's probably not a tiny refactor to do that cleanly) 
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
SliceFromReadCommand	TokenNameIdentifier	 Slice From Read Command
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
queryPath	TokenNameIdentifier	 query Path
,	TokenNameCOMMA	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
makeFilter	TokenNameIdentifier	 make Filter
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ...of a list of column names 	TokenNameCOMMENT_LINE	...of a list of column names 
else	TokenNameelse	
{	TokenNameLBRACE	
// ByNames commands can share the filter 	TokenNameCOMMENT_LINE	ByNames commands can share the filter 
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
makeFilter	TokenNameIdentifier	 make Filter
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
keys	TokenNameIdentifier	 keys
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QueryProcessor	TokenNameIdentifier	 Query Processor
.	TokenNameDOT	
validateKey	TokenNameIdentifier	 validate Key
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
commands	TokenNameIdentifier	 commands
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
SliceByNamesReadCommand	TokenNameIdentifier	 Slice By Names Read Command
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
queryPath	TokenNameIdentifier	 query Path
,	TokenNameCOMMA	
(	TokenNameLPAREN	
NamesQueryFilter	TokenNameIdentifier	 Names Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
commands	TokenNameIdentifier	 commands
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
getRangeCommand	TokenNameIdentifier	 get Range Command
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
RequestValidationException	TokenNameIdentifier	 Request Validation Exception
{	TokenNameLBRACE	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
makeFilter	TokenNameIdentifier	 make Filter
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
expressions	TokenNameIdentifier	 expressions
=	TokenNameEQUAL	
getIndexExpressions	TokenNameIdentifier	 get Index Expressions
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// The LIMIT provided by the user is the number of CQL row he wants returned. 	TokenNameCOMMENT_LINE	The LIMIT provided by the user is the number of CQL row he wants returned. 
// We want to have getRangeSlice to count the number of columns, not the number of keys. 	TokenNameCOMMENT_LINE	We want to have getRangeSlice to count the number of columns, not the number of keys. 
return	TokenNamereturn	
new	TokenNamenew	
RangeSliceCommand	TokenNameIdentifier	 Range Slice Command
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
getKeyBounds	TokenNameIdentifier	 get Key Bounds
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
,	TokenNameCOMMA	
expressions	TokenNameIdentifier	 expressions
,	TokenNameCOMMA	
getLimit	TokenNameIdentifier	 get Limit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
getKeyBounds	TokenNameIdentifier	 get Key Bounds
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
IPartitioner	TokenNameIdentifier	 I Partitioner
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
bounds	TokenNameIdentifier	 bounds
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
startToken	TokenNameIdentifier	 start Token
=	TokenNameEQUAL	
getTokenBound	TokenNameIdentifier	 get Token Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Token	TokenNameIdentifier	 Token
endToken	TokenNameIdentifier	 end Token
=	TokenNameEQUAL	
getTokenBound	TokenNameIdentifier	 get Token Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowPosition	TokenNameIdentifier	 Row Position
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
?	TokenNameQUESTION	
startToken	TokenNameIdentifier	 start Token
.	TokenNameDOT	
minKeyBound	TokenNameIdentifier	 min Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
startToken	TokenNameIdentifier	 start Token
.	TokenNameDOT	
maxKeyBound	TokenNameIdentifier	 max Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowPosition	TokenNameIdentifier	 Row Position
end	TokenNameIdentifier	 end
=	TokenNameEQUAL	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
?	TokenNameQUESTION	
endToken	TokenNameIdentifier	 end Token
.	TokenNameDOT	
maxKeyBound	TokenNameIdentifier	 max Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
endToken	TokenNameIdentifier	 end Token
.	TokenNameDOT	
minKeyBound	TokenNameIdentifier	 min Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
startKeyBytes	TokenNameIdentifier	 start Key Bytes
=	TokenNameEQUAL	
getKeyBound	TokenNameIdentifier	 get Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
finishKeyBytes	TokenNameIdentifier	 finish Key Bytes
=	TokenNameEQUAL	
getKeyBound	TokenNameIdentifier	 get Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowPosition	TokenNameIdentifier	 Row Position
startKey	TokenNameIdentifier	 start Key
=	TokenNameEQUAL	
RowPosition	TokenNameIdentifier	 Row Position
.	TokenNameDOT	
forKey	TokenNameIdentifier	 for Key
(	TokenNameLPAREN	
startKeyBytes	TokenNameIdentifier	 start Key Bytes
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowPosition	TokenNameIdentifier	 Row Position
finishKey	TokenNameIdentifier	 finish Key
=	TokenNameEQUAL	
RowPosition	TokenNameIdentifier	 Row Position
.	TokenNameDOT	
forKey	TokenNameIdentifier	 for Key
(	TokenNameLPAREN	
finishKeyBytes	TokenNameIdentifier	 finish Key Bytes
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
finishKey	TokenNameIdentifier	 finish Key
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
finishKey	TokenNameIdentifier	 finish Key
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
instanceof	TokenNameinstanceof	
RandomPartitioner	TokenNameIdentifier	 Random Partitioner
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner"	TokenNameStringLiteral	Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Start key must sort before (or equal to) finish key in your partitioner!"	TokenNameStringLiteral	Start key must sort before (or equal to) finish key in your partitioner!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
,	TokenNameCOMMA	
finishKey	TokenNameIdentifier	 finish Key
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
IncludingExcludingBounds	TokenNameIdentifier	 Including Excluding Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
,	TokenNameCOMMA	
finishKey	TokenNameIdentifier	 finish Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
,	TokenNameCOMMA	
finishKey	TokenNameIdentifier	 finish Key
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
ExcludingBounds	TokenNameIdentifier	 Excluding Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
,	TokenNameCOMMA	
finishKey	TokenNameIdentifier	 finish Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
bounds	TokenNameIdentifier	 bounds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
makeFilter	TokenNameIdentifier	 make Filter
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isColumnRange	TokenNameIdentifier	 is Column Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// For sparse, we used to ask for 'defined columns' * 'asked limit' (where defined columns includes the row marker) 	TokenNameCOMMENT_LINE	For sparse, we used to ask for 'defined columns' * 'asked limit' (where defined columns includes the row marker) 
// to account for the grouping of columns. 	TokenNameCOMMENT_LINE	to account for the grouping of columns. 
// Since that doesn't work for maps/sets/lists, we now use the compositesToGroup option of SliceQueryFilter. 	TokenNameCOMMENT_LINE	Since that doesn't work for maps/sets/lists, we now use the compositesToGroup option of SliceQueryFilter. 
// But we must preserve backward compatibility too (for mixed version cluster that is). 	TokenNameCOMMENT_LINE	But we must preserve backward compatibility too (for mixed version cluster that is). 
int	TokenNameint	
multiplier	TokenNameIdentifier	 multiplier
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
toGroup	TokenNameIdentifier	 to Group
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnSlice	TokenNameIdentifier	 Column Slice
slice	TokenNameIdentifier	 slice
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnSlice	TokenNameIdentifier	 Column Slice
(	TokenNameLPAREN	
getRequestedBound	TokenNameIdentifier	 get Requested Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getRequestedBound	TokenNameIdentifier	 get Requested Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
new	TokenNamenew	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
(	TokenNameLPAREN	
new	TokenNamenew	
ColumnSlice	TokenNameIdentifier	 Column Slice
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
slice	TokenNameIdentifier	 slice
}	TokenNameRBRACE	
,	TokenNameCOMMA	
isReversed	TokenNameIdentifier	 is Reversed
,	TokenNameCOMMA	
getLimit	TokenNameIdentifier	 get Limit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
toGroup	TokenNameIdentifier	 to Group
,	TokenNameCOMMA	
multiplier	TokenNameIdentifier	 multiplier
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QueryProcessor	TokenNameIdentifier	 Query Processor
.	TokenNameDOT	
validateSliceFilter	TokenNameIdentifier	 validate Slice Filter
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
filter	TokenNameIdentifier	 filter
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
columnNames	TokenNameIdentifier	 column Names
=	TokenNameEQUAL	
getRequestedColumns	TokenNameIdentifier	 get Requested Columns
(	TokenNameLPAREN	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QueryProcessor	TokenNameIdentifier	 Query Processor
.	TokenNameDOT	
validateColumnNames	TokenNameIdentifier	 validate Column Names
(	TokenNameLPAREN	
columnNames	TokenNameIdentifier	 column Names
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
NamesQueryFilter	TokenNameIdentifier	 Names Query Filter
(	TokenNameLPAREN	
columnNames	TokenNameIdentifier	 column Names
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
getLimit	TokenNameIdentifier	 get Limit
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Internally, we don't support exclusive bounds for slices. Instead, 	TokenNameCOMMENT_LINE	Internally, we don't support exclusive bounds for slices. Instead, 
// we query one more element if necessary and exclude 	TokenNameCOMMENT_LINE	we query one more element if necessary and exclude 
return	TokenNamereturn	
sliceRestriction	TokenNameIdentifier	 slice Restriction
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
sliceRestriction	TokenNameIdentifier	 slice Restriction
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
!=	TokenNameNOT_EQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
?	TokenNameQUESTION	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
keys	TokenNameIdentifier	 keys
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getKeyNameBuilder	TokenNameIdentifier	 get Key Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
remainingCount	TokenNameIdentifier	 remaining Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
:	TokenNameCOLON	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
)	TokenNameRPAREN	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"IN is only supported on the last column of the partition key"	TokenNameStringLiteral	IN is only supported on the last column of the partition key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
keys	TokenNameIdentifier	 keys
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getKeyBound	TokenNameIdentifier	 get Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
buildBound	TokenNameIdentifier	 build Bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
keyRestrictions	TokenNameIdentifier	 key Restrictions
,	TokenNameCOMMA	
isReversed	TokenNameIdentifier	 is Reversed
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getKeyNameBuilder	TokenNameIdentifier	 get Key Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Token	TokenNameIdentifier	 Token
getTokenBound	TokenNameIdentifier	 get Token Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
onToken	TokenNameIdentifier	 on Token
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
keyRestriction	TokenNameIdentifier	 key Restriction
=	TokenNameEQUAL	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
keyRestriction	TokenNameIdentifier	 key Restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
keyRestriction	TokenNameIdentifier	 key Restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
keyRestriction	TokenNameIdentifier	 key Restriction
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getMinimumToken	TokenNameIdentifier	 get Minimum Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Term	TokenNameIdentifier	 Term
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
STRING	TokenNameIdentifier	 STRING
&&	TokenNameAND_AND	
!	TokenNameNOT	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
isToken	TokenNameIdentifier	 is Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getText	TokenNameIdentifier	 get Text
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getTokenFactory	TokenNameIdentifier	 get Token Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
fromString	TokenNameIdentifier	 from String
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ConfigurationException	TokenNameIdentifier	 Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
assert	TokenNameassert	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
isToken	TokenNameIdentifier	 is Token
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getKeyNameBuilder	TokenNameIdentifier	 get Key Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We know all keyRestriction must be set 	TokenNameCOMMENT_LINE	We know all keyRestriction must be set 
for	TokenNamefor	
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getToken	TokenNameIdentifier	 get Token
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
includeKeyBound	TokenNameIdentifier	 include Key Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
:	TokenNameCOLON	
keyRestrictions	TokenNameIdentifier	 key Restrictions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// All equality 	TokenNameCOMMENT_LINE	All equality 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isColumnRange	TokenNameIdentifier	 is Column Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Static CF never entails a column slice 	TokenNameCOMMENT_LINE	Static CF never entails a column slice 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
&&	TokenNameAND_AND	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// However, collections always entails one 	TokenNameCOMMENT_LINE	However, collections always entails one 
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
hasCollections	TokenNameIdentifier	 has Collections
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// Otherwise, it is a range query if it has at least one the column alias 	TokenNameCOMMENT_LINE	Otherwise, it is a range query if it has at least one the column alias 
// for which no relation is defined or is not EQ. 	TokenNameCOMMENT_LINE	for which no relation is defined or is not EQ. 
for	TokenNamefor	
(	TokenNameLPAREN	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
:	TokenNameCOLON	
columnRestrictions	TokenNameIdentifier	 column Restrictions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isWildcard	TokenNameIdentifier	 is Wildcard
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
selectedNames	TokenNameIdentifier	 selected Names
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
getRequestedColumns	TokenNameIdentifier	 get Requested Columns
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
isColumnRange	TokenNameIdentifier	 is Column Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getColumnNameBuilder	TokenNameIdentifier	 get Column Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
:	TokenNameCOLON	
columnRestrictions	TokenNameIdentifier	 column Restrictions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
;	TokenNameSEMICOLON	
// We have a IN. We only support this for the last column, so just create all columns and return. 	TokenNameCOMMENT_LINE	We have a IN. We only support this for the last column, so just create all columns and return. 
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
new	TokenNamenew	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Term	TokenNameIdentifier	 Term
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
cname	TokenNameIdentifier	 cname
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cname	TokenNameIdentifier	 cname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
singleton	TokenNameIdentifier	 singleton
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Collections require doing a slice query because a given collection is a 	TokenNameCOMMENT_LINE	Collections require doing a slice query because a given collection is a 
// non-know set of columns, so we shouldn't get there 	TokenNameCOMMENT_LINE	non-know set of columns, so we shouldn't get there 
assert	TokenNameassert	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
hasCollections	TokenNameIdentifier	 has Collections
;	TokenNameSEMICOLON	
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
new	TokenNamenew	
TreeSet	TokenNameIdentifier	 Tree Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We need to query the selected column as well as the marker 	TokenNameCOMMENT_LINE	We need to query the selected column as well as the marker 
// column (for the case where the row exists but has no columns outside the PK) 	TokenNameCOMMENT_LINE	column (for the case where the row exists but has no columns outside the PK) 
// One exception is "static CF" (non-composite non-compact CF) that 	TokenNameCOMMENT_LINE	One exception is "static CF" (non-composite non-compact CF) that 
// don't have marker and for which we must query all columns instead 	TokenNameCOMMENT_LINE	don't have marker and for which we must query all columns instead 
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// marker 	TokenNameCOMMENT_LINE	marker 
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// selected columns 	TokenNameCOMMENT_LINE	selected columns 
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
:	TokenNameCOLON	
getExpandedSelection	TokenNameIdentifier	 get Expanded Selection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
id	TokenNameIdentifier	 id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
cname	TokenNameIdentifier	 cname
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cname	TokenNameIdentifier	 cname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
buildBound	TokenNameIdentifier	 build Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
bound	TokenNameIdentifier	 bound
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
>	TokenNameGREATER	
names	TokenNameIdentifier	 names
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
restrictions	TokenNameIdentifier	 restrictions
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isReversed	TokenNameIdentifier	 is Reversed
,	TokenNameCOMMA	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
builder	TokenNameIdentifier	 builder
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
// The end-of-component of composite doesn't depend on whether the 	TokenNameCOMMENT_LINE	The end-of-component of composite doesn't depend on whether the 
// component type is reversed or not (i.e. the ReversedType is applied 	TokenNameCOMMENT_LINE	component type is reversed or not (i.e. the ReversedType is applied 
// to the component comparator but not to the end-of-component itself), 	TokenNameCOMMENT_LINE	to the component comparator but not to the end-of-component itself), 
// it only depends on whether the slice is reversed 	TokenNameCOMMENT_LINE	it only depends on whether the slice is reversed 
Bound	TokenNameIdentifier	 Bound
eocBound	TokenNameIdentifier	 eoc Bound
=	TokenNameEQUAL	
isReversed	TokenNameIdentifier	 is Reversed
?	TokenNameQUESTION	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
bound	TokenNameIdentifier	 bound
)	TokenNameRPAREN	
:	TokenNameCOLON	
bound	TokenNameIdentifier	 bound
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
names	TokenNameIdentifier	 names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// In a restriction, we always have Bound.START < Bound.END for the "base" comparator. 	TokenNameCOMMENT_LINE	In a restriction, we always have Bound.START < Bound.END for the "base" comparator. 
// So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter. 	TokenNameCOMMENT_LINE	So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter. 
// But if the actual comparator itself is reversed, we must inversed the bounds too. 	TokenNameCOMMENT_LINE	But if the actual comparator itself is reversed, we must inversed the bounds too. 
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
isReversed	TokenNameIdentifier	 is Reversed
==	TokenNameEQUAL_EQUAL	
isReversedType	TokenNameIdentifier	 is Reversed Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
?	TokenNameQUESTION	
bound	TokenNameIdentifier	 bound
:	TokenNameCOLON	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
bound	TokenNameIdentifier	 bound
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
restrictions	TokenNameIdentifier	 restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
!	TokenNameNOT	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix. 	TokenNameCOMMENT_LINE	There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix. 
// For composites, if there was preceding component and we're computing the end, we must change the last component 	TokenNameCOMMENT_LINE	For composites, if there was preceding component and we're computing the end, we must change the last component 
// End-Of-Component, otherwise we would be selecting only one record. 	TokenNameCOMMENT_LINE	End-Of-Component, otherwise we would be selecting only one record. 
if	TokenNameif	
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
componentCount	TokenNameIdentifier	 component Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
eocBound	TokenNameIdentifier	 eoc Bound
==	TokenNameEQUAL_EQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
buildAsEndOfRange	TokenNameIdentifier	 build As End Of Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
t	TokenNameIdentifier	 t
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
.	TokenNameDOT	
getRelation	TokenNameIdentifier	 get Relation
(	TokenNameLPAREN	
eocBound	TokenNameIdentifier	 eoc Bound
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Means no relation at all or everything was an equal 	TokenNameCOMMENT_LINE	Means no relation at all or everything was an equal 
return	TokenNamereturn	
(	TokenNameLPAREN	
bound	TokenNameIdentifier	 bound
==	TokenNameEQUAL_EQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
?	TokenNameQUESTION	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
buildAsEndOfRange	TokenNameIdentifier	 build As End Of Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
getRequestedBound	TokenNameIdentifier	 get Requested Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
isColumnRange	TokenNameIdentifier	 is Column Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
buildBound	TokenNameIdentifier	 build Bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnRestrictions	TokenNameIdentifier	 column Restrictions
,	TokenNameCOMMA	
isReversed	TokenNameIdentifier	 is Reversed
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getColumnNameBuilder	TokenNameIdentifier	 get Column Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
getIndexExpressions	TokenNameIdentifier	 get Index Expressions
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
expressions	TokenNameIdentifier	 expressions
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
:	TokenNameCOLON	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getByteBuffer	TokenNameIdentifier	 get Byte Buffer
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0xFFFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Index expression values may not be larger than 64K"	TokenNameStringLiteral	Index expression values may not be larger than 64K
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expressions	TokenNameIdentifier	 expressions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
IndexExpression	TokenNameIdentifier	 Index Expression
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
:	TokenNameCOLON	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
.	TokenNameDOT	
getByteBuffer	TokenNameIdentifier	 get Byte Buffer
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0xFFFF	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Index expression values may not be larger than 64K"	TokenNameStringLiteral	Index expression values may not be larger than 64K
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
expressions	TokenNameIdentifier	 expressions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
IndexExpression	TokenNameIdentifier	 Index Expression
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
getIndexOperator	TokenNameIdentifier	 get Index Operator
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
expressions	TokenNameIdentifier	 expressions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
getExpandedSelection	TokenNameIdentifier	 get Expanded Selection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
selectedNames	TokenNameIdentifier	 selected Names
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
cfDef	TokenNameIdentifier	 cf Def
)	TokenNameRPAREN	
selection	TokenNameIdentifier	 selection
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
selection	TokenNameIdentifier	 selection
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
selectedNames	TokenNameIdentifier	 selected Names
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
instanceof	TokenNameinstanceof	
CounterColumn	TokenNameIdentifier	 Counter Column
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
(	TokenNameLPAREN	
CounterContext	TokenNameIdentifier	 Counter Context
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
total	TokenNameIdentifier	 total
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addReturnValue	TokenNameIdentifier	 add Return Value
(	TokenNameLPAREN	
ResultSet	TokenNameIdentifier	 Result Set
cqlRows	TokenNameIdentifier	 cql Rows
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
hasFunction	TokenNameIdentifier	 has Function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
function	TokenNameIdentifier	 function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
WRITE_TIME	TokenNameIdentifier	 WRITE  TIME
:	TokenNameCOLON	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TTL	TokenNameIdentifier	 TTL
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
instanceof	TokenNameinstanceof	
ExpiringColumn	TokenNameIdentifier	 Expiring Column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
ttl	TokenNameIdentifier	 ttl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
ExpiringColumn	TokenNameIdentifier	 Expiring Column
)	TokenNameRPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
.	TokenNameDOT	
getLocalDeletionTime	TokenNameIdentifier	 get Local Deletion Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
bytes	TokenNameIdentifier	 bytes
(	TokenNameLPAREN	
ttl	TokenNameIdentifier	 ttl
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
ResultSet	TokenNameIdentifier	 Result Set
createResult	TokenNameIdentifier	 create Result
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ColumnSpecification	TokenNameIdentifier	 Column Specification
>	TokenNameGREATER	
names	TokenNameIdentifier	 names
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ColumnSpecification	TokenNameIdentifier	 Column Specification
>	TokenNameGREATER	
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
:	TokenNameCOLON	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
hasFunction	TokenNameIdentifier	 has Function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
function	TokenNameIdentifier	 function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
WRITE_TIME	TokenNameIdentifier	 WRITE  TIME
:	TokenNameCOLON	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
ColumnSpecification	TokenNameIdentifier	 Column Specification
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
new	TokenNamenew	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
LongType	TokenNameIdentifier	 Long Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TTL	TokenNameIdentifier	 TTL
:	TokenNameCOLON	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
ColumnSpecification	TokenNameIdentifier	 Column Specification
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
ksName	TokenNameIdentifier	 ks Name
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
new	TokenNamenew	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Int32Type	TokenNameIdentifier	 Int32 Type
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
names	TokenNameIdentifier	 names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ResultSet	TokenNameIdentifier	 Result Set
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
columnsInOrder	TokenNameIdentifier	 columns In Order
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
// If the restriction for the last column alias is an IN, respect 	TokenNameCOMMENT_LINE	If the restriction for the last column alias is an IN, respect 
// requested order 	TokenNameCOMMENT_LINE	requested order 
Restriction	TokenNameIdentifier	 Restriction
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
columnRestrictions	TokenNameIdentifier	 column Restrictions
[	TokenNameLBRACKET	
columnRestrictions	TokenNameIdentifier	 column Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getSortedColumns	TokenNameIdentifier	 get Sorted Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
getColumnNameBuilder	TokenNameIdentifier	 get Column Name Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
columnRestrictions	TokenNameIdentifier	 column Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
columnRestrictions	TokenNameIdentifier	 column Restrictions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
requested	TokenNameIdentifier	 requested
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnNameBuilder	TokenNameIdentifier	 Column Name Builder
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
;	TokenNameSEMICOLON	
requested	TokenNameIdentifier	 requested
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
requested	TokenNameIdentifier	 requested
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
IColumn	TokenNameIdentifier	 I Column
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IColumn	TokenNameIdentifier	 I Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
column	TokenNameIdentifier	 column
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ResultSet	TokenNameIdentifier	 Result Set
process	TokenNameIdentifier	 process
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
=	TokenNameEQUAL	
getExpandedSelection	TokenNameIdentifier	 get Expanded Selection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ResultSet	TokenNameIdentifier	 Result Set
cqlRows	TokenNameIdentifier	 cql Rows
=	TokenNameEQUAL	
createResult	TokenNameIdentifier	 create Result
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Row	TokenNameIdentifier	 Row
row	TokenNameIdentifier	 row
:	TokenNameCOLON	
rows	TokenNameIdentifier	 rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Not columns match the query, skip 	TokenNameCOMMENT_LINE	Not columns match the query, skip 
if	TokenNameif	
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyComponents	TokenNameIdentifier	 key Components
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
hasCompositeKey	TokenNameIdentifier	 has Composite Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyComponents	TokenNameIdentifier	 key Components
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
getKeyValidator	TokenNameIdentifier	 get Key Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
keyComponents	TokenNameIdentifier	 key Components
=	TokenNameEQUAL	
new	TokenNamenew	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// One cqlRow per column 	TokenNameCOMMENT_LINE	One cqlRow per column 
for	TokenNamefor	
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
:	TokenNameCOLON	
columnsInOrder	TokenNameIdentifier	 columns In Order
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
)	TokenNameRPAREN	
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
sliceRestriction	TokenNameIdentifier	 slice Restriction
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// For dynamic CF, the column could be out of the requested bounds, filter here 	TokenNameCOMMENT_LINE	For dynamic CF, the column could be out of the requested bounds, filter here 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sliceRestriction	TokenNameIdentifier	 slice Restriction
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
sliceRestriction	TokenNameIdentifier	 slice Restriction
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
.	TokenNameDOT	
getByteBuffer	TokenNameIdentifier	 get Byte Buffer
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sliceRestriction	TokenNameIdentifier	 slice Restriction
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
sliceRestriction	TokenNameIdentifier	 slice Restriction
.	TokenNameDOT	
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
.	TokenNameDOT	
getByteBuffer	TokenNameIdentifier	 get Byte Buffer
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
,	TokenNameCOMMA	
variables	TokenNameIdentifier	 variables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Respect selection order 	TokenNameCOMMENT_LINE	Respect selection order 
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
:	TokenNameCOLON	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
Selector	TokenNameIdentifier	 Selector
selector	TokenNameIdentifier	 selector
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
KEY_ALIAS	TokenNameIdentifier	 KEY  ALIAS
:	TokenNameCOLON	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
keyComponents	TokenNameIdentifier	 key Components
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_ALIAS	TokenNameIdentifier	 COLUMN  ALIAS
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
<	TokenNameLESS	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VALUE_ALIAS	TokenNameIdentifier	 VALUE  ALIAS
:	TokenNameCOLON	
addReturnValue	TokenNameIdentifier	 add Return Value
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
,	TokenNameCOMMA	
selector	TokenNameIdentifier	 selector
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
:	TokenNameCOLON	
// This should not happen for compact CF 	TokenNameCOMMENT_LINE	This should not happen for compact CF 
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Sparse case: group column in cqlRow when composite prefix is equal 	TokenNameCOMMENT_LINE	Sparse case: group column in cqlRow when composite prefix is equal 
CompositeType	TokenNameIdentifier	 Composite Type
composite	TokenNameIdentifier	 composite
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
ColumnGroupMap	TokenNameIdentifier	 Column Group Map
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
ColumnGroupMap	TokenNameIdentifier	 Column Group Map
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
(	TokenNameLPAREN	
composite	TokenNameIdentifier	 composite
,	TokenNameCOMMA	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
hasCollections	TokenNameIdentifier	 has Collections
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
:	TokenNameCOLON	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnGroupMap	TokenNameIdentifier	 Column Group Map
group	TokenNameIdentifier	 group
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
groups	TokenNameIdentifier	 groups
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
handleGroup	TokenNameIdentifier	 handle Group
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
keyComponents	TokenNameIdentifier	 key Components
,	TokenNameCOMMA	
group	TokenNameIdentifier	 group
,	TokenNameCOMMA	
cqlRows	TokenNameIdentifier	 cql Rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
hasOnlyTombstones	TokenNameIdentifier	 has Only Tombstones
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// Static case: One cqlRow for all columns 	TokenNameCOMMENT_LINE	Static case: One cqlRow for all columns 
// Respect selection order 	TokenNameCOMMENT_LINE	Respect selection order 
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
:	TokenNameCOLON	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
Selector	TokenNameIdentifier	 Selector
selector	TokenNameIdentifier	 selector
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
==	TokenNameEQUAL_EQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
.	TokenNameDOT	
Kind	TokenNameIdentifier	 Kind
.	TokenNameDOT	
KEY_ALIAS	TokenNameIdentifier	 KEY  ALIAS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
keyComponents	TokenNameIdentifier	 key Components
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addReturnValue	TokenNameIdentifier	 add Return Value
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
,	TokenNameCOMMA	
selector	TokenNameIdentifier	 selector
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
orderResults	TokenNameIdentifier	 order Results
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
cqlRows	TokenNameIdentifier	 cql Rows
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Internal calls always return columns in the comparator order, even when reverse was set 	TokenNameCOMMENT_LINE	Internal calls always return columns in the comparator order, even when reverse was set 
if	TokenNameif	
(	TokenNameLPAREN	
isReversed	TokenNameIdentifier	 is Reversed
)	TokenNameRPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
reverse	TokenNameIdentifier	 reverse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Trim result if needed to respect the limit 	TokenNameCOMMENT_LINE	Trim result if needed to respect the limit 
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cqlRows	TokenNameIdentifier	 cql Rows
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Orders results when multiple keys are selected (using IN) */	TokenNameCOMMENT_JAVADOC	 Orders results when multiple keys are selected (using IN) 
private	TokenNameprivate	
void	TokenNamevoid	
orderResults	TokenNameIdentifier	 order Results
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
ResultSet	TokenNameIdentifier	 Result Set
cqlRows	TokenNameIdentifier	 cql Rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// There is nothing to do if 	TokenNameCOMMENT_LINE	There is nothing to do if 
// a. there are no results, 	TokenNameCOMMENT_LINE	a. there are no results, 
// b. no ordering information where given, 	TokenNameCOMMENT_LINE	b. no ordering information where given, 
// c. key restriction is a Range or not an IN expression 	TokenNameCOMMENT_LINE	c. key restriction is a Range or not an IN expression 
if	TokenNameif	
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
isKeyRange	TokenNameIdentifier	 is Key Range
||	TokenNameOR_OR	
!	TokenNameNOT	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// optimization when only *one* order condition was given 	TokenNameCOMMENT_LINE	optimization when only *one* order condition was given 
// because there is no point of using composite comparator if there is only one order condition 	TokenNameCOMMENT_LINE	because there is no point of using composite comparator if there is only one order condition 
if	TokenNameif	
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
ordering	TokenNameIdentifier	 ordering
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
new	TokenNamenew	
SingleColumnComparator	TokenNameIdentifier	 Single Column Comparator
(	TokenNameLPAREN	
getColumnPositionInSelect	TokenNameIdentifier	 get Column Position In Select
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
ordering	TokenNameIdentifier	 ordering
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ordering	TokenNameIdentifier	 ordering
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// builds a 'composite' type for multi-column comparison from the comparators of the ordering components 	TokenNameCOMMENT_LINE	builds a 'composite' type for multi-column comparison from the comparators of the ordering components 
// and passes collected position information and built composite comparator to CompositeComparator to do 	TokenNameCOMMENT_LINE	and passes collected position information and built composite comparator to CompositeComparator to do 
// an actual comparison of the CQL rows. 	TokenNameCOMMENT_LINE	an actual comparison of the CQL rows. 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
types	TokenNameIdentifier	 types
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
identifier	TokenNameIdentifier	 identifier
:	TokenNameCOLON	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
orderingColumn	TokenNameIdentifier	 ordering Column
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
identifier	TokenNameIdentifier	 identifier
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
types	TokenNameIdentifier	 types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
orderingColumn	TokenNameIdentifier	 ordering Column
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
getColumnPositionInSelect	TokenNameIdentifier	 get Column Position In Select
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
orderingColumn	TokenNameIdentifier	 ordering Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
rows	TokenNameIdentifier	 rows
,	TokenNameCOMMA	
new	TokenNamenew	
CompositeComparator	TokenNameIdentifier	 Composite Comparator
(	TokenNameLPAREN	
types	TokenNameIdentifier	 types
,	TokenNameCOMMA	
positions	TokenNameIdentifier	 positions
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// determine position of column in the select clause 	TokenNameCOMMENT_LINE	determine position of column in the select clause 
private	TokenNameprivate	
int	TokenNameint	
getColumnPositionInSelect	TokenNameIdentifier	 get Column Position In Select
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
selection	TokenNameIdentifier	 selection
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
selection	TokenNameIdentifier	 selection
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Column %s wasn't found in select clause."	TokenNameStringLiteral	Column %s wasn't found in select clause.
,	TokenNameCOMMA	
columnName	TokenNameIdentifier	 column Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For sparse composite, returns wheter two columns belong to the same * cqlRow base on the full list of component in the name. * Two columns do belong together if they differ only by the last * component. */	TokenNameCOMMENT_JAVADOC	 For sparse composite, returns wheter two columns belong to the same cqlRow base on the full list of component in the name. Two columns do belong together if they differ only by the last component. 
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isSameRow	TokenNameIdentifier	 is Same Row
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
c1	TokenNameIdentifier	 c1
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
c2	TokenNameIdentifier	 c2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Cql don't allow to insert columns who doesn't have all component of 	TokenNameCOMMENT_LINE	Cql don't allow to insert columns who doesn't have all component of 
// the composite set for sparse composite. Someone coming from thrift 	TokenNameCOMMENT_LINE	the composite set for sparse composite. Someone coming from thrift 
// could hit that though. But since we have no way to handle this 	TokenNameCOMMENT_LINE	could hit that though. But since we have no way to handle this 
// correctly, better fail here and tell whomever may hit that (if 	TokenNameCOMMENT_LINE	correctly, better fail here and tell whomever may hit that (if 
// someone ever do) to change the definition to a dense composite 	TokenNameCOMMENT_LINE	someone ever do) to change the definition to a dense composite 
assert	TokenNameassert	
c1	TokenNameIdentifier	 c1
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
c2	TokenNameIdentifier	 c2
.	TokenNameDOT	
length	TokenNameIdentifier	 length
:	TokenNameCOLON	
"Sparse composite should not have partial column names"	TokenNameStringLiteral	Sparse composite should not have partial column names
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
c1	TokenNameIdentifier	 c1
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
c1	TokenNameIdentifier	 c1
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
c2	TokenNameIdentifier	 c2
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
handleGroup	TokenNameIdentifier	 handle Group
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>>	TokenNameRIGHT_SHIFT	
selection	TokenNameIdentifier	 selection
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
keyComponents	TokenNameIdentifier	 key Components
,	TokenNameCOMMA	
ColumnGroupMap	TokenNameIdentifier	 Column Group Map
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
ResultSet	TokenNameIdentifier	 Result Set
cqlRows	TokenNameIdentifier	 cql Rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Respect requested order 	TokenNameCOMMENT_LINE	Respect requested order 
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
:	TokenNameCOLON	
selection	TokenNameIdentifier	 selection
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
Selector	TokenNameIdentifier	 Selector
selector	TokenNameIdentifier	 selector
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
KEY_ALIAS	TokenNameIdentifier	 KEY  ALIAS
:	TokenNameCOLON	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
keyComponents	TokenNameIdentifier	 key Components
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_ALIAS	TokenNameIdentifier	 COLUMN  ALIAS
:	TokenNameCOLON	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
getKeyComponent	TokenNameIdentifier	 get Key Component
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VALUE_ALIAS	TokenNameIdentifier	 VALUE  ALIAS
:	TokenNameCOLON	
// This should not happen for SPARSE 	TokenNameCOMMENT_LINE	This should not happen for SPARSE 
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
isCollection	TokenNameIdentifier	 is Collection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>>	TokenNameRIGHT_SHIFT	
collection	TokenNameIdentifier	 collection
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
getCollection	TokenNameIdentifier	 get Collection
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
collection	TokenNameIdentifier	 collection
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
cqlRows	TokenNameIdentifier	 cql Rows
.	TokenNameDOT	
addColumnValue	TokenNameIdentifier	 add Column Value
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CollectionType	TokenNameIdentifier	 Collection Type
)	TokenNameRPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
collection	TokenNameIdentifier	 collection
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
getSimple	TokenNameIdentifier	 get Simple
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addReturnValue	TokenNameIdentifier	 add Return Value
(	TokenNameLPAREN	
cqlRows	TokenNameIdentifier	 cql Rows
,	TokenNameCOMMA	
selector	TokenNameIdentifier	 selector
,	TokenNameCOMMA	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
boolean	TokenNameboolean	
isReversedType	TokenNameIdentifier	 is Reversed Type
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
instanceof	TokenNameinstanceof	
ReversedType	TokenNameIdentifier	 Reversed Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
columnFilterIsIdentity	TokenNameIdentifier	 column Filter Is Identity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Restriction	TokenNameIdentifier	 Restriction
r	TokenNameIdentifier	 r
:	TokenNameCOLON	
columnRestrictions	TokenNameIdentifier	 column Restrictions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
RawStatement	TokenNameIdentifier	 Raw Statement
extends	TokenNameextends	
CFStatement	TokenNameIdentifier	 CF Statement
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Parameters	TokenNameIdentifier	 Parameters
parameters	TokenNameIdentifier	 parameters
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
selectClause	TokenNameIdentifier	 select Clause
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Relation	TokenNameIdentifier	 Relation
>	TokenNameGREATER	
whereClause	TokenNameIdentifier	 where Clause
;	TokenNameSEMICOLON	
public	TokenNamepublic	
RawStatement	TokenNameIdentifier	 Raw Statement
(	TokenNameLPAREN	
CFName	TokenNameIdentifier	 CF Name
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
Parameters	TokenNameIdentifier	 Parameters
parameters	TokenNameIdentifier	 parameters
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
selectClause	TokenNameIdentifier	 select Clause
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Relation	TokenNameIdentifier	 Relation
>	TokenNameGREATER	
whereClause	TokenNameIdentifier	 where Clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
cfName	TokenNameIdentifier	 cf Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
=	TokenNameEQUAL	
parameters	TokenNameIdentifier	 parameters
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
selectClause	TokenNameIdentifier	 select Clause
=	TokenNameEQUAL	
selectClause	TokenNameIdentifier	 select Clause
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
whereClause	TokenNameIdentifier	 where Clause
=	TokenNameEQUAL	
whereClause	TokenNameIdentifier	 where Clause
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
Relation	TokenNameIdentifier	 Relation
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
whereClause	TokenNameIdentifier	 where Clause
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ParsedStatement	TokenNameIdentifier	 Parsed Statement
.	TokenNameDOT	
Prepared	TokenNameIdentifier	 Prepared
prepare	TokenNameIdentifier	 prepare
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
CFMetaData	TokenNameIdentifier	 CF Meta Data
cfm	TokenNameIdentifier	 cfm
=	TokenNameEQUAL	
ThriftValidation	TokenNameIdentifier	 Thrift Validation
.	TokenNameDOT	
validateColumnFamily	TokenNameIdentifier	 validate Column Family
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"LIMIT must be strictly positive"	TokenNameStringLiteral	LIMIT must be strictly positive
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CFDefinition	TokenNameIdentifier	 CF Definition
cfDef	TokenNameIdentifier	 cf Def
=	TokenNameEQUAL	
cfm	TokenNameIdentifier	 cfm
.	TokenNameDOT	
getCfDef	TokenNameIdentifier	 get Cf Def
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SelectStatement	TokenNameIdentifier	 Select Statement
stmt	TokenNameIdentifier	 stmt
=	TokenNameEQUAL	
new	TokenNamenew	
SelectStatement	TokenNameIdentifier	 Select Statement
(	TokenNameLPAREN	
cfDef	TokenNameIdentifier	 cf Def
,	TokenNameCOMMA	
getBoundsTerms	TokenNameIdentifier	 get Bounds Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parameters	TokenNameIdentifier	 parameters
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
names	TokenNameIdentifier	 names
=	TokenNameEQUAL	
new	TokenNamenew	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
[	TokenNameLBRACKET	
getBoundsTerms	TokenNameIdentifier	 get Bounds Terms
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Select clause 	TokenNameCOMMENT_LINE	Select clause 
if	TokenNameif	
(	TokenNameLPAREN	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
isCount	TokenNameIdentifier	 is Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
selectClause	TokenNameIdentifier	 select Clause
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Only COUNT(*) and COUNT(1) operations are currently supported."	TokenNameStringLiteral	Only COUNT(*) and COUNT(1) operations are currently supported.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Selector	TokenNameIdentifier	 Selector
t	TokenNameIdentifier	 t
:	TokenNameCOLON	
selectClause	TokenNameIdentifier	 select Clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
id	TokenNameIdentifier	 id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Undefined name %s in selection clause"	TokenNameStringLiteral	Undefined name %s in selection clause
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
id	TokenNameIdentifier	 id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
hasFunction	TokenNameIdentifier	 has Function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
.	TokenNameDOT	
Kind	TokenNameIdentifier	 Kind
.	TokenNameDOT	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
.	TokenNameDOT	
Kind	TokenNameIdentifier	 Kind
.	TokenNameDOT	
VALUE_ALIAS	TokenNameIdentifier	 VALUE  ALIAS
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Cannot use function %s on PRIMARY KEY part %s"	TokenNameStringLiteral	Cannot use function %s on PRIMARY KEY part %s
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
function	TokenNameIdentifier	 function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
hasFunction	TokenNameIdentifier	 has Function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
isCollection	TokenNameIdentifier	 is Collection
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Function %s is not supported on collections"	TokenNameStringLiteral	Function %s is not supported on collections
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
function	TokenNameIdentifier	 function
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
selectedNames	TokenNameIdentifier	 selected Names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * WHERE clause. For a given entity, rules are: * - EQ relation conflicts with anything else (including a 2nd EQ) * - Can't have more than one LT(E) relation (resp. GT(E) relation) * - IN relation are restricted to row keys (for now) and conflics with anything else * (we could allow two IN for the same entity but that doesn't seem very useful) * - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far) */	TokenNameCOMMENT_BLOCK	 WHERE clause. For a given entity, rules are: - EQ relation conflicts with anything else (including a 2nd EQ) - Can't have more than one LT(E) relation (resp. GT(E) relation) - IN relation are restricted to row keys (for now) and conflics with anything else (we could allow two IN for the same entity but that doesn't seem very useful) - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far) 
for	TokenNamefor	
(	TokenNameLPAREN	
Relation	TokenNameIdentifier	 Relation
rel	TokenNameIdentifier	 rel
:	TokenNameCOLON	
whereClause	TokenNameIdentifier	 where Clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
getEntity	TokenNameIdentifier	 get Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Undefined name %s in where clause ('%s')"	TokenNameStringLiteral	Undefined name %s in where clause ('%s')
,	TokenNameCOMMA	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
getEntity	TokenNameIdentifier	 get Entity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
rel	TokenNameIdentifier	 rel
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
IN	TokenNameIdentifier	 IN
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
value	TokenNameIdentifier	 value
:	TokenNameCOLON	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
getInValues	TokenNameIdentifier	 get In Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
isBindMarker	TokenNameIdentifier	 is Bind Marker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
names	TokenNameIdentifier	 names
[	TokenNameLBRACKET	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
bindIndex	TokenNameIdentifier	 bind Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Term	TokenNameIdentifier	 Term
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
isBindMarker	TokenNameIdentifier	 is Bind Marker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
names	TokenNameIdentifier	 names
[	TokenNameLBRACKET	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
bindIndex	TokenNameIdentifier	 bind Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
KEY_ALIAS	TokenNameIdentifier	 KEY  ALIAS
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
&&	TokenNameAND_AND	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
IN	TokenNameIdentifier	 IN
&&	TokenNameAND_AND	
!	TokenNameNOT	
rel	TokenNameIdentifier	 rel
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
&&	TokenNameAND_AND	
!	TokenNameNOT	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
preservesOrder	TokenNameIdentifier	 preserves Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Only EQ and IN relation are supported on the partition key for RandomPartitioner (unless you use the token() function)"	TokenNameStringLiteral	Only EQ and IN relation are supported on the partition key for RandomPartitioner (unless you use the token() function)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
updateRestriction	TokenNameIdentifier	 update Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
rel	TokenNameIdentifier	 rel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_ALIAS	TokenNameIdentifier	 COLUMN  ALIAS
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
updateRestriction	TokenNameIdentifier	 update Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
rel	TokenNameIdentifier	 rel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
VALUE_ALIAS	TokenNameIdentifier	 VALUE  ALIAS
:	TokenNameCOLON	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Restricting the value of a compact CF (%s) is not supported"	TokenNameStringLiteral	Restricting the value of a compact CF (%s) is not supported
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
COLUMN_METADATA	TokenNameIdentifier	 COLUMN  METADATA
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
updateRestriction	TokenNameIdentifier	 update Restriction
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
,	TokenNameCOMMA	
rel	TokenNameIdentifier	 rel
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * At this point, the select statement if fully constructed, but we still have a few things to validate */	TokenNameCOMMENT_BLOCK	 At this point, the select statement if fully constructed, but we still have a few things to validate 
// If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding 	TokenNameCOMMENT_LINE	If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding 
// components must have a EQ, and all following must have no restriction 	TokenNameCOMMENT_LINE	components must have a EQ, and all following must have no restriction 
boolean	TokenNameboolean	
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
cname	TokenNameIdentifier	 cname
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
shouldBeDone	TokenNameIdentifier	 should Be Done
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"	TokenNameStringLiteral	PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)
,	TokenNameCOMMA	
cname	TokenNameIdentifier	 cname
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// For non-composite slices, we don't support internally the difference between exclusive and 	TokenNameCOMMENT_LINE	For non-composite slices, we don't support internally the difference between exclusive and 
// inclusive bounds, so we deal with it manually. 	TokenNameCOMMENT_LINE	inclusive bounds, so we deal with it manually. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isComposite	TokenNameIdentifier	 is Composite
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
sliceRestriction	TokenNameIdentifier	 slice Restriction
=	TokenNameEQUAL	
restriction	TokenNameIdentifier	 restriction
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We only support IN for the last name and for compact storage so far 	TokenNameCOMMENT_LINE	We only support IN for the last name and for compact storage so far 
// TODO: #3885 allows us to extend to non compact as well, but that remains to be done 	TokenNameCOMMENT_LINE	TODO: #3885 allows us to extend to non compact as well, but that remains to be done 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
isCompact	TokenNameIdentifier	 is Compact
||	TokenNameOR_OR	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnRestrictions	TokenNameIdentifier	 column Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"PRIMARY KEY part %s cannot be restricted by IN relation"	TokenNameStringLiteral	PRIMARY KEY part %s cannot be restricted by IN relation
,	TokenNameCOMMA	
cname	TokenNameIdentifier	 cname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
cname	TokenNameIdentifier	 cname
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If a component of the partition key is restricted by a non-EQ relation, all preceding 	TokenNameCOMMENT_LINE	If a component of the partition key is restricted by a non-EQ relation, all preceding 
// components must have a EQ, and all following must have no restriction 	TokenNameCOMMENT_LINE	components must have a EQ, and all following must have no restriction 
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
keys	TokenNameIdentifier	 keys
.	TokenNameDOT	
values	TokenNameIdentifier	 values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
cname	TokenNameIdentifier	 cname
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"The token() function must be applied to all partition key components or none of them"	TokenNameStringLiteral	The token() function must be applied to all partition key components or none of them
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
shouldBeDone	TokenNameIdentifier	 should Be Done
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"partition key part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"	TokenNameStringLiteral	partition key part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)
,	TokenNameCOMMA	
cname	TokenNameIdentifier	 cname
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this is a query on tokens, it's necessary a range query (there can be more than one key per token), so reject IN queries (as we don't know how to do them) 	TokenNameCOMMENT_LINE	If this is a query on tokens, it's necessary a range query (there can be more than one key per token), so reject IN queries (as we don't know how to do them) 
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Select using the token() function don't support IN clause"	TokenNameStringLiteral	Select using the token() function don't support IN clause
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"The token() function must be applied to all partition key components or none of them"	TokenNameStringLiteral	The token() function must be applied to all partition key components or none of them
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We only support IN for the last name so far 	TokenNameCOMMENT_LINE	We only support IN for the last name so far 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyRestrictions	TokenNameIdentifier	 key Restrictions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)"	TokenNameStringLiteral	Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)
,	TokenNameCOMMA	
cname	TokenNameIdentifier	 cname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
shouldBeDone	TokenNameIdentifier	 should Be Done
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
cname	TokenNameIdentifier	 cname
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Deal with indexed columns 	TokenNameCOMMENT_LINE	Deal with indexed columns 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasEq	TokenNameIdentifier	 has Eq
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
idxManager	TokenNameIdentifier	 idx Manager
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
keyspace	TokenNameIdentifier	 keyspace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
columnFamily	TokenNameIdentifier	 column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
indexedNames	TokenNameIdentifier	 indexed Names
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
index	TokenNameIdentifier	 index
:	TokenNameCOLON	
idxManager	TokenNameIdentifier	 idx Manager
.	TokenNameDOT	
getIndexes	TokenNameIdentifier	 get Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnDefinition	TokenNameIdentifier	 Column Definition
cdef	TokenNameIdentifier	 cdef
:	TokenNameCOLON	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getColumnDefs	TokenNameIdentifier	 get Column Defs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
indexedNames	TokenNameIdentifier	 indexed Names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cdef	TokenNameIdentifier	 cdef
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Note: we cannot use idxManager.indexes() methods because we don't have a complete column name at this point, we only 	TokenNameCOMMENT_LINE	Note: we cannot use idxManager.indexes() methods because we don't have a complete column name at this point, we only 
// have the indexed component. 	TokenNameCOMMENT_LINE	have the indexed component. 
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Restriction	TokenNameIdentifier	 Restriction
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// We don't support IN for indexed values (basically this would require supporting a form of OR) 	TokenNameCOMMENT_LINE	We don't support IN for indexed values (basically this would require supporting a form of OR) 
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Cannot use IN operator on column not part of the PRIMARY KEY"	TokenNameStringLiteral	Cannot use IN operator on column not part of the PRIMARY KEY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexedNames	TokenNameIdentifier	 indexed Names
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hasEq	TokenNameIdentifier	 has Eq
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasEq	TokenNameIdentifier	 has Eq
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"No indexed columns present in by-columns clause with Equal operator"	TokenNameStringLiteral	No indexed columns present in by-columns clause with Equal operator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If we have indexed columns and the key = X clause, we will do a range query, but if it's a IN relation, we don't know how to handle it. 	TokenNameCOMMENT_LINE	If we have indexed columns and the key = X clause, we will do a range query, but if it's a IN relation, we don't know how to handle it. 
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Select on indexed columns and with IN clause for the PRIMARY KEY are not supported"	TokenNameStringLiteral	Select on indexed columns and with IN clause for the PRIMARY KEY are not supported
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"ORDER BY with 2ndary indexes is not supported."	TokenNameStringLiteral	ORDER BY with 2ndary indexes is not supported.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"ORDER BY is only supported when the partition key is restricted by an EQ or an IN."	TokenNameStringLiteral	ORDER BY is only supported when the partition key is restricted by an EQ or an IN.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If we order an IN query, we'll have to do a manual sort post-query. Currently, this sorting requires that we 	TokenNameCOMMENT_LINE	If we order an IN query, we'll have to do a manual sort post-query. Currently, this sorting requires that we 
// have queried the column on which we sort (TODO: we should update it to add the column on which we sort to the one 	TokenNameCOMMENT_LINE	have queried the column on which we sort (TODO: we should update it to add the column on which we sort to the one 
// queried automatically, and then removing it from the resultSet afterwards if needed) 	TokenNameCOMMENT_LINE	queried automatically, and then removing it from the resultSet afterwards if needed) 
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
keyIsInRelation	TokenNameIdentifier	 key Is In Relation
&&	TokenNameAND_AND	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
selectedNames	TokenNameIdentifier	 selected Names
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// empty means wildcard was used 	TokenNameCOMMENT_LINE	empty means wildcard was used 
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
column	TokenNameIdentifier	 column
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasColumn	TokenNameIdentifier	 has Column
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
,	TokenNameCOMMA	
Selector	TokenNameIdentifier	 Selector
>	TokenNameGREATER	
selectPair	TokenNameIdentifier	 select Pair
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
selectedNames	TokenNameIdentifier	 selected Names
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
selectPair	TokenNameIdentifier	 select Pair
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hasColumn	TokenNameIdentifier	 has Column
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasColumn	TokenNameIdentifier	 has Column
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"ORDER BY could not be used on columns missing in select clause."	TokenNameStringLiteral	ORDER BY could not be used on columns missing in select clause.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
reversedMap	TokenNameIdentifier	 reversed Map
=	TokenNameEQUAL	
new	TokenNamenew	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
cfDef	TokenNameIdentifier	 cf Def
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Order by on unknown column %s"	TokenNameStringLiteral	Order by on unknown column %s
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
.	TokenNameDOT	
Kind	TokenNameIdentifier	 Kind
.	TokenNameDOT	
COLUMN_ALIAS	TokenNameIdentifier	 COLUMN  ALIAS
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s"	TokenNameStringLiteral	Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY"	TokenNameStringLiteral	Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reversedMap	TokenNameIdentifier	 reversed Map
[	TokenNameLBRACKET	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
!=	TokenNameNOT_EQUAL	
isReversedType	TokenNameIdentifier	 is Reversed Type
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check that all boolean in reversedMap, if set, agrees 	TokenNameCOMMENT_LINE	Check that all boolean in reversedMap, if set, agrees 
Boolean	TokenNameIdentifier	 Boolean
isReversed	TokenNameIdentifier	 is Reversed
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Boolean	TokenNameIdentifier	 Boolean
b	TokenNameIdentifier	 b
:	TokenNameCOLON	
reversedMap	TokenNameIdentifier	 reversed Map
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Column on which order is specified can be in any order 	TokenNameCOMMENT_LINE	Column on which order is specified can be in any order 
if	TokenNameif	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isReversed	TokenNameIdentifier	 is Reversed
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
isReversed	TokenNameIdentifier	 is Reversed
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isReversed	TokenNameIdentifier	 is Reversed
!=	TokenNameNOT_EQUAL	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Unsupported order by relation"	TokenNameStringLiteral	Unsupported order by relation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
isReversed	TokenNameIdentifier	 is Reversed
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isReversed	TokenNameIdentifier	 is Reversed
=	TokenNameEQUAL	
isReversed	TokenNameIdentifier	 is Reversed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Make sure this queries is allowed (note: only key range can involve filtering underneath) 	TokenNameCOMMENT_LINE	Make sure this queries is allowed (note: only key range can involve filtering underneath) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
allowFiltering	TokenNameIdentifier	 allow Filtering
&&	TokenNameAND_AND	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
isKeyRange	TokenNameIdentifier	 is Key Range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We will potentially filter data if either: 	TokenNameCOMMENT_LINE	We will potentially filter data if either: 
// - Have more than one IndexExpression 	TokenNameCOMMENT_LINE	- Have more than one IndexExpression 
// - Have no index expression and the column filter is not the identity 	TokenNameCOMMENT_LINE	- Have no index expression and the column filter is not the identity 
if	TokenNameif	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
metadataRestrictions	TokenNameIdentifier	 metadata Restrictions
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
stmt	TokenNameIdentifier	 stmt
.	TokenNameDOT	
columnFilterIsIdentity	TokenNameIdentifier	 column Filter Is Identity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
"Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. "	TokenNameStringLiteral	Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. 
+	TokenNamePLUS	
"If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"	TokenNameStringLiteral	If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ParsedStatement	TokenNameIdentifier	 Parsed Statement
.	TokenNameDOT	
Prepared	TokenNameIdentifier	 Prepared
(	TokenNameLPAREN	
stmt	TokenNameIdentifier	 stmt
,	TokenNameCOMMA	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
<	TokenNameLESS	
ColumnSpecification	TokenNameIdentifier	 Column Specification
>	TokenNameGREATER	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
names	TokenNameIdentifier	 names
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Restriction	TokenNameIdentifier	 Restriction
updateRestriction	TokenNameIdentifier	 update Restriction
(	TokenNameLPAREN	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Restriction	TokenNameIdentifier	 Restriction
restriction	TokenNameIdentifier	 restriction
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
newRel	TokenNameIdentifier	 new Rel
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
CFDefinition	TokenNameIdentifier	 CF Definition
.	TokenNameDOT	
Name	TokenNameIdentifier	 Name
.	TokenNameDOT	
Kind	TokenNameIdentifier	 Kind
.	TokenNameDOT	
KEY_ALIAS	TokenNameIdentifier	 KEY  ALIAS
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"The token() function is only supported on the partition key, found on %s"	TokenNameStringLiteral	The token() function is only supported on the partition key, found on %s
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
EQ	TokenNameIdentifier	 EQ
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s cannot be restricted by more than one relation if it includes an Equal"	TokenNameStringLiteral	%s cannot be restricted by more than one relation if it includes an Equal
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
new	TokenNamenew	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IN	TokenNameIdentifier	 IN
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s cannot be restricted by more than one reation if it includes a IN"	TokenNameStringLiteral	%s cannot be restricted by more than one reation if it includes a IN
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
new	TokenNamenew	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
getInValues	TokenNameIdentifier	 get In Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GT	TokenNameIdentifier	 GT
:	TokenNameCOLON	
case	TokenNamecase	
GTE	TokenNameIdentifier	 GTE
:	TokenNameCOLON	
case	TokenNamecase	
LT	TokenNameIdentifier	 LT
:	TokenNameCOLON	
case	TokenNamecase	
LTE	TokenNameIdentifier	 LTE
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
restriction	TokenNameIdentifier	 restriction
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
restriction	TokenNameIdentifier	 restriction
=	TokenNameEQUAL	
new	TokenNamenew	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
restriction	TokenNameIdentifier	 restriction
.	TokenNameDOT	
setBound	TokenNameIdentifier	 set Bound
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
operator	TokenNameIdentifier	 operator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
newRel	TokenNameIdentifier	 new Rel
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
restriction	TokenNameIdentifier	 restriction
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"SelectRawStatement[name=%s, selectClause=%s, whereClause=%s, isCount=%s, limit=%s]"	TokenNameStringLiteral	SelectRawStatement[name=%s, selectClause=%s, whereClause=%s, isCount=%s, limit=%s]
,	TokenNameCOMMA	
cfName	TokenNameIdentifier	 cf Name
,	TokenNameCOMMA	
selectClause	TokenNameIdentifier	 select Clause
,	TokenNameCOMMA	
whereClause	TokenNameIdentifier	 where Clause
,	TokenNameCOMMA	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
isCount	TokenNameIdentifier	 is Count
,	TokenNameCOMMA	
parameters	TokenNameIdentifier	 parameters
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// A rather raw class that simplify validation and query for select 	TokenNameCOMMENT_LINE	A rather raw class that simplify validation and query for select 
// Don't made public as this can be easily badly used 	TokenNameCOMMENT_LINE	Don't made public as this can be easily badly used 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
Restriction	TokenNameIdentifier	 Restriction
{	TokenNameLBRACE	
// for equality 	TokenNameCOMMENT_LINE	for equality 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
eqValues	TokenNameIdentifier	 eq Values
;	TokenNameSEMICOLON	
// if null, it's a restriction by bounds 	TokenNameCOMMENT_LINE	if null, it's a restriction by bounds 
// for bounds 	TokenNameCOMMENT_LINE	for bounds 
private	TokenNameprivate	
final	TokenNamefinal	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bounds	TokenNameIdentifier	 bounds
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
boundInclusive	TokenNameIdentifier	 bound Inclusive
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
onToken	TokenNameIdentifier	 on Token
;	TokenNameSEMICOLON	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
values	TokenNameIdentifier	 values
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
boundInclusive	TokenNameIdentifier	 bound Inclusive
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
Term	TokenNameIdentifier	 Term
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Restriction	TokenNameIdentifier	 Restriction
(	TokenNameLPAREN	
boolean	TokenNameboolean	
onToken	TokenNameIdentifier	 on Token
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
eqValues	TokenNameIdentifier	 eq Values
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bounds	TokenNameIdentifier	 bounds
=	TokenNameEQUAL	
new	TokenNamenew	
Term	TokenNameIdentifier	 Term
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
boundInclusive	TokenNameIdentifier	 bound Inclusive
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
onToken	TokenNameIdentifier	 on Token
=	TokenNameEQUAL	
onToken	TokenNameIdentifier	 on Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
isEquality	TokenNameIdentifier	 is Equality
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
eqValues	TokenNameIdentifier	 eq Values
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setBound	TokenNameIdentifier	 set Bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setInclusive	TokenNameIdentifier	 set Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Term	TokenNameIdentifier	 Term
bound	TokenNameIdentifier	 bound
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isInclusive	TokenNameIdentifier	 is Inclusive
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
getRelation	TokenNameIdentifier	 get Relation
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
eocBound	TokenNameIdentifier	 eoc Bound
,	TokenNameCOMMA	
Bound	TokenNameIdentifier	 Bound
inclusiveBound	TokenNameIdentifier	 inclusive Bound
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
eocBound	TokenNameIdentifier	 eoc Bound
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
START	TokenNameIdentifier	 START
:	TokenNameCOLON	
return	TokenNamereturn	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
inclusiveBound	TokenNameIdentifier	 inclusive Bound
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
GTE	TokenNameIdentifier	 GTE
:	TokenNameCOLON	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
GT	TokenNameIdentifier	 GT
;	TokenNameSEMICOLON	
case	TokenNamecase	
END	TokenNameIdentifier	 END
:	TokenNameCOLON	
return	TokenNamereturn	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
inclusiveBound	TokenNameIdentifier	 inclusive Bound
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
LTE	TokenNameIdentifier	 LTE
:	TokenNameCOLON	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
.	TokenNameDOT	
LT	TokenNameIdentifier	 LT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
IndexOperator	TokenNameIdentifier	 Index Operator
getIndexOperator	TokenNameIdentifier	 get Index Operator
(	TokenNameLPAREN	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
START	TokenNameIdentifier	 START
:	TokenNameCOLON	
return	TokenNamereturn	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
GTE	TokenNameIdentifier	 GTE
:	TokenNameCOLON	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
GT	TokenNameIdentifier	 GT
;	TokenNameSEMICOLON	
case	TokenNamecase	
END	TokenNameIdentifier	 END
:	TokenNameCOLON	
return	TokenNamereturn	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
LTE	TokenNameIdentifier	 LTE
:	TokenNameCOLON	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
LT	TokenNameIdentifier	 LT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setBound	TokenNameIdentifier	 set Bound
(	TokenNameLPAREN	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Relation	TokenNameIdentifier	 Relation
.	TokenNameDOT	
Type	TokenNameIdentifier	 Type
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
Term	TokenNameIdentifier	 Term
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
throws	TokenNamethrows	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
{	TokenNameLBRACE	
Bound	TokenNameIdentifier	 Bound
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
inclusive	TokenNameIdentifier	 inclusive
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
GT	TokenNameIdentifier	 GT
:	TokenNameCOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
;	TokenNameSEMICOLON	
inclusive	TokenNameIdentifier	 inclusive
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
GTE	TokenNameIdentifier	 GTE
:	TokenNameCOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
START	TokenNameIdentifier	 START
;	TokenNameSEMICOLON	
inclusive	TokenNameIdentifier	 inclusive
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LT	TokenNameIdentifier	 LT
:	TokenNameCOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
inclusive	TokenNameIdentifier	 inclusive
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LTE	TokenNameIdentifier	 LTE
:	TokenNameCOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
Bound	TokenNameIdentifier	 Bound
.	TokenNameDOT	
END	TokenNameIdentifier	 END
;	TokenNameSEMICOLON	
inclusive	TokenNameIdentifier	 inclusive
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s cannot be restricted by both an equal and an inequal relation"	TokenNameStringLiteral	%s cannot be restricted by both an equal and an inequal relation
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
InvalidRequestException	TokenNameIdentifier	 Invalid Request Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Invalid restrictions found on %s"	TokenNameStringLiteral	Invalid restrictions found on %s
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
idx	TokenNameIdentifier	 idx
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
inclusive	TokenNameIdentifier	 inclusive
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eqValues	TokenNameIdentifier	 eq Values
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"SLICE(%s %s, %s %s)"	TokenNameStringLiteral	SLICE(%s %s, %s %s)
,	TokenNameCOMMA	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
">="	TokenNameStringLiteral	>=
:	TokenNameCOLON	
">"	TokenNameStringLiteral	>
,	TokenNameCOMMA	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
boundInclusive	TokenNameIdentifier	 bound Inclusive
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
?	TokenNameQUESTION	
"<="	TokenNameStringLiteral	<=
:	TokenNameCOLON	
"<"	TokenNameStringLiteral	<
,	TokenNameCOMMA	
bounds	TokenNameIdentifier	 bounds
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"EQ(%s)"	TokenNameStringLiteral	EQ(%s)
,	TokenNameCOMMA	
eqValues	TokenNameIdentifier	 eq Values
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
onToken	TokenNameIdentifier	 on Token
?	TokenNameQUESTION	
s	TokenNameIdentifier	 s
+	TokenNamePLUS	
"*"	TokenNameStringLiteral	*
:	TokenNameCOLON	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
Parameters	TokenNameIdentifier	 Parameters
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
orderings	TokenNameIdentifier	 orderings
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
isCount	TokenNameIdentifier	 is Count
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
allowFiltering	TokenNameIdentifier	 allow Filtering
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Parameters	TokenNameIdentifier	 Parameters
(	TokenNameLPAREN	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
,	TokenNameCOMMA	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
ColumnIdentifier	TokenNameIdentifier	 Column Identifier
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
orderings	TokenNameIdentifier	 orderings
,	TokenNameCOMMA	
boolean	TokenNameboolean	
isCount	TokenNameIdentifier	 is Count
,	TokenNameCOMMA	
boolean	TokenNameboolean	
allowFiltering	TokenNameIdentifier	 allow Filtering
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
limit	TokenNameIdentifier	 limit
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
orderings	TokenNameIdentifier	 orderings
=	TokenNameEQUAL	
orderings	TokenNameIdentifier	 orderings
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
isCount	TokenNameIdentifier	 is Count
=	TokenNameEQUAL	
isCount	TokenNameIdentifier	 is Count
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
allowFiltering	TokenNameIdentifier	 allow Filtering
=	TokenNameEQUAL	
allowFiltering	TokenNameIdentifier	 allow Filtering
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Used in orderResults(...) method when single 'ORDER BY' condition where given */	TokenNameCOMMENT_JAVADOC	 Used in orderResults(...) method when single 'ORDER BY' condition where given 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
SingleColumnComparator	TokenNameIdentifier	 Single Column Comparator
implements	TokenNameimplements	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>>	TokenNameRIGHT_SHIFT	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SingleColumnComparator	TokenNameIdentifier	 Single Column Comparator
(	TokenNameLPAREN	
int	TokenNameint	
columnIndex	TokenNameIdentifier	 column Index
,	TokenNameCOMMA	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
orderer	TokenNameIdentifier	 orderer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
columnIndex	TokenNameIdentifier	 column Index
;	TokenNameSEMICOLON	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
orderer	TokenNameIdentifier	 orderer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Used in orderResults(...) method when multiple 'ORDER BY' conditions where given */	TokenNameCOMMENT_JAVADOC	 Used in orderResults(...) method when multiple 'ORDER BY' conditions where given 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CompositeComparator	TokenNameIdentifier	 Composite Comparator
implements	TokenNameimplements	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>>	TokenNameRIGHT_SHIFT	
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
orderTypes	TokenNameIdentifier	 order Types
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
positions	TokenNameIdentifier	 positions
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CompositeComparator	TokenNameIdentifier	 Composite Comparator
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
orderTypes	TokenNameIdentifier	 order Types
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
positions	TokenNameIdentifier	 positions
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
orderTypes	TokenNameIdentifier	 order Types
=	TokenNameEQUAL	
orderTypes	TokenNameIdentifier	 order Types
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
orderTypes	TokenNameIdentifier	 order Types
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnPos	TokenNameIdentifier	 column Pos
=	TokenNameEQUAL	
positions	TokenNameIdentifier	 positions
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
aValue	TokenNameIdentifier	 a Value
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnPos	TokenNameIdentifier	 column Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
bValue	TokenNameIdentifier	 b Value
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
columnPos	TokenNameIdentifier	 column Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
aValue	TokenNameIdentifier	 a Value
,	TokenNameCOMMA	
bValue	TokenNameIdentifier	 b Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
comparison	TokenNameIdentifier	 comparison
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
comparison	TokenNameIdentifier	 comparison
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
