/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ManagementFactory	TokenNameIdentifier	 Management Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
Lock	TokenNameIdentifier	 Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
locks	TokenNameIdentifier	 locks
.	TokenNameDOT	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
MBeanServer	TokenNameIdentifier	 M Bean Server
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ObjectName	TokenNameIdentifier	 Object Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Predicates	TokenNameIdentifier	 Predicates
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Throwables	TokenNameIdentifier	 Throwables
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
ConcurrentHashMultiset	TokenNameIdentifier	 Concurrent Hash Multiset
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Iterators	TokenNameIdentifier	 Iterators
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
Multiset	TokenNameIdentifier	 Multiset
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
primitives	TokenNameIdentifier	 primitives
.	TokenNameDOT	
Longs	TokenNameIdentifier	 Longs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
AutoSavingCache	TokenNameIdentifier	 Auto Saving Cache
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Schema	TokenNameIdentifier	 Schema
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
ReplayPosition	TokenNameIdentifier	 Replay Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexBuilder	TokenNameIdentifier	 Secondary Index Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Bounds	TokenNameIdentifier	 Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
CacheService	TokenNameIdentifier	 Cache Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
CloseableIterator	TokenNameIdentifier	 Closeable Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
CounterId	TokenNameIdentifier	 Counter Id
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
;	TokenNameSEMICOLON	
/** * A singleton which manages a private executor of ongoing compactions. A readwrite lock * controls whether compactions can proceed: an external consumer can completely stop * compactions by acquiring the write half of the lock via getCompactionLock(). * * Scheduling for compaction is accomplished by swapping sstables to be compacted into * a set via DataTracker. New scheduling attempts will ignore currently compacting * sstables. */	TokenNameCOMMENT_JAVADOC	 A singleton which manages a private executor of ongoing compactions. A readwrite lock controls whether compactions can proceed: an external consumer can completely stop compactions by acquiring the write half of the lock via getCompactionLock(). * Scheduling for compaction is accomplished by swapping sstables to be compacted into a set via DataTracker. New scheduling attempts will ignore currently compacting sstables. 
public	TokenNamepublic	
class	TokenNameclass	
CompactionManager	TokenNameIdentifier	 Compaction Manager
implements	TokenNameimplements	
CompactionManagerMBean	TokenNameIdentifier	 Compaction Manager M Bean
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
MBEAN_OBJECT_NAME	TokenNameIdentifier	 MBEAN  OBJECT  NAME
=	TokenNameEQUAL	
"org.apache.cassandra.db:type=CompactionManager"	TokenNameStringLiteral	org.apache.cassandra.db:type=CompactionManager
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
CompactionManager	TokenNameIdentifier	 Compaction Manager
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
CompactionManager	TokenNameIdentifier	 Compaction Manager
instance	TokenNameIdentifier	 instance
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
NO_GC	TokenNameIdentifier	 NO  GC
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
GC_ALL	TokenNameIdentifier	 GC  ALL
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
// A thread local that tells us if the current thread is owned by the compaction manager. Used 	TokenNameCOMMENT_LINE	A thread local that tells us if the current thread is owned by the compaction manager. Used 
// by CounterContext to figure out if it should log a warning for invalid counter shards. 	TokenNameCOMMENT_LINE	by CounterContext to figure out if it should log a warning for invalid counter shards. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
ThreadLocal	TokenNameIdentifier	 Thread Local
<	TokenNameLESS	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
isCompactionManager	TokenNameIdentifier	 is Compaction Manager
=	TokenNameEQUAL	
new	TokenNamenew	
ThreadLocal	TokenNameIdentifier	 Thread Local
<	TokenNameLESS	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
Boolean	TokenNameIdentifier	 Boolean
initialValue	TokenNameIdentifier	 initial Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** * compactionLock has two purposes: * - "Special" compactions will acquire writelock instead of readlock to make sure that all * other compaction activity is quiesced and they can grab ALL the sstables to do something. * - Some schema migrations cannot run concurrently with compaction. (Currently, this is * only when changing compaction strategy -- see CFS.maybeReloadCompactionStrategy.) * * TODO this is too big a hammer -- we should only care about quiescing all for the given CFS. */	TokenNameCOMMENT_JAVADOC	 compactionLock has two purposes: - "Special" compactions will acquire writelock instead of readlock to make sure that all other compaction activity is quiesced and they can grab ALL the sstables to do something. - Some schema migrations cannot run concurrently with compaction. (Currently, this is only when changing compaction strategy -- see CFS.maybeReloadCompactionStrategy.) * TODO this is too big a hammer -- we should only care about quiescing all for the given CFS. 
private	TokenNameprivate	
final	TokenNamefinal	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
compactionLock	TokenNameIdentifier	 compaction Lock
=	TokenNameEQUAL	
new	TokenNamenew	
ReentrantReadWriteLock	TokenNameIdentifier	 Reentrant Read Write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
instance	TokenNameIdentifier	 instance
=	TokenNameEQUAL	
new	TokenNamenew	
CompactionManager	TokenNameIdentifier	 Compaction Manager
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
registerMBean	TokenNameIdentifier	 register M Bean
(	TokenNameLPAREN	
instance	TokenNameIdentifier	 instance
,	TokenNameCOMMA	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
MBEAN_OBJECT_NAME	TokenNameIdentifier	 MBEAN  OBJECT  NAME
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
new	TokenNamenew	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
validationExecutor	TokenNameIdentifier	 validation Executor
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationExecutor	TokenNameIdentifier	 Validation Executor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
metrics	TokenNameIdentifier	 metrics
=	TokenNameEQUAL	
new	TokenNamenew	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
,	TokenNameCOMMA	
validationExecutor	TokenNameIdentifier	 validation Executor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Multiset	TokenNameIdentifier	 Multiset
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
compactingCF	TokenNameIdentifier	 compacting CF
=	TokenNameEQUAL	
ConcurrentHashMultiset	TokenNameIdentifier	 Concurrent Hash Multiset
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * @return A lock, for which acquisition means no compactions can run. */	TokenNameCOMMENT_JAVADOC	 @return A lock, for which acquisition means no compactions can run. 
public	TokenNamepublic	
Lock	TokenNameIdentifier	 Lock
getCompactionLock	TokenNameIdentifier	 get Compaction Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Call this whenever a compaction might be needed on the given columnfamily. * It's okay to over-call (within reason) since the compactions are single-threaded, * and if a call is unnecessary, it will just be no-oped in the bucketing phase. */	TokenNameCOMMENT_JAVADOC	 Call this whenever a compaction might be needed on the given columnfamily. It's okay to over-call (within reason) since the compactions are single-threaded, and if a call is unnecessary, it will just be no-oped in the bucketing phase. 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
submitBackground	TokenNameIdentifier	 submit Background
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
compactingCF	TokenNameIdentifier	 compacting CF
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
getActiveCount	TokenNameIdentifier	 get Active Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
getMaximumPoolSize	TokenNameIdentifier	 get Maximum Pool Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Background compaction is still running for {}.{} ({} remaining). Skipping"	TokenNameStringLiteral	Background compaction is still running for {}.{} ({} remaining). Skipping
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Scheduling a background task check for {}.{} with {}"	TokenNameStringLiteral	Scheduling a background task check for {}.{} with {}
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getSimpleName	TokenNameIdentifier	 get Simple Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
futures	TokenNameIdentifier	 futures
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if we have room for more compactions, then fill up executor 	TokenNameCOMMENT_LINE	if we have room for more compactions, then fill up executor 
while	TokenNamewhile	
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
getActiveCount	TokenNameIdentifier	 get Active Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
futures	TokenNameIdentifier	 futures
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
<	TokenNameLESS	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
getMaximumPoolSize	TokenNameIdentifier	 get Maximum Pool Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
futures	TokenNameIdentifier	 futures
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
new	TokenNamenew	
BackgroundCompactionTask	TokenNameIdentifier	 Background Compaction Task
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compactingCF	TokenNameIdentifier	 compacting CF
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
futures	TokenNameIdentifier	 futures
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// the actual sstables to compact are not determined until we run the BCT; that way, if new sstables 	TokenNameCOMMENT_LINE	the actual sstables to compact are not determined until we run the BCT; that way, if new sstables 
// are created between task submission and execution, we execute against the most up-to-date information 	TokenNameCOMMENT_LINE	are created between task submission and execution, we execute against the most up-to-date information 
class	TokenNameclass	
BackgroundCompactionTask	TokenNameIdentifier	 Background Compaction Task
implements	TokenNameimplements	
Runnable	TokenNameIdentifier	 Runnable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
BackgroundCompactionTask	TokenNameIdentifier	 Background Compaction Task
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Checking {}.{}"	TokenNameStringLiteral	Checking {}.{}
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// log after we get the lock so we can see delays from that if any 	TokenNameCOMMENT_LINE	log after we get the lock so we can see delays from that if any 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Aborting compaction for dropped CF"	TokenNameStringLiteral	Aborting compaction for dropped CF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
AbstractCompactionStrategy	TokenNameIdentifier	 Abstract Compaction Strategy
strategy	TokenNameIdentifier	 strategy
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractCompactionTask	TokenNameIdentifier	 Abstract Compaction Task
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getNextBackgroundTask	TokenNameIdentifier	 get Next Background Task
(	TokenNameLPAREN	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"No tasks available"	TokenNameStringLiteral	No tasks available
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
unmarkSSTables	TokenNameIdentifier	 unmark SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactingCF	TokenNameIdentifier	 compacting CF
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
submitBackground	TokenNameIdentifier	 submit Background
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
interface	TokenNameinterface	
AllSSTablesOperation	TokenNameIdentifier	 All SS Tables Operation
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
perform	TokenNameIdentifier	 perform
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
performAllSSTableOperation	TokenNameIdentifier	 perform All SS Table Operation
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
final	TokenNamefinal	
AllSSTablesOperation	TokenNameIdentifier	 All SS Tables Operation
operation	TokenNameIdentifier	 operation
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getUncompactingSSTables	TokenNameIdentifier	 get Uncompacting SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
markCompacting	TokenNameIdentifier	 mark Compacting
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// downgrade the lock acquisition 	TokenNameCOMMENT_LINE	downgrade the lock acquisition 
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
operation	TokenNameIdentifier	 operation
.	TokenNameDOT	
perform	TokenNameIdentifier	 perform
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unmarkCompacting	TokenNameIdentifier	 unmark Compacting
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// we probably already downgraded 	TokenNameCOMMENT_LINE	we probably already downgraded 
if	TokenNameif	
(	TokenNameLPAREN	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isHeldByCurrentThread	TokenNameIdentifier	 is Held By Current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
performScrub	TokenNameIdentifier	 perform Scrub
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
performAllSSTableOperation	TokenNameIdentifier	 perform All SS Table Operation
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
new	TokenNamenew	
AllSSTablesOperation	TokenNameIdentifier	 All SS Tables Operation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
perform	TokenNameIdentifier	 perform
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
doScrub	TokenNameIdentifier	 do Scrub
(	TokenNameLPAREN	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
performSSTableRewrite	TokenNameIdentifier	 perform SS Table Rewrite
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
performAllSSTableOperation	TokenNameIdentifier	 perform All SS Table Operation
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
new	TokenNamenew	
AllSSTablesOperation	TokenNameIdentifier	 All SS Tables Operation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
perform	TokenNameIdentifier	 perform
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// SSTables are marked by the caller 	TokenNameCOMMENT_LINE	SSTables are marked by the caller 
// NOTE: it is important that the task create one and only one sstable, even for Leveled compaction (see LeveledManifest.replace()) 	TokenNameCOMMENT_LINE	NOTE: it is important that the task create one and only one sstable, even for Leveled compaction (see LeveledManifest.replace()) 
CompactionTask	TokenNameIdentifier	 Compaction Task
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
new	TokenNamenew	
CompactionTask	TokenNameIdentifier	 Compaction Task
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
NO_GC	TokenNameIdentifier	 NO  GC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
setUserDefined	TokenNameIdentifier	 set User Defined
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
setCompactionType	TokenNameIdentifier	 set Compaction Type
(	TokenNameLPAREN	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
UPGRADE_SSTABLES	TokenNameIdentifier	 UPGRADE  SSTABLES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
performCleanup	TokenNameIdentifier	 perform Cleanup
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
final	TokenNamefinal	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
OneShotRenewer	TokenNameIdentifier	 One Shot Renewer
renewer	TokenNameIdentifier	 renewer
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
performAllSSTableOperation	TokenNameIdentifier	 perform All SS Table Operation
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
new	TokenNamenew	
AllSSTablesOperation	TokenNameIdentifier	 All SS Tables Operation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
perform	TokenNameIdentifier	 perform
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Sort the column families in order of SSTable size, so cleanup of smaller CFs 	TokenNameCOMMENT_LINE	Sort the column families in order of SSTable size, so cleanup of smaller CFs 
// can free up space for larger ones 	TokenNameCOMMENT_LINE	can free up space for larger ones 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sortedSSTables	TokenNameIdentifier	 sorted SS Tables
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
sortedSSTables	TokenNameIdentifier	 sorted SS Tables
,	TokenNameCOMMA	
new	TokenNamenew	
Comparator	TokenNameIdentifier	 Comparator
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
o1	TokenNameIdentifier	 o1
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
o2	TokenNameIdentifier	 o2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
Longs	TokenNameIdentifier	 Longs
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
o1	TokenNameIdentifier	 o1
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
o2	TokenNameIdentifier	 o2
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
doCleanupCompaction	TokenNameIdentifier	 do Cleanup Compaction
(	TokenNameLPAREN	
store	TokenNameIdentifier	 store
,	TokenNameCOMMA	
sortedSSTables	TokenNameIdentifier	 sorted SS Tables
,	TokenNameCOMMA	
renewer	TokenNameIdentifier	 renewer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
performMaximal	TokenNameIdentifier	 perform Maximal
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
submitMaximal	TokenNameIdentifier	 submit Maximal
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
submitMaximal	TokenNameIdentifier	 submit Maximal
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// acquire the write lock long enough to schedule all sstables 	TokenNameCOMMENT_LINE	acquire the write lock long enough to schedule all sstables 
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
AbstractCompactionTask	TokenNameIdentifier	 Abstract Compaction Task
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
cfStore	TokenNameIdentifier	 cf Store
.	TokenNameDOT	
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getMaximalTask	TokenNameIdentifier	 get Maximal Task
(	TokenNameLPAREN	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// downgrade the lock acquisition 	TokenNameCOMMENT_LINE	downgrade the lock acquisition 
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
unmarkSSTables	TokenNameIdentifier	 unmark SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
// we probably already downgraded 	TokenNameCOMMENT_LINE	we probably already downgraded 
if	TokenNameif	
(	TokenNameLPAREN	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isHeldByCurrentThread	TokenNameIdentifier	 is Held By Current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
forceUserDefinedCompaction	TokenNameIdentifier	 force User Defined Compaction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksname	TokenNameIdentifier	 ksname
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
dataFiles	TokenNameIdentifier	 data Files
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTables	TokenNameIdentifier	 get Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
ksname	TokenNameIdentifier	 ksname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Unknown keyspace "	TokenNameStringLiteral	Unknown keyspace 
+	TokenNamePLUS	
ksname	TokenNameIdentifier	 ksname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
directory	TokenNameIdentifier	 directory
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
ksname	TokenNameIdentifier	 ksname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
filenames	TokenNameIdentifier	 filenames
=	TokenNameEQUAL	
dataFiles	TokenNameIdentifier	 data Files
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
","	TokenNameStringLiteral	,
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
>	TokenNameGREATER	
descriptors	TokenNameIdentifier	 descriptors
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
>	TokenNameGREATER	
(	TokenNameLPAREN	
filenames	TokenNameIdentifier	 filenames
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
filename	TokenNameIdentifier	 filename
:	TokenNameCOLON	
filenames	TokenNameIdentifier	 filenames
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
Descriptor	TokenNameIdentifier	 Descriptor
.	TokenNameDOT	
fromFilename	TokenNameIdentifier	 from Filename
(	TokenNameLPAREN	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
filename	TokenNameIdentifier	 filename
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
+	TokenNamePLUS	
" does not appear to be a data file"	TokenNameStringLiteral	 does not appear to be a data file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
cfname	TokenNameIdentifier	 cfname
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfname	TokenNameIdentifier	 cfname
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"All provided sstables should be for the same column family"	TokenNameStringLiteral	All provided sstables should be for the same column family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
descriptors	TokenNameIdentifier	 descriptors
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
ksname	TokenNameIdentifier	 ksname
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamilyStore	TokenNameIdentifier	 get Column Family Store
(	TokenNameLPAREN	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
submitUserDefined	TokenNameIdentifier	 submit User Defined
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
descriptors	TokenNameIdentifier	 descriptors
,	TokenNameCOMMA	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
submitUserDefined	TokenNameIdentifier	 submit User Defined
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
final	TokenNamefinal	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
>	TokenNameGREATER	
dataFiles	TokenNameIdentifier	 data Files
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
WrappedRunnable	TokenNameIdentifier	 Wrapped Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
runMayThrow	TokenNameIdentifier	 run May Throw
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// look up the sstables now that we're on the compaction executor, so we don't try to re-compact 	TokenNameCOMMENT_LINE	look up the sstables now that we're on the compaction executor, so we don't try to re-compact 
// something that was already being compacted earlier. 	TokenNameCOMMENT_LINE	something that was already being compacted earlier. 
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
dataFiles	TokenNameIdentifier	 data Files
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
:	TokenNameCOLON	
dataFiles	TokenNameIdentifier	 data Files
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// inefficient but not in a performance sensitive path 	TokenNameCOMMENT_LINE	inefficient but not in a performance sensitive path 
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
lookupSSTable	TokenNameIdentifier	 lookup SS Table
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Will not compact {}: it is not an active sstable"	TokenNameStringLiteral	Will not compact {}: it is not an active sstable
,	TokenNameCOMMA	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"No file to compact for user defined compaction"	TokenNameStringLiteral	No file to compact for user defined compaction
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// attempt to schedule the set 	TokenNameCOMMENT_LINE	attempt to schedule the set 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
markCompacting	TokenNameIdentifier	 mark Compacting
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// success: perform the compaction 	TokenNameCOMMENT_LINE	success: perform the compaction 
try	TokenNametry	
{	TokenNameLBRACE	
AbstractCompactionStrategy	TokenNameIdentifier	 Abstract Compaction Strategy
strategy	TokenNameIdentifier	 strategy
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractCompactionTask	TokenNameIdentifier	 Abstract Compaction Task
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
strategy	TokenNameIdentifier	 strategy
.	TokenNameDOT	
getUserDefinedTask	TokenNameIdentifier	 get User Defined Task
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
task	TokenNameIdentifier	 task
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
metrics	TokenNameIdentifier	 metrics
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getDataTracker	TokenNameIdentifier	 get Data Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unmarkCompacting	TokenNameIdentifier	 unmark Compacting
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"SSTables for user defined compaction are already being compacted."	TokenNameStringLiteral	SSTables for user defined compaction are already being compacted.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// This acquire a reference on the sstable 	TokenNameCOMMENT_LINE	This acquire a reference on the sstable 
// This is not efficent, do not use in any critical path 	TokenNameCOMMENT_LINE	This is not efficent, do not use in any critical path 
private	TokenNameprivate	
SSTableReader	TokenNameIdentifier	 SS Table Reader
lookupSSTable	TokenNameIdentifier	 lookup SS Table
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
markCurrentSSTablesReferenced	TokenNameIdentifier	 mark Current SS Tables Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// .equals() with no other changes won't work because in sstable.descriptor, the directory is an absolute path. 	TokenNameCOMMENT_LINE	.equals() with no other changes won't work because in sstable.descriptor, the directory is an absolute path. 
// We could construct descriptor with an absolute path too but I haven't found any satisfying way to do that 	TokenNameCOMMENT_LINE	We could construct descriptor with an absolute path too but I haven't found any satisfying way to do that 
// (DB.getDataFileLocationForTable() may not return the right path if you have multiple volumes). Hence the 	TokenNameCOMMENT_LINE	(DB.getDataFileLocationForTable() may not return the right path if you have multiple volumes). Hence the 
// endsWith. 	TokenNameCOMMENT_LINE	endsWith. 
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
found	TokenNameIdentifier	 found
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
else	TokenNameelse	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
releaseReference	TokenNameIdentifier	 release Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
found	TokenNameIdentifier	 found
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Does not mutate data, so is not scheduled. */	TokenNameCOMMENT_JAVADOC	 Does not mutate data, so is not scheduled. 
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
submitValidation	TokenNameIdentifier	 submit Validation
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
final	TokenNamefinal	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
Validator	TokenNameIdentifier	 Validator
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
callable	TokenNameIdentifier	 callable
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
doValidationCompaction	TokenNameIdentifier	 do Validation Compaction
(	TokenNameLPAREN	
cfStore	TokenNameIdentifier	 cf Store
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
validationExecutor	TokenNameIdentifier	 validation Executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
callable	TokenNameIdentifier	 callable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Used in tests. */	TokenNameCOMMENT_BLOCK	 Used in tests. 
public	TokenNamepublic	
void	TokenNamevoid	
disableAutoCompaction	TokenNameIdentifier	 disable Auto Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
ksname	TokenNameIdentifier	 ksname
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getNonSystemTables	TokenNameIdentifier	 get Non System Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
:	TokenNameCOLON	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
ksname	TokenNameIdentifier	 ksname
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamilyStores	TokenNameIdentifier	 get Column Family Stores
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
disableAutoCompaction	TokenNameIdentifier	 disable Auto Compaction
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Deserialize everything in the CFS and re-serialize w/ the newest version. Also attempts to recover * from bogus row keys / sizes using data from the index, and skips rows with garbage columns that resulted * from early ByteBuffer bugs. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Deserialize everything in the CFS and re-serialize w/ the newest version. Also attempts to recover from bogus row keys / sizes using data from the index, and skips rows with garbage columns that resulted from early ByteBuffer bugs. * @throws IOException 
private	TokenNameprivate	
void	TokenNamevoid	
doScrub	TokenNameIdentifier	 do Scrub
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
scrubOne	TokenNameIdentifier	 scrub One
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
scrubOne	TokenNameIdentifier	 scrub One
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
Scrubber	TokenNameIdentifier	 Scrubber
scrubber	TokenNameIdentifier	 scrubber
=	TokenNameEQUAL	
new	TokenNamenew	
Scrubber	TokenNameIdentifier	 Scrubber
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
scrubInfo	TokenNameIdentifier	 scrub Info
=	TokenNameEQUAL	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
getScrubInfo	TokenNameIdentifier	 get Scrub Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
scrubInfo	TokenNameIdentifier	 scrub Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
scrub	TokenNameIdentifier	 scrub
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
scrubInfo	TokenNameIdentifier	 scrub Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
getNewInOrderSSTable	TokenNameIdentifier	 get New In Order SS Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
addSSTable	TokenNameIdentifier	 add SS Table
(	TokenNameLPAREN	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
getNewInOrderSSTable	TokenNameIdentifier	 get New In Order SS Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
getNewSSTable	TokenNameIdentifier	 get New SS Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
markCompacted	TokenNameIdentifier	 mark Compacted
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
SCRUB	TokenNameIdentifier	 SCRUB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
replaceCompactedSSTables	TokenNameIdentifier	 replace Compacted SS Tables
(	TokenNameLPAREN	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
scrubber	TokenNameIdentifier	 scrubber
.	TokenNameDOT	
getNewSSTable	TokenNameIdentifier	 get New SS Table
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
SCRUB	TokenNameIdentifier	 SCRUB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * This function goes over each file and removes the keys that the node is not responsible for * and only keeps keys that this node is responsible for. * * @throws IOException */	TokenNameCOMMENT_JAVADOC	 This function goes over each file and removes the keys that the node is not responsible for and only keeps keys that this node is responsible for. * @throws IOException 
private	TokenNameprivate	
void	TokenNamevoid	
doCleanupCompaction	TokenNameIdentifier	 do Cleanup Compaction
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
CounterId	TokenNameIdentifier	 Counter Id
.	TokenNameDOT	
OneShotRenewer	TokenNameIdentifier	 One Shot Renewer
renewer	TokenNameIdentifier	 renewer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Table	TokenNameIdentifier	 Table
table	TokenNameIdentifier	 table
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getLocalRanges	TokenNameIdentifier	 get Local Ranges
(	TokenNameLPAREN	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Cleanup cannot run before a node has joined the ring"	TokenNameStringLiteral	Cleanup cannot run before a node has joined the ring
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
isCommutative	TokenNameIdentifier	 is Commutative
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getDefaultValidator	TokenNameIdentifier	 get Default Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isCommutative	TokenNameIdentifier	 is Commutative
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasIndexes	TokenNameIdentifier	 has Indexes
=	TokenNameEQUAL	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexes	TokenNameIdentifier	 get Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasIndexes	TokenNameIdentifier	 has Indexes
&&	TokenNameAND_AND	
!	TokenNameNOT	
new	TokenNamenew	
Bounds	TokenNameIdentifier	 Bounds
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
.	TokenNameDOT	
intersects	TokenNameIdentifier	 intersects
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
replaceCompactedSSTables	TokenNameIdentifier	 replace Compacted SS Tables
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
CLEANUP	TokenNameIdentifier	 CLEANUP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CompactionController	TokenNameIdentifier	 Compaction Controller
controller	TokenNameIdentifier	 controller
=	TokenNameEQUAL	
new	TokenNamenew	
CompactionController	TokenNameIdentifier	 Compaction Controller
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
startTime	TokenNameIdentifier	 start Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
totalkeysWritten	TokenNameIdentifier	 totalkeys Written
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
expectedBloomFilterSize	TokenNameIdentifier	 expected Bloom Filter Size
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
getApproximateKeyCount	TokenNameIdentifier	 get Approximate Key Count
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Expected bloom filter size : "	TokenNameStringLiteral	Expected bloom filter size : 
+	TokenNamePLUS	
expectedBloomFilterSize	TokenNameIdentifier	 expected Bloom Filter Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
newSstable	TokenNameIdentifier	 new Sstable
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Cleaning up "	TokenNameStringLiteral	Cleaning up 
+	TokenNamePLUS	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Calculate the expected compacted filesize 	TokenNameCOMMENT_LINE	Calculate the expected compacted filesize 
long	TokenNamelong	
expectedRangeFileSize	TokenNameIdentifier	 expected Range File Size
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getExpectedCompactedFileSize	TokenNameIdentifier	 get Expected Compacted File Size
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
CLEANUP	TokenNameIdentifier	 CLEANUP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
compactionFileLocation	TokenNameIdentifier	 compaction File Location
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
getDirectoryForNewSSTables	TokenNameIdentifier	 get Directory For New SS Tables
(	TokenNameLPAREN	
expectedRangeFileSize	TokenNameIdentifier	 expected Range File Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compactionFileLocation	TokenNameIdentifier	 compaction File Location
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"disk full"	TokenNameStringLiteral	disk full
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
scanner	TokenNameIdentifier	 scanner
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getDirectScanner	TokenNameIdentifier	 get Direct Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
rowsRead	TokenNameIdentifier	 rows Read
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
CleanupInfo	TokenNameIdentifier	 Cleanup Info
ci	TokenNameIdentifier	 ci
=	TokenNameEQUAL	
new	TokenNamenew	
CleanupInfo	TokenNameIdentifier	 Cleanup Info
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
scanner	TokenNameIdentifier	 scanner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
isStopRequested	TokenNameIdentifier	 is Stop Requested
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
CompactionInterruptedException	TokenNameIdentifier	 Compaction Interrupted Exception
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableIdentityIterator	TokenNameIdentifier	 SS Table Identity Iterator
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SSTableIdentityIterator	TokenNameIdentifier	 SS Table Identity Iterator
)	TokenNameRPAREN	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
.	TokenNameDOT	
isInRanges	TokenNameIdentifier	 is In Ranges
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AbstractCompactedRow	TokenNameIdentifier	 Abstract Compacted Row
compactedRow	TokenNameIdentifier	 compacted Row
=	TokenNameEQUAL	
controller	TokenNameIdentifier	 controller
.	TokenNameDOT	
getCompactedRow	TokenNameIdentifier	 get Compacted Row
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
compactedRow	TokenNameIdentifier	 compacted Row
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
maybeCreateWriter	TokenNameIdentifier	 maybe Create Writer
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
compactionFileLocation	TokenNameIdentifier	 compaction File Location
,	TokenNameCOMMA	
expectedBloomFilterSize	TokenNameIdentifier	 expected Bloom Filter Size
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
compactedRow	TokenNameIdentifier	 compacted Row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalkeysWritten	TokenNameIdentifier	 totalkeys Written
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
invalidateCachedRow	TokenNameIdentifier	 invalidate Cached Row
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
hasIndexes	TokenNameIdentifier	 has Indexes
||	TokenNameOR_OR	
isCommutative	TokenNameIdentifier	 is Commutative
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
instanceof	TokenNameinstanceof	
CounterColumn	TokenNameIdentifier	 Counter Column
)	TokenNameRPAREN	
renewer	TokenNameIdentifier	 renewer
.	TokenNameDOT	
maybeRenew	TokenNameIdentifier	 maybe Renew
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CounterColumn	TokenNameIdentifier	 Counter Column
)	TokenNameRPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
instanceof	TokenNameinstanceof	
IColumn	TokenNameIdentifier	 I Column
&&	TokenNameAND_AND	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
indexes	TokenNameIdentifier	 indexes
(	TokenNameLPAREN	
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
)	TokenNameRPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
)	TokenNameRPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// acquire memtable lock here because secondary index deletion may cause a race. See CASSANDRA-3712 	TokenNameCOMMENT_LINE	acquire memtable lock here because secondary index deletion may cause a race. See CASSANDRA-3712 
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
deleteFromIndexes	TokenNameIdentifier	 delete From Indexes
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
indexedColumnsInRow	TokenNameIdentifier	 indexed Columns In Row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
switchLock	TokenNameIdentifier	 switch Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
rowsRead	TokenNameIdentifier	 rows Read
++	TokenNamePLUS_PLUS	
%	TokenNameREMAINDER	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
controller	TokenNameIdentifier	 controller
.	TokenNameDOT	
mayThrottle	TokenNameIdentifier	 may Throttle
(	TokenNameLPAREN	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
getCurrentPosition	TokenNameIdentifier	 get Current Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
newSstable	TokenNameIdentifier	 new Sstable
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
closeAndOpenReader	TokenNameIdentifier	 close And Open Reader
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
maxDataAge	TokenNameIdentifier	 max Data Age
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
Throwables	TokenNameIdentifier	 Throwables
.	TokenNameDOT	
propagate	TokenNameIdentifier	 propagate
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
controller	TokenNameIdentifier	 controller
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
results	TokenNameIdentifier	 results
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
newSstable	TokenNameIdentifier	 new Sstable
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
results	TokenNameIdentifier	 results
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
newSstable	TokenNameIdentifier	 new Sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
format	TokenNameIdentifier	 format
=	TokenNameEQUAL	
"Cleaned up to %s. %,d to %,d (~%d%% of original) bytes for %,d keys. Time: %,dms."	TokenNameStringLiteral	Cleaned up to %s. %,d to %,d (~%d%% of original) bytes for %,d keys. Time: %,dms.
;	TokenNameSEMICOLON	
long	TokenNamelong	
dTime	TokenNameIdentifier	 d Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
startTime	TokenNameIdentifier	 start Time
;	TokenNameSEMICOLON	
long	TokenNamelong	
startsize	TokenNameIdentifier	 startsize
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
endsize	TokenNameIdentifier	 endsize
=	TokenNameEQUAL	
newSstable	TokenNameIdentifier	 new Sstable
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
double	TokenNamedouble	
ratio	TokenNameIdentifier	 ratio
=	TokenNameEQUAL	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
endsize	TokenNameIdentifier	 endsize
/	TokenNameDIVIDE	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
startsize	TokenNameIdentifier	 startsize
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
format	TokenNameIdentifier	 format
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
startsize	TokenNameIdentifier	 startsize
,	TokenNameCOMMA	
endsize	TokenNameIdentifier	 endsize
,	TokenNameCOMMA	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
ratio	TokenNameIdentifier	 ratio
*	TokenNameMULTIPLY	
100	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
totalkeysWritten	TokenNameIdentifier	 totalkeys Written
,	TokenNameCOMMA	
dTime	TokenNameIdentifier	 d Time
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd 	TokenNameCOMMENT_LINE	flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd 
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
flushIndexesBlocking	TokenNameIdentifier	 flush Indexes Blocking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
replaceCompactedSSTables	TokenNameIdentifier	 replace Compacted SS Tables
(	TokenNameLPAREN	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
asList	TokenNameIdentifier	 as List
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
,	TokenNameCOMMA	
results	TokenNameIdentifier	 results
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
CLEANUP	TokenNameIdentifier	 CLEANUP
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
maybeCreateWriter	TokenNameIdentifier	 maybe Create Writer
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
compactionFileLocation	TokenNameIdentifier	 compaction File Location
,	TokenNameCOMMA	
int	TokenNameint	
expectedBloomFilterSize	TokenNameIdentifier	 expected Bloom Filter Size
,	TokenNameCOMMA	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
createDirectory	TokenNameIdentifier	 create Directory
(	TokenNameLPAREN	
compactionFileLocation	TokenNameIdentifier	 compaction File Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
createCompactionWriter	TokenNameIdentifier	 create Compaction Writer
(	TokenNameLPAREN	
expectedBloomFilterSize	TokenNameIdentifier	 expected Bloom Filter Size
,	TokenNameCOMMA	
compactionFileLocation	TokenNameIdentifier	 compaction File Location
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
writer	TokenNameIdentifier	 writer
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Performs a readonly "compaction" of all sstables in order to validate complete rows, * but without writing the merge result */	TokenNameCOMMENT_JAVADOC	 Performs a readonly "compaction" of all sstables in order to validate complete rows, but without writing the merge result 
private	TokenNameprivate	
void	TokenNamevoid	
doValidationCompaction	TokenNameIdentifier	 do Validation Compaction
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
AntiEntropyService	TokenNameIdentifier	 Anti Entropy Service
.	TokenNameDOT	
Validator	TokenNameIdentifier	 Validator
validator	TokenNameIdentifier	 validator
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// this isn't meant to be race-proof, because it's not -- it won't cause bugs for a CFS to be dropped 	TokenNameCOMMENT_LINE	this isn't meant to be race-proof, because it's not -- it won't cause bugs for a CFS to be dropped 
// mid-validation, or to attempt to validate a droped CFS. this is just a best effort to avoid useless work, 	TokenNameCOMMENT_LINE	mid-validation, or to attempt to validate a droped CFS. this is just a best effort to avoid useless work, 
// particularly in the scenario where a validation is submitted before the drop, and there are compactions 	TokenNameCOMMENT_LINE	particularly in the scenario where a validation is submitted before the drop, and there are compactions 
// started prior to the drop keeping some sstables alive. Since validationCompaction can run 	TokenNameCOMMENT_LINE	started prior to the drop keeping some sstables alive. Since validationCompaction can run 
// concurrently with other compactions, it would otherwise go ahead and scan those again. 	TokenNameCOMMENT_LINE	concurrently with other compactions, it would otherwise go ahead and scan those again. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
sessionid	TokenNameIdentifier	 sessionid
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If there is a snapshot created for the session then read from there. 	TokenNameCOMMENT_LINE	If there is a snapshot created for the session then read from there. 
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getSnapshotSSTableReader	TokenNameIdentifier	 get Snapshot SS Table Reader
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
sessionid	TokenNameIdentifier	 sessionid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Computing gcbefore based on the current time wouldn't be very good because we know each replica will execute 	TokenNameCOMMENT_LINE	Computing gcbefore based on the current time wouldn't be very good because we know each replica will execute 
// this at a different time (that's the whole purpose of repair with snaphsot). So instead we take the creation 	TokenNameCOMMENT_LINE	this at a different time (that's the whole purpose of repair with snaphsot). So instead we take the creation 
// time of the snapshot, which should give us roughtly the same time on each replica (roughtly being in that case 	TokenNameCOMMENT_LINE	time of the snapshot, which should give us roughtly the same time on each replica (roughtly being in that case 
// 'as good as in the non-snapshot' case) 	TokenNameCOMMENT_LINE	'as good as in the non-snapshot' case) 
gcBefore	TokenNameIdentifier	 gc Before
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getSnapshotCreationTime	TokenNameIdentifier	 get Snapshot Creation Time
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
sessionid	TokenNameIdentifier	 sessionid
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getGcGraceSeconds	TokenNameIdentifier	 get Gc Grace Seconds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// flush first so everyone is validating data that is as similar as possible 	TokenNameCOMMENT_LINE	flush first so everyone is validating data that is as similar as possible 
try	TokenNametry	
{	TokenNameLBRACE	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
forceTableFlush	TokenNameIdentifier	 force Table Flush
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ExecutionException	TokenNameIdentifier	 Execution Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we don't mark validating sstables as compacting in DataTracker, so we have to mark them referenced 	TokenNameCOMMENT_LINE	we don't mark validating sstables as compacting in DataTracker, so we have to mark them referenced 
// instead so they won't be cleaned up if they do get compacted during the validation 	TokenNameCOMMENT_LINE	instead so they won't be cleaned up if they do get compacted during the validation 
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
markCurrentSSTablesReferenced	TokenNameIdentifier	 mark Current SS Tables Referenced
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gcBefore	TokenNameIdentifier	 gc Before
=	TokenNameEQUAL	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
CompactionIterable	TokenNameIdentifier	 Compaction Iterable
ci	TokenNameIdentifier	 ci
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationCompactionIterable	TokenNameIdentifier	 Validation Compaction Iterable
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CloseableIterator	TokenNameIdentifier	 Closeable Iterator
<	TokenNameLESS	
AbstractCompactedRow	TokenNameIdentifier	 Abstract Compacted Row
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
AbstractCompactedRow	TokenNameIdentifier	 Abstract Compacted Row
>	TokenNameGREATER	
nni	TokenNameIdentifier	 nni
=	TokenNameEQUAL	
Iterators	TokenNameIdentifier	 Iterators
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
,	TokenNameCOMMA	
Predicates	TokenNameIdentifier	 Predicates
.	TokenNameDOT	
notNull	TokenNameIdentifier	 not Null
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// validate the CF as we iterate over it 	TokenNameCOMMENT_LINE	validate the CF as we iterate over it 
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
prepare	TokenNameIdentifier	 prepare
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
nni	TokenNameIdentifier	 nni
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
isStopRequested	TokenNameIdentifier	 is Stop Requested
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
CompactionInterruptedException	TokenNameIdentifier	 Compaction Interrupted Exception
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AbstractCompactedRow	TokenNameIdentifier	 Abstract Compacted Row
row	TokenNameIdentifier	 row
=	TokenNameEQUAL	
nni	TokenNameIdentifier	 nni
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
row	TokenNameIdentifier	 row
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
complete	TokenNameIdentifier	 complete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
sessionid	TokenNameIdentifier	 sessionid
)	TokenNameRPAREN	
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
validator	TokenNameIdentifier	 validator
.	TokenNameDOT	
request	TokenNameIdentifier	 request
.	TokenNameDOT	
sessionid	TokenNameIdentifier	 sessionid
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Is not scheduled, because it is performing disjoint work from sstable compaction. */	TokenNameCOMMENT_JAVADOC	 Is not scheduled, because it is performing disjoint work from sstable compaction. 
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
submitIndexBuild	TokenNameIdentifier	 submit Index Build
(	TokenNameLPAREN	
final	TokenNamefinal	
SecondaryIndexBuilder	TokenNameIdentifier	 Secondary Index Builder
builder	TokenNameIdentifier	 builder
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
readLock	TokenNameIdentifier	 read Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// don't submit to the executor if the compaction lock is held by the current thread. Instead return a simple 	TokenNameCOMMENT_LINE	don't submit to the executor if the compaction lock is held by the current thread. Instead return a simple 
// future that will be immediately immediately get()ed and executed. Happens during a migration, which locks 	TokenNameCOMMENT_LINE	future that will be immediately immediately get()ed and executed. Happens during a migration, which locks 
// the compaction thread and then reinitializes a ColumnFamilyStore. Under normal circumstances, CFS spawns 	TokenNameCOMMENT_LINE	the compaction thread and then reinitializes a ColumnFamilyStore. Under normal circumstances, CFS spawns 
// index jobs to the compaction manager (this) and blocks on them. 	TokenNameCOMMENT_LINE	index jobs to the compaction manager (this) and blocks on them. 
if	TokenNameif	
(	TokenNameLPAREN	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
isWriteLockedByCurrentThread	TokenNameIdentifier	 is Write Locked By Current Thread
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
new	TokenNamenew	
SimpleFuture	TokenNameIdentifier	 Simple Future
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
submitCacheWrite	TokenNameIdentifier	 submit Cache Write
(	TokenNameLPAREN	
final	TokenNamefinal	
AutoSavingCache	TokenNameIdentifier	 Auto Saving Cache
.	TokenNameDOT	
Writer	TokenNameIdentifier	 Writer
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
AutoSavingCache	TokenNameIdentifier	 Auto Saving Cache
.	TokenNameDOT	
flushInProgress	TokenNameIdentifier	 flush In Progress
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
cacheType	TokenNameIdentifier	 cache Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Cache flushing was already in progress: skipping {}"	TokenNameStringLiteral	Cache flushing was already in progress: skipping {}
,	TokenNameCOMMA	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
saveCache	TokenNameIdentifier	 save Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
AutoSavingCache	TokenNameIdentifier	 Auto Saving Cache
.	TokenNameDOT	
flushInProgress	TokenNameIdentifier	 flush In Progress
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
cacheType	TokenNameIdentifier	 cache Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
submitTruncate	TokenNameIdentifier	 submit Truncate
(	TokenNameLPAREN	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
main	TokenNameIdentifier	 main
,	TokenNameCOMMA	
final	TokenNamefinal	
long	TokenNamelong	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lock	TokenNameIdentifier	 lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ReplayPosition	TokenNameIdentifier	 Replay Position
replayAfter	TokenNameIdentifier	 replay After
=	TokenNameEQUAL	
main	TokenNameIdentifier	 main
.	TokenNameDOT	
discardSSTables	TokenNameIdentifier	 discard SS Tables
(	TokenNameLPAREN	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
index	TokenNameIdentifier	 index
:	TokenNameCOLON	
main	TokenNameIdentifier	 main
.	TokenNameDOT	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexes	TokenNameIdentifier	 get Indexes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
truncate	TokenNameIdentifier	 truncate
(	TokenNameLPAREN	
truncatedAt	TokenNameIdentifier	 truncated At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
saveTruncationPosition	TokenNameIdentifier	 save Truncation Position
(	TokenNameLPAREN	
main	TokenNameIdentifier	 main
,	TokenNameCOMMA	
replayAfter	TokenNameIdentifier	 replay After
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
RowCacheKey	TokenNameIdentifier	 Row Cache Key
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
getKeySet	TokenNameIdentifier	 get Key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
==	TokenNameEQUAL_EQUAL	
main	TokenNameIdentifier	 main
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
cfId	TokenNameIdentifier	 cf Id
)	TokenNameRPAREN	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
rowCache	TokenNameIdentifier	 row Cache
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
compactionLock	TokenNameIdentifier	 compaction Lock
.	TokenNameDOT	
writeLock	TokenNameIdentifier	 write Lock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
unlock	TokenNameIdentifier	 unlock
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
int	TokenNameint	
getDefaultGcBefore	TokenNameIdentifier	 get Default Gc Before
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to 	TokenNameCOMMENT_LINE	2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to 
// add any GcGrace however since 2ndary indexes are local to a node. 	TokenNameCOMMENT_LINE	add any GcGrace however since 2ndary indexes are local to a node. 
return	TokenNamereturn	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
isIndex	TokenNameIdentifier	 is Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
:	TokenNameCOLON	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
1000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
-	TokenNameMINUS	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getGcGraceSeconds	TokenNameIdentifier	 get Gc Grace Seconds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ValidationCompactionIterable	TokenNameIdentifier	 Validation Compaction Iterable
extends	TokenNameextends	
CompactionIterable	TokenNameIdentifier	 Compaction Iterable
{	TokenNameLBRACE	
public	TokenNamepublic	
ValidationCompactionIterable	TokenNameIdentifier	 Validation Compaction Iterable
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getCompactionStrategy	TokenNameIdentifier	 get Compaction Strategy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanners	TokenNameIdentifier	 get Scanners
(	TokenNameLPAREN	
sstables	TokenNameIdentifier	 sstables
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
ValidationCompactionController	TokenNameIdentifier	 Validation Compaction Controller
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/* * Controller for validation compaction that always purges. * Note that we should not call cfs.getOverlappingSSTables on the provided * sstables because those sstables are not guaranteed to be active sstables * (since we can run repair on a snapshot). */	TokenNameCOMMENT_BLOCK	 Controller for validation compaction that always purges. Note that we should not call cfs.getOverlappingSSTables on the provided sstables because those sstables are not guaranteed to be active sstables (since we can run repair on a snapshot). 
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ValidationCompactionController	TokenNameIdentifier	 Validation Compaction Controller
extends	TokenNameextends	
CompactionController	TokenNameIdentifier	 Compaction Controller
{	TokenNameLBRACE	
public	TokenNamepublic	
ValidationCompactionController	TokenNameIdentifier	 Validation Compaction Controller
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
shouldPurge	TokenNameIdentifier	 should Purge
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * The main reason we always purge is that including gcable tombstone would mean that the * repair digest will depends on the scheduling of compaction on the different nodes. This * is still not perfect because gcbefore is currently dependend on the current time at which * the validation compaction start, which while not too bad for normal repair is broken for * repair on snapshots. A better solution would be to agree on a gcbefore that all node would * use, and we'll do that with CASSANDRA-4932. * Note validation compaction includes all sstables, so we don't have the problem of purging * a tombstone that could shadow a column in another sstable, but this is doubly not a concern * since validation compaction is read-only. */	TokenNameCOMMENT_BLOCK	 The main reason we always purge is that including gcable tombstone would mean that the repair digest will depends on the scheduling of compaction on the different nodes. This is still not perfect because gcbefore is currently dependend on the current time at which the validation compaction start, which while not too bad for normal repair is broken for repair on snapshots. A better solution would be to agree on a gcbefore that all node would use, and we'll do that with CASSANDRA-4932. Note validation compaction includes all sstables, so we don't have the problem of purging a tombstone that could shadow a column in another sstable, but this is doubly not a concern since validation compaction is read-only. 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getActiveCompactions	TokenNameIdentifier	 get Active Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
extends	TokenNameextends	
ThreadPoolExecutor	TokenNameIdentifier	 Thread Pool Executor
{	TokenNameLBRACE	
protected	TokenNameprotected	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
(	TokenNameLPAREN	
int	TokenNameint	
minThreads	TokenNameIdentifier	 min Threads
,	TokenNameCOMMA	
int	TokenNameint	
maxThreads	TokenNameIdentifier	 max Threads
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
BlockingQueue	TokenNameIdentifier	 Blocking Queue
<	TokenNameLESS	
Runnable	TokenNameIdentifier	 Runnable
>	TokenNameGREATER	
queue	TokenNameIdentifier	 queue
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
minThreads	TokenNameIdentifier	 min Threads
,	TokenNameCOMMA	
maxThreads	TokenNameIdentifier	 max Threads
,	TokenNameCOMMA	
60	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
SECONDS	TokenNameIdentifier	 SECONDS
,	TokenNameCOMMA	
queue	TokenNameIdentifier	 queue
,	TokenNameCOMMA	
new	TokenNamenew	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
MIN_PRIORITY	TokenNameIdentifier	 MIN  PRIORITY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allowCoreThreadTimeOut	TokenNameIdentifier	 allow Core Thread Time Out
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
(	TokenNameLPAREN	
int	TokenNameint	
threadCount	TokenNameIdentifier	 thread Count
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
threadCount	TokenNameIdentifier	 thread Count
,	TokenNameCOMMA	
threadCount	TokenNameIdentifier	 thread Count
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
new	TokenNamenew	
LinkedBlockingQueue	TokenNameIdentifier	 Linked Blocking Queue
<	TokenNameLESS	
Runnable	TokenNameIdentifier	 Runnable
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getConcurrentCompactors	TokenNameIdentifier	 get Concurrent Compactors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
"CompactionExecutor"	TokenNameStringLiteral	CompactionExecutor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
beforeExecute	TokenNameIdentifier	 before Execute
(	TokenNameLPAREN	
Thread	TokenNameIdentifier	 Thread
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
Runnable	TokenNameIdentifier	 Runnable
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// can't set this in Thread factory, so we do it redundantly here 	TokenNameCOMMENT_LINE	can't set this in Thread factory, so we do it redundantly here 
isCompactionManager	TokenNameIdentifier	 is Compaction Manager
.	TokenNameDOT	
set	TokenNameIdentifier	 set
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
super	TokenNamesuper	
.	TokenNameDOT	
beforeExecute	TokenNameIdentifier	 before Execute
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// modified from DebuggableThreadPoolExecutor so that CompactionInterruptedExceptions are not logged 	TokenNameCOMMENT_LINE	modified from DebuggableThreadPoolExecutor so that CompactionInterruptedExceptions are not logged 
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
afterExecute	TokenNameIdentifier	 after Execute
(	TokenNameLPAREN	
Runnable	TokenNameIdentifier	 Runnable
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
afterExecute	TokenNameIdentifier	 after Execute
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
.	TokenNameDOT	
extractThrowable	TokenNameIdentifier	 extract Throwable
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
instanceof	TokenNameinstanceof	
CompactionInterruptedException	TokenNameIdentifier	 Compaction Interrupted Exception
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Full interruption stack trace:"	TokenNameStringLiteral	Full interruption stack trace:
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
.	TokenNameDOT	
handleOrLog	TokenNameIdentifier	 handle Or Log
(	TokenNameLPAREN	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
ValidationExecutor	TokenNameIdentifier	 Validation Executor
extends	TokenNameextends	
CompactionExecutor	TokenNameIdentifier	 Compaction Executor
{	TokenNameLBRACE	
public	TokenNamepublic	
ValidationExecutor	TokenNameIdentifier	 Validation Executor
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
"ValidationExecutor"	TokenNameStringLiteral	ValidationExecutor
,	TokenNameCOMMA	
new	TokenNamenew	
SynchronousQueue	TokenNameIdentifier	 Synchronous Queue
<	TokenNameLESS	
Runnable	TokenNameIdentifier	 Runnable
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
interface	TokenNameinterface	
CompactionExecutorStatsCollector	TokenNameIdentifier	 Compaction Executor Stats Collector
{	TokenNameLBRACE	
void	TokenNamevoid	
beginCompaction	TokenNameIdentifier	 begin Compaction
(	TokenNameLPAREN	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
void	TokenNamevoid	
finishCompaction	TokenNameIdentifier	 finish Compaction
(	TokenNameLPAREN	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
ci	TokenNameIdentifier	 ci
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Holder	TokenNameIdentifier	 Holder
>	TokenNameGREATER	
compactionHolders	TokenNameIdentifier	 compaction Holders
=	TokenNameEQUAL	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
compactionHolders	TokenNameIdentifier	 compaction Holders
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
ci	TokenNameIdentifier	 ci
:	TokenNameCOLON	
compactionHolders	TokenNameIdentifier	 compaction Holders
)	TokenNameRPAREN	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
asMap	TokenNameIdentifier	 as Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getCompactionSummary	TokenNameIdentifier	 get Compaction Summary
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Holder	TokenNameIdentifier	 Holder
>	TokenNameGREATER	
compactionHolders	TokenNameIdentifier	 compaction Holders
=	TokenNameEQUAL	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
out	TokenNameIdentifier	 out
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
compactionHolders	TokenNameIdentifier	 compaction Holders
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
ci	TokenNameIdentifier	 ci
:	TokenNameCOLON	
compactionHolders	TokenNameIdentifier	 compaction Holders
)	TokenNameRPAREN	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
ci	TokenNameIdentifier	 ci
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalBytesCompacted	TokenNameIdentifier	 get Total Bytes Compacted
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
bytesCompacted	TokenNameIdentifier	 bytes Compacted
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getTotalCompactionsCompleted	TokenNameIdentifier	 get Total Compactions Completed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
totalCompactionsCompleted	TokenNameIdentifier	 total Compactions Completed
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
getPendingTasks	TokenNameIdentifier	 get Pending Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
pendingTasks	TokenNameIdentifier	 pending Tasks
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getCompletedTasks	TokenNameIdentifier	 get Completed Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
completedTasks	TokenNameIdentifier	 completed Tasks
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
SimpleFuture	TokenNameIdentifier	 Simple Future
implements	TokenNameimplements	
Future	TokenNameIdentifier	 Future
{	TokenNameLBRACE	
private	TokenNameprivate	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SimpleFuture	TokenNameIdentifier	 Simple Future
(	TokenNameLPAREN	
Runnable	TokenNameIdentifier	 Runnable
r	TokenNameIdentifier	 r
)	TokenNameRPAREN	
{	TokenNameLBRACE	
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
cancel	TokenNameIdentifier	 cancel
(	TokenNameLPAREN	
boolean	TokenNameboolean	
mayInterruptIfRunning	TokenNameIdentifier	 may Interrupt If Running
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"May not call SimpleFuture.cancel()"	TokenNameStringLiteral	May not call SimpleFuture.cancel()
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isCancelled	TokenNameIdentifier	 is Cancelled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isDone	TokenNameIdentifier	 is Done
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
runnable	TokenNameIdentifier	 runnable
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
{	TokenNameLBRACE	
runnable	TokenNameIdentifier	 runnable
.	TokenNameDOT	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
runnable	TokenNameIdentifier	 runnable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
long	TokenNamelong	
timeout	TokenNameIdentifier	 timeout
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
unit	TokenNameIdentifier	 unit
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
,	TokenNameCOMMA	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
TimeoutException	TokenNameIdentifier	 Timeout Exception
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"May not call SimpleFuture.get(long, TimeUnit)"	TokenNameStringLiteral	May not call SimpleFuture.get(long, TimeUnit)
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
CleanupInfo	TokenNameIdentifier	 Cleanup Info
extends	TokenNameextends	
CompactionInfo	TokenNameIdentifier	 Compaction Info
.	TokenNameDOT	
Holder	TokenNameIdentifier	 Holder
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
scanner	TokenNameIdentifier	 scanner
;	TokenNameSEMICOLON	
public	TokenNamepublic	
CleanupInfo	TokenNameIdentifier	 Cleanup Info
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
scanner	TokenNameIdentifier	 scanner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scanner	TokenNameIdentifier	 scanner
=	TokenNameEQUAL	
scanner	TokenNameIdentifier	 scanner
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
CompactionInfo	TokenNameIdentifier	 Compaction Info
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
CompactionInfo	TokenNameIdentifier	 Compaction Info
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
CLEANUP	TokenNameIdentifier	 CLEANUP
,	TokenNameCOMMA	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
getCurrentPosition	TokenNameIdentifier	 get Current Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
scanner	TokenNameIdentifier	 scanner
.	TokenNameDOT	
getLengthInBytes	TokenNameIdentifier	 get Length In Bytes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
stopCompaction	TokenNameIdentifier	 stop Compaction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
OperationType	TokenNameIdentifier	 Operation Type
operation	TokenNameIdentifier	 operation
=	TokenNameEQUAL	
OperationType	TokenNameIdentifier	 Operation Type
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Holder	TokenNameIdentifier	 Holder
holder	TokenNameIdentifier	 holder
:	TokenNameCOLON	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
holder	TokenNameIdentifier	 holder
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getTaskType	TokenNameIdentifier	 get Task Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
operation	TokenNameIdentifier	 operation
)	TokenNameRPAREN	
holder	TokenNameIdentifier	 holder
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Try to stop all of the compactions for given ColumnFamilies. * Note that this method does not wait indefinitely for all compactions to finish, maximum wait time is 30 secs. * * @param columnFamilies The ColumnFamilies to try to stop compaction upon. */	TokenNameCOMMENT_JAVADOC	 Try to stop all of the compactions for given ColumnFamilies. Note that this method does not wait indefinitely for all compactions to finish, maximum wait time is 30 secs. * @param columnFamilies The ColumnFamilies to try to stop compaction upon. 
public	TokenNamepublic	
void	TokenNamevoid	
stopCompactionFor	TokenNameIdentifier	 stop Compaction For
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
CFMetaData	TokenNameIdentifier	 CF Meta Data
>	TokenNameGREATER	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
columnFamilies	TokenNameIdentifier	 column Families
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Holder	TokenNameIdentifier	 Holder
compactionHolder	TokenNameIdentifier	 compaction Holder
:	TokenNameCOLON	
CompactionMetrics	TokenNameIdentifier	 Compaction Metrics
.	TokenNameDOT	
getCompactions	TokenNameIdentifier	 get Compactions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CompactionInfo	TokenNameIdentifier	 Compaction Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
compactionHolder	TokenNameIdentifier	 compaction Holder
.	TokenNameDOT	
getCompactionInfo	TokenNameIdentifier	 get Compaction Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
compactionHolder	TokenNameIdentifier	 compaction Holder
.	TokenNameDOT	
stop	TokenNameIdentifier	 stop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// signal compaction to stop 	TokenNameCOMMENT_LINE	signal compaction to stop 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
