/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ManagementFactory	TokenNameIdentifier	 Management Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Callable	TokenNameIdentifier	 Callable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
ExecutionException	TokenNameIdentifier	 Execution Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
Future	TokenNameIdentifier	 Future
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
MBeanServer	TokenNameIdentifier	 M Bean Server
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
management	TokenNameIdentifier	 management
.	TokenNameDOT	
ObjectName	TokenNameIdentifier	 Object Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Config	TokenNameIdentifier	 Config
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FSWriteError	TokenNameIdentifier	 FS Write Error
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
CommitLogMetrics	TokenNameIdentifier	 Commit Log Metrics
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
net	TokenNameIdentifier	 net
.	TokenNameDOT	
MessagingService	TokenNameIdentifier	 Messaging Service
;	TokenNameSEMICOLON	
/* * Commit Log tracks every write operation into the system. The aim of the commit log is to be able to * successfully recover data that was not stored to disk via the Memtable. */	TokenNameCOMMENT_BLOCK	 Commit Log tracks every write operation into the system. The aim of the commit log is to be able to successfully recover data that was not stored to disk via the Memtable. 
public	TokenNamepublic	
class	TokenNameclass	
CommitLog	TokenNameIdentifier	 Commit Log
implements	TokenNameimplements	
CommitLogMBean	TokenNameIdentifier	 Commit Log M Bean
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
CommitLog	TokenNameIdentifier	 Commit Log
instance	TokenNameIdentifier	 instance
=	TokenNameEQUAL	
new	TokenNamenew	
CommitLog	TokenNameIdentifier	 Commit Log
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ICommitLogExecutorService	TokenNameIdentifier	 I Commit Log Executor Service
executor	TokenNameIdentifier	 executor
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
CommitLogAllocator	TokenNameIdentifier	 Commit Log Allocator
allocator	TokenNameIdentifier	 allocator
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
CommitLogArchiver	TokenNameIdentifier	 Commit Log Archiver
archiver	TokenNameIdentifier	 archiver
=	TokenNameEQUAL	
new	TokenNamenew	
CommitLogArchiver	TokenNameIdentifier	 Commit Log Archiver
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
END_OF_SEGMENT_MARKER	TokenNameIdentifier	 END  OF  SEGMENT  MARKER
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// this is written out at the end of a segment 	TokenNameCOMMENT_LINE	this is written out at the end of a segment 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
END_OF_SEGMENT_MARKER_SIZE	TokenNameIdentifier	 END  OF  SEGMENT  MARKER  SIZE
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// number of bytes of ^^^ 	TokenNameCOMMENT_LINE	number of bytes of ^^^ 
public	TokenNamepublic	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
activeSegment	TokenNameIdentifier	 active Segment
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CommitLogMetrics	TokenNameIdentifier	 Commit Log Metrics
metrics	TokenNameIdentifier	 metrics
;	TokenNameSEMICOLON	
private	TokenNameprivate	
CommitLog	TokenNameIdentifier	 Commit Log
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
createAllDirectories	TokenNameIdentifier	 create All Directories
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allocator	TokenNameIdentifier	 allocator
=	TokenNameEQUAL	
new	TokenNamenew	
CommitLogAllocator	TokenNameIdentifier	 Commit Log Allocator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activateNextSegment	TokenNameIdentifier	 activate Next Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getCommitLogSync	TokenNameIdentifier	 get Commit Log Sync
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Config	TokenNameIdentifier	 Config
.	TokenNameDOT	
CommitLogSync	TokenNameIdentifier	 Commit Log Sync
.	TokenNameDOT	
batch	TokenNameIdentifier	 batch
?	TokenNameQUESTION	
new	TokenNamenew	
BatchCommitLogExecutorService	TokenNameIdentifier	 Batch Commit Log Executor Service
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
PeriodicCommitLogExecutorService	TokenNameIdentifier	 Periodic Commit Log Executor Service
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
MBeanServer	TokenNameIdentifier	 M Bean Server
mbs	TokenNameIdentifier	 mbs
=	TokenNameEQUAL	
ManagementFactory	TokenNameIdentifier	 Management Factory
.	TokenNameDOT	
getPlatformMBeanServer	TokenNameIdentifier	 get Platform M Bean Server
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
mbs	TokenNameIdentifier	 mbs
.	TokenNameDOT	
registerMBean	TokenNameIdentifier	 register M Bean
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
new	TokenNamenew	
ObjectName	TokenNameIdentifier	 Object Name
(	TokenNameLPAREN	
"org.apache.cassandra.db:type=Commitlog"	TokenNameStringLiteral	org.apache.cassandra.db:type=Commitlog
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// register metrics 	TokenNameCOMMENT_LINE	register metrics 
metrics	TokenNameIdentifier	 metrics
=	TokenNameEQUAL	
new	TokenNamenew	
CommitLogMetrics	TokenNameIdentifier	 Commit Log Metrics
(	TokenNameLPAREN	
executor	TokenNameIdentifier	 executor
,	TokenNameCOMMA	
allocator	TokenNameIdentifier	 allocator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * FOR TESTING PURPOSES. See CommitLogAllocator. */	TokenNameCOMMENT_JAVADOC	 FOR TESTING PURPOSES. See CommitLogAllocator. 
public	TokenNamepublic	
void	TokenNamevoid	
resetUnsafe	TokenNameIdentifier	 reset Unsafe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
resetUnsafe	TokenNameIdentifier	 reset Unsafe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activateNextSegment	TokenNameIdentifier	 activate Next Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Perform recovery on commit logs located in the directory specified by the config file. * * @return the number of mutations replayed */	TokenNameCOMMENT_JAVADOC	 Perform recovery on commit logs located in the directory specified by the config file. * @return the number of mutations replayed 
public	TokenNamepublic	
int	TokenNameint	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
archiver	TokenNameIdentifier	 archiver
.	TokenNameDOT	
maybeRestoreArchive	TokenNameIdentifier	 maybe Restore Archive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getCommitLogLocation	TokenNameIdentifier	 get Commit Log Location
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
new	TokenNamenew	
FilenameFilter	TokenNameIdentifier	 Filename Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
accept	TokenNameIdentifier	 accept
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we used to try to avoid instantiating commitlog (thus creating an empty segment ready for writes) 	TokenNameCOMMENT_LINE	we used to try to avoid instantiating commitlog (thus creating an empty segment ready for writes) 
// until after recover was finished. this turns out to be fragile; it is less error-prone to go 	TokenNameCOMMENT_LINE	until after recover was finished. this turns out to be fragile; it is less error-prone to go 
// ahead and allow writes before recover(), and just skip active segments when we do. 	TokenNameCOMMENT_LINE	ahead and allow writes before recover(), and just skip active segments when we do. 
return	TokenNamereturn	
CommitLogDescriptor	TokenNameIdentifier	 Commit Log Descriptor
.	TokenNameDOT	
isValid	TokenNameIdentifier	 is Valid
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
manages	TokenNameIdentifier	 manages
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
replayed	TokenNameIdentifier	 replayed
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"No commitlog files found; skipping replay"	TokenNameStringLiteral	No commitlog files found; skipping replay
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Arrays	TokenNameIdentifier	 Arrays
.	TokenNameDOT	
sort	TokenNameIdentifier	 sort
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
new	TokenNamenew	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
.	TokenNameDOT	
CommitLogSegmentFileComparator	TokenNameIdentifier	 Commit Log Segment File Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Replaying "	TokenNameStringLiteral	Replaying 
+	TokenNamePLUS	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
,	TokenNameCOMMA	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
replayed	TokenNameIdentifier	 replayed
=	TokenNameEQUAL	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Log replay complete, "	TokenNameStringLiteral	Log replay complete, 
+	TokenNamePLUS	
replayed	TokenNameIdentifier	 replayed
+	TokenNamePLUS	
" replayed mutations"	TokenNameStringLiteral	 replayed mutations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
:	TokenNameCOLON	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
CommitLog	TokenNameIdentifier	 Commit Log
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
recycleSegment	TokenNameIdentifier	 recycle Segment
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
enableReserveSegmentCreation	TokenNameIdentifier	 enable Reserve Segment Creation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
replayed	TokenNameIdentifier	 replayed
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Perform recovery on a list of commit log files. * * @param clogs the list of commit log files to replay * @return the number of mutations replayed */	TokenNameCOMMENT_JAVADOC	 Perform recovery on a list of commit log files. * @param clogs the list of commit log files to replay @return the number of mutations replayed 
public	TokenNamepublic	
int	TokenNameint	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
...	TokenNameELLIPSIS	
clogs	TokenNameIdentifier	 clogs
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
CommitLogReplayer	TokenNameIdentifier	 Commit Log Replayer
recovery	TokenNameIdentifier	 recovery
=	TokenNameEQUAL	
new	TokenNamenew	
CommitLogReplayer	TokenNameIdentifier	 Commit Log Replayer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
recovery	TokenNameIdentifier	 recovery
.	TokenNameDOT	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
clogs	TokenNameIdentifier	 clogs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
recovery	TokenNameIdentifier	 recovery
.	TokenNameDOT	
blockForWrites	TokenNameIdentifier	 block For Writes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Perform recovery on a single commit log. */	TokenNameCOMMENT_JAVADOC	 Perform recovery on a single commit log. 
public	TokenNamepublic	
void	TokenNamevoid	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
recover	TokenNameIdentifier	 recover
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return a Future representing a ReplayPosition such that when it is ready, * all commitlog tasks enqueued prior to the getContext call will be complete (i.e., appended to the log) */	TokenNameCOMMENT_JAVADOC	 @return a Future representing a ReplayPosition such that when it is ready, all commitlog tasks enqueued prior to the getContext call will be complete (i.e., appended to the log) 
public	TokenNamepublic	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
getContext	TokenNameIdentifier	 get Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
ReplayPosition	TokenNameIdentifier	 Replay Position
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
activeSegment	TokenNameIdentifier	 active Segment
.	TokenNameDOT	
getContext	TokenNameIdentifier	 get Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Used by tests. * * @return the number of active segments (segments with unflushed data in them) */	TokenNameCOMMENT_JAVADOC	 Used by tests. * @return the number of active segments (segments with unflushed data in them) 
public	TokenNamepublic	
int	TokenNameint	
activeSegments	TokenNameIdentifier	 active Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
getActiveSegments	TokenNameIdentifier	 get Active Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Add a RowMutation to the commit log. * * @param rm the RowMutation to add to the log */	TokenNameCOMMENT_JAVADOC	 Add a RowMutation to the commit log. * @param rm the RowMutation to add to the log 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
totalSize	TokenNameIdentifier	 total Size
=	TokenNameEQUAL	
RowMutation	TokenNameIdentifier	 Row Mutation
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
,	TokenNameCOMMA	
MessagingService	TokenNameIdentifier	 Messaging Service
.	TokenNameDOT	
current_version	TokenNameIdentifier	 current version
)	TokenNameRPAREN	
+	TokenNamePLUS	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
.	TokenNameDOT	
ENTRY_OVERHEAD_SIZE	TokenNameIdentifier	 ENTRY  OVERHEAD  SIZE
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
totalSize	TokenNameIdentifier	 total Size
>	TokenNameGREATER	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getCommitLogSegmentSize	TokenNameIdentifier	 get Commit Log Segment Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"Skipping commitlog append of extremely large mutation ({} bytes)"	TokenNameStringLiteral	Skipping commitlog append of extremely large mutation ({} bytes)
,	TokenNameCOMMA	
totalSize	TokenNameIdentifier	 total Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
LogRecordAdder	TokenNameIdentifier	 Log Record Adder
(	TokenNameLPAREN	
rm	TokenNameIdentifier	 rm
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Modifies the per-CF dirty cursors of any commit log segments for the column family according to the position * given. Discards any commit log segments that are no longer used. * * @param cfId the column family ID that was flushed * @param context the replay position of the flush */	TokenNameCOMMENT_JAVADOC	 Modifies the per-CF dirty cursors of any commit log segments for the column family according to the position given. Discards any commit log segments that are no longer used. * @param cfId the column family ID that was flushed @param context the replay position of the flush 
public	TokenNamepublic	
void	TokenNamevoid	
discardCompletedSegments	TokenNameIdentifier	 discard Completed Segments
(	TokenNameLPAREN	
final	TokenNamefinal	
UUID	TokenNameIdentifier	 UUID
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
final	TokenNamefinal	
ReplayPosition	TokenNameIdentifier	 Replay Position
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Callable	TokenNameIdentifier	 Callable
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"discard completed log segments for {}, column family {}"	TokenNameStringLiteral	discard completed log segments for {}, column family {}
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
cfId	TokenNameIdentifier	 cf Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Go thru the active segment files, which are ordered oldest to newest, marking the 	TokenNameCOMMENT_LINE	Go thru the active segment files, which are ordered oldest to newest, marking the 
// flushed CF as clean, until we reach the segment file containing the ReplayPosition passed 	TokenNameCOMMENT_LINE	flushed CF as clean, until we reach the segment file containing the ReplayPosition passed 
// in the arguments. Any segments that become unused after they are marked clean will be 	TokenNameCOMMENT_LINE	in the arguments. Any segments that become unused after they are marked clean will be 
// recycled or discarded. 	TokenNameCOMMENT_LINE	recycled or discarded. 
for	TokenNamefor	
(	TokenNameLPAREN	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
getActiveSegments	TokenNameIdentifier	 get Active Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
segment	TokenNameIdentifier	 segment
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
markClean	TokenNameIdentifier	 mark Clean
(	TokenNameLPAREN	
cfId	TokenNameIdentifier	 cf Id
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If the segment is no longer needed, and we have another spare segment in the hopper 	TokenNameCOMMENT_LINE	If the segment is no longer needed, and we have another spare segment in the hopper 
// (to keep the last segment from getting discarded), pursue either recycling or deleting 	TokenNameCOMMENT_LINE	(to keep the last segment from getting discarded), pursue either recycling or deleting 
// this segment file. 	TokenNameCOMMENT_LINE	this segment file. 
if	TokenNameif	
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
isUnused	TokenNameIdentifier	 is Unused
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Commit log segment {} is unused"	TokenNameStringLiteral	Commit log segment {} is unused
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
recycleSegment	TokenNameIdentifier	 recycle Segment
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Not safe to delete commit log %s; dirty is %s; hasNext: %s"	TokenNameStringLiteral	Not safe to delete commit log %s; dirty is %s; hasNext: %s
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
,	TokenNameCOMMA	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
dirtyString	TokenNameIdentifier	 dirty String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Don't mark or try to delete any newer segments once we've reached the one containing the 	TokenNameCOMMENT_LINE	Don't mark or try to delete any newer segments once we've reached the one containing the 
// position of the flush. 	TokenNameCOMMENT_LINE	position of the flush. 
if	TokenNameif	
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
ExecutionException	TokenNameIdentifier	 Execution Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Forces a disk flush on the commit log files that need it. */	TokenNameCOMMENT_JAVADOC	 Forces a disk flush on the commit log files that need it. 
public	TokenNamepublic	
void	TokenNamevoid	
sync	TokenNameIdentifier	 sync
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
segment	TokenNameIdentifier	 segment
:	TokenNameCOLON	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
getActiveSegments	TokenNameIdentifier	 get Active Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
sync	TokenNameIdentifier	 sync
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * @return the number of tasks completed by the commit log executor */	TokenNameCOMMENT_JAVADOC	 @return the number of tasks completed by the commit log executor 
public	TokenNamepublic	
long	TokenNamelong	
getCompletedTasks	TokenNameIdentifier	 get Completed Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
completedTasks	TokenNameIdentifier	 completed Tasks
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return the depth of pending commit log executor queue */	TokenNameCOMMENT_JAVADOC	 @return the depth of pending commit log executor queue 
public	TokenNamepublic	
long	TokenNamelong	
getPendingTasks	TokenNameIdentifier	 get Pending Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
pendingTasks	TokenNameIdentifier	 pending Tasks
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return the total size occupied by commitlo segments expressed in bytes. (used by MBean) */	TokenNameCOMMENT_JAVADOC	 @return the total size occupied by commitlo segments expressed in bytes. (used by MBean) 
public	TokenNamepublic	
long	TokenNamelong	
getTotalCommitlogSize	TokenNameIdentifier	 get Total Commitlog Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
metrics	TokenNameIdentifier	 metrics
.	TokenNameDOT	
totalCommitLogSize	TokenNameIdentifier	 total Commit Log Size
.	TokenNameDOT	
value	TokenNameIdentifier	 value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Forces a new segment file to be allocated and activated. Used mainly by truncate. */	TokenNameCOMMENT_JAVADOC	 Forces a new segment file to be allocated and activated. Used mainly by truncate. 
public	TokenNamepublic	
void	TokenNamevoid	
forceNewSegment	TokenNameIdentifier	 force New Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Forcing new segment creation"	TokenNameStringLiteral	Forcing new segment creation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
task	TokenNameIdentifier	 task
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
activeSegment	TokenNameIdentifier	 active Segment
.	TokenNameDOT	
position	TokenNameIdentifier	 position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
activateNextSegment	TokenNameIdentifier	 activate Next Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
task	TokenNameIdentifier	 task
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Fetches a new segment file from the allocator and activates it. * * @return the newly activated segment */	TokenNameCOMMENT_JAVADOC	 Fetches a new segment file from the allocator and activates it. * @return the newly activated segment 
private	TokenNameprivate	
void	TokenNamevoid	
activateNextSegment	TokenNameIdentifier	 activate Next Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
activeSegment	TokenNameIdentifier	 active Segment
=	TokenNameEQUAL	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
fetchSegment	TokenNameIdentifier	 fetch Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Active segment is now {}"	TokenNameStringLiteral	Active segment is now {}
,	TokenNameCOMMA	
activeSegment	TokenNameIdentifier	 active Segment
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getActiveSegmentNames	TokenNameIdentifier	 get Active Segment Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
segmentNames	TokenNameIdentifier	 segment Names
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
segment	TokenNameIdentifier	 segment
:	TokenNameCOLON	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
getActiveSegments	TokenNameIdentifier	 get Active Segments
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
segmentNames	TokenNameIdentifier	 segment Names
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
segment	TokenNameIdentifier	 segment
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
segmentNames	TokenNameIdentifier	 segment Names
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
getArchivingSegmentNames	TokenNameIdentifier	 get Archiving Segment Names
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
String	TokenNameIdentifier	 String
>	TokenNameGREATER	
(	TokenNameLPAREN	
archiver	TokenNameIdentifier	 archiver
.	TokenNameDOT	
archivePending	TokenNameIdentifier	 archive Pending
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Shuts down the threads used by the commit log, blocking until completion. */	TokenNameCOMMENT_JAVADOC	 Shuts down the threads used by the commit log, blocking until completion. 
public	TokenNamepublic	
void	TokenNamevoid	
shutdownBlocking	TokenNameIdentifier	 shutdown Blocking
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// TODO this should be a Runnable since it doesn't actually return anything, but it's difficult to do that 	TokenNameCOMMENT_LINE	TODO this should be a Runnable since it doesn't actually return anything, but it's difficult to do that 
// without breaking the fragile CheaterFutureTask in BatchCLES. 	TokenNameCOMMENT_LINE	without breaking the fragile CheaterFutureTask in BatchCLES. 
class	TokenNameclass	
LogRecordAdder	TokenNameIdentifier	 Log Record Adder
implements	TokenNameimplements	
Callable	TokenNameIdentifier	 Callable
,	TokenNameCOMMA	
Runnable	TokenNameIdentifier	 Runnable
{	TokenNameLBRACE	
final	TokenNamefinal	
RowMutation	TokenNameIdentifier	 Row Mutation
rowMutation	TokenNameIdentifier	 row Mutation
;	TokenNameSEMICOLON	
LogRecordAdder	TokenNameIdentifier	 Log Record Adder
(	TokenNameLPAREN	
RowMutation	TokenNameIdentifier	 Row Mutation
rm	TokenNameIdentifier	 rm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
rowMutation	TokenNameIdentifier	 row Mutation
=	TokenNameEQUAL	
rm	TokenNameIdentifier	 rm
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
activeSegment	TokenNameIdentifier	 active Segment
.	TokenNameDOT	
hasCapacityFor	TokenNameIdentifier	 has Capacity For
(	TokenNameLPAREN	
rowMutation	TokenNameIdentifier	 row Mutation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CommitLogSegment	TokenNameIdentifier	 Commit Log Segment
oldSegment	TokenNameIdentifier	 old Segment
=	TokenNameEQUAL	
activeSegment	TokenNameIdentifier	 active Segment
;	TokenNameSEMICOLON	
activateNextSegment	TokenNameIdentifier	 activate Next Segment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Now we can run the user defined command just before switching to the new commit log. 	TokenNameCOMMENT_LINE	Now we can run the user defined command just before switching to the new commit log. 
// (Do this here instead of in the recycle call so we can get a head start on the archive.) 	TokenNameCOMMENT_LINE	(Do this here instead of in the recycle call so we can get a head start on the archive.) 
archiver	TokenNameIdentifier	 archiver
.	TokenNameDOT	
maybeArchive	TokenNameIdentifier	 maybe Archive
(	TokenNameLPAREN	
oldSegment	TokenNameIdentifier	 old Segment
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
oldSegment	TokenNameIdentifier	 old Segment
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
activeSegment	TokenNameIdentifier	 active Segment
.	TokenNameDOT	
write	TokenNameIdentifier	 write
(	TokenNameLPAREN	
rowMutation	TokenNameIdentifier	 row Mutation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
FSWriteError	TokenNameIdentifier	 FS Write Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
activeSegment	TokenNameIdentifier	 active Segment
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
