/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicBoolean	TokenNameIdentifier	 Atomic Boolean
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
InstrumentingCache	TokenNameIdentifier	 Instrumenting Cache
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
CFMetaData	TokenNameIdentifier	 CF Meta Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
ColumnDefinition	TokenNameIdentifier	 Column Definition
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
Schema	TokenNameIdentifier	 Schema
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
ReplayPosition	TokenNameIdentifier	 Replay Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
QueryFilter	TokenNameIdentifier	 Query Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
IPartitioner	TokenNameIdentifier	 I Partitioner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
LocalPartitioner	TokenNameIdentifier	 Local Partitioner
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Token	TokenNameIdentifier	 Token
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
compress	TokenNameIdentifier	 compress
.	TokenNameDOT	
CompressedRandomAccessReader	TokenNameIdentifier	 Compressed Random Access Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
compress	TokenNameIdentifier	 compress
.	TokenNameDOT	
CompressionMetadata	TokenNameIdentifier	 Compression Metadata
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
CacheService	TokenNameIdentifier	 Cache Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
tracing	TokenNameIdentifier	 tracing
.	TokenNameDOT	
Tracing	TokenNameIdentifier	 Tracing
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
static	TokenNamestatic	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
;	TokenNameSEMICOLON	
/** * SSTableReaders are open()ed by Table.onStart; after that they are created by SSTableWriter.renameAndOpen. * Do not re-call open() on existing SSTable files; use the references kept by ColumnFamilyStore post-start instead. */	TokenNameCOMMENT_JAVADOC	 SSTableReaders are open()ed by Table.onStart; after that they are created by SSTableWriter.renameAndOpen. Do not re-call open() on existing SSTable files; use the references kept by ColumnFamilyStore post-start instead. 
public	TokenNamepublic	
class	TokenNameclass	
SSTableReader	TokenNameIdentifier	 SS Table Reader
extends	TokenNameextends	
SSTable	TokenNameIdentifier	 SS Table
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// guesstimated size of INDEX_INTERVAL index entries 	TokenNameCOMMENT_LINE	guesstimated size of INDEX_INTERVAL index entries 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INDEX_FILE_BUFFER_BYTES	TokenNameIdentifier	 INDEX  FILE  BUFFER  BYTES
=	TokenNameEQUAL	
16	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * maxDataAge is a timestamp in local server time (e.g. System.currentTimeMilli) which represents an uppper bound * to the newest piece of data stored in the sstable. In other words, this sstable does not contain items created * later than maxDataAge. * * The field is not serialized to disk, so relying on it for more than what truncate does is not advised. * * When a new sstable is flushed, maxDataAge is set to the time of creation. * When a sstable is created from compaction, maxDataAge is set to max of all merged tables. * * The age is in milliseconds since epoc and is local to this host. */	TokenNameCOMMENT_JAVADOC	 maxDataAge is a timestamp in local server time (e.g. System.currentTimeMilli) which represents an uppper bound to the newest piece of data stored in the sstable. In other words, this sstable does not contain items created later than maxDataAge. * The field is not serialized to disk, so relying on it for more than what truncate does is not advised. * When a new sstable is flushed, maxDataAge is set to the time of creation. When a sstable is created from compaction, maxDataAge is set to max of all merged tables. * The age is in milliseconds since epoc and is local to this host. 
public	TokenNamepublic	
final	TokenNamefinal	
long	TokenNamelong	
maxDataAge	TokenNameIdentifier	 max Data Age
;	TokenNameSEMICOLON	
// indexfile and datafile: might be null before a call to load() 	TokenNameCOMMENT_LINE	indexfile and datafile: might be null before a call to load() 
private	TokenNameprivate	
SegmentedFile	TokenNameIdentifier	 Segmented File
ifile	TokenNameIdentifier	 ifile
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SegmentedFile	TokenNameIdentifier	 Segmented File
dfile	TokenNameIdentifier	 dfile
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IndexSummary	TokenNameIdentifier	 Index Summary
indexSummary	TokenNameIdentifier	 index Summary
;	TokenNameSEMICOLON	
private	TokenNameprivate	
IFilter	TokenNameIdentifier	 I Filter
bf	TokenNameIdentifier	 bf
;	TokenNameSEMICOLON	
private	TokenNameprivate	
InstrumentingCache	TokenNameIdentifier	 Instrumenting Cache
<	TokenNameLESS	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
,	TokenNameCOMMA	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
>	TokenNameGREATER	
keyCache	TokenNameIdentifier	 key Cache
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BloomFilterTracker	TokenNameIdentifier	 Bloom Filter Tracker
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
=	TokenNameEQUAL	
new	TokenNamenew	
BloomFilterTracker	TokenNameIdentifier	 Bloom Filter Tracker
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
references	TokenNameIdentifier	 references
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted, 	TokenNameCOMMENT_LINE	technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted, 
// but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone 	TokenNameCOMMENT_LINE	but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone 
private	TokenNameprivate	
final	TokenNamefinal	
AtomicBoolean	TokenNameIdentifier	 Atomic Boolean
isCompacted	TokenNameIdentifier	 is Compacted
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicBoolean	TokenNameIdentifier	 Atomic Boolean
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AtomicBoolean	TokenNameIdentifier	 Atomic Boolean
isSuspect	TokenNameIdentifier	 is Suspect
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicBoolean	TokenNameIdentifier	 Atomic Boolean
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SSTableDeletingTask	TokenNameIdentifier	 SS Table Deleting Task
deletingTask	TokenNameIdentifier	 deleting Task
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
sstableMetadata	TokenNameIdentifier	 sstable Metadata
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
getApproximateKeyCount	TokenNameIdentifier	 get Approximate Key Count
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
indexKeyCount	TokenNameIdentifier	 index Key Count
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getKeySamples	TokenNameIdentifier	 get Key Samples
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
count	TokenNameIdentifier	 count
+	TokenNamePLUS	
(	TokenNameLPAREN	
indexKeyCount	TokenNameIdentifier	 index Key Count
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"index size for bloom filter calc for file : "	TokenNameStringLiteral	index size for bloom filter calc for file : 
+	TokenNamePLUS	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" : "	TokenNameStringLiteral	 : 
+	TokenNamePLUS	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
parentName	TokenNameIdentifier	 parent Name
=	TokenNameEQUAL	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CFMetaData	TokenNameIdentifier	 CF Meta Data
parent	TokenNameIdentifier	 parent
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
ksname	TokenNameIdentifier	 ksname
,	TokenNameCOMMA	
parentName	TokenNameIdentifier	 parent Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnDefinition	TokenNameIdentifier	 Column Definition
def	TokenNameIdentifier	 def
=	TokenNameEQUAL	
parent	TokenNameIdentifier	 parent
.	TokenNameDOT	
getColumnDefinitionForIndex	TokenNameIdentifier	 get Column Definition For Index
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
metadata	TokenNameIdentifier	 metadata
=	TokenNameEQUAL	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
newIndexMetadata	TokenNameIdentifier	 new Index Metadata
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
def	TokenNameIdentifier	 def
,	TokenNameCOMMA	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
.	TokenNameDOT	
getIndexComparator	TokenNameIdentifier	 get Index Comparator
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
def	TokenNameIdentifier	 def
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
metadata	TokenNameIdentifier	 metadata
=	TokenNameEQUAL	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getCFMetaData	TokenNameIdentifier	 get CF Meta Data
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
ksname	TokenNameIdentifier	 ksname
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
IPartitioner	TokenNameIdentifier	 I Partitioner
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
LocalPartitioner	TokenNameIdentifier	 Local Partitioner
(	TokenNameLPAREN	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getKeyValidator	TokenNameIdentifier	 get Key Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
componentsFor	TokenNameIdentifier	 components For
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
openNoValidation	TokenNameIdentifier	 open No Validation
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
getPartitioner	TokenNameIdentifier	 get Partitioner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
boolean	TokenNameboolean	
validate	TokenNameIdentifier	 validate
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
partitioner	TokenNameIdentifier	 partitioner
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Minimum components without which we can't do anything 	TokenNameCOMMENT_LINE	Minimum components without which we can't do anything 
assert	TokenNameassert	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
:	TokenNameCOLON	
"Data component is missing for sstable"	TokenNameStringLiteral	Data component is missing for sstable
+	TokenNamePLUS	
descriptor	TokenNameIdentifier	 descriptor
;	TokenNameSEMICOLON	
assert	TokenNameassert	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
PRIMARY_INDEX	TokenNameIdentifier	 PRIMARY  INDEX
)	TokenNameRPAREN	
:	TokenNameCOLON	
"Primary index component is missing for sstable "	TokenNameStringLiteral	Primary index component is missing for sstable 
+	TokenNamePLUS	
descriptor	TokenNameIdentifier	 descriptor
;	TokenNameSEMICOLON	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Opening {} ({} bytes)"	TokenNameStringLiteral	Opening {} ({} bytes)
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
COMPONENT_DATA	TokenNameIdentifier	 COMPONENT  DATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
sstableMetadata	TokenNameIdentifier	 sstable Metadata
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
STATS	TokenNameIdentifier	 STATS
)	TokenNameRPAREN	
?	TokenNameQUESTION	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
:	TokenNameCOLON	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
createDefaultInstance	TokenNameIdentifier	 create Default Instance
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check if sstable is created using same partitioner. 	TokenNameCOMMENT_LINE	Check if sstable is created using same partitioner. 
// Partitioner can be null, which indicates older version of sstable or no stats available. 	TokenNameCOMMENT_LINE	Partitioner can be null, which indicates older version of sstable or no stats available. 
// In that case, we skip the check. 	TokenNameCOMMENT_LINE	In that case, we skip the check. 
String	TokenNameIdentifier	 String
partitionerName	TokenNameIdentifier	 partitioner Name
=	TokenNameEQUAL	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCanonicalName	TokenNameIdentifier	 get Canonical Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
partitionerName	TokenNameIdentifier	 partitioner Name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Cannot open %s; partitioner %s does not match system partitioner %s. Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading."	TokenNameStringLiteral	Cannot open %s; partitioner %s does not match system partitioner %s. Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading.
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
partitionerName	TokenNameIdentifier	 partitioner Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
exit	TokenNameIdentifier	 exit
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
new	TokenNamenew	
SSTableReader	TokenNameIdentifier	 SS Table Reader
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// versions before 'c' encoded keys as utf-16 before hashing to the filter 	TokenNameCOMMENT_LINE	versions before 'c' encoded keys as utf-16 before hashing to the filter 
if	TokenNameif	
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
hasStringsInBloomFilter	TokenNameIdentifier	 has Strings In Bloom Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
loadBloomFilter	TokenNameIdentifier	 load Bloom Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
validate	TokenNameIdentifier	 validate
)	TokenNameRPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"INDEX LOAD TIME for "	TokenNameStringLiteral	INDEX LOAD TIME for 
+	TokenNamePLUS	
descriptor	TokenNameIdentifier	 descriptor
+	TokenNamePLUS	
": "	TokenNameStringLiteral	: 
+	TokenNamePLUS	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
+	TokenNamePLUS	
" ms."	TokenNameStringLiteral	 ms.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getKeyCache	TokenNameIdentifier	 get Key Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"key cache contains %s/%s keys"	TokenNameStringLiteral	key cache contains %s/%s keys
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getKeyCache	TokenNameIdentifier	 get Key Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getKeyCache	TokenNameIdentifier	 get Key Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
logOpenException	TokenNameIdentifier	 log Open Exception
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
instanceof	TokenNameinstanceof	
FileNotFoundException	TokenNameIdentifier	 File Not Found Exception
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Missing sstable component in "	TokenNameStringLiteral	Missing sstable component in 
+	TokenNamePLUS	
descriptor	TokenNameIdentifier	 descriptor
+	TokenNamePLUS	
"; skipped because of "	TokenNameStringLiteral	; skipped because of 
+	TokenNamePLUS	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getMessage	TokenNameIdentifier	 get Message
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Corrupt sstable "	TokenNameStringLiteral	Corrupt sstable 
+	TokenNamePLUS	
descriptor	TokenNameIdentifier	 descriptor
+	TokenNamePLUS	
"; skipped"	TokenNameStringLiteral	; skipped
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
batchOpen	TokenNameIdentifier	 batch Open
(	TokenNameLPAREN	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
entries	TokenNameIdentifier	 entries
,	TokenNameCOMMA	
final	TokenNamefinal	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
final	TokenNamefinal	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedBlockingQueue	TokenNameIdentifier	 Linked Blocking Queue
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ExecutorService	TokenNameIdentifier	 Executor Service
executor	TokenNameIdentifier	 executor
=	TokenNameEQUAL	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
.	TokenNameDOT	
createWithFixedPoolSize	TokenNameIdentifier	 create With Fixed Pool Size
(	TokenNameLPAREN	
"SSTableBatchOpen"	TokenNameStringLiteral	SSTableBatchOpen
,	TokenNameCOMMA	
FBUtilities	TokenNameIdentifier	 FB Utilities
.	TokenNameDOT	
getAvailableProcessors	TokenNameIdentifier	 get Available Processors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
entries	TokenNameIdentifier	 entries
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
error	TokenNameIdentifier	 error
(	TokenNameLPAREN	
"Corrupt sstable "	TokenNameStringLiteral	Corrupt sstable 
+	TokenNamePLUS	
entry	TokenNameIdentifier	 entry
+	TokenNamePLUS	
"; skipped"	TokenNameStringLiteral	; skipped
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sstables	TokenNameIdentifier	 sstables
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
shutdown	TokenNameIdentifier	 shutdown
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
executor	TokenNameIdentifier	 executor
.	TokenNameDOT	
awaitTermination	TokenNameIdentifier	 await Termination
(	TokenNameLPAREN	
7	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
DAYS	TokenNameIdentifier	 DAYS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
sstables	TokenNameIdentifier	 sstables
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Open a RowIndexedReader which already has its state initialized (by SSTableWriter). */	TokenNameCOMMENT_JAVADOC	 Open a RowIndexedReader which already has its state initialized (by SSTableWriter). 
static	TokenNamestatic	
SSTableReader	TokenNameIdentifier	 SS Table Reader
internalOpen	TokenNameIdentifier	 internal Open
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
ifile	TokenNameIdentifier	 ifile
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
dfile	TokenNameIdentifier	 dfile
,	TokenNameCOMMA	
IndexSummary	TokenNameIdentifier	 Index Summary
isummary	TokenNameIdentifier	 isummary
,	TokenNameCOMMA	
IFilter	TokenNameIdentifier	 I Filter
bf	TokenNameIdentifier	 bf
,	TokenNameCOMMA	
long	TokenNamelong	
maxDataAge	TokenNameIdentifier	 max Data Age
,	TokenNameCOMMA	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
sstableMetadata	TokenNameIdentifier	 sstable Metadata
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
desc	TokenNameIdentifier	 desc
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
partitioner	TokenNameIdentifier	 partitioner
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
ifile	TokenNameIdentifier	 ifile
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
dfile	TokenNameIdentifier	 dfile
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
isummary	TokenNameIdentifier	 isummary
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
bf	TokenNameIdentifier	 bf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SSTableReader	TokenNameIdentifier	 SS Table Reader
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
ifile	TokenNameIdentifier	 ifile
,	TokenNameCOMMA	
dfile	TokenNameIdentifier	 dfile
,	TokenNameCOMMA	
isummary	TokenNameIdentifier	 isummary
,	TokenNameCOMMA	
bf	TokenNameIdentifier	 bf
,	TokenNameCOMMA	
maxDataAge	TokenNameIdentifier	 max Data Age
,	TokenNameCOMMA	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
SSTableReader	TokenNameIdentifier	 SS Table Reader
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
IPartitioner	TokenNameIdentifier	 I Partitioner
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
ifile	TokenNameIdentifier	 ifile
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
dfile	TokenNameIdentifier	 dfile
,	TokenNameCOMMA	
IndexSummary	TokenNameIdentifier	 Index Summary
indexSummary	TokenNameIdentifier	 index Summary
,	TokenNameCOMMA	
IFilter	TokenNameIdentifier	 I Filter
bloomFilter	TokenNameIdentifier	 bloom Filter
,	TokenNameCOMMA	
long	TokenNamelong	
maxDataAge	TokenNameIdentifier	 max Data Age
,	TokenNameCOMMA	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
sstableMetadata	TokenNameIdentifier	 sstable Metadata
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
,	TokenNameCOMMA	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
=	TokenNameEQUAL	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
maxDataAge	TokenNameIdentifier	 max Data Age
=	TokenNameEQUAL	
maxDataAge	TokenNameIdentifier	 max Data Age
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
ifile	TokenNameIdentifier	 ifile
=	TokenNameEQUAL	
ifile	TokenNameIdentifier	 ifile
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
dfile	TokenNameIdentifier	 dfile
=	TokenNameEQUAL	
dfile	TokenNameIdentifier	 dfile
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
indexSummary	TokenNameIdentifier	 index Summary
=	TokenNameEQUAL	
indexSummary	TokenNameIdentifier	 index Summary
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
bf	TokenNameIdentifier	 bf
=	TokenNameEQUAL	
bloomFilter	TokenNameIdentifier	 bloom Filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
deletingTask	TokenNameIdentifier	 deleting Task
=	TokenNameEQUAL	
new	TokenNamenew	
SSTableDeletingTask	TokenNameIdentifier	 SS Table Deleting Task
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setTrackedBy	TokenNameIdentifier	 set Tracked By
(	TokenNameLPAREN	
DataTracker	TokenNameIdentifier	 Data Tracker
tracker	TokenNameIdentifier	 tracker
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deletingTask	TokenNameIdentifier	 deleting Task
.	TokenNameDOT	
setTracker	TokenNameIdentifier	 set Tracker
(	TokenNameLPAREN	
tracker	TokenNameIdentifier	 tracker
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// under normal operation we can do this at any time, but SSTR is also used outside C* proper, 	TokenNameCOMMENT_LINE	under normal operation we can do this at any time, but SSTR is also used outside C* proper, 
// e.g. by BulkLoader, which does not initialize the cache. As a kludge, we set up the cache 	TokenNameCOMMENT_LINE	e.g. by BulkLoader, which does not initialize the cache. As a kludge, we set up the cache 
// here when we know we're being wired into the rest of the server infrastructure. 	TokenNameCOMMENT_LINE	here when we know we're being wired into the rest of the server infrastructure. 
keyCache	TokenNameIdentifier	 key Cache
=	TokenNameEQUAL	
CacheService	TokenNameIdentifier	 Cache Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
keyCache	TokenNameIdentifier	 key Cache
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
loadBloomFilter	TokenNameIdentifier	 load Bloom Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
FILTER	TokenNameIdentifier	 FILTER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bf	TokenNameIdentifier	 bf
=	TokenNameEQUAL	
new	TokenNamenew	
AlwaysPresentFilter	TokenNameIdentifier	 Always Present Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
DataInputStream	TokenNameIdentifier	 Data Input Stream
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
stream	TokenNameIdentifier	 stream
=	TokenNameEQUAL	
new	TokenNamenew	
DataInputStream	TokenNameIdentifier	 Data Input Stream
(	TokenNameLPAREN	
new	TokenNamenew	
BufferedInputStream	TokenNameIdentifier	 Buffered Input Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
FILTER	TokenNameIdentifier	 FILTER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
bf	TokenNameIdentifier	 bf
=	TokenNameEQUAL	
FilterFactory	TokenNameIdentifier	 Filter Factory
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
filterType	TokenNameIdentifier	 filter Type
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Loads ifile, dfile and indexSummary, and optionally recreates the bloom filter. */	TokenNameCOMMENT_JAVADOC	 Loads ifile, dfile and indexSummary, and optionally recreates the bloom filter. 
private	TokenNameprivate	
void	TokenNamevoid	
load	TokenNameIdentifier	 load
(	TokenNameLPAREN	
boolean	TokenNameboolean	
recreatebloom	TokenNameIdentifier	 recreatebloom
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
ibuilder	TokenNameIdentifier	 ibuilder
=	TokenNameEQUAL	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
getBuilder	TokenNameIdentifier	 get Builder
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexAccessMode	TokenNameIdentifier	 get Index Access Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
dbuilder	TokenNameIdentifier	 dbuilder
=	TokenNameEQUAL	
compression	TokenNameIdentifier	 compression
?	TokenNameQUESTION	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
getCompressedBuilder	TokenNameIdentifier	 get Compressed Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
getBuilder	TokenNameIdentifier	 get Builder
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getDiskAccessMode	TokenNameIdentifier	 get Disk Access Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we read the positions in a BRAF so we don't have to worry about an entry spanning a mmap boundary. 	TokenNameCOMMENT_LINE	we read the positions in a BRAF so we don't have to worry about an entry spanning a mmap boundary. 
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
primaryIndex	TokenNameIdentifier	 primary Index
=	TokenNameEQUAL	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
PRIMARY_INDEX	TokenNameIdentifier	 PRIMARY  INDEX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// try to load summaries from the disk and check if we need 	TokenNameCOMMENT_LINE	try to load summaries from the disk and check if we need 
// to read primary index because we should re-create a BloomFilter or pre-load KeyCache 	TokenNameCOMMENT_LINE	to read primary index because we should re-create a BloomFilter or pre-load KeyCache 
final	TokenNamefinal	
boolean	TokenNameboolean	
summaryLoaded	TokenNameIdentifier	 summary Loaded
=	TokenNameEQUAL	
loadSummary	TokenNameIdentifier	 load Summary
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
ibuilder	TokenNameIdentifier	 ibuilder
,	TokenNameCOMMA	
dbuilder	TokenNameIdentifier	 dbuilder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
readIndex	TokenNameIdentifier	 read Index
=	TokenNameEQUAL	
recreatebloom	TokenNameIdentifier	 recreatebloom
||	TokenNameOR_OR	
!	TokenNameNOT	
summaryLoaded	TokenNameIdentifier	 summary Loaded
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
long	TokenNamelong	
indexSize	TokenNameIdentifier	 index Size
=	TokenNameEQUAL	
primaryIndex	TokenNameIdentifier	 primary Index
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
histogramCount	TokenNameIdentifier	 histogram Count
=	TokenNameEQUAL	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
estimatedRowSize	TokenNameIdentifier	 estimated Row Size
.	TokenNameDOT	
count	TokenNameIdentifier	 count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
estimatedKeys	TokenNameIdentifier	 estimated Keys
=	TokenNameEQUAL	
histogramCount	TokenNameIdentifier	 histogram Count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
estimatedRowSize	TokenNameIdentifier	 estimated Row Size
.	TokenNameDOT	
isOverflowed	TokenNameIdentifier	 is Overflowed
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
histogramCount	TokenNameIdentifier	 histogram Count
:	TokenNameCOLON	
estimateRowsFromIndex	TokenNameIdentifier	 estimate Rows From Index
(	TokenNameLPAREN	
primaryIndex	TokenNameIdentifier	 primary Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// statistics is supposed to be optional 	TokenNameCOMMENT_LINE	statistics is supposed to be optional 
if	TokenNameif	
(	TokenNameLPAREN	
recreatebloom	TokenNameIdentifier	 recreatebloom
)	TokenNameRPAREN	
bf	TokenNameIdentifier	 bf
=	TokenNameEQUAL	
LegacyBloomFilter	TokenNameIdentifier	 Legacy Bloom Filter
.	TokenNameDOT	
getFilter	TokenNameIdentifier	 get Filter
(	TokenNameLPAREN	
estimatedKeys	TokenNameIdentifier	 estimated Keys
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
summaryLoaded	TokenNameIdentifier	 summary Loaded
)	TokenNameRPAREN	
indexSummary	TokenNameIdentifier	 index Summary
=	TokenNameEQUAL	
new	TokenNamenew	
IndexSummary	TokenNameIdentifier	 Index Summary
(	TokenNameLPAREN	
estimatedKeys	TokenNameIdentifier	 estimated Keys
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
indexPosition	TokenNameIdentifier	 index Position
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
readIndex	TokenNameIdentifier	 read Index
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
indexPosition	TokenNameIdentifier	 index Position
=	TokenNameEQUAL	
primaryIndex	TokenNameIdentifier	 primary Index
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
indexSize	TokenNameIdentifier	 index Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithShortLength	TokenNameIdentifier	 read With Short Length
(	TokenNameLPAREN	
primaryIndex	TokenNameIdentifier	 primary Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
indexEntry	TokenNameIdentifier	 index Entry
=	TokenNameEQUAL	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
primaryIndex	TokenNameIdentifier	 primary Index
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DecoratedKey	TokenNameIdentifier	 Decorated Key
decoratedKey	TokenNameIdentifier	 decorated Key
=	TokenNameEQUAL	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
decoratedKey	TokenNameIdentifier	 decorated Key
;	TokenNameSEMICOLON	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
decoratedKey	TokenNameIdentifier	 decorated Key
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
recreatebloom	TokenNameIdentifier	 recreatebloom
)	TokenNameRPAREN	
bf	TokenNameIdentifier	 bf
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
decoratedKey	TokenNameIdentifier	 decorated Key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if summary was already read from disk we don't want to re-populate it using primary index 	TokenNameCOMMENT_LINE	if summary was already read from disk we don't want to re-populate it using primary index 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
summaryLoaded	TokenNameIdentifier	 summary Loaded
)	TokenNameRPAREN	
{	TokenNameLBRACE	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
maybeAddEntry	TokenNameIdentifier	 maybe Add Entry
(	TokenNameLPAREN	
decoratedKey	TokenNameIdentifier	 decorated Key
,	TokenNameCOMMA	
indexPosition	TokenNameIdentifier	 index Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ibuilder	TokenNameIdentifier	 ibuilder
.	TokenNameDOT	
addPotentialBoundary	TokenNameIdentifier	 add Potential Boundary
(	TokenNameLPAREN	
indexPosition	TokenNameIdentifier	 index Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dbuilder	TokenNameIdentifier	 dbuilder
.	TokenNameDOT	
addPotentialBoundary	TokenNameIdentifier	 add Potential Boundary
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
primaryIndex	TokenNameIdentifier	 primary Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
getMinimalKey	TokenNameIdentifier	 get Minimal Key
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
getMinimalKey	TokenNameIdentifier	 get Minimal Key
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// finalize the load. 	TokenNameCOMMENT_LINE	finalize the load. 
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
complete	TokenNameIdentifier	 complete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// finalize the state of the reader 	TokenNameCOMMENT_LINE	finalize the state of the reader 
ifile	TokenNameIdentifier	 ifile
=	TokenNameEQUAL	
ibuilder	TokenNameIdentifier	 ibuilder
.	TokenNameDOT	
complete	TokenNameIdentifier	 complete
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
PRIMARY_INDEX	TokenNameIdentifier	 PRIMARY  INDEX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dfile	TokenNameIdentifier	 dfile
=	TokenNameEQUAL	
dbuilder	TokenNameIdentifier	 dbuilder
.	TokenNameDOT	
complete	TokenNameIdentifier	 complete
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
DATA	TokenNameIdentifier	 DATA
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
readIndex	TokenNameIdentifier	 read Index
)	TokenNameRPAREN	
// save summary information to disk 	TokenNameCOMMENT_LINE	save summary information to disk 
saveSummary	TokenNameIdentifier	 save Summary
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
ibuilder	TokenNameIdentifier	 ibuilder
,	TokenNameCOMMA	
dbuilder	TokenNameIdentifier	 dbuilder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
loadSummary	TokenNameIdentifier	 load Summary
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
ibuilder	TokenNameIdentifier	 ibuilder
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
dbuilder	TokenNameIdentifier	 dbuilder
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
summariesFile	TokenNameIdentifier	 summaries File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
SUMMARY	TokenNameIdentifier	 SUMMARY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
DataInputStream	TokenNameIdentifier	 Data Input Stream
iStream	TokenNameIdentifier	 i Stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
iStream	TokenNameIdentifier	 i Stream
=	TokenNameEQUAL	
new	TokenNamenew	
DataInputStream	TokenNameIdentifier	 Data Input Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileInputStream	TokenNameIdentifier	 File Input Stream
(	TokenNameLPAREN	
summariesFile	TokenNameIdentifier	 summaries File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
indexSummary	TokenNameIdentifier	 index Summary
=	TokenNameEQUAL	
IndexSummary	TokenNameIdentifier	 Index Summary
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithLength	TokenNameIdentifier	 read With Length
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithLength	TokenNameIdentifier	 read With Length
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ibuilder	TokenNameIdentifier	 ibuilder
.	TokenNameDOT	
deserializeBounds	TokenNameIdentifier	 deserialize Bounds
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dbuilder	TokenNameIdentifier	 dbuilder
.	TokenNameDOT	
deserializeBounds	TokenNameIdentifier	 deserialize Bounds
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Cannot deserialize SSTable Summary: "	TokenNameStringLiteral	Cannot deserialize SSTable Summary: 
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// corrupted hence delete it and let it load it now. 	TokenNameCOMMENT_LINE	corrupted hence delete it and let it load it now. 
if	TokenNameif	
(	TokenNameLPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
iStream	TokenNameIdentifier	 i Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
saveSummary	TokenNameIdentifier	 save Summary
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
ibuilder	TokenNameIdentifier	 ibuilder
,	TokenNameCOMMA	
SegmentedFile	TokenNameIdentifier	 Segmented File
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
dbuilder	TokenNameIdentifier	 dbuilder
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
summariesFile	TokenNameIdentifier	 summaries File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
SUMMARY	TokenNameIdentifier	 SUMMARY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
oStream	TokenNameIdentifier	 o Stream
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
oStream	TokenNameIdentifier	 o Stream
=	TokenNameEQUAL	
new	TokenNamenew	
DataOutputStream	TokenNameIdentifier	 Data Output Stream
(	TokenNameLPAREN	
new	TokenNamenew	
FileOutputStream	TokenNameIdentifier	 File Output Stream
(	TokenNameLPAREN	
summariesFile	TokenNameIdentifier	 summaries File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexSummary	TokenNameIdentifier	 Index Summary
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
serialize	TokenNameIdentifier	 serialize
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
indexSummary	TokenNameIdentifier	 index Summary
,	TokenNameCOMMA	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
writeWithLength	TokenNameIdentifier	 write With Length
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
writeWithLength	TokenNameIdentifier	 write With Length
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
.	TokenNameDOT	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ibuilder	TokenNameIdentifier	 ibuilder
.	TokenNameDOT	
serializeBounds	TokenNameIdentifier	 serialize Bounds
(	TokenNameLPAREN	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dbuilder	TokenNameIdentifier	 dbuilder
.	TokenNameDOT	
serializeBounds	TokenNameIdentifier	 serialize Bounds
(	TokenNameLPAREN	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Cannot save SSTable Summary: "	TokenNameStringLiteral	Cannot save SSTable Summary: 
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// corrupted hence delete it and let it load it now. 	TokenNameCOMMENT_LINE	corrupted hence delete it and let it load it now. 
if	TokenNameif	
(	TokenNameLPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
summariesFile	TokenNameIdentifier	 summaries File
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
oStream	TokenNameIdentifier	 o Stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
first	TokenNameIdentifier	 first
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"SSTable first key %s > last key %s"	TokenNameStringLiteral	SSTable first key %s > last key %s
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
first	TokenNameIdentifier	 first
,	TokenNameCOMMA	
this	TokenNamethis	
.	TokenNameDOT	
last	TokenNameIdentifier	 last
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** get the position in the index file to start scanning to find the given key (at most indexInterval keys away) */	TokenNameCOMMENT_JAVADOC	 get the position in the index file to start scanning to find the given key (at most indexInterval keys away) 
public	TokenNamepublic	
long	TokenNamelong	
getIndexScanPosition	TokenNameIdentifier	 get Index Scan Position
(	TokenNameLPAREN	
RowPosition	TokenNameIdentifier	 Row Position
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// binary search gives us the first index _greater_ than the key searched for, 	TokenNameCOMMENT_LINE	binary search gives us the first index _greater_ than the key searched for, 
// i.e., its insertion position 	TokenNameCOMMENT_LINE	i.e., its insertion position 
int	TokenNameint	
greaterThan	TokenNameIdentifier	 greater Than
=	TokenNameEQUAL	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
greaterThan	TokenNameIdentifier	 greater Than
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
greaterThan	TokenNameIdentifier	 greater Than
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns the compression metadata for this sstable. * @throws IllegalStateException if the sstable is not compressed */	TokenNameCOMMENT_JAVADOC	 Returns the compression metadata for this sstable. @throws IllegalStateException if the sstable is not compressed 
public	TokenNamepublic	
CompressionMetadata	TokenNameIdentifier	 Compression Metadata
getCompressionMetadata	TokenNameIdentifier	 get Compression Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
compression	TokenNameIdentifier	 compression
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
this	TokenNamethis	
+	TokenNamePLUS	
" is not compressed"	TokenNameStringLiteral	 is not compressed
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
CompressedSegmentedFile	TokenNameIdentifier	 Compressed Segmented File
)	TokenNameRPAREN	
dfile	TokenNameIdentifier	 dfile
)	TokenNameRPAREN	
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For testing purposes only. */	TokenNameCOMMENT_JAVADOC	 For testing purposes only. 
public	TokenNamepublic	
void	TokenNamevoid	
forceFilterFailures	TokenNameIdentifier	 force Filter Failures
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
bf	TokenNameIdentifier	 bf
=	TokenNameEQUAL	
LegacyBloomFilter	TokenNameIdentifier	 Legacy Bloom Filter
.	TokenNameDOT	
alwaysMatchingBloomFilter	TokenNameIdentifier	 always Matching Bloom Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
IFilter	TokenNameIdentifier	 I Filter
getBloomFilter	TokenNameIdentifier	 get Bloom Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bf	TokenNameIdentifier	 bf
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getBloomFilterSerializedSize	TokenNameIdentifier	 get Bloom Filter Serialized Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FilterFactory	TokenNameIdentifier	 Filter Factory
.	TokenNameDOT	
serializedSize	TokenNameIdentifier	 serialized Size
(	TokenNameLPAREN	
bf	TokenNameIdentifier	 bf
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
filterType	TokenNameIdentifier	 filter Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return An estimate of the number of keys in this SSTable. */	TokenNameCOMMENT_JAVADOC	 @return An estimate of the number of keys in this SSTable. 
public	TokenNamepublic	
long	TokenNamelong	
estimatedKeys	TokenNameIdentifier	 estimated Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param ranges * @return An estimate of the number of keys for given ranges in this SSTable. */	TokenNameCOMMENT_JAVADOC	 @param ranges @return An estimate of the number of keys for given ranges in this SSTable. 
public	TokenNamepublic	
long	TokenNamelong	
estimatedKeysForRanges	TokenNameIdentifier	 estimated Keys For Ranges
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
sampleKeyCount	TokenNameIdentifier	 sample Key Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
sampleIndexes	TokenNameIdentifier	 sample Indexes
=	TokenNameEQUAL	
getSampleIndexesForRanges	TokenNameIdentifier	 get Sample Indexes For Ranges
(	TokenNameLPAREN	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
sampleIndexRange	TokenNameIdentifier	 sample Index Range
:	TokenNameCOLON	
sampleIndexes	TokenNameIdentifier	 sample Indexes
)	TokenNameRPAREN	
sampleKeyCount	TokenNameIdentifier	 sample Key Count
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
sampleIndexRange	TokenNameIdentifier	 sample Index Range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
-	TokenNameMINUS	
sampleIndexRange	TokenNameIdentifier	 sample Index Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
sampleKeyCount	TokenNameIdentifier	 sample Key Count
*	TokenNameMULTIPLY	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return Approximately 1/INDEX_INTERVALth of the keys in this SSTable. */	TokenNameCOMMENT_JAVADOC	 @return Approximately 1/INDEX_INTERVALth of the keys in this SSTable. 
public	TokenNamepublic	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
getKeySamples	TokenNameIdentifier	 get Key Samples
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
getSampleIndexesForRanges	TokenNameIdentifier	 get Sample Indexes For Ranges
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
samples	TokenNameIdentifier	 samples
,	TokenNameCOMMA	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use the index to determine a minimal section for each range 	TokenNameCOMMENT_LINE	use the index to determine a minimal section for each range 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
positions	TokenNameIdentifier	 positions
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
Range	TokenNameIdentifier	 Range
.	TokenNameDOT	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RowPosition	TokenNameIdentifier	 Row Position
leftPosition	TokenNameIdentifier	 left Position
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
maxKeyBound	TokenNameIdentifier	 max Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowPosition	TokenNameIdentifier	 Row Position
rightPosition	TokenNameIdentifier	 right Position
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
maxKeyBound	TokenNameIdentifier	 max Key Bound
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
,	TokenNameCOMMA	
leftPosition	TokenNameIdentifier	 left Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
// left range are start exclusive 	TokenNameCOMMENT_LINE	left range are start exclusive 
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
left	TokenNameIdentifier	 left
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
==	TokenNameEQUAL_EQUAL	
samples	TokenNameIdentifier	 samples
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// left is past the end of the sampling 	TokenNameCOMMENT_LINE	left is past the end of the sampling 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
int	TokenNameint	
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
Range	TokenNameIdentifier	 Range
.	TokenNameDOT	
isWrapAround	TokenNameIdentifier	 is Wrap Around
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
?	TokenNameQUESTION	
samples	TokenNameIdentifier	 samples
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
binarySearch	TokenNameIdentifier	 binary Search
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
,	TokenNameCOMMA	
rightPosition	TokenNameIdentifier	 right Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// range are end inclusive so we use the previous index from what binarySearch give us 	TokenNameCOMMENT_LINE	range are end inclusive so we use the previous index from what binarySearch give us 
// since that will be the last index we will return 	TokenNameCOMMENT_LINE	since that will be the last index we will return 
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// Means the first key is already stricly greater that the right bound 	TokenNameCOMMENT_LINE	Means the first key is already stricly greater that the right bound 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
right	TokenNameIdentifier	 right
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
>	TokenNameGREATER	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
// empty range 	TokenNameCOMMENT_LINE	empty range 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
positions	TokenNameIdentifier	 positions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
getKeySamples	TokenNameIdentifier	 get Key Samples
(	TokenNameLPAREN	
final	TokenNamefinal	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
samples	TokenNameIdentifier	 samples
=	TokenNameEQUAL	
indexSummary	TokenNameIdentifier	 index Summary
.	TokenNameDOT	
getKeys	TokenNameIdentifier	 get Keys
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
indexRanges	TokenNameIdentifier	 index Ranges
=	TokenNameEQUAL	
getSampleIndexesForRanges	TokenNameIdentifier	 get Sample Indexes For Ranges
(	TokenNameLPAREN	
samples	TokenNameIdentifier	 samples
,	TokenNameCOMMA	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
singletonList	TokenNameIdentifier	 singleton List
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexRanges	TokenNameIdentifier	 index Ranges
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
emptyList	TokenNameIdentifier	 empty List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>>	TokenNameRIGHT_SHIFT	
rangeIter	TokenNameIdentifier	 range Iter
=	TokenNameEQUAL	
indexRanges	TokenNameIdentifier	 index Ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
;	TokenNameSEMICOLON	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
idx	TokenNameIdentifier	 idx
>	TokenNameGREATER	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
rangeIter	TokenNameIdentifier	 range Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
rangeIter	TokenNameIdentifier	 range Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
current	TokenNameIdentifier	 current
.	TokenNameDOT	
left	TokenNameIdentifier	 left
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RowPosition	TokenNameIdentifier	 Row Position
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
samples	TokenNameIdentifier	 samples
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the index should only contain valid row key, we only allow RowPosition in KeyPosition for search purposes 	TokenNameCOMMENT_LINE	the index should only contain valid row key, we only allow RowPosition in KeyPosition for search purposes 
assert	TokenNameassert	
k	TokenNameIdentifier	 k
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Determine the minimal set of sections that can be extracted from this SSTable to cover the given ranges. * @return A sorted list of (offset,end) pairs that cover the given ranges in the datafile for this SSTable. */	TokenNameCOMMENT_JAVADOC	 Determine the minimal set of sections that can be extracted from this SSTable to cover the given ranges. @return A sorted list of (offset,end) pairs that cover the given ranges in the datafile for this SSTable. 
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
getPositionsForRanges	TokenNameIdentifier	 get Positions For Ranges
(	TokenNameLPAREN	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>>	TokenNameRIGHT_SHIFT	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use the index to determine a minimal section for each range 	TokenNameCOMMENT_LINE	use the index to determine a minimal section for each range 
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
positions	TokenNameIdentifier	 positions
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Long	TokenNameIdentifier	 Long
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
:	TokenNameCOLON	
Range	TokenNameIdentifier	 Range
.	TokenNameDOT	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
keyRange	TokenNameIdentifier	 key Range
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
toRowBounds	TokenNameIdentifier	 to Row Bounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
idxLeft	TokenNameIdentifier	 idx Left
=	TokenNameEQUAL	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
keyRange	TokenNameIdentifier	 key Range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
GT	TokenNameIdentifier	 GT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
left	TokenNameIdentifier	 left
=	TokenNameEQUAL	
idxLeft	TokenNameIdentifier	 idx Left
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
idxLeft	TokenNameIdentifier	 idx Left
.	TokenNameDOT	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// left is past the end of the file 	TokenNameCOMMENT_LINE	left is past the end of the file 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
idxRight	TokenNameIdentifier	 idx Right
=	TokenNameEQUAL	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
keyRange	TokenNameIdentifier	 key Range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
,	TokenNameCOMMA	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
GT	TokenNameIdentifier	 GT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
long	TokenNamelong	
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
idxRight	TokenNameIdentifier	 idx Right
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
idxRight	TokenNameIdentifier	 idx Right
.	TokenNameDOT	
position	TokenNameIdentifier	 position
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
Range	TokenNameIdentifier	 Range
.	TokenNameDOT	
isWrapAround	TokenNameIdentifier	 is Wrap Around
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// right is past the end of the file, or it wraps 	TokenNameCOMMENT_LINE	right is past the end of the file, or it wraps 
right	TokenNameIdentifier	 right
=	TokenNameEQUAL	
uncompressedLength	TokenNameIdentifier	 uncompressed Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
==	TokenNameEQUAL_EQUAL	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
// empty range 	TokenNameCOMMENT_LINE	empty range 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
positions	TokenNameIdentifier	 positions
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Pair	TokenNameIdentifier	 Pair
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Long	TokenNameIdentifier	 Long
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
positions	TokenNameIdentifier	 positions
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
cacheKey	TokenNameIdentifier	 cache Key
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
Caching	TokenNameIdentifier	 Caching
caching	TokenNameIdentifier	 caching
=	TokenNameEQUAL	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
getCaching	TokenNameIdentifier	 get Caching
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
caching	TokenNameIdentifier	 caching
==	TokenNameEQUAL_EQUAL	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
NONE	TokenNameIdentifier	 NONE
||	TokenNameOR_OR	
caching	TokenNameIdentifier	 caching
==	TokenNameEQUAL_EQUAL	
CFMetaData	TokenNameIdentifier	 CF Meta Data
.	TokenNameDOT	
Caching	TokenNameIdentifier	 Caching
.	TokenNameDOT	
ROWS_ONLY	TokenNameIdentifier	 ROWS  ONLY
||	TokenNameOR_OR	
keyCache	TokenNameIdentifier	 key Cache
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
cacheKey	TokenNameIdentifier	 cache Key
=	TokenNameEQUAL	
new	TokenNamenew	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Adding cache entry for {} -> {}"	TokenNameStringLiteral	Adding cache entry for {} -> {}
,	TokenNameCOMMA	
cacheKey	TokenNameIdentifier	 cache Key
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
cacheKey	TokenNameIdentifier	 cache Key
,	TokenNameCOMMA	
info	TokenNameIdentifier	 info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
getCachedPosition	TokenNameIdentifier	 get Cached Position
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
boolean	TokenNameboolean	
updateStats	TokenNameIdentifier	 update Stats
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getCachedPosition	TokenNameIdentifier	 get Cached Position
(	TokenNameLPAREN	
new	TokenNamenew	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
,	TokenNameCOMMA	
updateStats	TokenNameIdentifier	 update Stats
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
getCachedPosition	TokenNameIdentifier	 get Cached Position
(	TokenNameLPAREN	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
unifiedKey	TokenNameIdentifier	 unified Key
,	TokenNameCOMMA	
boolean	TokenNameboolean	
updateStats	TokenNameIdentifier	 update Stats
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
keyCache	TokenNameIdentifier	 key Cache
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
getCapacity	TokenNameIdentifier	 get Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
updateStats	TokenNameIdentifier	 update Stats
?	TokenNameQUESTION	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
unifiedKey	TokenNameIdentifier	 unified Key
)	TokenNameRPAREN	
:	TokenNameCOLON	
keyCache	TokenNameIdentifier	 key Cache
.	TokenNameDOT	
getInternal	TokenNameIdentifier	 get Internal
(	TokenNameLPAREN	
unifiedKey	TokenNameIdentifier	 unified Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Get position updating key cache and stats. * @see #getPosition(org.apache.cassandra.db.RowPosition, org.apache.cassandra.io.sstable.SSTableReader.Operator, boolean) */	TokenNameCOMMENT_JAVADOC	 Get position updating key cache and stats. @see #getPosition(org.apache.cassandra.db.RowPosition, org.apache.cassandra.io.sstable.SSTableReader.Operator, boolean) 
public	TokenNamepublic	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
RowPosition	TokenNameIdentifier	 Row Position
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Operator	TokenNameIdentifier	 Operator
op	TokenNameIdentifier	 op
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
op	TokenNameIdentifier	 op
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to * allow key selection by token bounds but only if op != * EQ * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins. * @param updateCacheAndStats true if updating stats and cache * @return The index entry corresponding to the key, or null if the key is not present */	TokenNameCOMMENT_JAVADOC	 @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to allow key selection by token bounds but only if op != EQ @param op The Operator defining matching keys: the nearest key to the target matching the operator wins. @param updateCacheAndStats true if updating stats and cache @return The index entry corresponding to the key, or null if the key is not present 
public	TokenNamepublic	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
RowPosition	TokenNameIdentifier	 Row Position
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Operator	TokenNameIdentifier	 Operator
op	TokenNameIdentifier	 op
,	TokenNameCOMMA	
boolean	TokenNameboolean	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// first, check bloom filter 	TokenNameCOMMENT_LINE	first, check bloom filter 
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
key	TokenNameIdentifier	 key
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
// EQ only make sense if the key is a valid row key 	TokenNameCOMMENT_LINE	EQ only make sense if the key is a valid row key 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
bf	TokenNameIdentifier	 bf
.	TokenNameDOT	
isPresent	TokenNameIdentifier	 is Present
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Bloom filter allows skipping sstable {}"	TokenNameStringLiteral	Bloom filter allows skipping sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// next, the key cache (only make sense for valid row key) 	TokenNameCOMMENT_LINE	next, the key cache (only make sense for valid row key) 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
||	TokenNameOR_OR	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
GE	TokenNameIdentifier	 GE
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DecoratedKey	TokenNameIdentifier	 Decorated Key
decoratedKey	TokenNameIdentifier	 decorated Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
cacheKey	TokenNameIdentifier	 cache Key
=	TokenNameEQUAL	
new	TokenNamenew	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
decoratedKey	TokenNameIdentifier	 decorated Key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
cachedPosition	TokenNameIdentifier	 cached Position
=	TokenNameEQUAL	
getCachedPosition	TokenNameIdentifier	 get Cached Position
(	TokenNameLPAREN	
cacheKey	TokenNameIdentifier	 cache Key
,	TokenNameCOMMA	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cachedPosition	TokenNameIdentifier	 cached Position
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Cache hit for {} -> {}"	TokenNameStringLiteral	Cache hit for {} -> {}
,	TokenNameCOMMA	
cacheKey	TokenNameIdentifier	 cache Key
,	TokenNameCOMMA	
cachedPosition	TokenNameIdentifier	 cached Position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Key cache hit for sstable {}"	TokenNameStringLiteral	Key cache hit for sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
cachedPosition	TokenNameIdentifier	 cached Position
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// next, see if the sampled index says it's impossible for the key to be present 	TokenNameCOMMENT_LINE	next, see if the sampled index says it's impossible for the key to be present 
long	TokenNamelong	
sampledPosition	TokenNameIdentifier	 sampled Position
=	TokenNameEQUAL	
getIndexScanPosition	TokenNameIdentifier	 get Index Scan Position
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sampledPosition	TokenNameIdentifier	 sampled Position
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
&&	TokenNameAND_AND	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
addFalsePositive	TokenNameIdentifier	 add False Positive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// we matched the -1th position: if the operator might match forward, we'll start at the first 	TokenNameCOMMENT_LINE	we matched the -1th position: if the operator might match forward, we'll start at the first 
// position. We however need to return the correct index entry for that first position. 	TokenNameCOMMENT_LINE	position. We however need to return the correct index entry for that first position. 
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sampledPosition	TokenNameIdentifier	 sampled Position
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Index sample allows skipping sstable {}"	TokenNameStringLiteral	Index sample allows skipping sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// scan the on-disk index, starting at the nearest sampled position. 	TokenNameCOMMENT_LINE	scan the on-disk index, starting at the nearest sampled position. 
// The check against IndexInterval is to be exit the loop in the EQ case when the key looked for is not present 	TokenNameCOMMENT_LINE	The check against IndexInterval is to be exit the loop in the EQ case when the key looked for is not present 
// (bloom filter false positive). But note that for non-EQ cases, we might need to check the first key of the 	TokenNameCOMMENT_LINE	(bloom filter false positive). But note that for non-EQ cases, we might need to check the first key of the 
// next index position because the searched key can be greater the last key of the index interval checked if it 	TokenNameCOMMENT_LINE	next index position because the searched key can be greater the last key of the index interval checked if it 
// is lesser than the first key of next interval (and in that case we must return the position of the first key 	TokenNameCOMMENT_LINE	is lesser than the first key of next interval (and in that case we must return the position of the first key 
// of the next interval). 	TokenNameCOMMENT_LINE	of the next interval). 
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
FileDataInput	TokenNameIdentifier	 File Data Input
>	TokenNameGREATER	
segments	TokenNameIdentifier	 segments
=	TokenNameEQUAL	
ifile	TokenNameIdentifier	 ifile
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
sampledPosition	TokenNameIdentifier	 sampled Position
,	TokenNameCOMMA	
INDEX_FILE_BUFFER_BYTES	TokenNameIdentifier	 INDEX  FILE  BUFFER  BYTES
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FileDataInput	TokenNameIdentifier	 File Data Input
in	TokenNameIdentifier	 in
=	TokenNameEQUAL	
segments	TokenNameIdentifier	 segments
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
isEOF	TokenNameIdentifier	 is EOF
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexInterval	TokenNameIdentifier	 get Index Interval
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
indexKey	TokenNameIdentifier	 index Key
=	TokenNameEQUAL	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithShortLength	TokenNameIdentifier	 read With Short Length
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
opSatisfied	TokenNameIdentifier	 op Satisfied
;	TokenNameSEMICOLON	
// did we find an appropriate position for the op requested 	TokenNameCOMMENT_LINE	did we find an appropriate position for the op requested 
boolean	TokenNameboolean	
exactMatch	TokenNameIdentifier	 exact Match
;	TokenNameSEMICOLON	
// is the current position an exact match for the key, suitable for caching 	TokenNameCOMMENT_LINE	is the current position an exact match for the key, suitable for caching 
// Compare raw keys if possible for performance, otherwise compare decorated keys. 	TokenNameCOMMENT_LINE	Compare raw keys if possible for performance, otherwise compare decorated keys. 
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
)	TokenNameRPAREN	
{	TokenNameLBRACE	
opSatisfied	TokenNameIdentifier	 op Satisfied
=	TokenNameEQUAL	
exactMatch	TokenNameIdentifier	 exact Match
=	TokenNameEQUAL	
indexKey	TokenNameIdentifier	 index Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
DecoratedKey	TokenNameIdentifier	 Decorated Key
indexDecoratedKey	TokenNameIdentifier	 index Decorated Key
=	TokenNameEQUAL	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
indexKey	TokenNameIdentifier	 index Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
=	TokenNameEQUAL	
indexDecoratedKey	TokenNameIdentifier	 index Decorated Key
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
v	TokenNameIdentifier	 v
=	TokenNameEQUAL	
op	TokenNameIdentifier	 op
.	TokenNameDOT	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
comparison	TokenNameIdentifier	 comparison
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
opSatisfied	TokenNameIdentifier	 op Satisfied
=	TokenNameEQUAL	
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
exactMatch	TokenNameIdentifier	 exact Match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
comparison	TokenNameIdentifier	 comparison
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
v	TokenNameIdentifier	 v
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Partition index lookup allows skipping sstable {}"	TokenNameStringLiteral	Partition index lookup allows skipping sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
opSatisfied	TokenNameIdentifier	 op Satisfied
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// read data position from index entry 	TokenNameCOMMENT_LINE	read data position from index entry 
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
indexEntry	TokenNameIdentifier	 index Entry
=	TokenNameEQUAL	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
deserialize	TokenNameIdentifier	 deserialize
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
exactMatch	TokenNameIdentifier	 exact Match
&&	TokenNameAND_AND	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
key	TokenNameIdentifier	 key
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
// key can be == to the index key only if it's a true row key 	TokenNameCOMMENT_LINE	key can be == to the index key only if it's a true row key 
DecoratedKey	TokenNameIdentifier	 Decorated Key
decoratedKey	TokenNameIdentifier	 decorated Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// expensive sanity check! see CASSANDRA-4687 	TokenNameCOMMENT_LINE	expensive sanity check! see CASSANDRA-4687 
FileDataInput	TokenNameIdentifier	 File Data Input
fdi	TokenNameIdentifier	 fdi
=	TokenNameEQUAL	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
getSegment	TokenNameIdentifier	 get Segment
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DecoratedKey	TokenNameIdentifier	 Decorated Key
keyInDisk	TokenNameIdentifier	 key In Disk
=	TokenNameEQUAL	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithShortLength	TokenNameIdentifier	 read With Short Length
(	TokenNameLPAREN	
fdi	TokenNameIdentifier	 fdi
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
keyInDisk	TokenNameIdentifier	 key In Disk
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"%s != %s in %s"	TokenNameStringLiteral	%s != %s in %s
,	TokenNameCOMMA	
keyInDisk	TokenNameIdentifier	 key In Disk
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
fdi	TokenNameIdentifier	 fdi
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fdi	TokenNameIdentifier	 fdi
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store exact match for the key 	TokenNameCOMMENT_LINE	store exact match for the key 
cacheKey	TokenNameIdentifier	 cache Key
(	TokenNameLPAREN	
decoratedKey	TokenNameIdentifier	 decorated Key
,	TokenNameCOMMA	
indexEntry	TokenNameIdentifier	 index Entry
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
&&	TokenNameAND_AND	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
addTruePositive	TokenNameIdentifier	 add True Positive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Partition index lookup complete for sstable {}"	TokenNameStringLiteral	Partition index lookup complete for sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
indexEntry	TokenNameIdentifier	 index Entry
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
.	TokenNameDOT	
skip	TokenNameIdentifier	 skip
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
markSuspect	TokenNameIdentifier	 mark Suspect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptSSTableException	TokenNameIdentifier	 Corrupt SS Table Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
in	TokenNameIdentifier	 in
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
op	TokenNameIdentifier	 op
==	TokenNameEQUAL_EQUAL	
Operator	TokenNameIdentifier	 Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
&&	TokenNameAND_AND	
updateCacheAndStats	TokenNameIdentifier	 update Cache And Stats
)	TokenNameRPAREN	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
addFalsePositive	TokenNameIdentifier	 add False Positive
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Tracing	TokenNameIdentifier	 Tracing
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Partition index lookup complete (bloom filter false positive) for sstable {}"	TokenNameStringLiteral	Partition index lookup complete (bloom filter false positive) for sstable {}
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
generation	TokenNameIdentifier	 generation
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return The length in bytes of the data for this SSTable. For * compressed files, this is not the same thing as the on disk size (see * onDiskLength()) */	TokenNameCOMMENT_JAVADOC	 @return The length in bytes of the data for this SSTable. For compressed files, this is not the same thing as the on disk size (see onDiskLength()) 
public	TokenNamepublic	
long	TokenNamelong	
uncompressedLength	TokenNameIdentifier	 uncompressed Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return The length in bytes of the on disk size for this SSTable. For * compressed files, this is not the same thing as the data length (see * length()) */	TokenNameCOMMENT_JAVADOC	 @return The length in bytes of the on disk size for this SSTable. For compressed files, this is not the same thing as the data length (see length()) 
public	TokenNamepublic	
long	TokenNamelong	
onDiskLength	TokenNameIdentifier	 on Disk Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
onDiskLength	TokenNameIdentifier	 on Disk Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
acquireReference	TokenNameIdentifier	 acquire Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
references	TokenNameIdentifier	 references
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
references	TokenNameIdentifier	 references
.	TokenNameDOT	
compareAndSet	TokenNameIdentifier	 compare And Set
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
n	TokenNameIdentifier	 n
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
releaseReference	TokenNameIdentifier	 release Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
references	TokenNameIdentifier	 references
.	TokenNameDOT	
decrementAndGet	TokenNameIdentifier	 decrement And Get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
isCompacted	TokenNameIdentifier	 is Compacted
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Force finalizing mmapping if necessary 	TokenNameCOMMENT_LINE	Force finalizing mmapping if necessary 
ifile	TokenNameIdentifier	 ifile
.	TokenNameDOT	
cleanup	TokenNameIdentifier	 cleanup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
cleanup	TokenNameIdentifier	 cleanup
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
deletingTask	TokenNameIdentifier	 deleting Task
.	TokenNameDOT	
schedule	TokenNameIdentifier	 schedule
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// close the BF so it can be opened later. 	TokenNameCOMMENT_LINE	close the BF so it can be opened later. 
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
closeQuietly	TokenNameIdentifier	 close Quietly
(	TokenNameLPAREN	
bf	TokenNameIdentifier	 bf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
assert	TokenNameassert	
references	TokenNameIdentifier	 references
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
"Reference counter "	TokenNameStringLiteral	Reference counter 
+	TokenNamePLUS	
references	TokenNameIdentifier	 references
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" for "	TokenNameStringLiteral	 for 
+	TokenNamePLUS	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Mark the sstable as compacted. * When calling this function, the caller must ensure that the SSTableReader is not referenced anywhere * except for threads holding a reference. * * @return true if the this is the first time the file was marked compacted. With rare exceptions * (see DataTracker.unmarkCompacted) calling this multiple times would be buggy. */	TokenNameCOMMENT_JAVADOC	 Mark the sstable as compacted. When calling this function, the caller must ensure that the SSTableReader is not referenced anywhere except for threads holding a reference. * @return true if the this is the first time the file was marked compacted. With rare exceptions (see DataTracker.unmarkCompacted) calling this multiple times would be buggy. 
public	TokenNamepublic	
boolean	TokenNameboolean	
markCompacted	TokenNameIdentifier	 mark Compacted
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Marking "	TokenNameStringLiteral	Marking 
+	TokenNamePLUS	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" compacted"	TokenNameStringLiteral	 compacted
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
!	TokenNameNOT	
isCompacted	TokenNameIdentifier	 is Compacted
.	TokenNameDOT	
getAndSet	TokenNameIdentifier	 get And Set
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
markSuspect	TokenNameIdentifier	 mark Suspect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Marking "	TokenNameStringLiteral	Marking 
+	TokenNamePLUS	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" as a suspect for blacklisting."	TokenNameStringLiteral	 as a suspect for blacklisting.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
isSuspect	TokenNameIdentifier	 is Suspect
.	TokenNameDOT	
getAndSet	TokenNameIdentifier	 get And Set
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isMarkedSuspect	TokenNameIdentifier	 is Marked Suspect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isSuspect	TokenNameIdentifier	 is Suspect
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * * @param filter filter to use when reading the columns * @return A Scanner for seeking over the rows of the SSTable. */	TokenNameCOMMENT_JAVADOC	 * @param filter filter to use when reading the columns @return A Scanner for seeking over the rows of the SSTable. 
public	TokenNamepublic	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
getScanner	TokenNameIdentifier	 get Scanner
(	TokenNameLPAREN	
QueryFilter	TokenNameIdentifier	 Query Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Direct I/O SSTableScanner * @return A Scanner for seeking over the rows of the SSTable. */	TokenNameCOMMENT_JAVADOC	 Direct I/O SSTableScanner @return A Scanner for seeking over the rows of the SSTable. 
public	TokenNamepublic	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
getDirectScanner	TokenNameIdentifier	 get Direct Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Direct I/O SSTableScanner over a defined range of tokens. * * @param range the range of keys to cover * @return A Scanner for seeking over the rows of the SSTable. */	TokenNameCOMMENT_JAVADOC	 Direct I/O SSTableScanner over a defined range of tokens. * @param range the range of keys to cover @return A Scanner for seeking over the rows of the SSTable. 
public	TokenNamepublic	
SSTableScanner	TokenNameIdentifier	 SS Table Scanner
getDirectScanner	TokenNameIdentifier	 get Direct Scanner
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
<	TokenNameLESS	
Token	TokenNameIdentifier	 Token
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
getDirectScanner	TokenNameIdentifier	 get Direct Scanner
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SSTableBoundedScanner	TokenNameIdentifier	 SS Table Bounded Scanner
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
FileDataInput	TokenNameIdentifier	 File Data Input
getFileDataInput	TokenNameIdentifier	 get File Data Input
(	TokenNameLPAREN	
long	TokenNamelong	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
dfile	TokenNameIdentifier	 dfile
.	TokenNameDOT	
getSegment	TokenNameIdentifier	 get Segment
(	TokenNameLPAREN	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Tests if the sstable contains data newer than the given age param (in localhost currentMilli time). * This works in conjunction with maxDataAge which is an upper bound on the create of data in this sstable. * @param age The age to compare the maxDataAre of this sstable. Measured in millisec since epoc on this host * @return True iff this sstable contains data that's newer than the given age parameter. */	TokenNameCOMMENT_JAVADOC	 Tests if the sstable contains data newer than the given age param (in localhost currentMilli time). This works in conjunction with maxDataAge which is an upper bound on the create of data in this sstable. @param age The age to compare the maxDataAre of this sstable. Measured in millisec since epoc on this host @return True iff this sstable contains data that's newer than the given age parameter. 
public	TokenNamepublic	
boolean	TokenNameboolean	
newSince	TokenNameIdentifier	 new Since
(	TokenNameLPAREN	
long	TokenNamelong	
age	TokenNameIdentifier	 age
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
maxDataAge	TokenNameIdentifier	 max Data Age
>	TokenNameGREATER	
age	TokenNameIdentifier	 age
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
long	TokenNamelong	
readRowSize	TokenNameIdentifier	 read Row Size
(	TokenNameLPAREN	
DataInput	TokenNameIdentifier	 Data Input
in	TokenNameIdentifier	 in
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
d	TokenNameIdentifier	 d
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
hasIntRowSize	TokenNameIdentifier	 has Int Row Size
)	TokenNameRPAREN	
return	TokenNamereturn	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
in	TokenNameIdentifier	 in
.	TokenNameDOT	
readLong	TokenNameIdentifier	 read Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
createLinks	TokenNameIdentifier	 create Links
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotDirectoryPath	TokenNameIdentifier	 snapshot Directory Path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
component	TokenNameIdentifier	 component
:	TokenNameCOLON	
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
sourceFile	TokenNameIdentifier	 source File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
targetLink	TokenNameIdentifier	 target Link
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
snapshotDirectoryPath	TokenNameIdentifier	 snapshot Directory Path
,	TokenNameCOMMA	
sourceFile	TokenNameIdentifier	 source File
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
createHardLink	TokenNameIdentifier	 create Hard Link
(	TokenNameLPAREN	
sourceFile	TokenNameIdentifier	 source File
,	TokenNameCOMMA	
targetLink	TokenNameIdentifier	 target Link
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Conditionally use the deprecated 'IPartitioner.convertFromDiskFormat' method. */	TokenNameCOMMENT_JAVADOC	 Conditionally use the deprecated 'IPartitioner.convertFromDiskFormat' method. 
public	TokenNamepublic	
static	TokenNamestatic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
IPartitioner	TokenNameIdentifier	 I Partitioner
p	TokenNameIdentifier	 p
,	TokenNameCOMMA	
Descriptor	TokenNameIdentifier	 Descriptor
d	TokenNameIdentifier	 d
,	TokenNameCOMMA	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
d	TokenNameIdentifier	 d
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
hasEncodedKeys	TokenNameIdentifier	 has Encoded Keys
)	TokenNameRPAREN	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
convertFromDiskFormat	TokenNameIdentifier	 convert From Disk Format
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
decorateKey	TokenNameIdentifier	 decorate Key
(	TokenNameLPAREN	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
descriptor	TokenNameIdentifier	 descriptor
,	TokenNameCOMMA	
bytes	TokenNameIdentifier	 bytes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * TODO: Move someplace reusable */	TokenNameCOMMENT_JAVADOC	 TODO: Move someplace reusable 
public	TokenNamepublic	
abstract	TokenNameabstract	
static	TokenNamestatic	
class	TokenNameclass	
Operator	TokenNameIdentifier	 Operator
{	TokenNameLBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Operator	TokenNameIdentifier	 Operator
EQ	TokenNameIdentifier	 EQ
=	TokenNameEQUAL	
new	TokenNamenew	
Equals	TokenNameIdentifier	 Equals
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Operator	TokenNameIdentifier	 Operator
GE	TokenNameIdentifier	 GE
=	TokenNameEQUAL	
new	TokenNamenew	
GreaterThanOrEqualTo	TokenNameIdentifier	 Greater Than Or Equal To
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
Operator	TokenNameIdentifier	 Operator
GT	TokenNameIdentifier	 GT
=	TokenNameEQUAL	
new	TokenNamenew	
GreaterThan	TokenNameIdentifier	 Greater Than
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * @param comparison The result of a call to compare/compareTo, with the desired field on the rhs. * @return less than 0 if the operator cannot match forward, 0 if it matches, greater than 0 if it might match forward. */	TokenNameCOMMENT_JAVADOC	 @param comparison The result of a call to compare/compareTo, with the desired field on the rhs. @return less than 0 if the operator cannot match forward, 0 if it matches, greater than 0 if it might match forward. 
public	TokenNamepublic	
abstract	TokenNameabstract	
int	TokenNameint	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
Equals	TokenNameIdentifier	 Equals
extends	TokenNameextends	
Operator	TokenNameIdentifier	 Operator
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
comparison	TokenNameIdentifier	 comparison
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
GreaterThanOrEqualTo	TokenNameIdentifier	 Greater Than Or Equal To
extends	TokenNameextends	
Operator	TokenNameIdentifier	 Operator
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparison	TokenNameIdentifier	 comparison
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
-	TokenNameMINUS	
comparison	TokenNameIdentifier	 comparison
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
static	TokenNamestatic	
class	TokenNameclass	
GreaterThan	TokenNameIdentifier	 Greater Than
extends	TokenNameextends	
Operator	TokenNameIdentifier	 Operator
{	TokenNameLBRACE	
public	TokenNamepublic	
int	TokenNameint	
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
int	TokenNameint	
comparison	TokenNameIdentifier	 comparison
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
comparison	TokenNameIdentifier	 comparison
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getBloomFilterFalsePositiveCount	TokenNameIdentifier	 get Bloom Filter False Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
getFalsePositiveCount	TokenNameIdentifier	 get False Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getRecentBloomFilterFalsePositiveCount	TokenNameIdentifier	 get Recent Bloom Filter False Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
getRecentFalsePositiveCount	TokenNameIdentifier	 get Recent False Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getBloomFilterTruePositiveCount	TokenNameIdentifier	 get Bloom Filter True Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
getTruePositiveCount	TokenNameIdentifier	 get True Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getRecentBloomFilterTruePositiveCount	TokenNameIdentifier	 get Recent Bloom Filter True Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
bloomFilterTracker	TokenNameIdentifier	 bloom Filter Tracker
.	TokenNameDOT	
getRecentTruePositiveCount	TokenNameIdentifier	 get Recent True Positive Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
InstrumentingCache	TokenNameIdentifier	 Instrumenting Cache
<	TokenNameLESS	
KeyCacheKey	TokenNameIdentifier	 Key Cache Key
,	TokenNameCOMMA	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
>	TokenNameGREATER	
getKeyCache	TokenNameIdentifier	 get Key Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
keyCache	TokenNameIdentifier	 key Cache
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
EstimatedHistogram	TokenNameIdentifier	 Estimated Histogram
getEstimatedRowSize	TokenNameIdentifier	 get Estimated Row Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
estimatedRowSize	TokenNameIdentifier	 estimated Row Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
EstimatedHistogram	TokenNameIdentifier	 Estimated Histogram
getEstimatedColumnCount	TokenNameIdentifier	 get Estimated Column Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
estimatedColumnCount	TokenNameIdentifier	 estimated Column Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getEstimatedDroppableTombstoneRatio	TokenNameIdentifier	 get Estimated Droppable Tombstone Ratio
(	TokenNameLPAREN	
int	TokenNameint	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
getEstimatedDroppableTombstoneRatio	TokenNameIdentifier	 get Estimated Droppable Tombstone Ratio
(	TokenNameLPAREN	
gcBefore	TokenNameIdentifier	 gc Before
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
double	TokenNamedouble	
getCompressionRatio	TokenNameIdentifier	 get Compression Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
compressionRatio	TokenNameIdentifier	 compression Ratio
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ReplayPosition	TokenNameIdentifier	 Replay Position
getReplayPosition	TokenNameIdentifier	 get Replay Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
replayPosition	TokenNameIdentifier	 replay Position
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getMaxTimestamp	TokenNameIdentifier	 get Max Timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
maxTimestamp	TokenNameIdentifier	 max Timestamp
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Integer	TokenNameIdentifier	 Integer
>	TokenNameGREATER	
getAncestors	TokenNameIdentifier	 get Ancestors
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sstableMetadata	TokenNameIdentifier	 sstable Metadata
.	TokenNameDOT	
ancestors	TokenNameIdentifier	 ancestors
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
openDataReader	TokenNameIdentifier	 open Data Reader
(	TokenNameLPAREN	
boolean	TokenNameboolean	
skipIOCache	TokenNameIdentifier	 skip IO Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
compression	TokenNameIdentifier	 compression
?	TokenNameQUESTION	
CompressedRandomAccessReader	TokenNameIdentifier	 Compressed Random Access Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
getCompressionMetadata	TokenNameIdentifier	 get Compression Metadata
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
skipIOCache	TokenNameIdentifier	 skip IO Cache
)	TokenNameRPAREN	
:	TokenNameCOLON	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
skipIOCache	TokenNameIdentifier	 skip IO Cache
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
openIndexReader	TokenNameIdentifier	 open Index Reader
(	TokenNameLPAREN	
boolean	TokenNameboolean	
skipIOCache	TokenNameIdentifier	 skip IO Cache
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
RandomAccessReader	TokenNameIdentifier	 Random Access Reader
.	TokenNameDOT	
open	TokenNameIdentifier	 open
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
getIndexFilename	TokenNameIdentifier	 get Index Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
skipIOCache	TokenNameIdentifier	 skip IO Cache
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param component component to get timestamp. * @return last modified time for given component. 0 if given component does not exist or IO error occurs. */	TokenNameCOMMENT_JAVADOC	 @param component component to get timestamp. @return last modified time for given component. 0 if given component does not exist or IO error occurs. 
public	TokenNamepublic	
long	TokenNamelong	
getCreationTimeFor	TokenNameIdentifier	 get Creation Time For
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
component	TokenNameIdentifier	 component
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param sstables * @return true if all desired references were acquired. Otherwise, it will unreference any partial acquisition, and return false. */	TokenNameCOMMENT_JAVADOC	 @param sstables @return true if all desired references were acquired. Otherwise, it will unreference any partial acquisition, and return false. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
acquireReferences	TokenNameIdentifier	 acquire References
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SSTableReader	TokenNameIdentifier	 SS Table Reader
failed	TokenNameIdentifier	 failed
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
acquireReference	TokenNameIdentifier	 acquire Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
failed	TokenNameIdentifier	 failed
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
failed	TokenNameIdentifier	 failed
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
==	TokenNameEQUAL_EQUAL	
failed	TokenNameIdentifier	 failed
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
releaseReference	TokenNameIdentifier	 release Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
releaseReferences	TokenNameIdentifier	 release References
(	TokenNameLPAREN	
Iterable	TokenNameIdentifier	 Iterable
<	TokenNameLESS	
SSTableReader	TokenNameIdentifier	 SS Table Reader
>	TokenNameGREATER	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
:	TokenNameCOLON	
sstables	TokenNameIdentifier	 sstables
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
releaseReference	TokenNameIdentifier	 release Reference
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
