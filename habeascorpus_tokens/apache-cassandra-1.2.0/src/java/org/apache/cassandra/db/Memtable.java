/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicLong	TokenNameIdentifier	 Atomic Long
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Function	TokenNameIdentifier	 Function
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
base	TokenNameIdentifier	 base
.	TokenNameDOT	
Throwables	TokenNameIdentifier	 Throwables
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
DiskAwareRunnable	TokenNameIdentifier	 Disk Aware Runnable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
cliffc	TokenNameIdentifier	 cliffc
.	TokenNameDOT	
high_scale_lib	TokenNameIdentifier	 high scale lib
.	TokenNameDOT	
NonBlockingHashSet	TokenNameIdentifier	 Non Blocking Hash Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
github	TokenNameIdentifier	 github
.	TokenNameDOT	
jamm	TokenNameIdentifier	 jamm
.	TokenNameDOT	
MemoryMeter	TokenNameIdentifier	 Memory Meter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
columniterator	TokenNameIdentifier	 columniterator
.	TokenNameDOT	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
columniterator	TokenNameIdentifier	 columniterator
.	TokenNameDOT	
SimpleAbstractColumnIterator	TokenNameIdentifier	 Simple Abstract Column Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
commitlog	TokenNameIdentifier	 commitlog
.	TokenNameDOT	
ReplayPosition	TokenNameIdentifier	 Replay Position
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
AbstractColumnIterator	TokenNameIdentifier	 Abstract Column Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
NamesQueryFilter	TokenNameIdentifier	 Names Query Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
AbstractType	TokenNameIdentifier	 Abstract Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableReader	TokenNameIdentifier	 SS Table Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
SlabAllocator	TokenNameIdentifier	 Slab Allocator
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
Memtable	TokenNameIdentifier	 Memtable
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
Memtable	TokenNameIdentifier	 Memtable
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// size in memory can never be less than serialized size 	TokenNameCOMMENT_LINE	size in memory can never be less than serialized size 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
MIN_SANE_LIVE_RATIO	TokenNameIdentifier	 MIN  SANE  LIVE  RATIO
=	TokenNameEQUAL	
1.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
// max liveratio seen w/ 1-byte columns on a 64-bit jvm was 19. If it gets higher than 64 something is probably broken. 	TokenNameCOMMENT_LINE	max liveratio seen w/ 1-byte columns on a 64-bit jvm was 19. If it gets higher than 64 something is probably broken. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
double	TokenNamedouble	
MAX_SANE_LIVE_RATIO	TokenNameIdentifier	 MAX  SANE  LIVE  RATIO
=	TokenNameEQUAL	
64.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
// we want to limit the amount of concurrently running and/or queued meterings, because counting is slow (can be 	TokenNameCOMMENT_LINE	we want to limit the amount of concurrently running and/or queued meterings, because counting is slow (can be 
// minutes, for a large memtable and a busy server). so we could keep memtables 	TokenNameCOMMENT_LINE	minutes, for a large memtable and a busy server). so we could keep memtables 
// alive after they're flushed and would otherwise be GC'd. the approach we take is to bound the number of 	TokenNameCOMMENT_LINE	alive after they're flushed and would otherwise be GC'd. the approach we take is to bound the number of 
// outstanding/running meterings to a maximum of one per CFS using this set; the executor's queue is unbounded but 	TokenNameCOMMENT_LINE	outstanding/running meterings to a maximum of one per CFS using this set; the executor's queue is unbounded but 
// will implicitly be bounded by the number of CFS:s. 	TokenNameCOMMENT_LINE	will implicitly be bounded by the number of CFS:s. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
meteringInProgress	TokenNameIdentifier	 metering In Progress
=	TokenNameEQUAL	
new	TokenNamenew	
NonBlockingHashSet	TokenNameIdentifier	 Non Blocking Hash Set
<	TokenNameLESS	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
ExecutorService	TokenNameIdentifier	 Executor Service
meterExecutor	TokenNameIdentifier	 meter Executor
=	TokenNameEQUAL	
new	TokenNamenew	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
TimeUnit	TokenNameIdentifier	 Time Unit
.	TokenNameDOT	
MILLISECONDS	TokenNameIdentifier	 MILLISECONDS
,	TokenNameCOMMA	
new	TokenNamenew	
LinkedBlockingQueue	TokenNameIdentifier	 Linked Blocking Queue
<	TokenNameLESS	
Runnable	TokenNameIdentifier	 Runnable
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
NamedThreadFactory	TokenNameIdentifier	 Named Thread Factory
(	TokenNameLPAREN	
"MemoryMeter"	TokenNameStringLiteral	MemoryMeter
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
protected	TokenNameprotected	
void	TokenNamevoid	
afterExecute	TokenNameIdentifier	 after Execute
(	TokenNameLPAREN	
Runnable	TokenNameIdentifier	 Runnable
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
Throwable	TokenNameIdentifier	 Throwable
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
afterExecute	TokenNameIdentifier	 after Execute
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DebuggableThreadPoolExecutor	TokenNameIdentifier	 Debuggable Thread Pool Executor
.	TokenNameDOT	
logExceptionsAfterExecute	TokenNameIdentifier	 log Exceptions After Execute
(	TokenNameLPAREN	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
t	TokenNameIdentifier	 t
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
MemoryMeter	TokenNameIdentifier	 Memory Meter
meter	TokenNameIdentifier	 meter
;	TokenNameSEMICOLON	
volatile	TokenNamevolatile	
static	TokenNamestatic	
Memtable	TokenNameIdentifier	 Memtable
activelyMeasuring	TokenNameIdentifier	 actively Measuring
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
currentSize	TokenNameIdentifier	 current Size
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
currentOperations	TokenNameIdentifier	 current Operations
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We index the memtable by RowPosition only for the purpose of being able 	TokenNameCOMMENT_LINE	We index the memtable by RowPosition only for the purpose of being able 
// to select key range using Token.KeyBound. However put() ensures that we 	TokenNameCOMMENT_LINE	to select key range using Token.KeyBound. However put() ensures that we 
// actually only store DecoratedKey. 	TokenNameCOMMENT_LINE	actually only store DecoratedKey. 
private	TokenNameprivate	
final	TokenNamefinal	
ConcurrentNavigableMap	TokenNameIdentifier	 Concurrent Navigable Map
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
columnFamilies	TokenNameIdentifier	 column Families
=	TokenNameEQUAL	
new	TokenNamenew	
ConcurrentSkipListMap	TokenNameIdentifier	 Concurrent Skip List Map
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
creationTime	TokenNameIdentifier	 creation Time
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SlabAllocator	TokenNameIdentifier	 Slab Allocator
allocator	TokenNameIdentifier	 allocator
=	TokenNameEQUAL	
new	TokenNamenew	
SlabAllocator	TokenNameIdentifier	 Slab Allocator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We really only need one column by allocator but one by memtable is not a big waste and avoids needing allocators to know about CFS 	TokenNameCOMMENT_LINE	We really only need one column by allocator but one by memtable is not a big waste and avoids needing allocators to know about CFS 
private	TokenNameprivate	
final	TokenNamefinal	
Function	TokenNameIdentifier	 Function
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
localCopyFunction	TokenNameIdentifier	 local Copy Function
=	TokenNameEQUAL	
new	TokenNamenew	
Function	TokenNameIdentifier	 Function
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
,	TokenNameCOMMA	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
IColumn	TokenNameIdentifier	 I Column
apply	TokenNameIdentifier	 apply
(	TokenNameLPAREN	
IColumn	TokenNameIdentifier	 I Column
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
c	TokenNameIdentifier	 c
.	TokenNameDOT	
localCopy	TokenNameIdentifier	 local Copy
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
allocator	TokenNameIdentifier	 allocator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// Record the comparator of the CFS at the creation of the memtable. This 	TokenNameCOMMENT_LINE	Record the comparator of the CFS at the creation of the memtable. This 
// is only used when a user update the CF comparator, to know if the 	TokenNameCOMMENT_LINE	is only used when a user update the CF comparator, to know if the 
// memtable was created with the new or old comparator. 	TokenNameCOMMENT_LINE	memtable was created with the new or old comparator. 
public	TokenNamepublic	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
initialComparator	TokenNameIdentifier	 initial Comparator
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Memtable	TokenNameIdentifier	 Memtable
(	TokenNameLPAREN	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
creationTime	TokenNameIdentifier	 creation Time
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
initialComparator	TokenNameIdentifier	 initial Comparator
=	TokenNameEQUAL	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
provider	TokenNameIdentifier	 provider
=	TokenNameEQUAL	
new	TokenNamenew	
Callable	TokenNameIdentifier	 Callable
<	TokenNameLESS	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
call	TokenNameIdentifier	 call
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
// avoid counting this once for each row 	TokenNameCOMMENT_LINE	avoid counting this once for each row 
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
>	TokenNameGREATER	
set	TokenNameIdentifier	 set
=	TokenNameEQUAL	
Collections	TokenNameIdentifier	 Collections
.	TokenNameDOT	
newSetFromMap	TokenNameIdentifier	 new Set From Map
(	TokenNameLPAREN	
new	TokenNamenew	
IdentityHashMap	TokenNameIdentifier	 Identity Hash Map
<	TokenNameLESS	
Object	TokenNameIdentifier	 Object
,	TokenNameCOMMA	
Boolean	TokenNameIdentifier	 Boolean
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
set	TokenNameIdentifier	 set
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
Memtable	TokenNameIdentifier	 Memtable
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
set	TokenNameIdentifier	 set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
meter	TokenNameIdentifier	 meter
=	TokenNameEQUAL	
new	TokenNamenew	
MemoryMeter	TokenNameIdentifier	 Memory Meter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
omitSharedBufferOverhead	TokenNameIdentifier	 omit Shared Buffer Overhead
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
withTrackerProvider	TokenNameIdentifier	 with Tracker Provider
(	TokenNameLPAREN	
provider	TokenNameIdentifier	 provider
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getLiveSize	TokenNameIdentifier	 get Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
currentSize	TokenNameIdentifier	 current Size
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getSerializedSize	TokenNameIdentifier	 get Serialized Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentSize	TokenNameIdentifier	 current Size
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getOperations	TokenNameIdentifier	 get Operations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentOperations	TokenNameIdentifier	 current Operations
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Should only be called by ColumnFamilyStore.apply. NOT a public API. * (CFS handles locking to avoid submitting an op * to a flushing memtable. Any other way is unsafe.) */	TokenNameCOMMENT_JAVADOC	 Should only be called by ColumnFamilyStore.apply. NOT a public API. (CFS handles locking to avoid submitting an op to a flushing memtable. Any other way is unsafe.) 
void	TokenNamevoid	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
columnFamily	TokenNameIdentifier	 column Family
,	TokenNameCOMMA	
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
updateLiveRatio	TokenNameIdentifier	 update Live Ratio
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
RuntimeException	TokenNameIdentifier	 Runtime Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
MemoryMeter	TokenNameIdentifier	 Memory Meter
.	TokenNameDOT	
isInitialized	TokenNameIdentifier	 is Initialized
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// hack for openjdk. we log a warning about this in the startup script too. 	TokenNameCOMMENT_LINE	hack for openjdk. we log a warning about this in the startup script too. 
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"MemoryMeter uninitialized (jamm not specified as java agent); assuming liveRatio of 10.0. Usually this means cassandra-env.sh disabled jamm because you are using a buggy JRE; upgrade to the Sun JRE instead"	TokenNameStringLiteral	MemoryMeter uninitialized (jamm not specified as java agent); assuming liveRatio of 10.0. Usually this means cassandra-env.sh disabled jamm because you are using a buggy JRE; upgrade to the Sun JRE instead
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
=	TokenNameEQUAL	
10.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
meteringInProgress	TokenNameIdentifier	 metering In Progress
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Metering already pending or active for {}; skipping liveRatio update"	TokenNameStringLiteral	Metering already pending or active for {}; skipping liveRatio update
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Runnable	TokenNameIdentifier	 Runnable
runnable	TokenNameIdentifier	 runnable
=	TokenNameEQUAL	
new	TokenNamenew	
Runnable	TokenNameIdentifier	 Runnable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
run	TokenNameIdentifier	 run
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
activelyMeasuring	TokenNameIdentifier	 actively Measuring
=	TokenNameEQUAL	
Memtable	TokenNameIdentifier	 Memtable
.	TokenNameDOT	
this	TokenNamethis	
;	TokenNameSEMICOLON	
long	TokenNamelong	
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits. 	TokenNameCOMMENT_LINE	ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits. 
// So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time. 	TokenNameCOMMENT_LINE	So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time. 
long	TokenNamelong	
deepSize	TokenNameIdentifier	 deep Size
=	TokenNameEQUAL	
meter	TokenNameIdentifier	 meter
.	TokenNameDOT	
measure	TokenNameIdentifier	 measure
(	TokenNameLPAREN	
columnFamilies	TokenNameIdentifier	 column Families
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
objects	TokenNameIdentifier	 objects
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
deepSize	TokenNameIdentifier	 deep Size
+=	TokenNamePLUS_EQUAL	
meter	TokenNameIdentifier	 meter
.	TokenNameDOT	
measureDeep	TokenNameIdentifier	 measure Deep
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
meter	TokenNameIdentifier	 meter
.	TokenNameDOT	
measureDeep	TokenNameIdentifier	 measure Deep
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
objects	TokenNameIdentifier	 objects
+=	TokenNamePLUS_EQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnCount	TokenNameIdentifier	 get Column Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
double	TokenNamedouble	
newRatio	TokenNameIdentifier	 new Ratio
=	TokenNameEQUAL	
(	TokenNameLPAREN	
double	TokenNamedouble	
)	TokenNameRPAREN	
deepSize	TokenNameIdentifier	 deep Size
/	TokenNameDIVIDE	
currentSize	TokenNameIdentifier	 current Size
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
newRatio	TokenNameIdentifier	 new Ratio
<	TokenNameLESS	
MIN_SANE_LIVE_RATIO	TokenNameIdentifier	 MIN  SANE  LIVE  RATIO
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"setting live ratio to minimum of {} instead of {}"	TokenNameStringLiteral	setting live ratio to minimum of {} instead of {}
,	TokenNameCOMMA	
MIN_SANE_LIVE_RATIO	TokenNameIdentifier	 MIN  SANE  LIVE  RATIO
,	TokenNameCOMMA	
newRatio	TokenNameIdentifier	 new Ratio
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newRatio	TokenNameIdentifier	 new Ratio
=	TokenNameEQUAL	
MIN_SANE_LIVE_RATIO	TokenNameIdentifier	 MIN  SANE  LIVE  RATIO
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
newRatio	TokenNameIdentifier	 new Ratio
>	TokenNameGREATER	
MAX_SANE_LIVE_RATIO	TokenNameIdentifier	 MAX  SANE  LIVE  RATIO
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
warn	TokenNameIdentifier	 warn
(	TokenNameLPAREN	
"setting live ratio to maximum of {} instead of {}"	TokenNameStringLiteral	setting live ratio to maximum of {} instead of {}
,	TokenNameCOMMA	
MAX_SANE_LIVE_RATIO	TokenNameIdentifier	 MAX  SANE  LIVE  RATIO
,	TokenNameCOMMA	
newRatio	TokenNameIdentifier	 new Ratio
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
newRatio	TokenNameIdentifier	 new Ratio
=	TokenNameEQUAL	
MAX_SANE_LIVE_RATIO	TokenNameIdentifier	 MAX  SANE  LIVE  RATIO
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// we want to be very conservative about our estimate, since the penalty for guessing low is OOM 	TokenNameCOMMENT_LINE	we want to be very conservative about our estimate, since the penalty for guessing low is OOM 
// death. thus, higher estimates are believed immediately; lower ones are averaged w/ the old 	TokenNameCOMMENT_LINE	death. thus, higher estimates are believed immediately; lower ones are averaged w/ the old 
if	TokenNameif	
(	TokenNameLPAREN	
newRatio	TokenNameIdentifier	 new Ratio
>	TokenNameGREATER	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
)	TokenNameRPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
=	TokenNameEQUAL	
newRatio	TokenNameIdentifier	 new Ratio
;	TokenNameSEMICOLON	
else	TokenNameelse	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
=	TokenNameEQUAL	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
+	TokenNamePLUS	
newRatio	TokenNameIdentifier	 new Ratio
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
2.0	TokenNameDoubleLiteral	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"{} liveRatio is {} (just-counted was {}). calculation took {}ms for {} columns"	TokenNameStringLiteral	{} liveRatio is {} (just-counted was {}). calculation took {}ms for {} columns
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
cfs	TokenNameIdentifier	 cfs
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
liveRatio	TokenNameIdentifier	 live Ratio
,	TokenNameCOMMA	
newRatio	TokenNameIdentifier	 new Ratio
,	TokenNameCOMMA	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
objects	TokenNameIdentifier	 objects
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activelyMeasuring	TokenNameIdentifier	 actively Measuring
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
finally	TokenNamefinally	
{	TokenNameLBRACE	
meteringInProgress	TokenNameIdentifier	 metering In Progress
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
meterExecutor	TokenNameIdentifier	 meter Executor
.	TokenNameDOT	
submit	TokenNameIdentifier	 submit
(	TokenNameLPAREN	
runnable	TokenNameIdentifier	 runnable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
.	TokenNameDOT	
Updater	TokenNameIdentifier	 Updater
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// AtomicSortedColumns doesn't work for super columns (see #3821) 	TokenNameCOMMENT_LINE	AtomicSortedColumns doesn't work for super columns (see #3821) 
ColumnFamily	TokenNameIdentifier	 Column Family
empty	TokenNameIdentifier	 empty
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
cloneMeShallow	TokenNameIdentifier	 clone Me Shallow
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ThreadSafeSortedColumns	TokenNameIdentifier	 Thread Safe Sorted Columns
.	TokenNameDOT	
factory	TokenNameIdentifier	 factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
AtomicSortedColumns	TokenNameIdentifier	 Atomic Sorted Columns
.	TokenNameDOT	
factory	TokenNameIdentifier	 factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We'll add the columns later. This avoids wasting works if we get beaten in the putIfAbsent 	TokenNameCOMMENT_LINE	We'll add the columns later. This avoids wasting works if we get beaten in the putIfAbsent 
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
putIfAbsent	TokenNameIdentifier	 put If Absent
(	TokenNameLPAREN	
new	TokenNamenew	
DecoratedKey	TokenNameIdentifier	 Decorated Key
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
token	TokenNameIdentifier	 token
,	TokenNameCOMMA	
allocator	TokenNameIdentifier	 allocator
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
empty	TokenNameIdentifier	 empty
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
empty	TokenNameIdentifier	 empty
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
long	TokenNamelong	
sizeDelta	TokenNameIdentifier	 size Delta
=	TokenNameEQUAL	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
addAllWithSizeDelta	TokenNameIdentifier	 add All With Size Delta
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
allocator	TokenNameIdentifier	 allocator
,	TokenNameCOMMA	
localCopyFunction	TokenNameIdentifier	 local Copy Function
,	TokenNameCOMMA	
indexer	TokenNameIdentifier	 indexer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentSize	TokenNameIdentifier	 current Size
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
sizeDelta	TokenNameIdentifier	 size Delta
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currentOperations	TokenNameIdentifier	 current Operations
.	TokenNameDOT	
addAndGet	TokenNameIdentifier	 add And Get
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumnCount	TokenNameIdentifier	 get Column Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumnCount	TokenNameIdentifier	 get Column Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// for debugging 	TokenNameCOMMENT_LINE	for debugging 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
contents	TokenNameIdentifier	 contents
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuilder	TokenNameIdentifier	 String Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuilder	TokenNameIdentifier	 String Builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
": "	TokenNameStringLiteral	: 
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
"}"	TokenNameStringLiteral	}
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
flushAndSignal	TokenNameIdentifier	 flush And Signal
(	TokenNameLPAREN	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
,	TokenNameCOMMA	
ExecutorService	TokenNameIdentifier	 Executor Service
writer	TokenNameIdentifier	 writer
,	TokenNameCOMMA	
final	TokenNamefinal	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
execute	TokenNameIdentifier	 execute
(	TokenNameLPAREN	
new	TokenNamenew	
FlushRunnable	TokenNameIdentifier	 Flush Runnable
(	TokenNameLPAREN	
latch	TokenNameIdentifier	 latch
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Memtable-%s@%s(%s/%s serialized/live bytes, %s ops)"	TokenNameStringLiteral	Memtable-%s@%s(%s/%s serialized/live bytes, %s ops)
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
currentSize	TokenNameIdentifier	 current Size
,	TokenNameCOMMA	
getLiveSize	TokenNameIdentifier	 get Live Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
currentOperations	TokenNameIdentifier	 current Operations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param startWith Include data in the result from and including this key and to the end of the memtable * @return An iterator of entries with the data from the start key */	TokenNameCOMMENT_JAVADOC	 @param startWith Include data in the result from and including this key and to the end of the memtable @return An iterator of entries with the data from the start key 
public	TokenNamepublic	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>>	TokenNameRIGHT_SHIFT	
getEntryIterator	TokenNameIdentifier	 get Entry Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
RowPosition	TokenNameIdentifier	 Row Position
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
final	TokenNamefinal	
RowPosition	TokenNameIdentifier	 Row Position
stopAt	TokenNameIdentifier	 stop At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>>	TokenNameRIGHT_SHIFT	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
stopAt	TokenNameIdentifier	 stop At
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
tailMap	TokenNameIdentifier	 tail Map
(	TokenNameLPAREN	
startWith	TokenNameIdentifier	 start With
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
subMap	TokenNameIdentifier	 sub Map
(	TokenNameLPAREN	
startWith	TokenNameIdentifier	 start With
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
stopAt	TokenNameIdentifier	 stop At
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Actual stored key should be true DecoratedKey 	TokenNameCOMMENT_LINE	Actual stored key should be true DecoratedKey 
assert	TokenNameassert	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
DecoratedKey	TokenNameIdentifier	 Decorated Key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
;	TokenNameSEMICOLON	
// yes, it's ugly 	TokenNameCOMMENT_LINE	yes, it's ugly 
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isClean	TokenNameIdentifier	 is Clean
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * obtain an iterator of columns in this memtable in the specified order starting from a given column. */	TokenNameCOMMENT_JAVADOC	 obtain an iterator of columns in this memtable in the specified order starting from a given column. 
public	TokenNamepublic	
static	TokenNamestatic	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
getSliceIterator	TokenNameIdentifier	 get Slice Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
final	TokenNamefinal	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
cf	TokenNameIdentifier	 cf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
filteredIter	TokenNameIdentifier	 filtered Iter
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
reversed	TokenNameIdentifier	 reversed
?	TokenNameQUESTION	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
reverseIterator	TokenNameIdentifier	 reverse Iterator
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
slices	TokenNameIdentifier	 slices
)	TokenNameRPAREN	
:	TokenNameCOLON	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
slices	TokenNameIdentifier	 slices
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
AbstractColumnIterator	TokenNameIdentifier	 Abstract Column Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cf	TokenNameIdentifier	 cf
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
filteredIter	TokenNameIdentifier	 filtered Iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
filteredIter	TokenNameIdentifier	 filtered Iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
getNamesIterator	TokenNameIdentifier	 get Names Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
final	TokenNamefinal	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
final	TokenNamefinal	
NamesQueryFilter	TokenNameIdentifier	 Names Query Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
cf	TokenNameIdentifier	 cf
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
boolean	TokenNameboolean	
isStandard	TokenNameIdentifier	 is Standard
=	TokenNameEQUAL	
!	TokenNameNOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isSuper	TokenNameIdentifier	 is Super
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SimpleAbstractColumnIterator	TokenNameIdentifier	 Simple Abstract Column Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
private	TokenNameprivate	
Iterator	TokenNameIdentifier	 Iterator
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
iter	TokenNameIdentifier	 iter
=	TokenNameEQUAL	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
cf	TokenNameIdentifier	 cf
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
current	TokenNameIdentifier	 current
=	TokenNameEQUAL	
iter	TokenNameIdentifier	 iter
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IColumn	TokenNameIdentifier	 I Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
getColumn	TokenNameIdentifier	 get Column
(	TokenNameLPAREN	
current	TokenNameIdentifier	 current
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
// clone supercolumns so caller can freely removeDeleted or otherwise mutate it 	TokenNameCOMMENT_LINE	clone supercolumns so caller can freely removeDeleted or otherwise mutate it 
return	TokenNamereturn	
isStandard	TokenNameIdentifier	 is Standard
?	TokenNameQUESTION	
column	TokenNameIdentifier	 column
:	TokenNameCOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SuperColumn	TokenNameIdentifier	 Super Column
)	TokenNameRPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
.	TokenNameDOT	
cloneMe	TokenNameIdentifier	 clone Me
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
clearUnsafe	TokenNameIdentifier	 clear Unsafe
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
creationTime	TokenNameIdentifier	 creation Time
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
creationTime	TokenNameIdentifier	 creation Time
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
class	TokenNameclass	
FlushRunnable	TokenNameIdentifier	 Flush Runnable
extends	TokenNameextends	
DiskAwareRunnable	TokenNameIdentifier	 Disk Aware Runnable
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
context	TokenNameIdentifier	 context
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
estimatedSize	TokenNameIdentifier	 estimated Size
;	TokenNameSEMICOLON	
FlushRunnable	TokenNameIdentifier	 Flush Runnable
(	TokenNameLPAREN	
CountDownLatch	TokenNameIdentifier	 Count Down Latch
latch	TokenNameIdentifier	 latch
,	TokenNameCOMMA	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
context	TokenNameIdentifier	 context
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
latch	TokenNameIdentifier	 latch
=	TokenNameEQUAL	
latch	TokenNameIdentifier	 latch
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
context	TokenNameIdentifier	 context
=	TokenNameEQUAL	
context	TokenNameIdentifier	 context
;	TokenNameSEMICOLON	
long	TokenNamelong	
keySize	TokenNameIdentifier	 key Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
RowPosition	TokenNameIdentifier	 Row Position
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
keySet	TokenNameIdentifier	 key Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// make sure we don't write non-sensical keys 	TokenNameCOMMENT_LINE	make sure we don't write non-sensical keys 
assert	TokenNameassert	
key	TokenNameIdentifier	 key
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
keySize	TokenNameIdentifier	 key Size
+=	TokenNamePLUS_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
estimatedSize	TokenNameIdentifier	 estimated Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
keySize	TokenNameIdentifier	 key Size
// index entries 	TokenNameCOMMENT_LINE	index entries 
+	TokenNamePLUS	
keySize	TokenNameIdentifier	 key Size
// keys in data file 	TokenNameCOMMENT_LINE	keys in data file 
+	TokenNamePLUS	
currentSize	TokenNameIdentifier	 current Size
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// data 	TokenNameCOMMENT_LINE	data 
*	TokenNameMULTIPLY	
1.2	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// bloom filter and row index overhead 	TokenNameCOMMENT_LINE	bloom filter and row index overhead 
}	TokenNameRBRACE	
public	TokenNamepublic	
long	TokenNamelong	
getExpectedWriteSize	TokenNameIdentifier	 get Expected Write Size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
estimatedSize	TokenNameIdentifier	 estimated Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
runWith	TokenNameIdentifier	 run With
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
Exception	TokenNameIdentifier	 Exception
{	TokenNameLBRACE	
assert	TokenNameassert	
dataDirectory	TokenNameIdentifier	 data Directory
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
:	TokenNameCOLON	
"Flush task is not bound to any disk"	TokenNameStringLiteral	Flush task is not bound to any disk
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
writeSortedContents	TokenNameIdentifier	 write Sorted Contents
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
replaceFlushed	TokenNameIdentifier	 replace Flushed
(	TokenNameLPAREN	
Memtable	TokenNameIdentifier	 Memtable
.	TokenNameDOT	
this	TokenNamethis	
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
latch	TokenNameIdentifier	 latch
.	TokenNameDOT	
countDown	TokenNameIdentifier	 count Down
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
SSTableReader	TokenNameIdentifier	 SS Table Reader
writeSortedContents	TokenNameIdentifier	 write Sorted Contents
(	TokenNameLPAREN	
Future	TokenNameIdentifier	 Future
<	TokenNameLESS	
ReplayPosition	TokenNameIdentifier	 Replay Position
>	TokenNameGREATER	
context	TokenNameIdentifier	 context
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Writing "	TokenNameStringLiteral	Writing 
+	TokenNamePLUS	
Memtable	TokenNameIdentifier	 Memtable
.	TokenNameDOT	
this	TokenNamethis	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
ssTable	TokenNameIdentifier	 ss Table
;	TokenNameSEMICOLON	
// errors when creating the writer that may leave empty temp files. 	TokenNameCOMMENT_LINE	errors when creating the writer that may leave empty temp files. 
SSTableWriter	TokenNameIdentifier	 SS Table Writer
writer	TokenNameIdentifier	 writer
=	TokenNameEQUAL	
createFlushWriter	TokenNameIdentifier	 create Flush Writer
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
getTempSSTablePath	TokenNameIdentifier	 get Temp SS Table Path
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
getLocationForDisk	TokenNameIdentifier	 get Location For Disk
(	TokenNameLPAREN	
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
// (we can't clear out the map as-we-go to free up memory, 	TokenNameCOMMENT_LINE	(we can't clear out the map as-we-go to free up memory, 
// since the memtable is being used for queries in the "pending flush" category) 	TokenNameCOMMENT_LINE	since the memtable is being used for queries in the "pending flush" category) 
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColumnFamily	TokenNameIdentifier	 Column Family
cf	TokenNameIdentifier	 cf
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// When every node is up, there's no reason to write batchlog data out to sstables 	TokenNameCOMMENT_LINE	When every node is up, there's no reason to write batchlog data out to sstables 
// (which in turn incurs cost like compaction) since the BL write + delete cancel each other out, 	TokenNameCOMMENT_LINE	(which in turn incurs cost like compaction) since the BL write + delete cancel each other out, 
// and BL data is strictly local, so we don't need to preserve tombstones for repair. 	TokenNameCOMMENT_LINE	and BL data is strictly local, so we don't need to preserve tombstones for repair. 
// If we have a data row + row level tombstone, then writing it is effectively an expensive no-op so we skip it. 	TokenNameCOMMENT_LINE	If we have a data row + row level tombstone, then writing it is effectively an expensive no-op so we skip it. 
// See CASSANDRA-4667. 	TokenNameCOMMENT_LINE	See CASSANDRA-4667. 
if	TokenNameif	
(	TokenNameLPAREN	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
BATCHLOG_CF	TokenNameIdentifier	 BATCHLOG  CF
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
table	TokenNameIdentifier	 table
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
cf	TokenNameIdentifier	 cf
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// Pedantically, you could purge column level tombstones that are past GcGRace when writing to the SSTable. 	TokenNameCOMMENT_LINE	Pedantically, you could purge column level tombstones that are past GcGRace when writing to the SSTable. 
// But it can result in unexpected behaviour where deletes never make it to disk, 	TokenNameCOMMENT_LINE	But it can result in unexpected behaviour where deletes never make it to disk, 
// as they are lost and so cannot override existing column values. So we only remove deleted columns if there 	TokenNameCOMMENT_LINE	as they are lost and so cannot override existing column values. So we only remove deleted columns if there 
// is a CF level tombstone to ensure the delete makes it into an SSTable. 	TokenNameCOMMENT_LINE	is a CF level tombstone to ensure the delete makes it into an SSTable. 
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
removeDeletedColumnsOnly	TokenNameIdentifier	 remove Deleted Columns Only
(	TokenNameLPAREN	
cf	TokenNameIdentifier	 cf
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MIN_VALUE	TokenNameIdentifier	 MIN  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cf	TokenNameIdentifier	 cf
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ssTable	TokenNameIdentifier	 ss Table
=	TokenNameEQUAL	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
closeAndOpenReader	TokenNameIdentifier	 close And Open Reader
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Completed flushing %s (%d bytes) for commitlog position %s"	TokenNameStringLiteral	Completed flushing %s (%d bytes) for commitlog position %s
,	TokenNameCOMMA	
ssTable	TokenNameIdentifier	 ss Table
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
ssTable	TokenNameIdentifier	 ss Table
.	TokenNameDOT	
getFilename	TokenNameIdentifier	 get Filename
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ssTable	TokenNameIdentifier	 ss Table
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Completed flushing; nothing needed to be retained. Commitlog position was {}"	TokenNameStringLiteral	Completed flushing; nothing needed to be retained. Commitlog position was {}
,	TokenNameCOMMA	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ssTable	TokenNameIdentifier	 ss Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Throwable	TokenNameIdentifier	 Throwable
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
writer	TokenNameIdentifier	 writer
.	TokenNameDOT	
abort	TokenNameIdentifier	 abort
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
Throwables	TokenNameIdentifier	 Throwables
.	TokenNameDOT	
propagate	TokenNameIdentifier	 propagate
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
createFlushWriter	TokenNameIdentifier	 create Flush Writer
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
filename	TokenNameIdentifier	 filename
)	TokenNameRPAREN	
throws	TokenNamethrows	
ExecutionException	TokenNameIdentifier	 Execution Exception
,	TokenNameCOMMA	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
{	TokenNameLBRACE	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
Collector	TokenNameIdentifier	 Collector
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
=	TokenNameEQUAL	
SSTableMetadata	TokenNameIdentifier	 SS Table Metadata
.	TokenNameDOT	
createCollector	TokenNameIdentifier	 create Collector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
replayPosition	TokenNameIdentifier	 replay Position
(	TokenNameLPAREN	
context	TokenNameIdentifier	 context
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
SSTableWriter	TokenNameIdentifier	 SS Table Writer
(	TokenNameLPAREN	
filename	TokenNameIdentifier	 filename
,	TokenNameCOMMA	
columnFamilies	TokenNameIdentifier	 column Families
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
,	TokenNameCOMMA	
cfs	TokenNameIdentifier	 cfs
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
,	TokenNameCOMMA	
sstableMetadataCollector	TokenNameIdentifier	 sstable Metadata Collector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
