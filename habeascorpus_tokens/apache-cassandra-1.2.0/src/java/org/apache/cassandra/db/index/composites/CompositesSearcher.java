/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
composites	TokenNameIdentifier	 composites
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
AbstractSimplePerColumnSecondaryIndex	TokenNameIdentifier	 Abstract Simple Per Column Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
PerColumnSecondaryIndex	TokenNameIdentifier	 Per Column Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
SecondaryIndexSearcher	TokenNameIdentifier	 Secondary Index Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
CompositeType	TokenNameIdentifier	 Composite Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
dht	TokenNameIdentifier	 dht
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
IndexExpression	TokenNameIdentifier	 Index Expression
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
thrift	TokenNameIdentifier	 thrift
.	TokenNameDOT	
IndexOperator	TokenNameIdentifier	 Index Operator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
public	TokenNamepublic	
class	TokenNameclass	
CompositesSearcher	TokenNameIdentifier	 Composites Searcher
extends	TokenNameextends	
SecondaryIndexSearcher	TokenNameIdentifier	 Secondary Index Searcher
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
CompositesSearcher	TokenNameIdentifier	 Composites Searcher
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
prefixSize	TokenNameIdentifier	 prefix Size
;	TokenNameSEMICOLON	
public	TokenNamepublic	
CompositesSearcher	TokenNameIdentifier	 Composites Searcher
(	TokenNameLPAREN	
SecondaryIndexManager	TokenNameIdentifier	 Secondary Index Manager
indexManager	TokenNameIdentifier	 index Manager
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
>	TokenNameGREATER	
columns	TokenNameIdentifier	 columns
,	TokenNameCOMMA	
int	TokenNameint	
prefixSize	TokenNameIdentifier	 prefix Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
indexManager	TokenNameIdentifier	 index Manager
,	TokenNameCOMMA	
columns	TokenNameIdentifier	 columns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
prefixSize	TokenNameIdentifier	 prefix Size
=	TokenNameEQUAL	
prefixSize	TokenNameIdentifier	 prefix Size
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
IndexExpression	TokenNameIdentifier	 Index Expression
highestSelectivityPredicate	TokenNameIdentifier	 highest Selectivity Predicate
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
clause	TokenNameIdentifier	 clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IndexExpression	TokenNameIdentifier	 Index Expression
best	TokenNameIdentifier	 best
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
bestMeanCount	TokenNameIdentifier	 best Mean Count
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
IndexExpression	TokenNameIdentifier	 Index Expression
expression	TokenNameIdentifier	 expression
:	TokenNameCOLON	
clause	TokenNameIdentifier	 clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//skip columns belonging to a different index type 	TokenNameCOMMENT_LINE	skip columns belonging to a different index type 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
expression	TokenNameIdentifier	 expression
.	TokenNameDOT	
column_name	TokenNameIdentifier	 column name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexForColumn	TokenNameIdentifier	 get Index For Column
(	TokenNameLPAREN	
expression	TokenNameIdentifier	 expression
.	TokenNameDOT	
column_name	TokenNameIdentifier	 column name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
expression	TokenNameIdentifier	 expression
.	TokenNameDOT	
op	TokenNameIdentifier	 op
!=	TokenNameNOT_EQUAL	
IndexOperator	TokenNameIdentifier	 Index Operator
.	TokenNameDOT	
EQ	TokenNameIdentifier	 EQ
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
int	TokenNameint	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexCfs	TokenNameIdentifier	 get Index Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getMeanColumns	TokenNameIdentifier	 get Mean Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
columns	TokenNameIdentifier	 columns
<	TokenNameLESS	
bestMeanCount	TokenNameIdentifier	 best Mean Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
best	TokenNameIdentifier	 best
=	TokenNameEQUAL	
expression	TokenNameIdentifier	 expression
;	TokenNameSEMICOLON	
bestMeanCount	TokenNameIdentifier	 best Mean Count
=	TokenNameEQUAL	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
best	TokenNameIdentifier	 best
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isIndexing	TokenNameIdentifier	 is Indexing
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
clause	TokenNameIdentifier	 clause
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
highestSelectivityPredicate	TokenNameIdentifier	 highest Selectivity Predicate
(	TokenNameLPAREN	
clause	TokenNameIdentifier	 clause
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
Row	TokenNameIdentifier	 Row
>	TokenNameGREATER	
search	TokenNameIdentifier	 search
(	TokenNameLPAREN	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexExpression	TokenNameIdentifier	 Index Expression
>	TokenNameGREATER	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
int	TokenNameint	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
IDiskAtomFilter	TokenNameIdentifier	 I Disk Atom Filter
dataFilter	TokenNameIdentifier	 data Filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
)	TokenNameRPAREN	
{	TokenNameLBRACE	
assert	TokenNameassert	
clause	TokenNameIdentifier	 clause
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
clause	TokenNameIdentifier	 clause
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
filter	TokenNameIdentifier	 filter
=	TokenNameEQUAL	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
baseCfs	TokenNameIdentifier	 base Cfs
,	TokenNameCOMMA	
dataFilter	TokenNameIdentifier	 data Filter
,	TokenNameCOMMA	
clause	TokenNameIdentifier	 clause
,	TokenNameCOMMA	
maxResults	TokenNameIdentifier	 max Results
,	TokenNameCOMMA	
countCQL3Rows	TokenNameIdentifier	 count CQ L3 Rows
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
getIndexedIterator	TokenNameIdentifier	 get Indexed Iterator
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
getIndexedIterator	TokenNameIdentifier	 get Indexed Iterator
(	TokenNameLPAREN	
final	TokenNamefinal	
AbstractBounds	TokenNameIdentifier	 Abstract Bounds
<	TokenNameLESS	
RowPosition	TokenNameIdentifier	 Row Position
>	TokenNameGREATER	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
final	TokenNamefinal	
ExtendedFilter	TokenNameIdentifier	 Extended Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Start with the most-restrictive indexed clause, then apply remaining clauses 	TokenNameCOMMENT_LINE	Start with the most-restrictive indexed clause, then apply remaining clauses 
// to each row matching that clause. 	TokenNameCOMMENT_LINE	to each row matching that clause. 
// TODO: allow merge join instead of just one index + loop 	TokenNameCOMMENT_LINE	TODO: allow merge join instead of just one index + loop 
final	TokenNamefinal	
IndexExpression	TokenNameIdentifier	 Index Expression
primary	TokenNameIdentifier	 primary
=	TokenNameEQUAL	
highestSelectivityPredicate	TokenNameIdentifier	 highest Selectivity Predicate
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
getClause	TokenNameIdentifier	 get Clause
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
SecondaryIndex	TokenNameIdentifier	 Secondary Index
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
indexManager	TokenNameIdentifier	 index Manager
.	TokenNameDOT	
getIndexForColumn	TokenNameIdentifier	 get Index For Column
(	TokenNameLPAREN	
primary	TokenNameIdentifier	 primary
.	TokenNameDOT	
column_name	TokenNameIdentifier	 column name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
assert	TokenNameassert	
index	TokenNameIdentifier	 index
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
DecoratedKey	TokenNameIdentifier	 Decorated Key
indexKey	TokenNameIdentifier	 index Key
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexKeyFor	TokenNameIdentifier	 get Index Key For
(	TokenNameLPAREN	
primary	TokenNameIdentifier	 primary
.	TokenNameDOT	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Most-selective indexed predicate is {}"	TokenNameStringLiteral	Most-selective indexed predicate is {}
,	TokenNameCOMMA	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
AbstractSimplePerColumnSecondaryIndex	TokenNameIdentifier	 Abstract Simple Per Column Secondary Index
)	TokenNameRPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
.	TokenNameDOT	
expressionString	TokenNameIdentifier	 expression String
(	TokenNameLPAREN	
primary	TokenNameIdentifier	 primary
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of * the indexed row unfortunately (which will be inefficient), because we have not way to intuit the small * possible key having a given token. A fix would be to actually store the token along the key in the * indexed row. */	TokenNameCOMMENT_BLOCK	 XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of the indexed row unfortunately (which will be inefficient), because we have not way to intuit the small possible key having a given token. A fix would be to actually store the token along the key in the indexed row. 
ByteBuffer	TokenNameIdentifier	 Byte Buffer
startKey	TokenNameIdentifier	 start Key
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
endKey	TokenNameIdentifier	 end Key
=	TokenNameEQUAL	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
instanceof	TokenNameinstanceof	
DecoratedKey	TokenNameIdentifier	 Decorated Key
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
)	TokenNameRPAREN	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
.	TokenNameDOT	
key	TokenNameIdentifier	 key
:	TokenNameCOLON	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CompositeType	TokenNameIdentifier	 Composite Type
baseComparator	TokenNameIdentifier	 base Comparator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
getComparator	TokenNameIdentifier	 get Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CompositeType	TokenNameIdentifier	 Composite Type
indexComparator	TokenNameIdentifier	 index Comparator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
CompositeType	TokenNameIdentifier	 Composite Type
)	TokenNameRPAREN	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexCfs	TokenNameIdentifier	 get Index Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getComparator	TokenNameIdentifier	 get Comparator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CompositeType	TokenNameIdentifier	 Composite Type
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
builder	TokenNameIdentifier	 builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
startKey	TokenNameIdentifier	 start Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// For names filter, we have no choice but to query from the beginning of the key. This can be highly inefficient however. 	TokenNameCOMMENT_LINE	For names filter, we have no choice but to query from the beginning of the key. This can be highly inefficient however. 
if	TokenNameif	
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
baseComparator	TokenNameIdentifier	 base Comparator
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
start	TokenNameIdentifier	 start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
prefixSize	TokenNameIdentifier	 prefix Size
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
startPrefix	TokenNameIdentifier	 start Prefix
=	TokenNameEQUAL	
startKey	TokenNameIdentifier	 start Key
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
endKey	TokenNameIdentifier	 end Key
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
builder	TokenNameIdentifier	 builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
endKey	TokenNameIdentifier	 end Key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// For names filter, we have no choice but to query until the end of the key. This can be highly inefficient however. 	TokenNameCOMMENT_LINE	For names filter, we have no choice but to query until the end of the key. This can be highly inefficient however. 
if	TokenNameif	
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
baseComparator	TokenNameIdentifier	 base Comparator
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
prefixSize	TokenNameIdentifier	 prefix Size
,	TokenNameCOMMA	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
final	TokenNamefinal	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
endPrefix	TokenNameIdentifier	 end Prefix
=	TokenNameEQUAL	
endKey	TokenNameIdentifier	 end Key
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
EMPTY_BYTE_BUFFER	TokenNameIdentifier	 EMPTY  BYTE  BUFFER
:	TokenNameCOLON	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
buildAsEndOfRange	TokenNameIdentifier	 build As End Of Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We will need to filter clustering keys based on the user filter. If 	TokenNameCOMMENT_LINE	We will need to filter clustering keys based on the user filter. If 
// it is a names filter, we are really interested on the clustering 	TokenNameCOMMENT_LINE	it is a names filter, we are really interested on the clustering 
// part, not the actual column name (NOTE: this is a hack that assumes CQL3). 	TokenNameCOMMENT_LINE	part, not the actual column name (NOTE: this is a hack that assumes CQL3). 
final	TokenNamefinal	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
originalFilter	TokenNameIdentifier	 original Filter
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
instanceof	TokenNameinstanceof	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
originalFilter	TokenNameIdentifier	 original Filter
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
NamesQueryFilter	TokenNameIdentifier	 Names Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
originalFilter	TokenNameIdentifier	 original Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
columns	TokenNameIdentifier	 columns
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
baseComparator	TokenNameIdentifier	 base Comparator
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
baseComparator	TokenNameIdentifier	 base Comparator
.	TokenNameDOT	
builder	TokenNameIdentifier	 builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// All all except the last component, since it's the column name 	TokenNameCOMMENT_LINE	All all except the last component, since it's the column name 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
originalFilter	TokenNameIdentifier	 original Filter
=	TokenNameEQUAL	
new	TokenNamenew	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
(	TokenNameLPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
buildAsEndOfRange	TokenNameIdentifier	 build As End Of Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ColumnFamilyStore	TokenNameIdentifier	 Column Family Store
.	TokenNameDOT	
AbstractScanIterator	TokenNameIdentifier	 Abstract Scan Iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
private	TokenNameprivate	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
=	TokenNameEQUAL	
startPrefix	TokenNameIdentifier	 start Prefix
;	TokenNameSEMICOLON	
private	TokenNameprivate	
Deque	TokenNameIdentifier	 Deque
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
indexColumns	TokenNameIdentifier	 index Columns
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
QueryPath	TokenNameIdentifier	 Query Path
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
columnFamily	TokenNameIdentifier	 column Family
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
columnsRead	TokenNameIdentifier	 columns Read
=	TokenNameEQUAL	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
meanColumns	TokenNameIdentifier	 mean Columns
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexCfs	TokenNameIdentifier	 get Index Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getMeanColumns	TokenNameIdentifier	 get Mean Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We shouldn't fetch only 1 row as this provides buggy paging in case the first row doesn't satisfy all clauses 	TokenNameCOMMENT_LINE	We shouldn't fetch only 1 row as this provides buggy paging in case the first row doesn't satisfy all clauses 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
rowsPerQuery	TokenNameIdentifier	 rows Per Query
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
min	TokenNameIdentifier	 min
(	TokenNameLPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
maxRows	TokenNameIdentifier	 max Rows
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
maxColumns	TokenNameIdentifier	 max Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
/	TokenNameDIVIDE	
meanColumns	TokenNameIdentifier	 mean Columns
)	TokenNameRPAREN	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
boolean	TokenNameboolean	
needsFiltering	TokenNameIdentifier	 needs Filtering
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Row	TokenNameIdentifier	 Row
makeReturn	TokenNameIdentifier	 make Return
(	TokenNameLPAREN	
DecoratedKey	TokenNameIdentifier	 Decorated Key
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
ColumnFamily	TokenNameIdentifier	 Column Family
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
assert	TokenNameassert	
key	TokenNameIdentifier	 key
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Row	TokenNameIdentifier	 Row
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Row	TokenNameIdentifier	 Row
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/* * Our internal index code is wired toward internal rows. So we need to acumulate all results for a given * row before returning from this method. Which unfortunately means that this method has to do what * CFS.filter does for KeysIndex. */	TokenNameCOMMENT_BLOCK	 Our internal index code is wired toward internal rows. So we need to acumulate all results for a given row before returning from this method. Which unfortunately means that this method has to do what CFS.filter does for KeysIndex. 
DecoratedKey	TokenNameIdentifier	 Decorated Key
currentKey	TokenNameIdentifier	 current Key
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
columnsCount	TokenNameIdentifier	 columns Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
limit	TokenNameIdentifier	 limit
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
)	TokenNameRPAREN	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
initialFilter	TokenNameIdentifier	 initial Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Did we got more columns that needed to respect the user limit? 	TokenNameCOMMENT_LINE	Did we got more columns that needed to respect the user limit? 
// (but we still need to return was fetch already) 	TokenNameCOMMENT_LINE	(but we still need to return was fetch already) 
if	TokenNameif	
(	TokenNameLPAREN	
columnsCount	TokenNameIdentifier	 columns Count
>	TokenNameGREATER	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
return	TokenNamereturn	
makeReturn	TokenNameIdentifier	 make Return
(	TokenNameLPAREN	
currentKey	TokenNameIdentifier	 current Key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexColumns	TokenNameIdentifier	 index Columns
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
columnsRead	TokenNameIdentifier	 columns Read
<	TokenNameLESS	
rowsPerQuery	TokenNameIdentifier	 rows Per Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Read only {} (< {}) last page through, must be done"	TokenNameStringLiteral	Read only {} (< {}) last page through, must be done
,	TokenNameCOMMA	
columnsRead	TokenNameIdentifier	 columns Read
,	TokenNameCOMMA	
rowsPerQuery	TokenNameIdentifier	 rows Per Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
makeReturn	TokenNameIdentifier	 make Return
(	TokenNameLPAREN	
currentKey	TokenNameIdentifier	 current Key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isTraceEnabled	TokenNameIdentifier	 is Trace Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Scanning index {} starting with {}"	TokenNameStringLiteral	Scanning index {} starting with {}
,	TokenNameCOMMA	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
AbstractSimplePerColumnSecondaryIndex	TokenNameIdentifier	 Abstract Simple Per Column Secondary Index
)	TokenNameRPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
.	TokenNameDOT	
expressionString	TokenNameIdentifier	 expression String
(	TokenNameLPAREN	
primary	TokenNameIdentifier	 primary
)	TokenNameRPAREN	
,	TokenNameCOMMA	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
startPrefix	TokenNameIdentifier	 start Prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
QueryFilter	TokenNameIdentifier	 Query Filter
indexFilter	TokenNameIdentifier	 index Filter
=	TokenNameEQUAL	
QueryFilter	TokenNameIdentifier	 Query Filter
.	TokenNameDOT	
getSliceFilter	TokenNameIdentifier	 get Slice Filter
(	TokenNameLPAREN	
indexKey	TokenNameIdentifier	 index Key
,	TokenNameCOMMA	
new	TokenNamenew	
QueryPath	TokenNameIdentifier	 Query Path
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexCfs	TokenNameIdentifier	 get Index Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamilyName	TokenNameIdentifier	 get Column Family Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
,	TokenNameCOMMA	
endPrefix	TokenNameIdentifier	 end Prefix
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
rowsPerQuery	TokenNameIdentifier	 rows Per Query
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
indexRow	TokenNameIdentifier	 index Row
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
getIndexCfs	TokenNameIdentifier	 get Index Cfs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
indexFilter	TokenNameIdentifier	 index Filter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexRow	TokenNameIdentifier	 index Row
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
makeReturn	TokenNameIdentifier	 make Return
(	TokenNameLPAREN	
currentKey	TokenNameIdentifier	 current Key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Collection	TokenNameIdentifier	 Collection
<	TokenNameLESS	
IColumn	TokenNameIdentifier	 I Column
>	TokenNameGREATER	
sortedColumns	TokenNameIdentifier	 sorted Columns
=	TokenNameEQUAL	
indexRow	TokenNameIdentifier	 index Row
.	TokenNameDOT	
getSortedColumns	TokenNameIdentifier	 get Sorted Columns
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnsRead	TokenNameIdentifier	 columns Read
=	TokenNameEQUAL	
sortedColumns	TokenNameIdentifier	 sorted Columns
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
indexColumns	TokenNameIdentifier	 index Columns
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayDeque	TokenNameIdentifier	 Array Deque
(	TokenNameLPAREN	
sortedColumns	TokenNameIdentifier	 sorted Columns
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IColumn	TokenNameIdentifier	 I Column
firstColumn	TokenNameIdentifier	 first Column
=	TokenNameEQUAL	
sortedColumns	TokenNameIdentifier	 sorted Columns
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Paging is racy, so it is possible the first column of a page is not the last seen one. 	TokenNameCOMMENT_LINE	Paging is racy, so it is possible the first column of a page is not the last seen one. 
if	TokenNameif	
(	TokenNameLPAREN	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
!=	TokenNameNOT_EQUAL	
startPrefix	TokenNameIdentifier	 start Prefix
&&	TokenNameAND_AND	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
firstColumn	TokenNameIdentifier	 first Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// skip the row we already saw w/ the last page of results 	TokenNameCOMMENT_LINE	skip the row we already saw w/ the last page of results 
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Skipping {}"	TokenNameStringLiteral	Skipping {}
,	TokenNameCOMMA	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
firstColumn	TokenNameIdentifier	 first Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
instanceof	TokenNameinstanceof	
Range	TokenNameIdentifier	 Range
&&	TokenNameAND_AND	
!	TokenNameNOT	
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
firstColumn	TokenNameIdentifier	 first Column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
startPrefix	TokenNameIdentifier	 start Prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// skip key excluded by range 	TokenNameCOMMENT_LINE	skip key excluded by range 
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Skipping first key as range excludes it"	TokenNameStringLiteral	Skipping first key as range excludes it
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
!	TokenNameNOT	
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
columnsCount	TokenNameIdentifier	 columns Count
<=	TokenNameLESS_EQUAL	
limit	TokenNameIdentifier	 limit
)	TokenNameRPAREN	
{	TokenNameLBRACE	
IColumn	TokenNameIdentifier	 I Column
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
=	TokenNameEQUAL	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
isMarkedForDelete	TokenNameIdentifier	 is Marked For Delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"skipping {}"	TokenNameStringLiteral	skipping {}
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
split	TokenNameIdentifier	 split
(	TokenNameLPAREN	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DecoratedKey	TokenNameIdentifier	 Decorated Key
dk	TokenNameIdentifier	 dk
=	TokenNameEQUAL	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
.	TokenNameDOT	
decorateKey	TokenNameIdentifier	 decorate Key
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Are we done for this row? 	TokenNameCOMMENT_LINE	Are we done for this row? 
if	TokenNameif	
(	TokenNameLPAREN	
currentKey	TokenNameIdentifier	 current Key
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentKey	TokenNameIdentifier	 current Key
=	TokenNameEQUAL	
dk	TokenNameIdentifier	 dk
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
currentKey	TokenNameIdentifier	 current Key
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DecoratedKey	TokenNameIdentifier	 Decorated Key
previousKey	TokenNameIdentifier	 previous Key
=	TokenNameEQUAL	
currentKey	TokenNameIdentifier	 current Key
;	TokenNameSEMICOLON	
currentKey	TokenNameIdentifier	 current Key
=	TokenNameEQUAL	
dk	TokenNameIdentifier	 dk
;	TokenNameSEMICOLON	
// We're done with the previous row, return it if it had data, continue otherwise 	TokenNameCOMMENT_LINE	We're done with the previous row, return it if it had data, continue otherwise 
indexColumns	TokenNameIdentifier	 index Columns
.	TokenNameDOT	
addFirst	TokenNameIdentifier	 add First
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
makeReturn	TokenNameIdentifier	 make Return
(	TokenNameLPAREN	
previousKey	TokenNameIdentifier	 previous Key
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
isMinimum	TokenNameIdentifier	 is Minimum
(	TokenNameLPAREN	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
partitioner	TokenNameIdentifier	 partitioner
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
right	TokenNameIdentifier	 right
.	TokenNameDOT	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Reached end of assigned scan range"	TokenNameStringLiteral	Reached end of assigned scan range
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Skipping entry {} outside of assigned scan range"	TokenNameStringLiteral	Skipping entry {} outside of assigned scan range
,	TokenNameCOMMA	
dk	TokenNameIdentifier	 dk
.	TokenNameDOT	
token	TokenNameIdentifier	 token
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
trace	TokenNameIdentifier	 trace
(	TokenNameLPAREN	
"Adding index hit to current row for {}"	TokenNameStringLiteral	Adding index hit to current row for {}
,	TokenNameCOMMA	
indexComparator	TokenNameIdentifier	 index Comparator
.	TokenNameDOT	
getString	TokenNameIdentifier	 get String
(	TokenNameLPAREN	
lastSeenPrefix	TokenNameIdentifier	 last Seen Prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// For sparse composites, we're good querying the whole logical row 	TokenNameCOMMENT_LINE	For sparse composites, we're good querying the whole logical row 
// Obviously if this index is used for other usage, that might be inefficient 	TokenNameCOMMENT_LINE	Obviously if this index is used for other usage, that might be inefficient 
CompositeType	TokenNameIdentifier	 Composite Type
.	TokenNameDOT	
Builder	TokenNameIdentifier	 Builder
builder	TokenNameIdentifier	 builder
=	TokenNameEQUAL	
baseComparator	TokenNameIdentifier	 base Comparator
.	TokenNameDOT	
builder	TokenNameIdentifier	 builder
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
prefixSize	TokenNameIdentifier	 prefix Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Does this "row" match the user original filter 	TokenNameCOMMENT_LINE	Does this "row" match the user original filter 
ByteBuffer	TokenNameIdentifier	 Byte Buffer
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
originalFilter	TokenNameIdentifier	 original Filter
.	TokenNameDOT	
includes	TokenNameIdentifier	 includes
(	TokenNameLPAREN	
baseComparator	TokenNameIdentifier	 base Comparator
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
dataFilter	TokenNameIdentifier	 data Filter
=	TokenNameEQUAL	
new	TokenNamenew	
SliceQueryFilter	TokenNameIdentifier	 Slice Query Filter
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
buildAsEndOfRange	TokenNameIdentifier	 build As End Of Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
MAX_VALUE	TokenNameIdentifier	 MAX  VALUE
,	TokenNameCOMMA	
prefixSize	TokenNameIdentifier	 prefix Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ColumnFamily	TokenNameIdentifier	 Column Family
newData	TokenNameIdentifier	 new Data
=	TokenNameEQUAL	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
new	TokenNamenew	
QueryFilter	TokenNameIdentifier	 Query Filter
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
,	TokenNameCOMMA	
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
dataFilter	TokenNameIdentifier	 data Filter
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
newData	TokenNameIdentifier	 new Data
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
baseColumnName	TokenNameIdentifier	 base Column Name
=	TokenNameEQUAL	
builder	TokenNameIdentifier	 builder
.	TokenNameDOT	
copy	TokenNameIdentifier	 copy
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
primary	TokenNameIdentifier	 primary
.	TokenNameDOT	
column_name	TokenNameIdentifier	 column name
)	TokenNameRPAREN	
.	TokenNameDOT	
build	TokenNameIdentifier	 build
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
indexedValue	TokenNameIdentifier	 indexed Value
=	TokenNameEQUAL	
indexKey	TokenNameIdentifier	 index Key
.	TokenNameDOT	
key	TokenNameIdentifier	 key
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isIndexValueStale	TokenNameIdentifier	 is Index Value Stale
(	TokenNameLPAREN	
newData	TokenNameIdentifier	 new Data
,	TokenNameCOMMA	
baseColumnName	TokenNameIdentifier	 base Column Name
,	TokenNameCOMMA	
indexedValue	TokenNameIdentifier	 indexed Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// delete the index entry w/ its own timestamp 	TokenNameCOMMENT_LINE	delete the index entry w/ its own timestamp 
IColumn	TokenNameIdentifier	 I Column
dummyColumn	TokenNameIdentifier	 dummy Column
=	TokenNameEQUAL	
new	TokenNamenew	
Column	TokenNameIdentifier	 Column
(	TokenNameLPAREN	
baseColumnName	TokenNameIdentifier	 base Column Name
,	TokenNameCOMMA	
indexedValue	TokenNameIdentifier	 indexed Value
,	TokenNameCOMMA	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
timestamp	TokenNameIdentifier	 timestamp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
PerColumnSecondaryIndex	TokenNameIdentifier	 Per Column Secondary Index
)	TokenNameRPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
dk	TokenNameIdentifier	 dk
.	TokenNameDOT	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
dummyColumn	TokenNameIdentifier	 dummy Column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
isSatisfiedBy	TokenNameIdentifier	 is Satisfied By
(	TokenNameLPAREN	
newData	TokenNameIdentifier	 new Data
,	TokenNameCOMMA	
builder	TokenNameIdentifier	 builder
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
data	TokenNameIdentifier	 data
=	TokenNameEQUAL	
ColumnFamily	TokenNameIdentifier	 Column Family
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
baseCfs	TokenNameIdentifier	 base Cfs
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
resolve	TokenNameIdentifier	 resolve
(	TokenNameLPAREN	
newData	TokenNameIdentifier	 new Data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
columnsCount	TokenNameIdentifier	 columns Count
+=	TokenNamePLUS_EQUAL	
dataFilter	TokenNameIdentifier	 data Filter
.	TokenNameDOT	
lastCounted	TokenNameIdentifier	 last Counted
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
