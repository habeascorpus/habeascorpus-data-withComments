package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
params	TokenNameIdentifier	 params
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
params	TokenNameIdentifier	 params
.	TokenNameDOT	
CategoryListParams	TokenNameIdentifier	 Category List Params
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
CategoryListIterator	TokenNameIdentifier	 Category List Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FacetArrays	TokenNameIdentifier	 Facet Arrays
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FacetResultsHandler	TokenNameIdentifier	 Facet Results Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopKFacetResultsHandler	TokenNameIdentifier	 Top K Facet Results Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TopKInEachNodeHandler	TokenNameIdentifier	 Top K In Each Node Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
aggregator	TokenNameIdentifier	 aggregator
.	TokenNameDOT	
Aggregator	TokenNameIdentifier	 Aggregator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
CategoryListData	TokenNameIdentifier	 Category List Data
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
cache	TokenNameIdentifier	 cache
.	TokenNameDOT	
CategoryListCache	TokenNameIdentifier	 Category List Cache
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
CategoryPath	TokenNameIdentifier	 Category Path
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
facet	TokenNameIdentifier	 facet
.	TokenNameDOT	
taxonomy	TokenNameIdentifier	 taxonomy
.	TokenNameDOT	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
/** * Request to accumulate facet information for a specified facet and possibly * also some of its descendants, upto a specified depth. * <p> * The facet request additionally defines what information should * be computed within the facet results, if and how should results * be ordered, etc. * <P> * An example facet request is to look at all sub-categories of "Author", and * return the 10 with the highest counts (sorted by decreasing count). * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 Request to accumulate facet information for a specified facet and possibly also some of its descendants, upto a specified depth. <p> The facet request additionally defines what information should be computed within the facet results, if and how should results be ordered, etc. <P> An example facet request is to look at all sub-categories of "Author", and return the 10 with the highest counts (sorted by decreasing count). * @lucene.experimental 
public	TokenNamepublic	
abstract	TokenNameabstract	
class	TokenNameclass	
FacetRequest	TokenNameIdentifier	 Facet Request
implements	TokenNameimplements	
Cloneable	TokenNameIdentifier	 Cloneable
{	TokenNameLBRACE	
/** * Default depth for facets accumulation. * @see #getDepth() */	TokenNameCOMMENT_JAVADOC	 Default depth for facets accumulation. @see #getDepth() 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
DEFAULT_DEPTH	TokenNameIdentifier	 DEFAULT  DEPTH
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Default sort mode. * @see #getSortBy() */	TokenNameCOMMENT_JAVADOC	 Default sort mode. @see #getSortBy() 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
SortBy	TokenNameIdentifier	 Sort By
DEFAULT_SORT_BY	TokenNameIdentifier	 DEFAULT  SORT  BY
=	TokenNameEQUAL	
SortBy	TokenNameIdentifier	 Sort By
.	TokenNameDOT	
VALUE	TokenNameIdentifier	 VALUE
;	TokenNameSEMICOLON	
/** * Default result mode * @see #getResultMode() */	TokenNameCOMMENT_JAVADOC	 Default result mode @see #getResultMode() 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
ResultMode	TokenNameIdentifier	 Result Mode
DEFAULT_RESULT_MODE	TokenNameIdentifier	 DEFAULT  RESULT  MODE
=	TokenNameEQUAL	
ResultMode	TokenNameIdentifier	 Result Mode
.	TokenNameDOT	
GLOBAL_FLAT	TokenNameIdentifier	 GLOBAL  FLAT
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CategoryPath	TokenNameIdentifier	 Category Path
categoryPath	TokenNameIdentifier	 category Path
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
numResults	TokenNameIdentifier	 num Results
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
numLabel	TokenNameIdentifier	 num Label
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SortOrder	TokenNameIdentifier	 Sort Order
sortOrder	TokenNameIdentifier	 sort Order
;	TokenNameSEMICOLON	
private	TokenNameprivate	
SortBy	TokenNameIdentifier	 Sort By
sortBy	TokenNameIdentifier	 sort By
;	TokenNameSEMICOLON	
/** * Computed at construction, this hashCode is based on two final members * {@link CategoryPath} and <code>numResults</code> */	TokenNameCOMMENT_JAVADOC	 Computed at construction, this hashCode is based on two final members {@link CategoryPath} and <code>numResults</code> 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ResultMode	TokenNameIdentifier	 Result Mode
resultMode	TokenNameIdentifier	 result Mode
=	TokenNameEQUAL	
DEFAULT_RESULT_MODE	TokenNameIdentifier	 DEFAULT  RESULT  MODE
;	TokenNameSEMICOLON	
/** * Initialize the request with a given path, and a requested number of facets * results. By default, all returned results would be labeled - to alter this * default see {@link #setNumLabel(int)}. * <p> * <b>NOTE:</b> if <code>numResults</code> is given as * <code>Integer.MAX_VALUE</code> than all the facet results would be * returned, without any limit. * <p> * <b>NOTE:</b> it is assumed that the given {@link CategoryPath} is not * modified after construction of this object. Otherwise, some things may not * function properly, e.g. {@link #hashCode()}. * * @throws IllegalArgumentException if numResults is &le; 0 */	TokenNameCOMMENT_JAVADOC	 Initialize the request with a given path, and a requested number of facets results. By default, all returned results would be labeled - to alter this default see {@link #setNumLabel(int)}. <p> <b>NOTE:</b> if <code>numResults</code> is given as <code>Integer.MAX_VALUE</code> than all the facet results would be returned, without any limit. <p> <b>NOTE:</b> it is assumed that the given {@link CategoryPath} is not modified after construction of this object. Otherwise, some things may not function properly, e.g. {@link #hashCode()}. * @throws IllegalArgumentException if numResults is &le; 0 
public	TokenNamepublic	
FacetRequest	TokenNameIdentifier	 Facet Request
(	TokenNameLPAREN	
CategoryPath	TokenNameIdentifier	 Category Path
path	TokenNameIdentifier	 path
,	TokenNameCOMMA	
int	TokenNameint	
numResults	TokenNameIdentifier	 num Results
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
numResults	TokenNameIdentifier	 num Results
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"num results must be a positive (>0) number: "	TokenNameStringLiteral	num results must be a positive (>0) number: 
+	TokenNamePLUS	
numResults	TokenNameIdentifier	 num Results
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"category path cannot be null!"	TokenNameStringLiteral	category path cannot be null!
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
categoryPath	TokenNameIdentifier	 category Path
=	TokenNameEQUAL	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
numResults	TokenNameIdentifier	 num Results
=	TokenNameEQUAL	
numResults	TokenNameIdentifier	 num Results
;	TokenNameSEMICOLON	
numLabel	TokenNameIdentifier	 num Label
=	TokenNameEQUAL	
numResults	TokenNameIdentifier	 num Results
;	TokenNameSEMICOLON	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
DEFAULT_DEPTH	TokenNameIdentifier	 DEFAULT  DEPTH
;	TokenNameSEMICOLON	
sortBy	TokenNameIdentifier	 sort By
=	TokenNameEQUAL	
DEFAULT_SORT_BY	TokenNameIdentifier	 DEFAULT  SORT  BY
;	TokenNameSEMICOLON	
sortOrder	TokenNameIdentifier	 sort Order
=	TokenNameEQUAL	
SortOrder	TokenNameIdentifier	 Sort Order
.	TokenNameDOT	
DESCENDING	TokenNameIdentifier	 DESCENDING
;	TokenNameSEMICOLON	
hashCode	TokenNameIdentifier	 hash Code
=	TokenNameEQUAL	
categoryPath	TokenNameIdentifier	 category Path
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
^	TokenNameXOR	
this	TokenNamethis	
.	TokenNameDOT	
numResults	TokenNameIdentifier	 num Results
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
CloneNotSupportedException	TokenNameIdentifier	 Clone Not Supported Exception
{	TokenNameLBRACE	
// Overridden to make it public 	TokenNameCOMMENT_LINE	Overridden to make it public 
return	TokenNamereturn	
super	TokenNamesuper	
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setNumLabel	TokenNameIdentifier	 set Num Label
(	TokenNameLPAREN	
int	TokenNameint	
numLabel	TokenNameIdentifier	 num Label
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
numLabel	TokenNameIdentifier	 num Label
=	TokenNameEQUAL	
numLabel	TokenNameIdentifier	 num Label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setDepth	TokenNameIdentifier	 set Depth
(	TokenNameLPAREN	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
=	TokenNameEQUAL	
depth	TokenNameIdentifier	 depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setSortOrder	TokenNameIdentifier	 set Sort Order
(	TokenNameLPAREN	
SortOrder	TokenNameIdentifier	 Sort Order
sortOrder	TokenNameIdentifier	 sort Order
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sortOrder	TokenNameIdentifier	 sort Order
=	TokenNameEQUAL	
sortOrder	TokenNameIdentifier	 sort Order
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
setSortBy	TokenNameIdentifier	 set Sort By
(	TokenNameLPAREN	
SortBy	TokenNameIdentifier	 Sort By
sortBy	TokenNameIdentifier	 sort By
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sortBy	TokenNameIdentifier	 sort By
=	TokenNameEQUAL	
sortBy	TokenNameIdentifier	 sort By
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The root category of this facet request. The categories that are returned * as a result of this request will all be descendants of this root. * <p> * <b>NOTE:</b> you should not modify the returned {@link CategoryPath}, or * otherwise some methonds may not work properly, e.g. {@link #hashCode()}. */	TokenNameCOMMENT_JAVADOC	 The root category of this facet request. The categories that are returned as a result of this request will all be descendants of this root. <p> <b>NOTE:</b> you should not modify the returned {@link CategoryPath}, or otherwise some methonds may not work properly, e.g. {@link #hashCode()}. 
public	TokenNamepublic	
final	TokenNamefinal	
CategoryPath	TokenNameIdentifier	 Category Path
getCategoryPath	TokenNameIdentifier	 get Category Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
categoryPath	TokenNameIdentifier	 category Path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * How deeply to look under the given category. If the depth is 0, * only the category itself is counted. If the depth is 1, its immediate * children are also counted, and so on. If the depth is Integer.MAX_VALUE, * all the category's descendants are counted.<br> * TODO (Facet): add AUTO_EXPAND option */	TokenNameCOMMENT_JAVADOC	 How deeply to look under the given category. If the depth is 0, only the category itself is counted. If the depth is 1, its immediate children are also counted, and so on. If the depth is Integer.MAX_VALUE, all the category's descendants are counted.<br> TODO (Facet): add AUTO_EXPAND option 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
getDepth	TokenNameIdentifier	 get Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
depth	TokenNameIdentifier	 depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * If getNumLabel()<getNumResults(), only the first getNumLabel() results * will have their category paths calculated, and the rest will only be * available as ordinals (category numbers) and will have null paths. * <P> * If Integer.MAX_VALUE is specified, all * results are labled. * <P> * The purpose of this parameter is to avoid having to run the whole * faceted search again when the user asks for more values for the facet; * The application can ask (getNumResults()) for more values than it needs * to show, but keep getNumLabel() only the number it wants to immediately * show. The slow-down caused by finding more values is negligible, because * the slowest part - finding the categories' paths, is avoided. * <p> * Depending on the {@link #getResultMode() LimitsMode}, * this limit is applied globally or per results node. * In the global mode, if this limit is 3, * only 3 top results would be labeled. * In the per-node mode, if this limit is 3, * 3 top children of {@link #getCategoryPath() the target category} would be labeled, * as well as 3 top children of each of them, and so forth, until the depth defined * by {@link #getDepth()}. * @see #getResultMode() */	TokenNameCOMMENT_JAVADOC	 If getNumLabel()<getNumResults(), only the first getNumLabel() results will have their category paths calculated, and the rest will only be available as ordinals (category numbers) and will have null paths. <P> If Integer.MAX_VALUE is specified, all results are labled. <P> The purpose of this parameter is to avoid having to run the whole faceted search again when the user asks for more values for the facet; The application can ask (getNumResults()) for more values than it needs to show, but keep getNumLabel() only the number it wants to immediately show. The slow-down caused by finding more values is negligible, because the slowest part - finding the categories' paths, is avoided. <p> Depending on the {@link #getResultMode() LimitsMode}, this limit is applied globally or per results node. In the global mode, if this limit is 3, only 3 top results would be labeled. In the per-node mode, if this limit is 3, 3 top children of {@link #getCategoryPath() the target category} would be labeled, as well as 3 top children of each of them, and so forth, until the depth defined by {@link #getDepth()}. @see #getResultMode() 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
getNumLabel	TokenNameIdentifier	 get Num Label
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
numLabel	TokenNameIdentifier	 num Label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * The number of sub-categories to return (at most). * If the sub-categories are returned. * <p> * If Integer.MAX_VALUE is specified, all * sub-categories are returned. * <p> * Depending on the {@link #getResultMode() LimitsMode}, * this limit is applied globally or per results node. * In the global mode, if this limit is 3, * only 3 top results would be computed. * In the per-node mode, if this limit is 3, * 3 top children of {@link #getCategoryPath() the target category} would be returned, * as well as 3 top children of each of them, and so forth, until the depth defined * by {@link #getDepth()}. * @see #getResultMode() */	TokenNameCOMMENT_JAVADOC	 The number of sub-categories to return (at most). If the sub-categories are returned. <p> If Integer.MAX_VALUE is specified, all sub-categories are returned. <p> Depending on the {@link #getResultMode() LimitsMode}, this limit is applied globally or per results node. In the global mode, if this limit is 3, only 3 top results would be computed. In the per-node mode, if this limit is 3, 3 top children of {@link #getCategoryPath() the target category} would be returned, as well as 3 top children of each of them, and so forth, until the depth defined by {@link #getDepth()}. @see #getResultMode() 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
getNumResults	TokenNameIdentifier	 get Num Results
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
numResults	TokenNameIdentifier	 num Results
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Sort options for facet results. */	TokenNameCOMMENT_JAVADOC	 Sort options for facet results. 
public	TokenNamepublic	
enum	TokenNameenum	
SortBy	TokenNameIdentifier	 Sort By
{	TokenNameLBRACE	
/** sort by category ordinal with the taxonomy */	TokenNameCOMMENT_JAVADOC	 sort by category ordinal with the taxonomy 
ORDINAL	TokenNameIdentifier	 ORDINAL
,	TokenNameCOMMA	
/** sort by computed category value */	TokenNameCOMMENT_JAVADOC	 sort by computed category value 
VALUE	TokenNameIdentifier	 VALUE
}	TokenNameRBRACE	
/** Specify how should results be sorted. */	TokenNameCOMMENT_JAVADOC	 Specify how should results be sorted. 
public	TokenNamepublic	
final	TokenNamefinal	
SortBy	TokenNameIdentifier	 Sort By
getSortBy	TokenNameIdentifier	 get Sort By
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sortBy	TokenNameIdentifier	 sort By
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Requested sort order for the results. */	TokenNameCOMMENT_JAVADOC	 Requested sort order for the results. 
public	TokenNamepublic	
enum	TokenNameenum	
SortOrder	TokenNameIdentifier	 Sort Order
{	TokenNameLBRACE	
ASCENDING	TokenNameIdentifier	 ASCENDING
,	TokenNameCOMMA	
DESCENDING	TokenNameIdentifier	 DESCENDING
}	TokenNameRBRACE	
/** Return the requested order of results. */	TokenNameCOMMENT_JAVADOC	 Return the requested order of results. 
public	TokenNamepublic	
final	TokenNamefinal	
SortOrder	TokenNameIdentifier	 Sort Order
getSortOrder	TokenNameIdentifier	 get Sort Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sortOrder	TokenNameIdentifier	 sort Order
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
categoryPath	TokenNameIdentifier	 category Path
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" nRes="	TokenNameStringLiteral	 nRes=
+	TokenNamePLUS	
numResults	TokenNameIdentifier	 num Results
+	TokenNamePLUS	
" nLbl="	TokenNameStringLiteral	 nLbl=
+	TokenNamePLUS	
numLabel	TokenNameIdentifier	 num Label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Creates a new {@link FacetResultsHandler} that matches the request logic * and current settings, such as {@link #getDepth() depth}, * {@link #getResultMode() limits-mode}, etc, as well as the passed in * {@link TaxonomyReader}. * * @param taxonomyReader taxonomy reader is needed e.g. for knowing the * taxonomy size. */	TokenNameCOMMENT_JAVADOC	 Creates a new {@link FacetResultsHandler} that matches the request logic and current settings, such as {@link #getDepth() depth}, {@link #getResultMode() limits-mode}, etc, as well as the passed in {@link TaxonomyReader}. * @param taxonomyReader taxonomy reader is needed e.g. for knowing the taxonomy size. 
public	TokenNamepublic	
FacetResultsHandler	TokenNameIdentifier	 Facet Results Handler
createFacetResultsHandler	TokenNameIdentifier	 create Facet Results Handler
(	TokenNameLPAREN	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
resultMode	TokenNameIdentifier	 result Mode
==	TokenNameEQUAL_EQUAL	
ResultMode	TokenNameIdentifier	 Result Mode
.	TokenNameDOT	
PER_NODE_IN_TREE	TokenNameIdentifier	 PER  NODE  IN  TREE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TopKInEachNodeHandler	TokenNameIdentifier	 Top K In Each Node Handler
(	TokenNameLPAREN	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
,	TokenNameCOMMA	
(	TokenNameLPAREN	
FacetRequest	TokenNameIdentifier	 Facet Request
)	TokenNameRPAREN	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TopKFacetResultsHandler	TokenNameIdentifier	 Top K Facet Results Handler
(	TokenNameLPAREN	
taxonomyReader	TokenNameIdentifier	 taxonomy Reader
,	TokenNameCOMMA	
(	TokenNameLPAREN	
FacetRequest	TokenNameIdentifier	 Facet Request
)	TokenNameRPAREN	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
CloneNotSupportedException	TokenNameIdentifier	 Clone Not Supported Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Shouldn't happen since we implement Cloneable. If it does happen, it is 	TokenNameCOMMENT_LINE	Shouldn't happen since we implement Cloneable. If it does happen, it is 
// probably because the class was changed to not implement Cloneable 	TokenNameCOMMENT_LINE	probably because the class was changed to not implement Cloneable 
// anymore. 	TokenNameCOMMENT_LINE	anymore. 
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Result structure manner of applying request's limits such as * {@link #getNumLabel()} and * {@link #getNumResults()}. */	TokenNameCOMMENT_JAVADOC	 Result structure manner of applying request's limits such as {@link #getNumLabel()} and {@link #getNumResults()}. 
public	TokenNamepublic	
enum	TokenNameenum	
ResultMode	TokenNameIdentifier	 Result Mode
{	TokenNameLBRACE	
/** Limits are applied per node, and the result has a full tree structure. */	TokenNameCOMMENT_JAVADOC	 Limits are applied per node, and the result has a full tree structure. 
PER_NODE_IN_TREE	TokenNameIdentifier	 PER  NODE  IN  TREE
,	TokenNameCOMMA	
/** Limits are applied globally, on total number of results, and the result has a flat structure. */	TokenNameCOMMENT_JAVADOC	 Limits are applied globally, on total number of results, and the result has a flat structure. 
GLOBAL_FLAT	TokenNameIdentifier	 GLOBAL  FLAT
}	TokenNameRBRACE	
/** Return the requested result mode. */	TokenNameCOMMENT_JAVADOC	 Return the requested result mode. 
public	TokenNamepublic	
final	TokenNamefinal	
ResultMode	TokenNameIdentifier	 Result Mode
getResultMode	TokenNameIdentifier	 get Result Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
resultMode	TokenNameIdentifier	 result Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @param resultMode the resultMode to set * @see #getResultMode() */	TokenNameCOMMENT_JAVADOC	 @param resultMode the resultMode to set @see #getResultMode() 
public	TokenNamepublic	
void	TokenNamevoid	
setResultMode	TokenNameIdentifier	 set Result Mode
(	TokenNameLPAREN	
ResultMode	TokenNameIdentifier	 Result Mode
resultMode	TokenNameIdentifier	 result Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
resultMode	TokenNameIdentifier	 result Mode
=	TokenNameEQUAL	
resultMode	TokenNameIdentifier	 result Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
hashCode	TokenNameIdentifier	 hash Code
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
o	TokenNameIdentifier	 o
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
instanceof	TokenNameinstanceof	
FacetRequest	TokenNameIdentifier	 Facet Request
)	TokenNameRPAREN	
{	TokenNameLBRACE	
FacetRequest	TokenNameIdentifier	 Facet Request
that	TokenNameIdentifier	 that
=	TokenNameEQUAL	
(	TokenNameLPAREN	
FacetRequest	TokenNameIdentifier	 Facet Request
)	TokenNameRPAREN	
o	TokenNameIdentifier	 o
;	TokenNameSEMICOLON	
return	TokenNamereturn	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
&&	TokenNameAND_AND	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
categoryPath	TokenNameIdentifier	 category Path
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
this	TokenNamethis	
.	TokenNameDOT	
categoryPath	TokenNameIdentifier	 category Path
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
numResults	TokenNameIdentifier	 num Results
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
numResults	TokenNameIdentifier	 num Results
&&	TokenNameAND_AND	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
depth	TokenNameIdentifier	 depth
&&	TokenNameAND_AND	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
resultMode	TokenNameIdentifier	 result Mode
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
resultMode	TokenNameIdentifier	 result Mode
&&	TokenNameAND_AND	
that	TokenNameIdentifier	 that
.	TokenNameDOT	
numLabel	TokenNameIdentifier	 num Label
==	TokenNameEQUAL_EQUAL	
this	TokenNamethis	
.	TokenNameDOT	
numLabel	TokenNameIdentifier	 num Label
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create an aggregator for this facet request. Aggregator action depends on * request definition. For a count request, it will usually increment the * count for that facet. * * @param useComplements * whether the complements optimization is being used for current * computation. * @param arrays * provider for facet arrays in use for current computation. * @param indexReader * index reader in effect. * @param taxonomy * reader of taxonomy in effect. * @throws IOException */	TokenNameCOMMENT_JAVADOC	 Create an aggregator for this facet request. Aggregator action depends on request definition. For a count request, it will usually increment the count for that facet. * @param useComplements whether the complements optimization is being used for current computation. @param arrays provider for facet arrays in use for current computation. @param indexReader index reader in effect. @param taxonomy reader of taxonomy in effect. @throws IOException 
public	TokenNamepublic	
abstract	TokenNameabstract	
Aggregator	TokenNameIdentifier	 Aggregator
createAggregator	TokenNameIdentifier	 create Aggregator
(	TokenNameLPAREN	
boolean	TokenNameboolean	
useComplements	TokenNameIdentifier	 use Complements
,	TokenNameCOMMA	
FacetArrays	TokenNameIdentifier	 Facet Arrays
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
IndexReader	TokenNameIdentifier	 Index Reader
indexReader	TokenNameIdentifier	 index Reader
,	TokenNameCOMMA	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
taxonomy	TokenNameIdentifier	 taxonomy
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
/** * Create the category list iterator for the specified partition. * If a non null cache is provided which contains the required data, * use it for the iteration. */	TokenNameCOMMENT_JAVADOC	 Create the category list iterator for the specified partition. If a non null cache is provided which contains the required data, use it for the iteration. 
public	TokenNamepublic	
CategoryListIterator	TokenNameIdentifier	 Category List Iterator
createCategoryListIterator	TokenNameIdentifier	 create Category List Iterator
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
TaxonomyReader	TokenNameIdentifier	 Taxonomy Reader
taxo	TokenNameIdentifier	 taxo
,	TokenNameCOMMA	
FacetSearchParams	TokenNameIdentifier	 Facet Search Params
sParams	TokenNameIdentifier	 s Params
,	TokenNameCOMMA	
int	TokenNameint	
partition	TokenNameIdentifier	 partition
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
CategoryListCache	TokenNameIdentifier	 Category List Cache
clCache	TokenNameIdentifier	 cl Cache
=	TokenNameEQUAL	
sParams	TokenNameIdentifier	 s Params
.	TokenNameDOT	
getClCache	TokenNameIdentifier	 get Cl Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CategoryListParams	TokenNameIdentifier	 Category List Params
clParams	TokenNameIdentifier	 cl Params
=	TokenNameEQUAL	
sParams	TokenNameIdentifier	 s Params
.	TokenNameDOT	
getFacetIndexingParams	TokenNameIdentifier	 get Facet Indexing Params
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getCategoryListParams	TokenNameIdentifier	 get Category List Params
(	TokenNameLPAREN	
categoryPath	TokenNameIdentifier	 category Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clCache	TokenNameIdentifier	 cl Cache
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
CategoryListData	TokenNameIdentifier	 Category List Data
clData	TokenNameIdentifier	 cl Data
=	TokenNameEQUAL	
clCache	TokenNameIdentifier	 cl Cache
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
clParams	TokenNameIdentifier	 cl Params
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
clData	TokenNameIdentifier	 cl Data
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
clData	TokenNameIdentifier	 cl Data
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
partition	TokenNameIdentifier	 partition
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
clParams	TokenNameIdentifier	 cl Params
.	TokenNameDOT	
createCategoryListIterator	TokenNameIdentifier	 create Category List Iterator
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
partition	TokenNameIdentifier	 partition
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Return the value of a category used for facets computations for this * request. For a count request this would be the count for that facet, i.e. * an integer number. but for other requests this can be the result of a more * complex operation, and the result can be any double precision number. * Having this method with a general name <b>value</b> which is double * precision allows to have more compact API and code for handling counts and * perhaps other requests (such as for associations) very similarly, and by * the same code and API, avoiding code duplication. * * @param arrays * provider for facet arrays in use for current computation. * @param idx * an index into the count arrays now in effect in * <code>arrays</code>. E.g., for ordinal number <i>n</i>, with * partition, of size <i>partitionSize</i>, now covering <i>n</i>, * <code>getValueOf</code> would be invoked with <code>idx</code> * being <i>n</i> % <i>partitionSize</i>. */	TokenNameCOMMENT_JAVADOC	 Return the value of a category used for facets computations for this request. For a count request this would be the count for that facet, i.e. an integer number. but for other requests this can be the result of a more complex operation, and the result can be any double precision number. Having this method with a general name <b>value</b> which is double precision allows to have more compact API and code for handling counts and perhaps other requests (such as for associations) very similarly, and by the same code and API, avoiding code duplication. * @param arrays provider for facet arrays in use for current computation. @param idx an index into the count arrays now in effect in <code>arrays</code>. E.g., for ordinal number <i>n</i>, with partition, of size <i>partitionSize</i>, now covering <i>n</i>, <code>getValueOf</code> would be invoked with <code>idx</code> being <i>n</i> % <i>partitionSize</i>. 
public	TokenNamepublic	
abstract	TokenNameabstract	
double	TokenNamedouble	
getValueOf	TokenNameIdentifier	 get Value Of
(	TokenNameLPAREN	
FacetArrays	TokenNameIdentifier	 Facet Arrays
arrays	TokenNameIdentifier	 arrays
,	TokenNameCOMMA	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Indicates whether this facet request is eligible for applying the complements optimization. */	TokenNameCOMMENT_JAVADOC	 Indicates whether this facet request is eligible for applying the complements optimization. 
public	TokenNamepublic	
boolean	TokenNameboolean	
supportsComplements	TokenNameIdentifier	 supports Complements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// by default: no 	TokenNameCOMMENT_LINE	by default: no 
}	TokenNameRBRACE	
/** Indicates whether the results of this request depends on each result document's score */	TokenNameCOMMENT_JAVADOC	 Indicates whether the results of this request depends on each result document's score 
public	TokenNamepublic	
abstract	TokenNameabstract	
boolean	TokenNameboolean	
requireDocumentScore	TokenNameIdentifier	 require Document Score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
