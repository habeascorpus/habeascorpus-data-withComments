/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Serializable	TokenNameIdentifier	 Serializable
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLAnchorElement	TokenNameIdentifier	 HTML Anchor Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLAppletElement	TokenNameIdentifier	 HTML Applet Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLAreaElement	TokenNameIdentifier	 HTML Area Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLCollection	TokenNameIdentifier	 HTML Collection
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLElement	TokenNameIdentifier	 HTML Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLFormElement	TokenNameIdentifier	 HTML Form Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLImageElement	TokenNameIdentifier	 HTML Image Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLObjectElement	TokenNameIdentifier	 HTML Object Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLOptionElement	TokenNameIdentifier	 HTML Option Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLTableCellElement	TokenNameIdentifier	 HTML Table Cell Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLTableRowElement	TokenNameIdentifier	 HTML Table Row Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
html	TokenNameIdentifier	 html
.	TokenNameDOT	
HTMLTableSectionElement	TokenNameIdentifier	 HTML Table Section Element
;	TokenNameSEMICOLON	
/** * Implements {@link org.w3c.dom.html.HTMLCollection} to traverse any named * elements on a {@link org.w3c.dom.html.HTMLDocument}. The elements type to * look for is identified in the constructor by code. This collection is not * optimized for traversing large trees. * <p> * The collection has to meet two requirements: it has to be live, and it has * to traverse depth first and always return results in that order. As such, * using an object container (such as {@link java.util.Vector}) is expensive on * insert/remove operations. Instead, the collection has been implemented using * three traversing functions. As a result, operations on large documents will * result in traversal of the entire document tree and consume a considerable * amount of time. * <p> * Note that synchronization on the traversed document cannot be achieved. * The document itself cannot be locked, and locking each traversed node is * likely to lead to a dead lock condition. Therefore, there is a chance of the * document being changed as results are fetched; in all likelihood, the results * might be out dated, but not erroneous. * * @xerces.internal * * @version $Revision: 1035042 $ $Date: 2010-11-14 13:41:49 -0500 (Sun, 14 Nov 2010) $ * @author <a href="mailto:arkin@exoffice.com">Assaf Arkin</a> * @see org.w3c.dom.html.HTMLCollection */	TokenNameCOMMENT_JAVADOC	 Implements {@link org.w3c.dom.html.HTMLCollection} to traverse any named elements on a {@link org.w3c.dom.html.HTMLDocument}. The elements type to look for is identified in the constructor by code. This collection is not optimized for traversing large trees. <p> The collection has to meet two requirements: it has to be live, and it has to traverse depth first and always return results in that order. As such, using an object container (such as {@link java.util.Vector}) is expensive on insert/remove operations. Instead, the collection has been implemented using three traversing functions. As a result, operations on large documents will result in traversal of the entire document tree and consume a considerable amount of time. <p> Note that synchronization on the traversed document cannot be achieved. The document itself cannot be locked, and locking each traversed node is likely to lead to a dead lock condition. Therefore, there is a chance of the document being changed as results are fetched; in all likelihood, the results might be out dated, but not erroneous. * @xerces.internal * @version $Revision: 1035042 $ $Date: 2010-11-14 13:41:49 -0500 (Sun, 14 Nov 2010) $ @author <a href="mailto:arkin@exoffice.com">Assaf Arkin</a> @see org.w3c.dom.html.HTMLCollection 
class	TokenNameclass	
HTMLCollectionImpl	TokenNameIdentifier	 HTML Collection Impl
implements	TokenNameimplements	
HTMLCollection	TokenNameIdentifier	 HTML Collection
,	TokenNameCOMMA	
Serializable	TokenNameIdentifier	 Serializable
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
9112122196669185082L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all anchors in document: &lt;A&gt; elements that * have a <code>name</code> attribute. */	TokenNameCOMMENT_JAVADOC	 Request collection of all anchors in document: &lt;A&gt; elements that have a <code>name</code> attribute. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
ANCHOR	TokenNameIdentifier	 ANCHOR
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all forms in document: &lt;FORM&gt; elements. */	TokenNameCOMMENT_JAVADOC	 Request collection of all forms in document: &lt;FORM&gt; elements. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
FORM	TokenNameIdentifier	 FORM
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all images in document: &lt;IMG&gt; elements. */	TokenNameCOMMENT_JAVADOC	 Request collection of all images in document: &lt;IMG&gt; elements. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
IMAGE	TokenNameIdentifier	 IMAGE
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all Applets in document: &lt;APPLET&gt; and * &lt;OBJECT&gt; elements (&lt;OBJECT&gt; must contain an Applet). */	TokenNameCOMMENT_JAVADOC	 Request collection of all Applets in document: &lt;APPLET&gt; and &lt;OBJECT&gt; elements (&lt;OBJECT&gt; must contain an Applet). 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
APPLET	TokenNameIdentifier	 APPLET
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all links in document: &lt;A&gt; and &lt;AREA&gt; * elements (must have a <code>href</code> attribute). */	TokenNameCOMMENT_JAVADOC	 Request collection of all links in document: &lt;A&gt; and &lt;AREA&gt; elements (must have a <code>href</code> attribute). 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
LINK	TokenNameIdentifier	 LINK
=	TokenNameEQUAL	
5	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all options in selection: &lt;OPTION&gt; elements in * &lt;SELECT&gt; or &lt;OPTGROUP&gt;. */	TokenNameCOMMENT_JAVADOC	 Request collection of all options in selection: &lt;OPTION&gt; elements in &lt;SELECT&gt; or &lt;OPTGROUP&gt;. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
OPTION	TokenNameIdentifier	 OPTION
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all rows in table: &lt;TR&gt; elements in table or * table section. */	TokenNameCOMMENT_JAVADOC	 Request collection of all rows in table: &lt;TR&gt; elements in table or table section. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
ROW	TokenNameIdentifier	 ROW
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all form elements: &lt;INPUT&gt;, &lt;BUTTON&gt;, * &lt;SELECT&gt;, and &lt;TEXTAREA&gt; elements inside form &lt;FORM&gt;. */	TokenNameCOMMENT_JAVADOC	 Request collection of all form elements: &lt;INPUT&gt;, &lt;BUTTON&gt;, &lt;SELECT&gt;, and &lt;TEXTAREA&gt; elements inside form &lt;FORM&gt;. 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
ELEMENT	TokenNameIdentifier	 ELEMENT
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all areas in map: &lt;AREA&gt; element in &lt;MAP&gt; * (non recursive). */	TokenNameCOMMENT_JAVADOC	 Request collection of all areas in map: &lt;AREA&gt; element in &lt;MAP&gt; (non recursive). 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
AREA	TokenNameIdentifier	 AREA
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all table bodies in table: &lt;TBODY&gt; element in * table &lt;TABLE&gt; (non recursive). */	TokenNameCOMMENT_JAVADOC	 Request collection of all table bodies in table: &lt;TBODY&gt; element in table &lt;TABLE&gt; (non recursive). 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
TBODY	TokenNameIdentifier	 TBODY
=	TokenNameEQUAL	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Request collection of all cells in row: &lt;TD&gt; and &lt;TH&gt; * elements in &lt;TR&gt; (non recursive). */	TokenNameCOMMENT_JAVADOC	 Request collection of all cells in row: &lt;TD&gt; and &lt;TH&gt; elements in &lt;TR&gt; (non recursive). 
static	TokenNamestatic	
final	TokenNamefinal	
short	TokenNameshort	
CELL	TokenNameIdentifier	 CELL
=	TokenNameEQUAL	
-	TokenNameMINUS	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * Indicates what this collection is looking for. Holds one of the enumerated * values and used by {@link #collectionMatch}. Set by the constructor and * determine the collection's use for its life time. */	TokenNameCOMMENT_JAVADOC	 Indicates what this collection is looking for. Holds one of the enumerated values and used by {@link #collectionMatch}. Set by the constructor and determine the collection's use for its life time. 
private	TokenNameprivate	
short	TokenNameshort	
_lookingFor	TokenNameIdentifier	 looking For
;	TokenNameSEMICOLON	
/** * This is the top level element underneath which the collection exists. */	TokenNameCOMMENT_JAVADOC	 This is the top level element underneath which the collection exists. 
private	TokenNameprivate	
Element	TokenNameIdentifier	 Element
_topLevel	TokenNameIdentifier	 top Level
;	TokenNameSEMICOLON	
/** * Construct a new collection that retrieves element of the specific type * (<code>lookingFor</code>) from the specific document portion * (<code>topLevel</code>). * * @param topLevel The element underneath which the collection exists * @param lookingFor Code indicating what elements to look for */	TokenNameCOMMENT_JAVADOC	 Construct a new collection that retrieves element of the specific type (<code>lookingFor</code>) from the specific document portion (<code>topLevel</code>). * @param topLevel The element underneath which the collection exists @param lookingFor Code indicating what elements to look for 
HTMLCollectionImpl	TokenNameIdentifier	 HTML Collection Impl
(	TokenNameLPAREN	
HTMLElement	TokenNameIdentifier	 HTML Element
topLevel	TokenNameIdentifier	 top Level
,	TokenNameCOMMA	
short	TokenNameshort	
lookingFor	TokenNameIdentifier	 looking For
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
topLevel	TokenNameIdentifier	 top Level
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
NullPointerException	TokenNameIdentifier	 Null Pointer Exception
(	TokenNameLPAREN	
"HTM011 Argument 'topLevel' is null."	TokenNameStringLiteral	HTM011 Argument 'topLevel' is null.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
_topLevel	TokenNameIdentifier	 top Level
=	TokenNameEQUAL	
topLevel	TokenNameIdentifier	 top Level
;	TokenNameSEMICOLON	
_lookingFor	TokenNameIdentifier	 looking For
=	TokenNameEQUAL	
lookingFor	TokenNameIdentifier	 looking For
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns the length of the collection. This method might traverse the * entire document tree. * * @return Length of the collection */	TokenNameCOMMENT_JAVADOC	 Returns the length of the collection. This method might traverse the entire document tree. * @return Length of the collection 
public	TokenNamepublic	
final	TokenNamefinal	
int	TokenNameint	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Call recursive function on top-level element. 	TokenNameCOMMENT_LINE	Call recursive function on top-level element. 
return	TokenNamereturn	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
_topLevel	TokenNameIdentifier	 top Level
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieves the indexed node from the collection. Nodes are numbered in * tree order - depth-first traversal order. This method might traverse * the entire document tree. * * @param index The index of the node to return * @return The specified node or null if no such node found */	TokenNameCOMMENT_JAVADOC	 Retrieves the indexed node from the collection. Nodes are numbered in tree order - depth-first traversal order. This method might traverse the entire document tree. * @param index The index of the node to return @return The specified node or null if no such node found 
public	TokenNamepublic	
final	TokenNamefinal	
Node	TokenNameIdentifier	 Node
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"HTM012 Argument 'index' is negative."	TokenNameStringLiteral	HTM012 Argument 'index' is negative.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Call recursive function on top-level element. 	TokenNameCOMMENT_LINE	Call recursive function on top-level element. 
return	TokenNamereturn	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
_topLevel	TokenNameIdentifier	 top Level
,	TokenNameCOMMA	
new	TokenNamenew	
CollectionIndex	TokenNameIdentifier	 Collection Index
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Retrieves the named node from the collection. The name is matched case * sensitive against the <TT>id</TT> attribute of each element in the * collection, returning the first match. The tree is traversed in * depth-first order. This method might traverse the entire document tree. * * @param name The name of the node to return * @return The specified node or null if no such node found */	TokenNameCOMMENT_JAVADOC	 Retrieves the named node from the collection. The name is matched case sensitive against the <TT>id</TT> attribute of each element in the collection, returning the first match. The tree is traversed in depth-first order. This method might traverse the entire document tree. * @param name The name of the node to return @return The specified node or null if no such node found 
public	TokenNamepublic	
final	TokenNamefinal	
Node	TokenNameIdentifier	 Node
namedItem	TokenNameIdentifier	 named Item
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
NullPointerException	TokenNameIdentifier	 Null Pointer Exception
(	TokenNameLPAREN	
"HTM013 Argument 'name' is null."	TokenNameStringLiteral	HTM013 Argument 'name' is null.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Call recursive function on top-level element. 	TokenNameCOMMENT_LINE	Call recursive function on top-level element. 
return	TokenNamereturn	
namedItem	TokenNameIdentifier	 named Item
(	TokenNameLPAREN	
_topLevel	TokenNameIdentifier	 top Level
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursive function returns the number of elements of a particular type * that exist under the top level element. This is a recursive function * and the top level element is passed along. * * @param topLevel Top level element from which to scan * @return Number of elements */	TokenNameCOMMENT_JAVADOC	 Recursive function returns the number of elements of a particular type that exist under the top level element. This is a recursive function and the top level element is passed along. * @param topLevel Top level element from which to scan @return Number of elements 
private	TokenNameprivate	
int	TokenNameint	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
topLevel	TokenNameIdentifier	 top Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
topLevel	TokenNameIdentifier	 top Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Always count from zero and traverse all the childs of the 	TokenNameCOMMENT_LINE	Always count from zero and traverse all the childs of the 
// current element in the order they appear. 	TokenNameCOMMENT_LINE	current element in the order they appear. 
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
topLevel	TokenNameIdentifier	 top Level
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If a particular node is an element (could be HTML or XML), 	TokenNameCOMMENT_LINE	If a particular node is an element (could be HTML or XML), 
// do two things: if it's the one we're looking for, count 	TokenNameCOMMENT_LINE	do two things: if it's the one we're looking for, count 
// another matched element; at any rate, traverse it's 	TokenNameCOMMENT_LINE	another matched element; at any rate, traverse it's 
// children as well. 	TokenNameCOMMENT_LINE	children as well. 
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
instanceof	TokenNameinstanceof	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
collectionMatch	TokenNameIdentifier	 collection Match
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
++	TokenNamePLUS_PLUS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
recurse	TokenNameIdentifier	 recurse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
length	TokenNameIdentifier	 length
+=	TokenNamePLUS_EQUAL	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursive function returns the numbered element of a particular type * that exist under the top level element. This is a recursive function * and the top level element is passed along. * <p> * Note that this function must call itself with an index and get back both * the element (if one was found) and the new index which is decremeneted * for any like element found. Since integers are only passed by value, * this function makes use of a separate class ({@link CollectionIndex}) * to hold that index. * * @param topLevel Top level element from which to scan * @param index The index of the item to retreive * @return Number of elements * @see CollectionIndex */	TokenNameCOMMENT_JAVADOC	 Recursive function returns the numbered element of a particular type that exist under the top level element. This is a recursive function and the top level element is passed along. <p> Note that this function must call itself with an index and get back both the element (if one was found) and the new index which is decremeneted for any like element found. Since integers are only passed by value, this function makes use of a separate class ({@link CollectionIndex}) to hold that index. * @param topLevel Top level element from which to scan @param index The index of the item to retreive @return Number of elements @see CollectionIndex 
private	TokenNameprivate	
Node	TokenNameIdentifier	 Node
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
topLevel	TokenNameIdentifier	 top Level
,	TokenNameCOMMA	
CollectionIndex	TokenNameIdentifier	 Collection Index
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
topLevel	TokenNameIdentifier	 top Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Traverse all the childs of the current element in the order 	TokenNameCOMMENT_LINE	Traverse all the childs of the current element in the order 
// they appear. Count from the index backwards until you reach 	TokenNameCOMMENT_LINE	they appear. Count from the index backwards until you reach 
// matching element with an index of zero. Return that element. 	TokenNameCOMMENT_LINE	matching element with an index of zero. Return that element. 
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
topLevel	TokenNameIdentifier	 top Level
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If a particular node is an element (could be HTML or XML), 	TokenNameCOMMENT_LINE	If a particular node is an element (could be HTML or XML), 
// do two things: if it's the one we're looking for, decrease 	TokenNameCOMMENT_LINE	do two things: if it's the one we're looking for, decrease 
// the index and if zero, return this node; at any rate, 	TokenNameCOMMENT_LINE	the index and if zero, return this node; at any rate, 
// traverse it's children as well. 	TokenNameCOMMENT_LINE	traverse it's children as well. 
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
instanceof	TokenNameinstanceof	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
collectionMatch	TokenNameIdentifier	 collection Match
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
isZero	TokenNameIdentifier	 is Zero
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
decrement	TokenNameIdentifier	 decrement
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
recurse	TokenNameIdentifier	 recurse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Recursive function returns an element of a particular type with the * specified name (<TT>id</TT> attribute). * * @param topLevel Top level element from which to scan * @param name The named element to look for * @return The first named element found */	TokenNameCOMMENT_JAVADOC	 Recursive function returns an element of a particular type with the specified name (<TT>id</TT> attribute). * @param topLevel Top level element from which to scan @param name The named element to look for @return The first named element found 
private	TokenNameprivate	
Node	TokenNameIdentifier	 Node
namedItem	TokenNameIdentifier	 named Item
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
topLevel	TokenNameIdentifier	 top Level
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
topLevel	TokenNameIdentifier	 top Level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Traverse all the childs of the current element in the order 	TokenNameCOMMENT_LINE	Traverse all the childs of the current element in the order 
// they appear. 	TokenNameCOMMENT_LINE	they appear. 
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
topLevel	TokenNameIdentifier	 top Level
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If a particular node is an element (could be HTML or XML), 	TokenNameCOMMENT_LINE	If a particular node is an element (could be HTML or XML), 
// do two things: if it's the one we're looking for, and the 	TokenNameCOMMENT_LINE	do two things: if it's the one we're looking for, and the 
// name (id attribute) attribute is the one we're looking for, 	TokenNameCOMMENT_LINE	name (id attribute) attribute is the one we're looking for, 
// return this element; otherwise, traverse it's children. 	TokenNameCOMMENT_LINE	return this element; otherwise, traverse it's children. 
if	TokenNameif	
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
instanceof	TokenNameinstanceof	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
collectionMatch	TokenNameIdentifier	 collection Match
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
recurse	TokenNameIdentifier	 recurse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
result	TokenNameIdentifier	 result
=	TokenNameEQUAL	
namedItem	TokenNameIdentifier	 named Item
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
)	TokenNameRPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
result	TokenNameIdentifier	 result
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
result	TokenNameIdentifier	 result
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns true if scanning methods should iterate through the collection. * When looking for elements in the document, recursing is needed to traverse * the full document tree. When looking inside a specific element (e.g. for a * cell inside a row), recursing can lead to erroneous results. * * @return True if methods should recurse to traverse entire tree */	TokenNameCOMMENT_JAVADOC	 Returns true if scanning methods should iterate through the collection. When looking for elements in the document, recursing is needed to traverse the full document tree. When looking inside a specific element (e.g. for a cell inside a row), recursing can lead to erroneous results. * @return True if methods should recurse to traverse entire tree 
protected	TokenNameprotected	
boolean	TokenNameboolean	
recurse	TokenNameIdentifier	 recurse
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_lookingFor	TokenNameIdentifier	 looking For
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Determines if current element matches based on what we're looking for. * The element is passed along with an optional identifier name. If the * element is the one we're looking for, return true. If the name is also * specified, the name must match the <code>id</code> attribute * (match <code>name</code> first for anchors). * * @param elem The current element * @param name The identifier name or null * @return The element matches what we're looking for */	TokenNameCOMMENT_JAVADOC	 Determines if current element matches based on what we're looking for. The element is passed along with an optional identifier name. If the element is the one we're looking for, return true. If the name is also specified, the name must match the <code>id</code> attribute (match <code>name</code> first for anchors). * @param elem The current element @param name The identifier name or null @return The element matches what we're looking for 
protected	TokenNameprotected	
boolean	TokenNameboolean	
collectionMatch	TokenNameIdentifier	 collection Match
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
elem	TokenNameIdentifier	 elem
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
match	TokenNameIdentifier	 match
;	TokenNameSEMICOLON	
synchronized	TokenNamesynchronized	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Begin with no matching. Depending on what we're looking for, 	TokenNameCOMMENT_LINE	Begin with no matching. Depending on what we're looking for, 
// attempt to match based on the element type. This is the quickest 	TokenNameCOMMENT_LINE	attempt to match based on the element type. This is the quickest 
// way to match involving only a cast. Do the expensive string 	TokenNameCOMMENT_LINE	way to match involving only a cast. Do the expensive string 
// comparison later on. 	TokenNameCOMMENT_LINE	comparison later on. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
_lookingFor	TokenNameIdentifier	 looking For
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
ANCHOR	TokenNameIdentifier	 ANCHOR
:	TokenNameCOLON	
// Anchor is an <A> element with a 'name' attribute. Otherwise, it's 	TokenNameCOMMENT_LINE	Anchor is an <A> element with a 'name' attribute. Otherwise, it's 
// just a link. 	TokenNameCOMMENT_LINE	just a link. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAnchorElement	TokenNameIdentifier	 HTML Anchor Element
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"name"	TokenNameStringLiteral	name
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
FORM	TokenNameIdentifier	 FORM
:	TokenNameCOLON	
// Any <FORM> element. 	TokenNameCOMMENT_LINE	Any <FORM> element. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLFormElement	TokenNameIdentifier	 HTML Form Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
IMAGE	TokenNameIdentifier	 IMAGE
:	TokenNameCOLON	
// Any <IMG> element. <OBJECT> elements with images are not returned. 	TokenNameCOMMENT_LINE	Any <IMG> element. <OBJECT> elements with images are not returned. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLImageElement	TokenNameIdentifier	 HTML Image Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
APPLET	TokenNameIdentifier	 APPLET
:	TokenNameCOLON	
// Any <APPLET> element, and any <OBJECT> element which represents an 	TokenNameCOMMENT_LINE	Any <APPLET> element, and any <OBJECT> element which represents an 
// Applet. This is determined by 'codetype' attribute being 	TokenNameCOMMENT_LINE	Applet. This is determined by 'codetype' attribute being 
// 'application/java' or 'classid' attribute starting with 'java:'. 	TokenNameCOMMENT_LINE	'application/java' or 'classid' attribute starting with 'java:'. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAppletElement	TokenNameIdentifier	 HTML Applet Element
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLObjectElement	TokenNameIdentifier	 HTML Object Element
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
"application/java"	TokenNameStringLiteral	application/java
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"codetype"	TokenNameStringLiteral	codetype
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"classid"	TokenNameStringLiteral	classid
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"java:"	TokenNameStringLiteral	java:
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ELEMENT	TokenNameIdentifier	 ELEMENT
:	TokenNameCOLON	
// All form elements implement HTMLFormControl for easy identification. 	TokenNameCOMMENT_LINE	All form elements implement HTMLFormControl for easy identification. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLFormControl	TokenNameIdentifier	 HTML Form Control
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
LINK	TokenNameIdentifier	 LINK
:	TokenNameCOLON	
// Any <A> element, and any <AREA> elements with an 'href' attribute. 	TokenNameCOMMENT_LINE	Any <A> element, and any <AREA> elements with an 'href' attribute. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAnchorElement	TokenNameIdentifier	 HTML Anchor Element
||	TokenNameOR_OR	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAreaElement	TokenNameIdentifier	 HTML Area Element
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"href"	TokenNameStringLiteral	href
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
AREA	TokenNameIdentifier	 AREA
:	TokenNameCOLON	
// Any <AREA> element. 	TokenNameCOMMENT_LINE	Any <AREA> element. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAreaElement	TokenNameIdentifier	 HTML Area Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
OPTION	TokenNameIdentifier	 OPTION
:	TokenNameCOLON	
// Any <OPTION> element. 	TokenNameCOMMENT_LINE	Any <OPTION> element. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLOptionElement	TokenNameIdentifier	 HTML Option Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
ROW	TokenNameIdentifier	 ROW
:	TokenNameCOLON	
// Any <TR> element. 	TokenNameCOMMENT_LINE	Any <TR> element. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLTableRowElement	TokenNameIdentifier	 HTML Table Row Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
TBODY	TokenNameIdentifier	 TBODY
:	TokenNameCOLON	
// Any <TBODY> element (one of three table section types). 	TokenNameCOMMENT_LINE	Any <TBODY> element (one of three table section types). 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLTableSectionElement	TokenNameIdentifier	 HTML Table Section Element
&&	TokenNameAND_AND	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getTagName	TokenNameIdentifier	 get Tag Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
"TBODY"	TokenNameStringLiteral	TBODY
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
CELL	TokenNameIdentifier	 CELL
:	TokenNameCOLON	
// Any <TD> or <TH> element. 	TokenNameCOMMENT_LINE	Any <TD> or <TH> element. 
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLTableCellElement	TokenNameIdentifier	 HTML Table Cell Element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If element type was matched and a name was specified, must also match 	TokenNameCOMMENT_LINE	If element type was matched and a name was specified, must also match 
// the name against either the 'id' or the 'name' attribute. The 'name' 	TokenNameCOMMENT_LINE	the name against either the 'id' or the 'name' attribute. The 'name' 
// attribute is relevant only for <A> elements for backward compatibility. 	TokenNameCOMMENT_LINE	attribute is relevant only for <A> elements for backward compatibility. 
if	TokenNameif	
(	TokenNameLPAREN	
match	TokenNameIdentifier	 match
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If an anchor and 'name' attribute matches, return true. Otherwise, 	TokenNameCOMMENT_LINE	If an anchor and 'name' attribute matches, return true. Otherwise, 
// try 'id' attribute. 	TokenNameCOMMENT_LINE	try 'id' attribute. 
if	TokenNameif	
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
instanceof	TokenNameinstanceof	
HTMLAnchorElement	TokenNameIdentifier	 HTML Anchor Element
&&	TokenNameAND_AND	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"name"	TokenNameStringLiteral	name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
match	TokenNameIdentifier	 match
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
elem	TokenNameIdentifier	 elem
.	TokenNameDOT	
getAttribute	TokenNameIdentifier	 get Attribute
(	TokenNameLPAREN	
"id"	TokenNameStringLiteral	id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
match	TokenNameIdentifier	 match
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * {@link CollectionImpl#item} must traverse down the tree and decrement the * index until it matches an element who's index is zero. Since integers are * passed by value, this class servers to pass the index into each recursion * by reference. It encompasses all the operations that need be performed on * the index, although direct access is possible. * * @xerces.internal * * @see CollectionImpl#item */	TokenNameCOMMENT_JAVADOC	 {@link CollectionImpl#item} must traverse down the tree and decrement the index until it matches an element who's index is zero. Since integers are passed by value, this class servers to pass the index into each recursion by reference. It encompasses all the operations that need be performed on the index, although direct access is possible. * @xerces.internal * @see CollectionImpl#item 
class	TokenNameclass	
CollectionIndex	TokenNameIdentifier	 Collection Index
{	TokenNameLBRACE	
/** * Returns the current index. * * @return Current index */	TokenNameCOMMENT_JAVADOC	 Returns the current index. * @return Current index 
int	TokenNameint	
getIndex	TokenNameIdentifier	 get Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Decrements the index by one. */	TokenNameCOMMENT_JAVADOC	 Decrements the index by one. 
void	TokenNamevoid	
decrement	TokenNameIdentifier	 decrement
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
--	TokenNameMINUS_MINUS	
_index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if index is zero (or negative). * * @return True if index is zero */	TokenNameCOMMENT_JAVADOC	 Returns true if index is zero (or negative). * @return True if index is zero 
boolean	TokenNameboolean	
isZero	TokenNameIdentifier	 is Zero
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
_index	TokenNameIdentifier	 index
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Constructs a new index with the specified initial value. The index will * then be decremeneted until it reaches zero. * * @param index The initial value */	TokenNameCOMMENT_JAVADOC	 Constructs a new index with the specified initial value. The index will then be decremeneted until it reaches zero. * @param index The initial value 
CollectionIndex	TokenNameIdentifier	 Collection Index
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
_index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Holds the actual value that is passed by reference using this class. */	TokenNameCOMMENT_JAVADOC	 Holds the actual value that is passed by reference using this class. 
private	TokenNameprivate	
int	TokenNameint	
_index	TokenNameIdentifier	 index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
