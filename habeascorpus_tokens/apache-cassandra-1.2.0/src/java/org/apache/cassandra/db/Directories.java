/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
File	TokenNameIdentifier	 File
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FileFilter	TokenNameIdentifier	 File Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
concurrent	TokenNameIdentifier	 concurrent
.	TokenNameDOT	
atomic	TokenNameIdentifier	 atomic
.	TokenNameDOT	
AtomicLong	TokenNameIdentifier	 Atomic Long
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
ImmutableMap	TokenNameIdentifier	 Immutable Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
ImmutableSortedSet	TokenNameIdentifier	 Immutable Sorted Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
primitives	TokenNameIdentifier	 primitives
.	TokenNameDOT	
Longs	TokenNameIdentifier	 Longs
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
commons	TokenNameIdentifier	 commons
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
StringUtils	TokenNameIdentifier	 String Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
Logger	TokenNameIdentifier	 Logger
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
slf4j	TokenNameIdentifier	 slf4j
.	TokenNameDOT	
LoggerFactory	TokenNameIdentifier	 Logger Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
config	TokenNameIdentifier	 config
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
compaction	TokenNameIdentifier	 compaction
.	TokenNameDOT	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
FSWriteError	TokenNameIdentifier	 FS Write Error
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileUtils	TokenNameIdentifier	 File Utils
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
*	TokenNameMULTIPLY	
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
service	TokenNameIdentifier	 service
.	TokenNameDOT	
StorageService	TokenNameIdentifier	 Storage Service
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
Pair	TokenNameIdentifier	 Pair
;	TokenNameSEMICOLON	
/** * Encapsulate handling of paths to the data files. * * The directory layout is the following: * /<path_to_data_dir>/ks/cf1/ks-cf1-hb-1-Data.db * /cf2/ks-cf2-hb-1-Data.db * ... * * In addition, more that one 'root' data directory can be specified so that * <path_to_data_dir> potentially represents multiple locations. * Note that in the case of multiple locations, the manifest for the leveled * compaction is only in one of the location. * * Snapshots (resp. backups) are always created along the sstables thare are * snapshoted (resp. backuped) but inside a subdirectory named 'snapshots' * (resp. backups) (and snapshots are furter inside a subdirectory of the name * of the snapshot). * * This class abstracts all those details from the rest of the code. */	TokenNameCOMMENT_JAVADOC	 Encapsulate handling of paths to the data files. * The directory layout is the following: /<path_to_data_dir>/ks/cf1/ks-cf1-hb-1-Data.db /cf2/ks-cf2-hb-1-Data.db ... * In addition, more that one 'root' data directory can be specified so that <path_to_data_dir> potentially represents multiple locations. Note that in the case of multiple locations, the manifest for the leveled compaction is only in one of the location. * Snapshots (resp. backups) are always created along the sstables thare are snapshoted (resp. backuped) but inside a subdirectory named 'snapshots' (resp. backups) (and snapshots are furter inside a subdirectory of the name of the snapshot). * This class abstracts all those details from the rest of the code. 
public	TokenNamepublic	
class	TokenNameclass	
Directories	TokenNameIdentifier	 Directories
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Logger	TokenNameIdentifier	 Logger
logger	TokenNameIdentifier	 logger
=	TokenNameEQUAL	
LoggerFactory	TokenNameIdentifier	 Logger Factory
.	TokenNameDOT	
getLogger	TokenNameIdentifier	 get Logger
(	TokenNameLPAREN	
Directories	TokenNameIdentifier	 Directories
.	TokenNameDOT	
class	TokenNameclass	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
BACKUPS_SUBDIR	TokenNameIdentifier	 BACKUPS  SUBDIR
=	TokenNameEQUAL	
"backups"	TokenNameStringLiteral	backups
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
=	TokenNameEQUAL	
"snapshots"	TokenNameStringLiteral	snapshots
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
=	TokenNameEQUAL	
"."	TokenNameStringLiteral	.
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
DataDirectory	TokenNameIdentifier	 Data Directory
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
dataFileLocations	TokenNameIdentifier	 data File Locations
;	TokenNameSEMICOLON	
static	TokenNamestatic	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locations	TokenNameIdentifier	 locations
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getAllDataFileLocations	TokenNameIdentifier	 get All Data File Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dataFileLocations	TokenNameIdentifier	 data File Locations
=	TokenNameEQUAL	
new	TokenNamenew	
DataDirectory	TokenNameIdentifier	 Data Directory
[	TokenNameLBRACKET	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
dataFileLocations	TokenNameIdentifier	 data File Locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DataDirectory	TokenNameIdentifier	 Data Directory
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
tablename	TokenNameIdentifier	 tablename
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
sstableDirectories	TokenNameIdentifier	 sstable Directories
;	TokenNameSEMICOLON	
public	TokenNamepublic	
static	TokenNamestatic	
Directories	TokenNameIdentifier	 Directories
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tablename	TokenNameIdentifier	 tablename
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
idx	TokenNameIdentifier	 idx
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// secondary index, goes in the same directory than the base cf 	TokenNameCOMMENT_LINE	secondary index, goes in the same directory than the base cf 
return	TokenNamereturn	
new	TokenNamenew	
Directories	TokenNameIdentifier	 Directories
(	TokenNameLPAREN	
tablename	TokenNameIdentifier	 tablename
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
new	TokenNamenew	
Directories	TokenNameIdentifier	 Directories
(	TokenNameLPAREN	
tablename	TokenNameIdentifier	 tablename
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
Directories	TokenNameIdentifier	 Directories
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
tablename	TokenNameIdentifier	 tablename
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
directoryName	TokenNameIdentifier	 directory Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
tablename	TokenNameIdentifier	 tablename
=	TokenNameEQUAL	
tablename	TokenNameIdentifier	 tablename
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
cfname	TokenNameIdentifier	 cfname
=	TokenNameEQUAL	
cfname	TokenNameIdentifier	 cfname
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
sstableDirectories	TokenNameIdentifier	 sstable Directories
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
dataFileLocations	TokenNameIdentifier	 data File Locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
dataFileLocations	TokenNameIdentifier	 data File Locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
sstableDirectories	TokenNameIdentifier	 sstable Directories
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dataFileLocations	TokenNameIdentifier	 data File Locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
tablename	TokenNameIdentifier	 tablename
,	TokenNameCOMMA	
directoryName	TokenNameIdentifier	 directory Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isClientMode	TokenNameIdentifier	 is Client Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
createDirectory	TokenNameIdentifier	 create Directory
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Returns SSTable location which is inside given data directory. * * @param dataDirectory * @return SSTable location */	TokenNameCOMMENT_JAVADOC	 Returns SSTable location which is inside given data directory. * @param dataDirectory @return SSTable location 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getLocationForDisk	TokenNameIdentifier	 get Location For Disk
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
dataDirectory	TokenNameIdentifier	 data Directory
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getDirectoryForNewSSTables	TokenNameIdentifier	 get Directory For New SS Tables
(	TokenNameLPAREN	
long	TokenNamelong	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
getLocationWithMaximumAvailableSpace	TokenNameIdentifier	 get Location With Maximum Available Space
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Requesting GC has a chance to free space only if we're using mmap and a non SUN jvm 	TokenNameCOMMENT_LINE	Requesting GC has a chance to free space only if we're using mmap and a non SUN jvm 
if	TokenNameif	
(	TokenNameLPAREN	
path	TokenNameIdentifier	 path
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getDiskAccessMode	TokenNameIdentifier	 get Disk Access Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Config	TokenNameIdentifier	 Config
.	TokenNameDOT	
DiskAccessMode	TokenNameIdentifier	 Disk Access Mode
.	TokenNameDOT	
mmap	TokenNameIdentifier	 mmap
||	TokenNameOR_OR	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getIndexAccessMode	TokenNameIdentifier	 get Index Access Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Config	TokenNameIdentifier	 Config
.	TokenNameDOT	
DiskAccessMode	TokenNameIdentifier	 Disk Access Mode
.	TokenNameDOT	
mmap	TokenNameIdentifier	 mmap
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
!	TokenNameNOT	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
isCleanerAvailable	TokenNameIdentifier	 is Cleaner Available
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Forcing GC to free up disk space. Upgrade to the Oracle JVM to avoid this"	TokenNameStringLiteral	Forcing GC to free up disk space. Upgrade to the Oracle JVM to avoid this
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
requestGC	TokenNameIdentifier	 request GC
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// retry after GCing has forced unmap of compacted SSTables so they can be deleted 	TokenNameCOMMENT_LINE	retry after GCing has forced unmap of compacted SSTables so they can be deleted 
// Note: GCInspector will do this already, but only sun JVM supports GCInspector so far 	TokenNameCOMMENT_LINE	Note: GCInspector will do this already, but only sun JVM supports GCInspector so far 
SSTableDeletingTask	TokenNameIdentifier	 SS Table Deleting Task
.	TokenNameDOT	
rescheduleFailedTasks	TokenNameIdentifier	 reschedule Failed Tasks
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
Thread	TokenNameIdentifier	 Thread
.	TokenNameDOT	
sleep	TokenNameIdentifier	 sleep
(	TokenNameLPAREN	
10000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InterruptedException	TokenNameIdentifier	 Interrupted Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
path	TokenNameIdentifier	 path
=	TokenNameEQUAL	
getLocationWithMaximumAvailableSpace	TokenNameIdentifier	 get Location With Maximum Available Space
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
path	TokenNameIdentifier	 path
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Loop through all the disks to see which disk has the max free space * return the disk with max free space for compactions. If the size of the expected * compacted file is greater than the max disk space available return null, we cannot * do compaction in this case. */	TokenNameCOMMENT_BLOCK	 Loop through all the disks to see which disk has the max free space return the disk with max free space for compactions. If the size of the expected compacted file is greater than the max disk space available return null, we cannot do compaction in this case. 
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getLocationWithMaximumAvailableSpace	TokenNameIdentifier	 get Location With Maximum Available Space
(	TokenNameLPAREN	
long	TokenNamelong	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
maxLocation	TokenNameIdentifier	 max Location
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
BlacklistedDirectories	TokenNameIdentifier	 Blacklisted Directories
.	TokenNameDOT	
isUnwritable	TokenNameIdentifier	 is Unwritable
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
long	TokenNamelong	
usableSpace	TokenNameIdentifier	 usable Space
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
getUsableSpace	TokenNameIdentifier	 get Usable Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
<	TokenNameLESS	
usableSpace	TokenNameIdentifier	 usable Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
=	TokenNameEQUAL	
usableSpace	TokenNameIdentifier	 usable Space
;	TokenNameSEMICOLON	
maxLocation	TokenNameIdentifier	 max Location
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Load factor of 0.9 we do not want to use the entire disk that is too risky. 	TokenNameCOMMENT_LINE	Load factor of 0.9 we do not want to use the entire disk that is too risky. 
maxFreeDisk	TokenNameIdentifier	 max Free Disk
=	TokenNameEQUAL	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
0.9	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"expected data files size is %d; largest free partition (%s) has %d bytes free"	TokenNameStringLiteral	expected data files size is %d; largest free partition (%s) has %d bytes free
,	TokenNameCOMMA	
estimatedSize	TokenNameIdentifier	 estimated Size
,	TokenNameCOMMA	
maxLocation	TokenNameIdentifier	 max Location
,	TokenNameCOMMA	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
estimatedSize	TokenNameIdentifier	 estimated Size
<	TokenNameLESS	
maxFreeDisk	TokenNameIdentifier	 max Free Disk
?	TokenNameQUESTION	
maxLocation	TokenNameIdentifier	 max Location
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Find location which is capable of holding given {@code estimatedSize}. * First it looks through for directory with no current task running and * the most free space available. * If no such directory is available, it just chose the one with the most * free space available. * If no directory can hold given {@code estimatedSize}, then returns null. * * @param estimatedSize estimated size you need to find location to fit * @return directory capable of given estimated size, or null if none found */	TokenNameCOMMENT_JAVADOC	 Find location which is capable of holding given {@code estimatedSize}. First it looks through for directory with no current task running and the most free space available. If no such directory is available, it just chose the one with the most free space available. If no directory can hold given {@code estimatedSize}, then returns null. * @param estimatedSize estimated size you need to find location to fit @return directory capable of given estimated size, or null if none found 
public	TokenNamepublic	
static	TokenNamestatic	
DataDirectory	TokenNameIdentifier	 Data Directory
getLocationCapableOfSize	TokenNameIdentifier	 get Location Capable Of Size
(	TokenNameLPAREN	
long	TokenNamelong	
estimatedSize	TokenNameIdentifier	 estimated Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// sort by available disk space 	TokenNameCOMMENT_LINE	sort by available disk space 
SortedSet	TokenNameIdentifier	 Sorted Set
<	TokenNameLESS	
DataDirectory	TokenNameIdentifier	 Data Directory
>	TokenNameGREATER	
directories	TokenNameIdentifier	 directories
=	TokenNameEQUAL	
ImmutableSortedSet	TokenNameIdentifier	 Immutable Sorted Set
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
dataFileLocations	TokenNameIdentifier	 data File Locations
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// if there is disk with sufficient space and no activity running on it, then use it 	TokenNameCOMMENT_LINE	if there is disk with sufficient space and no activity running on it, then use it 
for	TokenNamefor	
(	TokenNameLPAREN	
DataDirectory	TokenNameIdentifier	 Data Directory
directory	TokenNameIdentifier	 directory
:	TokenNameCOLON	
directories	TokenNameIdentifier	 directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
spaceAvailable	TokenNameIdentifier	 space Available
=	TokenNameEQUAL	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
getEstimatedAvailableSpace	TokenNameIdentifier	 get Estimated Available Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
<	TokenNameLESS	
spaceAvailable	TokenNameIdentifier	 space Available
&&	TokenNameAND_AND	
directory	TokenNameIdentifier	 directory
.	TokenNameDOT	
currentTasks	TokenNameIdentifier	 current Tasks
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
directory	TokenNameIdentifier	 directory
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if not, use the one that has largest free space 	TokenNameCOMMENT_LINE	if not, use the one that has largest free space 
if	TokenNameif	
(	TokenNameLPAREN	
estimatedSize	TokenNameIdentifier	 estimated Size
<	TokenNameLESS	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getEstimatedAvailableSpace	TokenNameIdentifier	 get Estimated Available Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
directories	TokenNameIdentifier	 directories
.	TokenNameDOT	
first	TokenNameIdentifier	 first
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
File	TokenNameIdentifier	 File
getSnapshotDirectory	TokenNameIdentifier	 get Snapshot Directory
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getOrCreate	TokenNameIdentifier	 get Or Create
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
File	TokenNameIdentifier	 File
getBackupsDirectory	TokenNameIdentifier	 get Backups Directory
(	TokenNameLPAREN	
Descriptor	TokenNameIdentifier	 Descriptor
desc	TokenNameIdentifier	 desc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
getOrCreate	TokenNameIdentifier	 get Or Create
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
.	TokenNameDOT	
directory	TokenNameIdentifier	 directory
,	TokenNameCOMMA	
BACKUPS_SUBDIR	TokenNameIdentifier	 BACKUPS  SUBDIR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableLister	TokenNameIdentifier	 SS Table Lister
sstableLister	TokenNameIdentifier	 sstable Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
SSTableLister	TokenNameIdentifier	 SS Table Lister
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
static	TokenNamestatic	
class	TokenNameclass	
DataDirectory	TokenNameIdentifier	 Data Directory
implements	TokenNameimplements	
Comparable	TokenNameIdentifier	 Comparable
<	TokenNameLESS	
DataDirectory	TokenNameIdentifier	 Data Directory
>	TokenNameGREATER	
{	TokenNameLBRACE	
public	TokenNamepublic	
final	TokenNamefinal	
File	TokenNameIdentifier	 File
location	TokenNameIdentifier	 location
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
currentTasks	TokenNameIdentifier	 current Tasks
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicInteger	TokenNameIdentifier	 Atomic Integer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
final	TokenNamefinal	
AtomicLong	TokenNameIdentifier	 Atomic Long
estimatedWorkingSize	TokenNameIdentifier	 estimated Working Size
=	TokenNameEQUAL	
new	TokenNamenew	
AtomicLong	TokenNameIdentifier	 Atomic Long
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
DataDirectory	TokenNameIdentifier	 Data Directory
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
location	TokenNameIdentifier	 location
=	TokenNameEQUAL	
location	TokenNameIdentifier	 location
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * @return estimated available disk space for bounded directory, * excluding the expected size written by tasks in the queue. */	TokenNameCOMMENT_JAVADOC	 @return estimated available disk space for bounded directory, excluding the expected size written by tasks in the queue. 
public	TokenNamepublic	
long	TokenNamelong	
getEstimatedAvailableSpace	TokenNameIdentifier	 get Estimated Available Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Load factor of 0.9 we do not want to use the entire disk that is too risky. 	TokenNameCOMMENT_LINE	Load factor of 0.9 we do not want to use the entire disk that is too risky. 
return	TokenNamereturn	
(	TokenNameLPAREN	
long	TokenNamelong	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
0.9	TokenNameDoubleLiteral	
*	TokenNameMULTIPLY	
location	TokenNameIdentifier	 location
.	TokenNameDOT	
getUsableSpace	TokenNameIdentifier	 get Usable Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
estimatedWorkingSize	TokenNameIdentifier	 estimated Working Size
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
compareTo	TokenNameIdentifier	 compare To
(	TokenNameLPAREN	
DataDirectory	TokenNameIdentifier	 Data Directory
o	TokenNameIdentifier	 o
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we want to sort by free space in descending order 	TokenNameCOMMENT_LINE	we want to sort by free space in descending order 
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
Longs	TokenNameIdentifier	 Longs
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
getEstimatedAvailableSpace	TokenNameIdentifier	 get Estimated Available Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
getEstimatedAvailableSpace	TokenNameIdentifier	 get Estimated Available Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
class	TokenNameclass	
SSTableLister	TokenNameIdentifier	 SS Table Lister
{	TokenNameLBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
skipTemporary	TokenNameIdentifier	 skip Temporary
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
includeBackups	TokenNameIdentifier	 include Backups
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
onlyBackups	TokenNameIdentifier	 only Backups
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
nbFiles	TokenNameIdentifier	 nb Files
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
components	TokenNameIdentifier	 components
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
filtered	TokenNameIdentifier	 filtered
;	TokenNameSEMICOLON	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
;	TokenNameSEMICOLON	
public	TokenNamepublic	
SSTableLister	TokenNameIdentifier	 SS Table Lister
skipTemporary	TokenNameIdentifier	 skip Temporary
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filtered	TokenNameIdentifier	 filtered
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"list() has already been called"	TokenNameStringLiteral	list() has already been called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
skipTemporary	TokenNameIdentifier	 skip Temporary
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableLister	TokenNameIdentifier	 SS Table Lister
includeBackups	TokenNameIdentifier	 include Backups
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filtered	TokenNameIdentifier	 filtered
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"list() has already been called"	TokenNameStringLiteral	list() has already been called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
includeBackups	TokenNameIdentifier	 include Backups
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableLister	TokenNameIdentifier	 SS Table Lister
onlyBackups	TokenNameIdentifier	 only Backups
(	TokenNameLPAREN	
boolean	TokenNameboolean	
b	TokenNameIdentifier	 b
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filtered	TokenNameIdentifier	 filtered
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"list() has already been called"	TokenNameStringLiteral	list() has already been called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
onlyBackups	TokenNameIdentifier	 only Backups
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
includeBackups	TokenNameIdentifier	 include Backups
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
SSTableLister	TokenNameIdentifier	 SS Table Lister
snapshots	TokenNameIdentifier	 snapshots
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sn	TokenNameIdentifier	 sn
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filtered	TokenNameIdentifier	 filtered
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"list() has already been called"	TokenNameStringLiteral	list() has already been called
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
snapshotName	TokenNameIdentifier	 snapshot Name
=	TokenNameEQUAL	
sn	TokenNameIdentifier	 sn
;	TokenNameSEMICOLON	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Map	TokenNameIdentifier	 Map
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
list	TokenNameIdentifier	 list
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ImmutableMap	TokenNameIdentifier	 Immutable Map
.	TokenNameDOT	
copyOf	TokenNameIdentifier	 copy Of
(	TokenNameLPAREN	
components	TokenNameIdentifier	 components
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
File	TokenNameIdentifier	 File
>	TokenNameGREATER	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
File	TokenNameIdentifier	 File
>	TokenNameGREATER	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
<	TokenNameLESS	
File	TokenNameIdentifier	 File
>	TokenNameGREATER	
(	TokenNameLPAREN	
nbFiles	TokenNameIdentifier	 nb Files
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>>	TokenNameRIGHT_SHIFT	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
c	TokenNameIdentifier	 c
:	TokenNameCOLON	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
l	TokenNameIdentifier	 l
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
filenameFor	TokenNameIdentifier	 filename For
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
l	TokenNameIdentifier	 l
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
filtered	TokenNameIdentifier	 filtered
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
location	TokenNameIdentifier	 location
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
BlacklistedDirectories	TokenNameIdentifier	 Blacklisted Directories
.	TokenNameDOT	
isUnreadable	TokenNameIdentifier	 is Unreadable
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
snapshotName	TokenNameIdentifier	 snapshot Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
getFilter	TokenNameIdentifier	 get Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
onlyBackups	TokenNameIdentifier	 only Backups
)	TokenNameRPAREN	
location	TokenNameIdentifier	 location
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
getFilter	TokenNameIdentifier	 get Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
includeBackups	TokenNameIdentifier	 include Backups
)	TokenNameRPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
BACKUPS_SUBDIR	TokenNameIdentifier	 BACKUPS  SUBDIR
)	TokenNameRPAREN	
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
getFilter	TokenNameIdentifier	 get Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
filtered	TokenNameIdentifier	 filtered
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
FileFilter	TokenNameIdentifier	 File Filter
getFilter	TokenNameIdentifier	 get Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Note: the prefix needs to include cfname + separator to distinguish between a cfs and it's secondary indexes 	TokenNameCOMMENT_LINE	Note: the prefix needs to include cfname + separator to distinguish between a cfs and it's secondary indexes 
final	TokenNamefinal	
String	TokenNameIdentifier	 String
sstablePrefix	TokenNameIdentifier	 sstable Prefix
=	TokenNameEQUAL	
tablename	TokenNameIdentifier	 tablename
+	TokenNamePLUS	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
+	TokenNamePLUS	
cfname	TokenNameIdentifier	 cfname
+	TokenNamePLUS	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
FileFilter	TokenNameIdentifier	 File Filter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This function always return false since accepts adds to the components map 	TokenNameCOMMENT_LINE	This function always return false since accepts adds to the components map 
public	TokenNamepublic	
boolean	TokenNameboolean	
accept	TokenNameIdentifier	 accept
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// we are only interested in the SSTable files that belong to the specific ColumnFamily 	TokenNameCOMMENT_LINE	we are only interested in the SSTable files that belong to the specific ColumnFamily 
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
sstablePrefix	TokenNameIdentifier	 sstable Prefix
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Pair	TokenNameIdentifier	 Pair
<	TokenNameLESS	
Descriptor	TokenNameIdentifier	 Descriptor
,	TokenNameCOMMA	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
pair	TokenNameIdentifier	 pair
=	TokenNameEQUAL	
SSTable	TokenNameIdentifier	 SS Table
.	TokenNameDOT	
tryComponentFromFilename	TokenNameIdentifier	 try Component From Filename
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
skipTemporary	TokenNameIdentifier	 skip Temporary
&&	TokenNameAND_AND	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
left	TokenNameIdentifier	 left
.	TokenNameDOT	
temporary	TokenNameIdentifier	 temporary
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
left	TokenNameIdentifier	 left
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
previous	TokenNameIdentifier	 previous
=	TokenNameEQUAL	
new	TokenNamenew	
HashSet	TokenNameIdentifier	 Hash Set
<	TokenNameLESS	
Component	TokenNameIdentifier	 Component
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
components	TokenNameIdentifier	 components
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
left	TokenNameIdentifier	 left
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
pair	TokenNameIdentifier	 pair
.	TokenNameDOT	
right	TokenNameIdentifier	 right
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
nbFiles	TokenNameIdentifier	 nb Files
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
File	TokenNameIdentifier	 File
tryGetLeveledManifest	TokenNameIdentifier	 try Get Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
+	TokenNamePLUS	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
.	TokenNameDOT	
EXTENSION	TokenNameIdentifier	 EXTENSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Found manifest at {}"	TokenNameStringLiteral	Found manifest at {}
,	TokenNameCOMMA	
manifestFile	TokenNameIdentifier	 manifest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
manifestFile	TokenNameIdentifier	 manifest File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"No level manifest found"	TokenNameStringLiteral	No level manifest found
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
File	TokenNameIdentifier	 File
getOrCreateLeveledManifest	TokenNameIdentifier	 get Or Create Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
tryGetLeveledManifest	TokenNameIdentifier	 try Get Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifestFile	TokenNameIdentifier	 manifest File
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
manifestFile	TokenNameIdentifier	 manifest File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
sstableDirectories	TokenNameIdentifier	 sstable Directories
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
+	TokenNamePLUS	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
.	TokenNameDOT	
EXTENSION	TokenNameIdentifier	 EXTENSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
manifestFile	TokenNameIdentifier	 manifest File
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
snapshotLeveledManifest	TokenNameIdentifier	 snapshot Leveled Manifest
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
manifest	TokenNameIdentifier	 manifest
=	TokenNameEQUAL	
tryGetLeveledManifest	TokenNameIdentifier	 try Get Leveled Manifest
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDirectory	TokenNameIdentifier	 snapshot Directory
=	TokenNameEQUAL	
getOrCreate	TokenNameIdentifier	 get Or Create
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
getParentFile	TokenNameIdentifier	 get Parent File
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
snapshotDirectory	TokenNameIdentifier	 snapshot Directory
,	TokenNameCOMMA	
manifest	TokenNameIdentifier	 manifest
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
createHardLink	TokenNameIdentifier	 create Hard Link
(	TokenNameLPAREN	
manifest	TokenNameIdentifier	 manifest
,	TokenNameCOMMA	
target	TokenNameIdentifier	 target
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
snapshotExists	TokenNameIdentifier	 snapshot Exists
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDir	TokenNameIdentifier	 snapshot Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
clearSnapshot	TokenNameIdentifier	 clear Snapshot
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If snapshotName is empty or null, we will delete the entire snapshot directory 	TokenNameCOMMENT_LINE	If snapshotName is empty or null, we will delete the entire snapshot directory 
String	TokenNameIdentifier	 String
tag	TokenNameIdentifier	 tag
=	TokenNameEQUAL	
snapshotName	TokenNameIdentifier	 snapshot Name
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
snapshotName	TokenNameIdentifier	 snapshot Name
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDir	TokenNameIdentifier	 snapshot Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
tag	TokenNameIdentifier	 tag
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
isDebugEnabled	TokenNameIdentifier	 is Debug Enabled
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
"Removing snapshot directory "	TokenNameStringLiteral	Removing snapshot directory 
+	TokenNamePLUS	
snapshotDir	TokenNameIdentifier	 snapshot Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
deleteRecursive	TokenNameIdentifier	 delete Recursive
(	TokenNameLPAREN	
snapshotDir	TokenNameIdentifier	 snapshot Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// The snapshot must exist 	TokenNameCOMMENT_LINE	The snapshot must exist 
public	TokenNamepublic	
long	TokenNamelong	
snapshotCreationTime	TokenNameIdentifier	 snapshot Creation Time
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
sstableDirectories	TokenNameIdentifier	 sstable Directories
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDir	TokenNameIdentifier	 snapshot Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshotName	TokenNameIdentifier	 snapshot Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
lastModified	TokenNameIdentifier	 last Modified
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Snapshot "	TokenNameStringLiteral	Snapshot 
+	TokenNamePLUS	
snapshotName	TokenNameIdentifier	 snapshot Name
+	TokenNamePLUS	
" doesn't exist"	TokenNameStringLiteral	 doesn't exist
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
File	TokenNameIdentifier	 File
getOrCreate	TokenNameIdentifier	 get Or Create
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
subdirs	TokenNameIdentifier	 subdirs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
dir	TokenNameIdentifier	 dir
=	TokenNameEQUAL	
subdirs	TokenNameIdentifier	 subdirs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
subdirs	TokenNameIdentifier	 subdirs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
base	TokenNameIdentifier	 base
:	TokenNameCOLON	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
base	TokenNameIdentifier	 base
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
subdirs	TokenNameIdentifier	 subdirs
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
AssertionError	TokenNameIdentifier	 Assertion Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Invalid directory path %s: path exists but is not a directory"	TokenNameStringLiteral	Invalid directory path %s: path exists but is not a directory
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
mkdirs	TokenNameIdentifier	 mkdirs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
FSWriteError	TokenNameIdentifier	 FS Write Error
(	TokenNameLPAREN	
new	TokenNamenew	
IOException	TokenNameIdentifier	 IO Exception
(	TokenNameLPAREN	
"Unable to create directory "	TokenNameStringLiteral	Unable to create directory 
+	TokenNamePLUS	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dir	TokenNameIdentifier	 dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
dir	TokenNameIdentifier	 dir
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
String	TokenNameIdentifier	 String
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
...	TokenNameELLIPSIS	
s	TokenNameIdentifier	 s
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
StringUtils	TokenNameIdentifier	 String Utils
.	TokenNameDOT	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
s	TokenNameIdentifier	 s
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * To check if sstables needs migration, we look at the System directory. * If it does not contain a directory for the schema cfs, we'll attempt a sstable * migration. * * Note that it is mostly harmless to try a migration uselessly, except * maybe for some wasted cpu cycles. */	TokenNameCOMMENT_JAVADOC	 To check if sstables needs migration, we look at the System directory. If it does not contain a directory for the schema cfs, we'll attempt a sstable migration. * Note that it is mostly harmless to try a migration uselessly, except maybe for some wasted cpu cycles. 
public	TokenNamepublic	
static	TokenNamestatic	
boolean	TokenNameboolean	
sstablesNeedsMigration	TokenNameIdentifier	 sstables Needs Migration
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
StorageService	TokenNameIdentifier	 Storage Service
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
isClientMode	TokenNameIdentifier	 is Client Mode
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
hasSystemKeyspace	TokenNameIdentifier	 has System Keyspace
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DataDirectory	TokenNameIdentifier	 Data Directory
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
dataFileLocations	TokenNameIdentifier	 data File Locations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
systemDir	TokenNameIdentifier	 system Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
Table	TokenNameIdentifier	 Table
.	TokenNameDOT	
SYSTEM_KS	TokenNameIdentifier	 SYSTEM  KS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hasSystemKeyspace	TokenNameIdentifier	 has System Keyspace
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
systemDir	TokenNameIdentifier	 system Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
systemDir	TokenNameIdentifier	 system Dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
statusCFDir	TokenNameIdentifier	 status CF Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
systemDir	TokenNameIdentifier	 system Dir
,	TokenNameCOMMA	
SystemTable	TokenNameIdentifier	 System Table
.	TokenNameDOT	
SCHEMA_KEYSPACES_CF	TokenNameIdentifier	 SCHEMA  KEYSPACES  CF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
statusCFDir	TokenNameIdentifier	 status CF Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasSystemKeyspace	TokenNameIdentifier	 has System Keyspace
)	TokenNameRPAREN	
// This is a brand new node. 	TokenNameCOMMENT_LINE	This is a brand new node. 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Check whether the migration might create too long a filename 	TokenNameCOMMENT_LINE	Check whether the migration might create too long a filename 
int	TokenNameint	
longestLocation	TokenNameIdentifier	 longest Location
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DataDirectory	TokenNameIdentifier	 Data Directory
loc	TokenNameIdentifier	 loc
:	TokenNameCOLON	
dataFileLocations	TokenNameIdentifier	 data File Locations
)	TokenNameRPAREN	
longestLocation	TokenNameIdentifier	 longest Location
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
longestLocation	TokenNameIdentifier	 longest Location
,	TokenNameCOMMA	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
getCanonicalPath	TokenNameIdentifier	 get Canonical Path
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
.	TokenNameDOT	
location	TokenNameIdentifier	 location
)	TokenNameRPAREN	
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check that migration won't error out halfway through from too-long paths. For Windows, we need to check 	TokenNameCOMMENT_LINE	Check that migration won't error out halfway through from too-long paths. For Windows, we need to check 
// total path length <= 255 (see http://msdn.microsoft.com/en-us/library/aa365247.aspx and discussion on CASSANDRA-2749); 	TokenNameCOMMENT_LINE	total path length <= 255 (see http://msdn.microsoft.com/en-us/library/aa365247.aspx and discussion on CASSANDRA-2749); 
// elsewhere, we just need to make sure filename is <= 255. 	TokenNameCOMMENT_LINE	elsewhere, we just need to make sure filename is <= 255. 
for	TokenNamefor	
(	TokenNameLPAREN	
KSMetaData	TokenNameIdentifier	 KS Meta Data
ksm	TokenNameIdentifier	 ksm
:	TokenNameCOLON	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
instance	TokenNameIdentifier	 instance
.	TokenNameDOT	
getTableDefinitions	TokenNameIdentifier	 get Table Definitions
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
ksname	TokenNameIdentifier	 ksname
=	TokenNameEQUAL	
ksm	TokenNameIdentifier	 ksm
.	TokenNameDOT	
name	TokenNameIdentifier	 name
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
<	TokenNameLESS	
String	TokenNameIdentifier	 String
,	TokenNameCOMMA	
CFMetaData	TokenNameIdentifier	 CF Meta Data
>	TokenNameGREATER	
entry	TokenNameIdentifier	 entry
:	TokenNameCOLON	
ksm	TokenNameIdentifier	 ksm
.	TokenNameDOT	
cfMetaData	TokenNameIdentifier	 cf Meta Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
=	TokenNameEQUAL	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// max path is roughly (guess-estimate) <location>/ksname/cfname/snapshots/1324314347102-somename/ksname-cfname-tmp-hb-65536-Statistics.db 	TokenNameCOMMENT_LINE	max path is roughly (guess-estimate) <location>/ksname/cfname/snapshots/1324314347102-somename/ksname-cfname-tmp-hb-65536-Statistics.db 
if	TokenNameif	
(	TokenNameLPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
"os.name"	TokenNameStringLiteral	os.name
)	TokenNameRPAREN	
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"Windows"	TokenNameStringLiteral	Windows
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
longestLocation	TokenNameIdentifier	 longest Location
+	TokenNamePLUS	
(	TokenNameLPAREN	
ksname	TokenNameIdentifier	 ksname
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
+	TokenNamePLUS	
63	TokenNameIntegerLiteral	
>	TokenNameGREATER	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"Starting with 1.1, keyspace names and column family "	TokenNameStringLiteral	Starting with 1.1, keyspace names and column family 
+	TokenNamePLUS	
"names must be less than %s characters long. %s/%s doesn't"	TokenNameStringLiteral	names must be less than %s characters long. %s/%s doesn't
+	TokenNamePLUS	
" respect that restriction. Please rename your "	TokenNameStringLiteral	 respect that restriction. Please rename your 
+	TokenNamePLUS	
"keyspace/column families to respect that restriction "	TokenNameStringLiteral	keyspace/column families to respect that restriction 
+	TokenNamePLUS	
"before updating."	TokenNameStringLiteral	before updating.
,	TokenNameCOMMA	
Schema	TokenNameIdentifier	 Schema
.	TokenNameDOT	
NAME_LENGTH	TokenNameIdentifier	 NAME  LENGTH
,	TokenNameCOMMA	
ksname	TokenNameIdentifier	 ksname
,	TokenNameCOMMA	
cfname	TokenNameIdentifier	 cfname
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ksm	TokenNameIdentifier	 ksm
.	TokenNameDOT	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
28	TokenNameIntegerLiteral	
>	TokenNameGREATER	
255	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"Starting with 1.1, the keyspace name is included in data filenames. For "	TokenNameStringLiteral	Starting with 1.1, the keyspace name is included in data filenames. For 
+	TokenNamePLUS	
ksm	TokenNameIdentifier	 ksm
.	TokenNameDOT	
name	TokenNameIdentifier	 name
+	TokenNamePLUS	
"/"	TokenNameStringLiteral	/
+	TokenNamePLUS	
cfname	TokenNameIdentifier	 cfname
+	TokenNamePLUS	
", this puts you over the largest possible filename of 255 characters"	TokenNameStringLiteral	, this puts you over the largest possible filename of 255 characters
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Move sstables from the pre-#2749 layout to their new location/names. * This involves: * - moving each sstable to their CF specific directory * - rename the sstable to include the keyspace in the filename * * Note that this also move leveled manifests, snapshots and backups. */	TokenNameCOMMENT_JAVADOC	 Move sstables from the pre-#2749 layout to their new location/names. This involves: - moving each sstable to their CF specific directory - rename the sstable to include the keyspace in the filename * Note that this also move leveled manifests, snapshots and backups. 
public	TokenNamepublic	
static	TokenNamestatic	
void	TokenNamevoid	
migrateSSTables	TokenNameIdentifier	 migrate SS Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Upgrade from pre-1.1 version detected: migrating sstables to new directory layout"	TokenNameStringLiteral	Upgrade from pre-1.1 version detected: migrating sstables to new directory layout
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
DataDirectory	TokenNameIdentifier	 Data Directory
dir	TokenNameIdentifier	 dir
:	TokenNameCOLON	
dataFileLocations	TokenNameIdentifier	 data File Locations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
location	TokenNameIdentifier	 location
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
location	TokenNameIdentifier	 location
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ksDirs	TokenNameIdentifier	 ks Dirs
=	TokenNameEQUAL	
dir	TokenNameIdentifier	 dir
.	TokenNameDOT	
location	TokenNameIdentifier	 location
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ksDirs	TokenNameIdentifier	 ks Dirs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
ksDir	TokenNameIdentifier	 ks Dir
:	TokenNameCOLON	
ksDirs	TokenNameIdentifier	 ks Dirs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ksDir	TokenNameIdentifier	 ks Dir
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
ksDir	TokenNameIdentifier	 ks Dir
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
:	TokenNameCOLON	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
migrateFile	TokenNameIdentifier	 migrate File
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
migrateSnapshots	TokenNameIdentifier	 migrate Snapshots
(	TokenNameLPAREN	
ksDir	TokenNameIdentifier	 ks Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
migrateBackups	TokenNameIdentifier	 migrate Backups
(	TokenNameLPAREN	
ksDir	TokenNameIdentifier	 ks Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
migrateSnapshots	TokenNameIdentifier	 migrate Snapshots
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
ksDir	TokenNameIdentifier	 ks Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
snapshotDir	TokenNameIdentifier	 snapshot Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
snapshots	TokenNameIdentifier	 snapshots
=	TokenNameEQUAL	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
snapshots	TokenNameIdentifier	 snapshots
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
snapshot	TokenNameIdentifier	 snapshot
:	TokenNameCOLON	
snapshots	TokenNameIdentifier	 snapshots
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
snapshot	TokenNameIdentifier	 snapshot
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
snapshot	TokenNameIdentifier	 snapshot
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
:	TokenNameCOLON	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
migrateFile	TokenNameIdentifier	 migrate File
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
join	TokenNameIdentifier	 join
(	TokenNameLPAREN	
SNAPSHOT_SUBDIR	TokenNameIdentifier	 SNAPSHOT  SUBDIR
,	TokenNameCOMMA	
snapshot	TokenNameIdentifier	 snapshot
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
snapshot	TokenNameIdentifier	 snapshot
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Old snapsot directory {} not deleted by migraation as it is not empty"	TokenNameStringLiteral	Old snapsot directory {} not deleted by migraation as it is not empty
,	TokenNameCOMMA	
snapshot	TokenNameIdentifier	 snapshot
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
snapshotDir	TokenNameIdentifier	 snapshot Dir
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Old directory {} not deleted by migration as it is not empty"	TokenNameStringLiteral	Old directory {} not deleted by migration as it is not empty
,	TokenNameCOMMA	
snapshotDir	TokenNameIdentifier	 snapshot Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
migrateBackups	TokenNameIdentifier	 migrate Backups
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
ksDir	TokenNameIdentifier	 ks Dir
)	TokenNameRPAREN	
{	TokenNameLBRACE	
File	TokenNameIdentifier	 File
backupDir	TokenNameIdentifier	 backup Dir
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
BACKUPS_SUBDIR	TokenNameIdentifier	 BACKUPS  SUBDIR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
backupDir	TokenNameIdentifier	 backup Dir
.	TokenNameDOT	
exists	TokenNameIdentifier	 exists
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
files	TokenNameIdentifier	 files
=	TokenNameEQUAL	
backupDir	TokenNameIdentifier	 backup Dir
.	TokenNameDOT	
listFiles	TokenNameIdentifier	 list Files
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
files	TokenNameIdentifier	 files
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
f	TokenNameIdentifier	 f
:	TokenNameCOLON	
files	TokenNameIdentifier	 files
)	TokenNameRPAREN	
migrateFile	TokenNameIdentifier	 migrate File
(	TokenNameLPAREN	
f	TokenNameIdentifier	 f
,	TokenNameCOMMA	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
BACKUPS_SUBDIR	TokenNameIdentifier	 BACKUPS  SUBDIR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
backupDir	TokenNameIdentifier	 backup Dir
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
info	TokenNameIdentifier	 info
(	TokenNameLPAREN	
"Old directory {} not deleted by migration as it is not empty"	TokenNameStringLiteral	Old directory {} not deleted by migration as it is not empty
,	TokenNameCOMMA	
backupDir	TokenNameIdentifier	 backup Dir
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
void	TokenNamevoid	
migrateFile	TokenNameIdentifier	 migrate File
(	TokenNameLPAREN	
File	TokenNameIdentifier	 File
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
File	TokenNameIdentifier	 File
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
additionalPath	TokenNameIdentifier	 additional Path
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
isDirectory	TokenNameIdentifier	 is Directory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isManifest	TokenNameIdentifier	 is Manifest
=	TokenNameEQUAL	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
endsWith	TokenNameIdentifier	 ends With
(	TokenNameLPAREN	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
.	TokenNameDOT	
EXTENSION	TokenNameIdentifier	 EXTENSION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cfname	TokenNameIdentifier	 cfname
=	TokenNameEQUAL	
isManifest	TokenNameIdentifier	 is Manifest
?	TokenNameQUESTION	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
LeveledManifest	TokenNameIdentifier	 Leveled Manifest
.	TokenNameDOT	
EXTENSION	TokenNameIdentifier	 EXTENSION
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
idx	TokenNameIdentifier	 idx
=	TokenNameEQUAL	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
indexOf	TokenNameIdentifier	 index Of
(	TokenNameLPAREN	
SECONDARY_INDEX_NAME_SEPARATOR	TokenNameIdentifier	 SECONDARY  INDEX  NAME  SEPARATOR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// idx > 0 => secondary index 	TokenNameCOMMENT_LINE	idx > 0 => secondary index 
String	TokenNameIdentifier	 String
dirname	TokenNameIdentifier	 dirname
=	TokenNameEQUAL	
idx	TokenNameIdentifier	 idx
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
cfname	TokenNameIdentifier	 cfname
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
idx	TokenNameIdentifier	 idx
)	TokenNameRPAREN	
:	TokenNameCOLON	
cfname	TokenNameIdentifier	 cfname
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
destDir	TokenNameIdentifier	 dest Dir
=	TokenNameEQUAL	
getOrCreate	TokenNameIdentifier	 get Or Create
(	TokenNameLPAREN	
ksDir	TokenNameIdentifier	 ks Dir
,	TokenNameCOMMA	
dirname	TokenNameIdentifier	 dirname
,	TokenNameCOMMA	
additionalPath	TokenNameIdentifier	 additional Path
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
File	TokenNameIdentifier	 File
destFile	TokenNameIdentifier	 dest File
=	TokenNameEQUAL	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
destDir	TokenNameIdentifier	 dest Dir
,	TokenNameCOMMA	
isManifest	TokenNameIdentifier	 is Manifest
?	TokenNameQUESTION	
name	TokenNameIdentifier	 name
:	TokenNameCOLON	
ksDir	TokenNameIdentifier	 ks Dir
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
Component	TokenNameIdentifier	 Component
.	TokenNameDOT	
separator	TokenNameIdentifier	 separator
+	TokenNamePLUS	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
logger	TokenNameIdentifier	 logger
.	TokenNameDOT	
debug	TokenNameIdentifier	 debug
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
format	TokenNameIdentifier	 format
(	TokenNameLPAREN	
"[upgrade to 1.1] Moving %s to %s"	TokenNameStringLiteral	[upgrade to 1.1] Moving %s to %s
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileUtils	TokenNameIdentifier	 File Utils
.	TokenNameDOT	
renameWithConfirm	TokenNameIdentifier	 rename With Confirm
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
destFile	TokenNameIdentifier	 dest File
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Hack for tests, don't use otherwise 	TokenNameCOMMENT_LINE	Hack for tests, don't use otherwise 
static	TokenNamestatic	
void	TokenNamevoid	
overrideDataDirectoriesForTest	TokenNameIdentifier	 override Data Directories For Test
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
dataFileLocations	TokenNameIdentifier	 data File Locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
dataFileLocations	TokenNameIdentifier	 data File Locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DataDirectory	TokenNameIdentifier	 Data Directory
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
loc	TokenNameIdentifier	 loc
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Hack for tests, don't use otherwise 	TokenNameCOMMENT_LINE	Hack for tests, don't use otherwise 
static	TokenNamestatic	
void	TokenNamevoid	
resetDataDirectoriesAfterTest	TokenNameIdentifier	 reset Data Directories After Test
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locations	TokenNameIdentifier	 locations
=	TokenNameEQUAL	
DatabaseDescriptor	TokenNameIdentifier	 Database Descriptor
.	TokenNameDOT	
getAllDataFileLocations	TokenNameIdentifier	 get All Data File Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
dataFileLocations	TokenNameIdentifier	 data File Locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
DataDirectory	TokenNameIdentifier	 Data Directory
(	TokenNameLPAREN	
new	TokenNamenew	
File	TokenNameIdentifier	 File
(	TokenNameLPAREN	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
