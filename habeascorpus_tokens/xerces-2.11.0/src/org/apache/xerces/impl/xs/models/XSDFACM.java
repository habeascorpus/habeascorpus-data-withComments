/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMNode	TokenNameIdentifier	 CM Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dtd	TokenNameIdentifier	 dtd
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMStateSet	TokenNameIdentifier	 CM State Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
/** * DFAContentModel is the implementation of XSCMValidator that does * all of the non-trivial element content validation. This class does * the conversion from the regular expression to the DFA that * it then uses in its validation algorithm. * * @xerces.internal * * @author Neil Graham, IBM * @version $Id: XSDFACM.java 806363 2009-08-20 21:18:48Z mrglavas $ */	TokenNameCOMMENT_JAVADOC	 DFAContentModel is the implementation of XSCMValidator that does all of the non-trivial element content validation. This class does the conversion from the regular expression to the DFA that it then uses in its validation algorithm. * @xerces.internal * @author Neil Graham, IBM @version $Id: XSDFACM.java 806363 2009-08-20 21:18:48Z mrglavas $ 
public	TokenNamepublic	
class	TokenNameclass	
XSDFACM	TokenNameIdentifier	 XSDFACM
implements	TokenNameimplements	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// special strings 	TokenNameCOMMENT_LINE	special strings 
// debugging 	TokenNameCOMMENT_LINE	debugging 
/** Set to true to debug content model validation. */	TokenNameCOMMENT_JAVADOC	 Set to true to debug content model validation. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier	 DEBUG  VALIDATE  CONTENT
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** * This is the map of unique input symbol elements to indices into * each state's per-input symbol transition table entry. This is part * of the built DFA information that must be kept around to do the * actual validation. Note tat since either XSElementDecl or XSParticleDecl object * can live here, we've got to use an Object. */	TokenNameCOMMENT_JAVADOC	 This is the map of unique input symbol elements to indices into each state's per-input symbol transition table entry. This is part of the built DFA information that must be kept around to do the actual validation. Note tat since either XSElementDecl or XSParticleDecl object can live here, we've got to use an Object. 
private	TokenNameprivate	
Object	TokenNameIdentifier	 Object
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * This is a map of whether the element map contains information * related to ANY models. */	TokenNameCOMMENT_JAVADOC	 This is a map of whether the element map contains information related to ANY models. 
private	TokenNameprivate	
int	TokenNameint	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * id of the unique input symbol */	TokenNameCOMMENT_JAVADOC	 id of the unique input symbol 
private	TokenNameprivate	
int	TokenNameint	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** The element map size. */	TokenNameCOMMENT_JAVADOC	 The element map size. 
private	TokenNameprivate	
int	TokenNameint	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * This is an array of booleans, one per state (there are * fTransTableSize states in the DFA) that indicates whether that * state is a final state. */	TokenNameCOMMENT_JAVADOC	 This is an array of booleans, one per state (there are fTransTableSize states in the DFA) that indicates whether that state is a final state. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * The list of follow positions for each NFA position (i.e. for each * non-epsilon leaf node.) This is only used during the building of * the DFA, and is let go afterwards. */	TokenNameCOMMENT_JAVADOC	 The list of follow positions for each NFA position (i.e. for each non-epsilon leaf node.) This is only used during the building of the DFA, and is let go afterwards. 
private	TokenNameprivate	
CMStateSet	TokenNameIdentifier	 CM State Set
fFollowList	TokenNameIdentifier	 f Follow List
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * This is the head node of our intermediate representation. It is * only non-null during the building of the DFA (just so that it * does not have to be passed all around.) Once the DFA is built, * this is no longer required so its nulled out. */	TokenNameCOMMENT_JAVADOC	 This is the head node of our intermediate representation. It is only non-null during the building of the DFA (just so that it does not have to be passed all around.) Once the DFA is built, this is no longer required so its nulled out. 
private	TokenNameprivate	
CMNode	TokenNameIdentifier	 CM Node
fHeadNode	TokenNameIdentifier	 f Head Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * The count of leaf nodes. This is an important number that set some * limits on the sizes of data structures in the DFA process. */	TokenNameCOMMENT_JAVADOC	 The count of leaf nodes. This is an important number that set some limits on the sizes of data structures in the DFA process. 
private	TokenNameprivate	
int	TokenNameint	
fLeafCount	TokenNameIdentifier	 f Leaf Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/** * An array of non-epsilon leaf nodes, which is used during the DFA * build operation, then dropped. */	TokenNameCOMMENT_JAVADOC	 An array of non-epsilon leaf nodes, which is used during the DFA build operation, then dropped. 
private	TokenNameprivate	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Array mapping ANY types to the leaf list. */	TokenNameCOMMENT_JAVADOC	 Array mapping ANY types to the leaf list. 
private	TokenNameprivate	
int	TokenNameint	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * This is the transition table that is the main by product of all * of the effort here. It is an array of arrays of ints. The first * dimension is the number of states we end up with in the DFA. The * second dimensions is the number of unique elements in the content * model (fElemMapSize). Each entry in the second dimension indicates * the new state given that input for the first dimension's start * state. * <p> * The fElemMap array handles mapping from element indexes to * positions in the second dimension of the transition table. */	TokenNameCOMMENT_JAVADOC	 This is the transition table that is the main by product of all of the effort here. It is an array of arrays of ints. The first dimension is the number of states we end up with in the DFA. The second dimensions is the number of unique elements in the content model (fElemMapSize). Each entry in the second dimension indicates the new state given that input for the first dimension's start state. <p> The fElemMap array handles mapping from element indexes to positions in the second dimension of the transition table. 
private	TokenNameprivate	
int	TokenNameint	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** * Array containing occurence information for looping states * which use counters to check minOccurs/maxOccurs. */	TokenNameCOMMENT_JAVADOC	 Array containing occurence information for looping states which use counters to check minOccurs/maxOccurs. 
private	TokenNameprivate	
Occurence	TokenNameIdentifier	 Occurence
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fCountingStates	TokenNameIdentifier	 f Counting States
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
Occurence	TokenNameIdentifier	 Occurence
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
minOccurs	TokenNameIdentifier	 min Occurs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
maxOccurs	TokenNameIdentifier	 max Occurs
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Occurence	TokenNameIdentifier	 Occurence
(	TokenNameLPAREN	
XSCMRepeatingLeaf	TokenNameIdentifier	 XSCM Repeating Leaf
leaf	TokenNameIdentifier	 leaf
,	TokenNameCOMMA	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
minOccurs	TokenNameIdentifier	 min Occurs
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
.	TokenNameDOT	
getMinOccurs	TokenNameIdentifier	 get Min Occurs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
maxOccurs	TokenNameIdentifier	 max Occurs
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
.	TokenNameDOT	
getMaxOccurs	TokenNameIdentifier	 get Max Occurs
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
elemIndex	TokenNameIdentifier	 elem Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"minOccurs="	TokenNameStringLiteral	minOccurs=
+	TokenNamePLUS	
minOccurs	TokenNameIdentifier	 min Occurs
+	TokenNamePLUS	
";maxOccurs="	TokenNameStringLiteral	;maxOccurs=
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
maxOccurs	TokenNameIdentifier	 max Occurs
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
?	TokenNameQUESTION	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
maxOccurs	TokenNameIdentifier	 max Occurs
)	TokenNameRPAREN	
:	TokenNameCOLON	
"unbounded"	TokenNameStringLiteral	unbounded
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * The number of valid entries in the transition table, and in the other * related tables such as fFinalStateFlags. */	TokenNameCOMMENT_JAVADOC	 The number of valid entries in the transition table, and in the other related tables such as fFinalStateFlags. 
private	TokenNameprivate	
int	TokenNameint	
fTransTableSize	TokenNameIdentifier	 f Trans Table Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fIsCompactedForUPA	TokenNameIdentifier	 f Is Compacted For UPA
;	TokenNameSEMICOLON	
// temp variables 	TokenNameCOMMENT_LINE	temp variables 
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** * Constructs a DFA content model. * * @param syntaxTree The syntax tree of the content model. * @param leafCount The number of leaves. * * @exception RuntimeException Thrown if DFA can't be built. */	TokenNameCOMMENT_JAVADOC	 Constructs a DFA content model. * @param syntaxTree The syntax tree of the content model. @param leafCount The number of leaves. * @exception RuntimeException Thrown if DFA can't be built. 
public	TokenNamepublic	
XSDFACM	TokenNameIdentifier	 XSDFACM
(	TokenNameLPAREN	
CMNode	TokenNameIdentifier	 CM Node
syntaxTree	TokenNameIdentifier	 syntax Tree
,	TokenNameCOMMA	
int	TokenNameint	
leafCount	TokenNameIdentifier	 leaf Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Store away our index and pools in members 	TokenNameCOMMENT_LINE	Store away our index and pools in members 
fLeafCount	TokenNameIdentifier	 f Leaf Count
=	TokenNameEQUAL	
leafCount	TokenNameIdentifier	 leaf Count
;	TokenNameSEMICOLON	
fIsCompactedForUPA	TokenNameIdentifier	 f Is Compacted For UPA
=	TokenNameEQUAL	
syntaxTree	TokenNameIdentifier	 syntax Tree
.	TokenNameDOT	
isCompactedForUPA	TokenNameIdentifier	 is Compacted For UPA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Create some string pool indexes that represent the names of some 	TokenNameCOMMENT_LINE	Create some string pool indexes that represent the names of some 
// magical nodes in the syntax tree. 	TokenNameCOMMENT_LINE	magical nodes in the syntax tree. 
// (already done in static initialization... 	TokenNameCOMMENT_LINE	(already done in static initialization... 
// 	TokenNameCOMMENT_LINE	 
// 	TokenNameCOMMENT_LINE	 
// Ok, so lets grind through the building of the DFA. This method 	TokenNameCOMMENT_LINE	Ok, so lets grind through the building of the DFA. This method 
// handles the high level logic of the algorithm, but it uses a 	TokenNameCOMMENT_LINE	handles the high level logic of the algorithm, but it uses a 
// number of helper classes to do its thing. 	TokenNameCOMMENT_LINE	number of helper classes to do its thing. 
// 	TokenNameCOMMENT_LINE	 
// In order to avoid having hundreds of references to the error and 	TokenNameCOMMENT_LINE	In order to avoid having hundreds of references to the error and 
// string handlers around, this guy and all of his helper classes 	TokenNameCOMMENT_LINE	string handlers around, this guy and all of his helper classes 
// just throw a simple exception and we then pass it along. 	TokenNameCOMMENT_LINE	just throw a simple exception and we then pass it along. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier	 DEBUG  VALIDATE  CONTENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSDFACM	TokenNameIdentifier	 XSDFACM
.	TokenNameDOT	
time	TokenNameIdentifier	 time
-=	TokenNameMINUS_EQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
buildDFA	TokenNameIdentifier	 build DFA
(	TokenNameLPAREN	
syntaxTree	TokenNameIdentifier	 syntax Tree
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier	 DEBUG  VALIDATE  CONTENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSDFACM	TokenNameIdentifier	 XSDFACM
.	TokenNameDOT	
time	TokenNameIdentifier	 time
+=	TokenNamePLUS_EQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
currentTimeMillis	TokenNameIdentifier	 current Time Millis
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"DFA build: "	TokenNameStringLiteral	DFA build: 
+	TokenNamePLUS	
XSDFACM	TokenNameIdentifier	 XSDFACM
.	TokenNameDOT	
time	TokenNameIdentifier	 time
+	TokenNamePLUS	
"ms"	TokenNameStringLiteral	ms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
long	TokenNamelong	
time	TokenNameIdentifier	 time
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// XSCMValidator methods 	TokenNameCOMMENT_LINE	XSCMValidator methods 
// 	TokenNameCOMMENT_LINE	 
/** * check whether the given state is one of the final states * * @param state the state to check * * @return whether it's a final state */	TokenNameCOMMENT_JAVADOC	 check whether the given state is one of the final states * @param state the state to check * @return whether it's a final state 
public	TokenNamepublic	
boolean	TokenNameboolean	
isFinalState	TokenNameIdentifier	 is Final State
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
false	TokenNamefalse	
:	TokenNameCOLON	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * one transition only * * @param curElem The current element's QName * @param state stack to store the previous state * @param subGroupHandler the substitution group handler * * @return null if transition is invalid; otherwise the Object corresponding to the * XSElementDecl or XSWildcardDecl identified. Also, the * state array will be modified to include the new state; this so that the validator can * store it away. * * @exception RuntimeException thrown on error */	TokenNameCOMMENT_JAVADOC	 one transition only * @param curElem The current element's QName @param state stack to store the previous state @param subGroupHandler the substitution group handler * @return null if transition is invalid; otherwise the Object corresponding to the XSElementDecl or XSWildcardDecl identified. Also, the state array will be modified to include the new state; this so that the validator can store it away. * @exception RuntimeException thrown on error 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
oneTransition	TokenNameIdentifier	 one Transition
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
||	TokenNameOR_OR	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
SUBSEQUENT_ERROR	TokenNameIdentifier	 SUBSEQUENT  ERROR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// there was an error last time; so just go find correct Object in fElemmMap. 	TokenNameCOMMENT_LINE	there was an error last time; so just go find correct Object in fElemmMap. 
// ... after resetting state[0]. 	TokenNameCOMMENT_LINE	... after resetting state[0]. 
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
)	TokenNameRPAREN	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
SUBSEQUENT_ERROR	TokenNameIdentifier	 SUBSEQUENT  ERROR
;	TokenNameSEMICOLON	
return	TokenNamereturn	
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
nextState	TokenNameIdentifier	 next State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextState	TokenNameIdentifier	 next State
=	TokenNameEQUAL	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextState	TokenNameIdentifier	 next State
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
.	TokenNameDOT	
getMatchingElemDecl	TokenNameIdentifier	 get Matching Elem Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingDecl	TokenNameIdentifier	 matching Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if we still can't find a match, set the state to first_error 	TokenNameCOMMENT_LINE	if we still can't find a match, set the state to first_error 
// and return null 	TokenNameCOMMENT_LINE	and return null 
if	TokenNameif	
(	TokenNameLPAREN	
elemIndex	TokenNameIdentifier	 elem Index
==	TokenNameEQUAL_EQUAL	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
;	TokenNameSEMICOLON	
return	TokenNamereturn	
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCountingStates	TokenNameIdentifier	 f Counting States
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
nextState	TokenNameIdentifier	 next State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
>	TokenNameGREATER	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
&&	TokenNameAND_AND	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// It's likely that we looped too many times on the current state 	TokenNameCOMMENT_LINE	It's likely that we looped too many times on the current state 
// however it's possible that we actually matched another particle 	TokenNameCOMMENT_LINE	however it's possible that we actually matched another particle 
// which allows the same name. 	TokenNameCOMMENT_LINE	which allows the same name. 
// 	TokenNameCOMMENT_LINE	 
// Consider: 	TokenNameCOMMENT_LINE	Consider: 
// 	TokenNameCOMMENT_LINE	 
// <xs:sequence> 	TokenNameCOMMENT_LINE	<xs:sequence> 
// <xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/> 	TokenNameCOMMENT_LINE	<xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/> 
// <xs:element name="foo" type="xs:string" fixed="bar"/> 	TokenNameCOMMENT_LINE	<xs:element name="foo" type="xs:string" fixed="bar"/> 
// </xs:sequence> 	TokenNameCOMMENT_LINE	</xs:sequence> 
// 	TokenNameCOMMENT_LINE	 
// and 	TokenNameCOMMENT_LINE	and 
// 	TokenNameCOMMENT_LINE	 
// <xs:sequence> 	TokenNameCOMMENT_LINE	<xs:sequence> 
// <xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/> 	TokenNameCOMMENT_LINE	<xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/> 
// <xs:any namespace="##any" processContents="skip"/> 	TokenNameCOMMENT_LINE	<xs:any namespace="##any" processContents="skip"/> 
// </xs:sequence> 	TokenNameCOMMENT_LINE	</xs:sequence> 
// 	TokenNameCOMMENT_LINE	 
// In the DFA there will be two transitions from the current state which 	TokenNameCOMMENT_LINE	In the DFA there will be two transitions from the current state which 
// allow "foo". Note that this is not a UPA violation. The ambiguity of which 	TokenNameCOMMENT_LINE	allow "foo". Note that this is not a UPA violation. The ambiguity of which 
// transition to take is resolved by the current value of the counter. Since 	TokenNameCOMMENT_LINE	transition to take is resolved by the current value of the counter. Since 
// we've already seen enough instances of the first "foo" perhaps there is 	TokenNameCOMMENT_LINE	we've already seen enough instances of the first "foo" perhaps there is 
// another element declaration or wildcard deeper in the element map which 	TokenNameCOMMENT_LINE	another element declaration or wildcard deeper in the element map which 
// matches. 	TokenNameCOMMENT_LINE	matches. 
return	TokenNamereturn	
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
,	TokenNameCOMMA	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
<	TokenNameLESS	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not enough loops on the current state. 	TokenNameCOMMENT_LINE	not enough loops on the current state. 
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
;	TokenNameSEMICOLON	
return	TokenNamereturn	
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// Exiting a counting state. If we're entering a new 	TokenNameCOMMENT_LINE	Exiting a counting state. If we're entering a new 
// counting state, reset the counter. 	TokenNameCOMMENT_LINE	counting state, reset the counter. 
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
nextState	TokenNameIdentifier	 next State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elemIndex	TokenNameIdentifier	 elem Index
==	TokenNameEQUAL_EQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
nextState	TokenNameIdentifier	 next State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Entering a new counting state. Reset the counter. 	TokenNameCOMMENT_LINE	Entering a new counting state. Reset the counter. 
// If we've already seen one instance of the looping 	TokenNameCOMMENT_LINE	If we've already seen one instance of the looping 
// particle set the counter to 1, otherwise set it 	TokenNameCOMMENT_LINE	particle set the counter to 1, otherwise set it 
// to 0. 	TokenNameCOMMENT_LINE	to 0. 
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elemIndex	TokenNameIdentifier	 elem Index
==	TokenNameEQUAL_EQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
nextState	TokenNameIdentifier	 next State
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchingDecl	TokenNameIdentifier	 matching Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// oneTransition(QName, int[], SubstitutionGroupHandler): Object 	TokenNameCOMMENT_LINE	oneTransition(QName, int[], SubstitutionGroupHandler): Object 
Object	TokenNameIdentifier	 Object
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
.	TokenNameDOT	
getMatchingElemDecl	TokenNameIdentifier	 get Matching Elem Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingDecl	TokenNameIdentifier	 matching Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
matchingDecl	TokenNameIdentifier	 matching Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// findMatchingDecl(QName, SubstitutionGroupHandler): Object 	TokenNameCOMMENT_LINE	findMatchingDecl(QName, SubstitutionGroupHandler): Object 
Object	TokenNameIdentifier	 Object
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
subGroupHandler	TokenNameIdentifier	 sub Group Handler
,	TokenNameCOMMA	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
nextState	TokenNameIdentifier	 next State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextState	TokenNameIdentifier	 next State
=	TokenNameEQUAL	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextState	TokenNameIdentifier	 next State
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
.	TokenNameDOT	
getMatchingElemDecl	TokenNameIdentifier	 get Matching Elem Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matchingDecl	TokenNameIdentifier	 matching Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchingDecl	TokenNameIdentifier	 matching Decl
=	TokenNameEQUAL	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if we still can't find a match, set the state to FIRST_ERROR and return null 	TokenNameCOMMENT_LINE	if we still can't find a match, set the state to FIRST_ERROR and return null 
if	TokenNameif	
(	TokenNameLPAREN	
elemIndex	TokenNameIdentifier	 elem Index
==	TokenNameEQUAL_EQUAL	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
;	TokenNameSEMICOLON	
return	TokenNamereturn	
findMatchingDecl	TokenNameIdentifier	 find Matching Decl
(	TokenNameLPAREN	
curElem	TokenNameIdentifier	 cur Elem
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we found a match, set the next state and reset the 	TokenNameCOMMENT_LINE	if we found a match, set the next state and reset the 
// counter if the next state is a counting state. 	TokenNameCOMMENT_LINE	counter if the next state is a counting state. 
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
nextState	TokenNameIdentifier	 next State
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
nextState	TokenNameIdentifier	 next State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
elemIndex	TokenNameIdentifier	 elem Index
==	TokenNameEQUAL_EQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
elemIndex	TokenNameIdentifier	 elem Index
)	TokenNameRPAREN	
?	TokenNameQUESTION	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
matchingDecl	TokenNameIdentifier	 matching Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// findMatchingDecl(QName, int[], SubstitutionGroupHandler, int): Object 	TokenNameCOMMENT_LINE	findMatchingDecl(QName, int[], SubstitutionGroupHandler, int): Object 
// This method returns the start states of the content model. 	TokenNameCOMMENT_LINE	This method returns the start states of the content model. 
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
startContentModel	TokenNameIdentifier	 start Content Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// [0] : the current state 	TokenNameCOMMENT_LINE	[0] : the current state 
// [1] : if [0] is an error state then the 	TokenNameCOMMENT_LINE	[1] : if [0] is an error state then the 
// last valid state before the error 	TokenNameCOMMENT_LINE	last valid state before the error 
// [2] : occurence counter for counting states 	TokenNameCOMMENT_LINE	[2] : occurence counter for counting states 
return	TokenNamereturn	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startContentModel():int[] 	TokenNameCOMMENT_LINE	startContentModel():int[] 
// this method returns whether the last state was a valid final state 	TokenNameCOMMENT_LINE	this method returns whether the last state was a valid final state 
public	TokenNamepublic	
boolean	TokenNameboolean	
endContentModel	TokenNameIdentifier	 end Content Model
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCountingStates	TokenNameIdentifier	 f Counting States
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
<	TokenNameLESS	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// not enough loops on the current state to be considered final. 	TokenNameCOMMENT_LINE	not enough loops on the current state to be considered final. 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endContentModel(int[]): boolean 	TokenNameCOMMENT_LINE	endContentModel(int[]): boolean 
// Killed off whatCanGoHere; we may need it for DOM canInsert(...) etc., 	TokenNameCOMMENT_LINE	Killed off whatCanGoHere; we may need it for DOM canInsert(...) etc., 
// but we can put it back later. 	TokenNameCOMMENT_LINE	but we can put it back later. 
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
/** * Builds the internal DFA transition table from the given syntax tree. * * @param syntaxTree The syntax tree. * * @exception RuntimeException Thrown if DFA cannot be built. */	TokenNameCOMMENT_JAVADOC	 Builds the internal DFA transition table from the given syntax tree. * @param syntaxTree The syntax tree. * @exception RuntimeException Thrown if DFA cannot be built. 
private	TokenNameprivate	
void	TokenNamevoid	
buildDFA	TokenNameIdentifier	 build DFA
(	TokenNameLPAREN	
CMNode	TokenNameIdentifier	 CM Node
syntaxTree	TokenNameIdentifier	 syntax Tree
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// The first step we need to take is to rewrite the content model 	TokenNameCOMMENT_LINE	The first step we need to take is to rewrite the content model 
// using our CMNode objects, and in the process get rid of any 	TokenNameCOMMENT_LINE	using our CMNode objects, and in the process get rid of any 
// repetition short cuts, converting them into '*' style repetitions 	TokenNameCOMMENT_LINE	repetition short cuts, converting them into '*' style repetitions 
// or getting rid of repetitions altogether. 	TokenNameCOMMENT_LINE	or getting rid of repetitions altogether. 
// 	TokenNameCOMMENT_LINE	 
// The conversions done are: 	TokenNameCOMMENT_LINE	The conversions done are: 
// 	TokenNameCOMMENT_LINE	 
// x+ -> (x|x*) 	TokenNameCOMMENT_LINE	x+ -> (x|x*) 
// x? -> (x|epsilon) 	TokenNameCOMMENT_LINE	x? -> (x|epsilon) 
// 	TokenNameCOMMENT_LINE	 
// This is a relatively complex scenario. What is happening is that 	TokenNameCOMMENT_LINE	This is a relatively complex scenario. What is happening is that 
// we create a top level binary node of which the special EOC value 	TokenNameCOMMENT_LINE	we create a top level binary node of which the special EOC value 
// is set as the right side node. The the left side is set to the 	TokenNameCOMMENT_LINE	is set as the right side node. The the left side is set to the 
// rewritten syntax tree. The source is the original content model 	TokenNameCOMMENT_LINE	rewritten syntax tree. The source is the original content model 
// info from the decl pool. The rewrite is done by buildSyntaxTree() 	TokenNameCOMMENT_LINE	info from the decl pool. The rewrite is done by buildSyntaxTree() 
// which recurses the decl pool's content of the element and builds 	TokenNameCOMMENT_LINE	which recurses the decl pool's content of the element and builds 
// a new tree in the process. 	TokenNameCOMMENT_LINE	a new tree in the process. 
// 	TokenNameCOMMENT_LINE	 
// Note that, during this operation, we set each non-epsilon leaf 	TokenNameCOMMENT_LINE	Note that, during this operation, we set each non-epsilon leaf 
// node's DFA state position and count the number of such leafs, which 	TokenNameCOMMENT_LINE	node's DFA state position and count the number of such leafs, which 
// is left in the fLeafCount member. 	TokenNameCOMMENT_LINE	is left in the fLeafCount member. 
// 	TokenNameCOMMENT_LINE	 
// The nodeTmp object is passed in just as a temp node to use during 	TokenNameCOMMENT_LINE	The nodeTmp object is passed in just as a temp node to use during 
// the recursion. Otherwise, we'd have to create a new node on every 	TokenNameCOMMENT_LINE	the recursion. Otherwise, we'd have to create a new node on every 
// level of recursion, which would be piggy in Java (as is everything 	TokenNameCOMMENT_LINE	level of recursion, which would be piggy in Java (as is everything 
// for that matter.) 	TokenNameCOMMENT_LINE	for that matter.) 
// 	TokenNameCOMMENT_LINE	 
/* MODIFIED (Jan, 2001) * * Use following rules. * nullable(x+) := nullable(x), first(x+) := first(x), last(x+) := last(x) * nullable(x?) := true, first(x?) := first(x), last(x?) := last(x) * * The same computation of follow as x* is applied to x+ * * The modification drastically reduces computation time of * "(a, (b, a+, (c, (b, a+)+, a+, (d, (c, (b, a+)+, a+)+, (b, a+)+, a+)+)+)+)+" */	TokenNameCOMMENT_BLOCK	 MODIFIED (Jan, 2001) * Use following rules. nullable(x+) := nullable(x), first(x+) := first(x), last(x+) := last(x) nullable(x?) := true, first(x?) := first(x), last(x?) := last(x) * The same computation of follow as x* is applied to x+ * The modification drastically reduces computation time of "(a, (b, a+, (c, (b, a+)+, a+, (d, (c, (b, a+)+, a+)+, (b, a+)+, a+)+)+)+)+" 
// 	TokenNameCOMMENT_LINE	 
// And handle specially the EOC node, which also must be numbered 	TokenNameCOMMENT_LINE	And handle specially the EOC node, which also must be numbered 
// and counted as a non-epsilon leaf node. It could not be handled 	TokenNameCOMMENT_LINE	and counted as a non-epsilon leaf node. It could not be handled 
// in the above tree build because it was created before all that 	TokenNameCOMMENT_LINE	in the above tree build because it was created before all that 
// started. We save the EOC position since its used during the DFA 	TokenNameCOMMENT_LINE	started. We save the EOC position since its used during the DFA 
// building loop. 	TokenNameCOMMENT_LINE	building loop. 
// 	TokenNameCOMMENT_LINE	 
int	TokenNameint	
EOCPos	TokenNameIdentifier	 EOC Pos
=	TokenNameEQUAL	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
nodeEOC	TokenNameIdentifier	 node EOC
=	TokenNameEQUAL	
new	TokenNamenew	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
(	TokenNameLPAREN	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fLeafCount	TokenNameIdentifier	 f Leaf Count
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fHeadNode	TokenNameIdentifier	 f Head Node
=	TokenNameEQUAL	
new	TokenNamenew	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
(	TokenNameLPAREN	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
,	TokenNameCOMMA	
syntaxTree	TokenNameIdentifier	 syntax Tree
,	TokenNameCOMMA	
nodeEOC	TokenNameIdentifier	 node EOC
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Ok, so now we have to iterate the new tree and do a little more 	TokenNameCOMMENT_LINE	Ok, so now we have to iterate the new tree and do a little more 
// work now that we know the leaf count. One thing we need to do is 	TokenNameCOMMENT_LINE	work now that we know the leaf count. One thing we need to do is 
// to calculate the first and last position sets of each node. This 	TokenNameCOMMENT_LINE	to calculate the first and last position sets of each node. This 
// is cached away in each of the nodes. 	TokenNameCOMMENT_LINE	is cached away in each of the nodes. 
// 	TokenNameCOMMENT_LINE	 
// Along the way we also set the leaf count in each node as the 	TokenNameCOMMENT_LINE	Along the way we also set the leaf count in each node as the 
// maximum state count. They must know this in order to create their 	TokenNameCOMMENT_LINE	maximum state count. They must know this in order to create their 
// first/last pos sets. 	TokenNameCOMMENT_LINE	first/last pos sets. 
// 	TokenNameCOMMENT_LINE	 
// We also need to build an array of references to the non-epsilon 	TokenNameCOMMENT_LINE	We also need to build an array of references to the non-epsilon 
// leaf nodes. Since we iterate it in the same way as before, this 	TokenNameCOMMENT_LINE	leaf nodes. Since we iterate it in the same way as before, this 
// will put them in the array according to their position values. 	TokenNameCOMMENT_LINE	will put them in the array according to their position values. 
// 	TokenNameCOMMENT_LINE	 
fLeafList	TokenNameIdentifier	 f Leaf List
=	TokenNameEQUAL	
new	TokenNamenew	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
postTreeBuildInit	TokenNameIdentifier	 post Tree Build Init
(	TokenNameLPAREN	
fHeadNode	TokenNameIdentifier	 f Head Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// And, moving onward... We now need to build the follow position 	TokenNameCOMMENT_LINE	And, moving onward... We now need to build the follow position 
// sets for all the nodes. So we allocate an array of state sets, 	TokenNameCOMMENT_LINE	sets for all the nodes. So we allocate an array of state sets, 
// one for each leaf node (i.e. each DFA position.) 	TokenNameCOMMENT_LINE	one for each leaf node (i.e. each DFA position.) 
// 	TokenNameCOMMENT_LINE	 
fFollowList	TokenNameIdentifier	 f Follow List
=	TokenNameEQUAL	
new	TokenNamenew	
CMStateSet	TokenNameIdentifier	 CM State Set
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
fFollowList	TokenNameIdentifier	 f Follow List
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
CMStateSet	TokenNameIdentifier	 CM State Set
(	TokenNameLPAREN	
fLeafCount	TokenNameIdentifier	 f Leaf Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
fHeadNode	TokenNameIdentifier	 f Head Node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// And finally the big push... Now we build the DFA using all the 	TokenNameCOMMENT_LINE	And finally the big push... Now we build the DFA using all the 
// states and the tree we've built up. First we set up the various 	TokenNameCOMMENT_LINE	states and the tree we've built up. First we set up the various 
// data structures we are going to use while we do this. 	TokenNameCOMMENT_LINE	data structures we are going to use while we do this. 
// 	TokenNameCOMMENT_LINE	 
// First of all we need an array of unique element names in our 	TokenNameCOMMENT_LINE	First of all we need an array of unique element names in our 
// content model. For each transition table entry, we need a set of 	TokenNameCOMMENT_LINE	content model. For each transition table entry, we need a set of 
// contiguous indices to represent the transitions for a particular 	TokenNameCOMMENT_LINE	contiguous indices to represent the transitions for a particular 
// input element. So we need to a zero based range of indexes that 	TokenNameCOMMENT_LINE	input element. So we need to a zero based range of indexes that 
// map to element types. This element map provides that mapping. 	TokenNameCOMMENT_LINE	map to element types. This element map provides that mapping. 
// 	TokenNameCOMMENT_LINE	 
fElemMap	TokenNameIdentifier	 f Elem Map
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
Occurence	TokenNameIdentifier	 Occurence
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
outIndex	TokenNameIdentifier	 out Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
outIndex	TokenNameIdentifier	 out Index
<	TokenNameLESS	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
outIndex	TokenNameIdentifier	 out Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// optimization from Henry Zongaro: 	TokenNameCOMMENT_LINE	optimization from Henry Zongaro: 
//fElemMap[outIndex] = new Object (); 	TokenNameCOMMENT_LINE	fElemMap[outIndex] = new Object (); 
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
outIndex	TokenNameIdentifier	 out Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
inIndex	TokenNameIdentifier	 in Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
outIndex	TokenNameIdentifier	 out Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
getParticleId	TokenNameIdentifier	 get Particle Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
inIndex	TokenNameIdentifier	 in Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
inIndex	TokenNameIdentifier	 in Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
==	TokenNameEQUAL_EQUAL	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
[	TokenNameLBRACKET	
inIndex	TokenNameIdentifier	 in Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If it was not in the list, then add it, if not the EOC node 	TokenNameCOMMENT_LINE	If it was not in the list, then add it, if not the EOC node 
if	TokenNameif	
(	TokenNameLPAREN	
inIndex	TokenNameIdentifier	 in Index
==	TokenNameEQUAL_EQUAL	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
leaf	TokenNameIdentifier	 leaf
=	TokenNameEQUAL	
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
outIndex	TokenNameIdentifier	 out Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
.	TokenNameDOT	
getLeaf	TokenNameIdentifier	 get Leaf
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
leaf	TokenNameIdentifier	 leaf
instanceof	TokenNameinstanceof	
XSCMRepeatingLeaf	TokenNameIdentifier	 XSCM Repeating Leaf
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
=	TokenNameEQUAL	
new	TokenNamenew	
Occurence	TokenNameIdentifier	 Occurence
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
Occurence	TokenNameIdentifier	 Occurence
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMRepeatingLeaf	TokenNameIdentifier	 XSCM Repeating Leaf
)	TokenNameRPAREN	
leaf	TokenNameIdentifier	 leaf
,	TokenNameCOMMA	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
[	TokenNameLBRACKET	
outIndex	TokenNameIdentifier	 out Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// the last entry in the element map must be the EOC element. 	TokenNameCOMMENT_LINE	the last entry in the element map must be the EOC element. 
// remove it from the map. 	TokenNameCOMMENT_LINE	remove it from the map. 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
err	TokenNameIdentifier	 err
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"interal error in DFA: last element is not EOC."	TokenNameStringLiteral	interal error in DFA: last element is not EOC.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
/*** * Optimization(Jan, 2001); We sort fLeafList according to * elemIndex which is *uniquely* associated to each leaf. * We are *assuming* that each element appears in at least one leaf. **/	TokenNameCOMMENT_JAVADOC	* Optimization(Jan, 2001); We sort fLeafList according to elemIndex which is *uniquely* associated to each leaf. We are *assuming* that each element appears in at least one leaf. *
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLeafSorter	TokenNameIdentifier	 f Leaf Sorter
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fLeafCount	TokenNameIdentifier	 f Leaf Count
+	TokenNamePLUS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
fSortCount	TokenNameIdentifier	 f Sort Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
leafIndex	TokenNameIdentifier	 leaf Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
leafIndex	TokenNameIdentifier	 leaf Index
<	TokenNameLESS	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
leafIndex	TokenNameIdentifier	 leaf Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
==	TokenNameEQUAL_EQUAL	
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
leafIndex	TokenNameIdentifier	 leaf Index
]	TokenNameRBRACKET	
.	TokenNameDOT	
getParticleId	TokenNameIdentifier	 get Particle Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fLeafSorter	TokenNameIdentifier	 f Leaf Sorter
[	TokenNameLBRACKET	
fSortCount	TokenNameIdentifier	 f Sort Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
leafIndex	TokenNameIdentifier	 leaf Index
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLeafSorter	TokenNameIdentifier	 f Leaf Sorter
[	TokenNameLBRACKET	
fSortCount	TokenNameIdentifier	 f Sort Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
// 	TokenNameCOMMENT_LINE	 
// Next lets create some arrays, some that hold transient 	TokenNameCOMMENT_LINE	Next lets create some arrays, some that hold transient 
// information during the DFA build and some that are permament. 	TokenNameCOMMENT_LINE	information during the DFA build and some that are permament. 
// These are kind of sticky since we cannot know how big they will 	TokenNameCOMMENT_LINE	These are kind of sticky since we cannot know how big they will 
// get, but we don't want to use any Java collections because of 	TokenNameCOMMENT_LINE	get, but we don't want to use any Java collections because of 
// performance. 	TokenNameCOMMENT_LINE	performance. 
// 	TokenNameCOMMENT_LINE	 
// Basically they will probably be about fLeafCount*2 on average, 	TokenNameCOMMENT_LINE	Basically they will probably be about fLeafCount*2 on average, 
// but can be as large as 2^(fLeafCount*2), worst case. So we start 	TokenNameCOMMENT_LINE	but can be as large as 2^(fLeafCount*2), worst case. So we start 
// with fLeafCount*4 as a middle ground. This will be very unlikely 	TokenNameCOMMENT_LINE	with fLeafCount*4 as a middle ground. This will be very unlikely 
// to ever have to expand, though it if does, the overhead will be 	TokenNameCOMMENT_LINE	to ever have to expand, though it if does, the overhead will be 
// somewhat ugly. 	TokenNameCOMMENT_LINE	somewhat ugly. 
// 	TokenNameCOMMENT_LINE	 
int	TokenNameint	
curArraySize	TokenNameIdentifier	 cur Array Size
=	TokenNameEQUAL	
fLeafCount	TokenNameIdentifier	 f Leaf Count
*	TokenNameMULTIPLY	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
CMStateSet	TokenNameIdentifier	 CM State Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
statesToDo	TokenNameIdentifier	 states To Do
=	TokenNameEQUAL	
new	TokenNamenew	
CMStateSet	TokenNameIdentifier	 CM State Set
[	TokenNameLBRACKET	
curArraySize	TokenNameIdentifier	 cur Array Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
curArraySize	TokenNameIdentifier	 cur Array Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fTransTable	TokenNameIdentifier	 f Trans Table
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
curArraySize	TokenNameIdentifier	 cur Array Size
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Ok we start with the initial set as the first pos set of the 	TokenNameCOMMENT_LINE	Ok we start with the initial set as the first pos set of the 
// head node (which is the seq node that holds the content model 	TokenNameCOMMENT_LINE	head node (which is the seq node that holds the content model 
// and the EOC node.) 	TokenNameCOMMENT_LINE	and the EOC node.) 
// 	TokenNameCOMMENT_LINE	 
CMStateSet	TokenNameIdentifier	 CM State Set
setT	TokenNameIdentifier	 set T
=	TokenNameEQUAL	
fHeadNode	TokenNameIdentifier	 f Head Node
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Init our two state flags. Basically the unmarked state counter 	TokenNameCOMMENT_LINE	Init our two state flags. Basically the unmarked state counter 
// is always chasing the current state counter. When it catches up, 	TokenNameCOMMENT_LINE	is always chasing the current state counter. When it catches up, 
// that means we made a pass through that did not add any new states 	TokenNameCOMMENT_LINE	that means we made a pass through that did not add any new states 
// to the lists, at which time we are done. We could have used a 	TokenNameCOMMENT_LINE	to the lists, at which time we are done. We could have used a 
// expanding array of flags which we used to mark off states as we 	TokenNameCOMMENT_LINE	expanding array of flags which we used to mark off states as we 
// complete them, but this is easier though less readable maybe. 	TokenNameCOMMENT_LINE	complete them, but this is easier though less readable maybe. 
// 	TokenNameCOMMENT_LINE	 
int	TokenNameint	
unmarkedState	TokenNameIdentifier	 unmarked State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Init the first transition table entry, and put the initial state 	TokenNameCOMMENT_LINE	Init the first transition table entry, and put the initial state 
// into the states to do list, then bump the current state. 	TokenNameCOMMENT_LINE	into the states to do list, then bump the current state. 
// 	TokenNameCOMMENT_LINE	 
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
makeDefStateList	TokenNameIdentifier	 make Def State List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
statesToDo	TokenNameIdentifier	 states To Do
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
setT	TokenNameIdentifier	 set T
;	TokenNameSEMICOLON	
curState	TokenNameIdentifier	 cur State
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001); This is faster for * a large content model such as, "(t001+|t002+|.... |t500+)". */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001); This is faster for a large content model such as, "(t001+|t002+|.... |t500+)". 
HashMap	TokenNameIdentifier	 Hash Map
stateTable	TokenNameIdentifier	 state Table
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
// 	TokenNameCOMMENT_LINE	 
// Ok, almost done with the algorithm... We now enter the 	TokenNameCOMMENT_LINE	Ok, almost done with the algorithm... We now enter the 
// loop where we go until the states done counter catches up with 	TokenNameCOMMENT_LINE	loop where we go until the states done counter catches up with 
// the states to do counter. 	TokenNameCOMMENT_LINE	the states to do counter. 
// 	TokenNameCOMMENT_LINE	 
while	TokenNamewhile	
(	TokenNameLPAREN	
unmarkedState	TokenNameIdentifier	 unmarked State
<	TokenNameLESS	
curState	TokenNameIdentifier	 cur State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Get the first unmarked state out of the list of states to do. 	TokenNameCOMMENT_LINE	Get the first unmarked state out of the list of states to do. 
// And get the associated transition table entry. 	TokenNameCOMMENT_LINE	And get the associated transition table entry. 
// 	TokenNameCOMMENT_LINE	 
setT	TokenNameIdentifier	 set T
=	TokenNameEQUAL	
statesToDo	TokenNameIdentifier	 states To Do
[	TokenNameLBRACKET	
unmarkedState	TokenNameIdentifier	 unmarked State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
transEntry	TokenNameIdentifier	 trans Entry
=	TokenNameEQUAL	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
unmarkedState	TokenNameIdentifier	 unmarked State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Mark this one final if it contains the EOC state 	TokenNameCOMMENT_LINE	Mark this one final if it contains the EOC state 
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
[	TokenNameLBRACKET	
unmarkedState	TokenNameIdentifier	 unmarked State
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
setT	TokenNameIdentifier	 set T
.	TokenNameDOT	
getBit	TokenNameIdentifier	 get Bit
(	TokenNameLPAREN	
EOCPos	TokenNameIdentifier	 EOC Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Bump up the unmarked state count, marking this state done 	TokenNameCOMMENT_LINE	Bump up the unmarked state count, marking this state done 
unmarkedState	TokenNameIdentifier	 unmarked State
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// Loop through each possible input symbol in the element map 	TokenNameCOMMENT_LINE	Loop through each possible input symbol in the element map 
CMStateSet	TokenNameIdentifier	 CM State Set
newSet	TokenNameIdentifier	 new Set
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
int	TokenNameint	
sorterIndex	TokenNameIdentifier	 sorter Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Build up a set of states which is the union of all of 	TokenNameCOMMENT_LINE	Build up a set of states which is the union of all of 
// the follow sets of DFA positions that are in the current 	TokenNameCOMMENT_LINE	the follow sets of DFA positions that are in the current 
// state. If we gave away the new set last time through then 	TokenNameCOMMENT_LINE	state. If we gave away the new set last time through then 
// create a new one. Otherwise, zero out the existing one. 	TokenNameCOMMENT_LINE	create a new one. Otherwise, zero out the existing one. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
newSet	TokenNameIdentifier	 new Set
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
newSet	TokenNameIdentifier	 new Set
=	TokenNameEQUAL	
new	TokenNamenew	
CMStateSet	TokenNameIdentifier	 CM State Set
(	TokenNameLPAREN	
fLeafCount	TokenNameIdentifier	 f Leaf Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
newSet	TokenNameIdentifier	 new Set
.	TokenNameDOT	
zeroBits	TokenNameIdentifier	 zero Bits
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
int	TokenNameint	
leafIndex	TokenNameIdentifier	 leaf Index
=	TokenNameEQUAL	
fLeafSorter	TokenNameIdentifier	 f Leaf Sorter
[	TokenNameLBRACKET	
sorterIndex	TokenNameIdentifier	 sorter Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
leafIndex	TokenNameIdentifier	 leaf Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this leaf index (DFA position) is in the current set... 	TokenNameCOMMENT_LINE	If this leaf index (DFA position) is in the current set... 
if	TokenNameif	
(	TokenNameLPAREN	
setT	TokenNameIdentifier	 set T
.	TokenNameDOT	
getBit	TokenNameIdentifier	 get Bit
(	TokenNameLPAREN	
leafIndex	TokenNameIdentifier	 leaf Index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// If this leaf is the current input symbol, then we 	TokenNameCOMMENT_LINE	If this leaf is the current input symbol, then we 
// want to add its follow list to the set of states to 	TokenNameCOMMENT_LINE	want to add its follow list to the set of states to 
// transition to from the current state. 	TokenNameCOMMENT_LINE	transition to from the current state. 
// 	TokenNameCOMMENT_LINE	 
newSet	TokenNameIdentifier	 new Set
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
fFollowList	TokenNameIdentifier	 f Follow List
[	TokenNameLBRACKET	
leafIndex	TokenNameIdentifier	 leaf Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
leafIndex	TokenNameIdentifier	 leaf Index
=	TokenNameEQUAL	
fLeafSorter	TokenNameIdentifier	 f Leaf Sorter
[	TokenNameLBRACKET	
sorterIndex	TokenNameIdentifier	 sorter Index
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
// 	TokenNameCOMMENT_LINE	 
// If this new set is not empty, then see if its in the list 	TokenNameCOMMENT_LINE	If this new set is not empty, then see if its in the list 
// of states to do. If not, then add it. 	TokenNameCOMMENT_LINE	of states to do. If not, then add it. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
newSet	TokenNameIdentifier	 new Set
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Search the 'states to do' list to see if this new 	TokenNameCOMMENT_LINE	Search the 'states to do' list to see if this new 
// state set is already in there. 	TokenNameCOMMENT_LINE	state set is already in there. 
// 	TokenNameCOMMENT_LINE	 
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
Integer	TokenNameIdentifier	 Integer
stateObj	TokenNameIdentifier	 state Obj
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Integer	TokenNameIdentifier	 Integer
)	TokenNameRPAREN	
stateTable	TokenNameIdentifier	 state Table
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
newSet	TokenNameIdentifier	 new Set
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
stateIndex	TokenNameIdentifier	 state Index
=	TokenNameEQUAL	
(	TokenNameLPAREN	
stateObj	TokenNameIdentifier	 state Obj
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
curState	TokenNameIdentifier	 cur State
:	TokenNameCOLON	
stateObj	TokenNameIdentifier	 state Obj
.	TokenNameDOT	
intValue	TokenNameIdentifier	 int Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
// If we did not find it, then add it 	TokenNameCOMMENT_LINE	If we did not find it, then add it 
if	TokenNameif	
(	TokenNameLPAREN	
stateIndex	TokenNameIdentifier	 state Index
==	TokenNameEQUAL_EQUAL	
curState	TokenNameIdentifier	 cur State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Put this new state into the states to do and init 	TokenNameCOMMENT_LINE	Put this new state into the states to do and init 
// a new entry at the same index in the transition 	TokenNameCOMMENT_LINE	a new entry at the same index in the transition 
// table. 	TokenNameCOMMENT_LINE	table. 
// 	TokenNameCOMMENT_LINE	 
statesToDo	TokenNameIdentifier	 states To Do
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
newSet	TokenNameIdentifier	 new Set
;	TokenNameSEMICOLON	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
makeDefStateList	TokenNameIdentifier	 make Def State List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
stateTable	TokenNameIdentifier	 state Table
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
newSet	TokenNameIdentifier	 new Set
,	TokenNameCOMMA	
new	TokenNamenew	
Integer	TokenNameIdentifier	 Integer
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* Optimization(Jan, 2001) */	TokenNameCOMMENT_BLOCK	 Optimization(Jan, 2001) 
// We now have a new state to do so bump the count 	TokenNameCOMMENT_LINE	We now have a new state to do so bump the count 
curState	TokenNameIdentifier	 cur State
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Null out the new set to indicate we adopted it. 	TokenNameCOMMENT_LINE	Null out the new set to indicate we adopted it. 
// This will cause the creation of a new set on the 	TokenNameCOMMENT_LINE	This will cause the creation of a new set on the 
// next time around the loop. 	TokenNameCOMMENT_LINE	next time around the loop. 
// 	TokenNameCOMMENT_LINE	 
newSet	TokenNameIdentifier	 new Set
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Now set this state in the transition table's entry 	TokenNameCOMMENT_LINE	Now set this state in the transition table's entry 
// for this element (using its index), with the DFA 	TokenNameCOMMENT_LINE	for this element (using its index), with the DFA 
// state we will move to from the current state when we 	TokenNameCOMMENT_LINE	state we will move to from the current state when we 
// see this input element. 	TokenNameCOMMENT_LINE	see this input element. 
// 	TokenNameCOMMENT_LINE	 
transEntry	TokenNameIdentifier	 trans Entry
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
stateIndex	TokenNameIdentifier	 state Index
;	TokenNameSEMICOLON	
// Expand the arrays if we're full 	TokenNameCOMMENT_LINE	Expand the arrays if we're full 
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
curArraySize	TokenNameIdentifier	 cur Array Size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Yikes, we overflowed the initial array size, so 	TokenNameCOMMENT_LINE	Yikes, we overflowed the initial array size, so 
// we've got to expand all of these arrays. So adjust 	TokenNameCOMMENT_LINE	we've got to expand all of these arrays. So adjust 
// up the size by 50% and allocate new arrays. 	TokenNameCOMMENT_LINE	up the size by 50% and allocate new arrays. 
// 	TokenNameCOMMENT_LINE	 
final	TokenNamefinal	
int	TokenNameint	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curArraySize	TokenNameIdentifier	 cur Array Size
*	TokenNameMULTIPLY	
1.5	TokenNameDoubleLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
CMStateSet	TokenNameIdentifier	 CM State Set
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newToDo	TokenNameIdentifier	 new To Do
=	TokenNameEQUAL	
new	TokenNamenew	
CMStateSet	TokenNameIdentifier	 CM State Set
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newFinalFlags	TokenNameIdentifier	 new Final Flags
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newTransTable	TokenNameIdentifier	 new Trans Table
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Copy over all of the existing content 	TokenNameCOMMENT_LINE	Copy over all of the existing content 
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
statesToDo	TokenNameIdentifier	 states To Do
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newToDo	TokenNameIdentifier	 new To Do
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
curArraySize	TokenNameIdentifier	 cur Array Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newFinalFlags	TokenNameIdentifier	 new Final Flags
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
curArraySize	TokenNameIdentifier	 cur Array Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fTransTable	TokenNameIdentifier	 f Trans Table
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newTransTable	TokenNameIdentifier	 new Trans Table
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
curArraySize	TokenNameIdentifier	 cur Array Size
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Store the new array size 	TokenNameCOMMENT_LINE	Store the new array size 
curArraySize	TokenNameIdentifier	 cur Array Size
=	TokenNameEQUAL	
newSize	TokenNameIdentifier	 new Size
;	TokenNameSEMICOLON	
statesToDo	TokenNameIdentifier	 states To Do
=	TokenNameEQUAL	
newToDo	TokenNameIdentifier	 new To Do
;	TokenNameSEMICOLON	
fFinalStateFlags	TokenNameIdentifier	 f Final State Flags
=	TokenNameEQUAL	
newFinalFlags	TokenNameIdentifier	 new Final Flags
;	TokenNameSEMICOLON	
fTransTable	TokenNameIdentifier	 f Trans Table
=	TokenNameEQUAL	
newTransTable	TokenNameIdentifier	 new Trans Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Fill in the occurence information for each looping state 	TokenNameCOMMENT_LINE	Fill in the occurence information for each looping state 
// if we're using counters. 	TokenNameCOMMENT_LINE	if we're using counters. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCountingStates	TokenNameIdentifier	 f Counting States
=	TokenNameEQUAL	
new	TokenNamenew	
Occurence	TokenNameIdentifier	 Occurence
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
curState	TokenNameIdentifier	 cur State
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
transitions	TokenNameIdentifier	 transitions
=	TokenNameEQUAL	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
transitions	TokenNameIdentifier	 transitions
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
transitions	TokenNameIdentifier	 transitions
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
elemOccurenceMap	TokenNameIdentifier	 elem Occurence Map
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// And now we can say bye bye to the temp representation since we've 	TokenNameCOMMENT_LINE	And now we can say bye bye to the temp representation since we've 
// built the DFA. 	TokenNameCOMMENT_LINE	built the DFA. 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier	 DEBUG  VALIDATE  CONTENT
)	TokenNameRPAREN	
dumpTree	TokenNameIdentifier	 dump Tree
(	TokenNameLPAREN	
fHeadNode	TokenNameIdentifier	 f Head Node
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fHeadNode	TokenNameIdentifier	 f Head Node
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLeafList	TokenNameIdentifier	 f Leaf List
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fFollowList	TokenNameIdentifier	 f Follow List
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fElemMapId	TokenNameIdentifier	 f Elem Map Id
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Calculates the follow list of the current node. * * @param nodeCur The curent node. * * @exception RuntimeException Thrown if follow list cannot be calculated. */	TokenNameCOMMENT_JAVADOC	 Calculates the follow list of the current node. * @param nodeCur The curent node. * @exception RuntimeException Thrown if follow list cannot be calculated. 
private	TokenNameprivate	
void	TokenNamevoid	
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
CMNode	TokenNameIdentifier	 CM Node
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Recurse as required 	TokenNameCOMMENT_LINE	Recurse as required 
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Recurse only 	TokenNameCOMMENT_LINE	Recurse only 
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeft	TokenNameIdentifier	 get Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getRight	TokenNameIdentifier	 get Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Recurse first 	TokenNameCOMMENT_LINE	Recurse first 
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeft	TokenNameIdentifier	 get Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getRight	TokenNameIdentifier	 get Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Now handle our level. We use our left child's last pos 	TokenNameCOMMENT_LINE	Now handle our level. We use our left child's last pos 
// set and our right child's first pos set, so go ahead and 	TokenNameCOMMENT_LINE	set and our right child's first pos set, so go ahead and 
// get them ahead of time. 	TokenNameCOMMENT_LINE	get them ahead of time. 
// 	TokenNameCOMMENT_LINE	 
final	TokenNamefinal	
CMStateSet	TokenNameIdentifier	 CM State Set
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeft	TokenNameIdentifier	 get Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CMStateSet	TokenNameIdentifier	 CM State Set
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getRight	TokenNameIdentifier	 get Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Now, for every position which is in our left child's last set 	TokenNameCOMMENT_LINE	Now, for every position which is in our left child's last set 
// add all of the states in our right child's first set to the 	TokenNameCOMMENT_LINE	add all of the states in our right child's first set to the 
// follow set for that position. 	TokenNameCOMMENT_LINE	follow set for that position. 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
getBit	TokenNameIdentifier	 get Bit
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fFollowList	TokenNameIdentifier	 f Follow List
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier	 PARTICLE  ZERO  OR  MORE
||	TokenNameOR_OR	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ONE_OR_MORE	TokenNameIdentifier	 PARTICLE  ONE  OR  MORE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Recurse first 	TokenNameCOMMENT_LINE	Recurse first 
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMUniOp	TokenNameIdentifier	 XSCM Uni Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Now handle our level. We use our own first and last position 	TokenNameCOMMENT_LINE	Now handle our level. We use our own first and last position 
// sets, so get them up front. 	TokenNameCOMMENT_LINE	sets, so get them up front. 
// 	TokenNameCOMMENT_LINE	 
final	TokenNamefinal	
CMStateSet	TokenNameIdentifier	 CM State Set
first	TokenNameIdentifier	 first
=	TokenNameEQUAL	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
CMStateSet	TokenNameIdentifier	 CM State Set
last	TokenNameIdentifier	 last
=	TokenNameEQUAL	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// For every position which is in our last position set, add all 	TokenNameCOMMENT_LINE	For every position which is in our last position set, add all 
// of our first position states to the follow set for that 	TokenNameCOMMENT_LINE	of our first position states to the follow set for that 
// position. 	TokenNameCOMMENT_LINE	position. 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
fLeafCount	TokenNameIdentifier	 f Leaf Count
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
last	TokenNameIdentifier	 last
.	TokenNameDOT	
getBit	TokenNameIdentifier	 get Bit
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
)	TokenNameRPAREN	
fFollowList	TokenNameIdentifier	 f Follow List
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
.	TokenNameDOT	
union	TokenNameIdentifier	 union
(	TokenNameLPAREN	
first	TokenNameIdentifier	 first
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier	 PARTICLE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Recurse only 	TokenNameCOMMENT_LINE	Recurse only 
calcFollowList	TokenNameIdentifier	 calc Follow List
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMUniOp	TokenNameIdentifier	 XSCM Uni Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Dumps the tree of the current node to standard output. * * @param nodeCur The current node. * @param level The maximum levels to output. * * @exception RuntimeException Thrown on error. */	TokenNameCOMMENT_JAVADOC	 Dumps the tree of the current node to standard output. * @param nodeCur The current node. @param level The maximum levels to output. * @exception RuntimeException Thrown on error. 
private	TokenNameprivate	
void	TokenNamevoid	
dumpTree	TokenNameIdentifier	 dump Tree
(	TokenNameLPAREN	
CMNode	TokenNameIdentifier	 CM Node
nodeCur	TokenNameIdentifier	 node Cur
,	TokenNameCOMMA	
int	TokenNameint	
level	TokenNameIdentifier	 level
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
level	TokenNameIdentifier	 level
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" "	TokenNameStringLiteral	 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
:	TokenNameCOLON	
case	TokenNamecase	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
:	TokenNameCOLON	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Choice Node "	TokenNameStringLiteral	Choice Node 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Seq Node "	TokenNameStringLiteral	Seq Node 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
isNullable	TokenNameIdentifier	 is Nullable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Nullable "	TokenNameStringLiteral	Nullable 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"firstPos="	TokenNameStringLiteral	firstPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" lastPos="	TokenNameStringLiteral	 lastPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dumpTree	TokenNameIdentifier	 dump Tree
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeft	TokenNameIdentifier	 get Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dumpTree	TokenNameIdentifier	 dump Tree
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getRight	TokenNameIdentifier	 get Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier	 PARTICLE  ZERO  OR  MORE
:	TokenNameCOLON	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ONE_OR_MORE	TokenNameIdentifier	 PARTICLE  ONE  OR  MORE
:	TokenNameCOLON	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier	 PARTICLE  ZERO  OR  ONE
:	TokenNameCOLON	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Rep Node "	TokenNameStringLiteral	Rep Node 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
isNullable	TokenNameIdentifier	 is Nullable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Nullable "	TokenNameStringLiteral	Nullable 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"firstPos="	TokenNameStringLiteral	firstPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" lastPos="	TokenNameStringLiteral	 lastPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dumpTree	TokenNameIdentifier	 dump Tree
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMUniOp	TokenNameIdentifier	 XSCM Uni Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
level	TokenNameIdentifier	 level
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
:	TokenNameCOLON	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Leaf: (pos="	TokenNameStringLiteral	Leaf: (pos=
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
"), "	TokenNameStringLiteral	), 
+	TokenNamePLUS	
"(elemIndex="	TokenNameStringLiteral	(elemIndex=
+	TokenNamePLUS	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeaf	TokenNameIdentifier	 get Leaf
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
") "	TokenNameStringLiteral	) 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
isNullable	TokenNameIdentifier	 is Nullable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" Nullable "	TokenNameStringLiteral	 Nullable 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"firstPos="	TokenNameStringLiteral	firstPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" lastPos="	TokenNameStringLiteral	 lastPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
case	TokenNamecase	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
:	TokenNameCOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"Any Node: "	TokenNameStringLiteral	Any Node: 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
"firstPos="	TokenNameStringLiteral	firstPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
firstPos	TokenNameIdentifier	 first Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
print	TokenNameIdentifier	 print
(	TokenNameLPAREN	
" lastPos="	TokenNameStringLiteral	 lastPos=
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
lastPos	TokenNameIdentifier	 last Pos
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"ImplementationMessages.VAL_NIICM"	TokenNameStringLiteral	ImplementationMessages.VAL_NIICM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * -1 is used to represent bad transitions in the transition table * entry for each state. So each entry is initialized to an all -1 * array. This method creates a new entry and initializes it. */	TokenNameCOMMENT_JAVADOC	 -1 is used to represent bad transitions in the transition table entry for each state. So each entry is initialized to an all -1 array. This method creates a new entry and initializes it. 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
makeDefStateList	TokenNameIdentifier	 make Def State List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
retArray	TokenNameIdentifier	 ret Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
retArray	TokenNameIdentifier	 ret Array
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
retArray	TokenNameIdentifier	 ret Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Post tree build initialization. */	TokenNameCOMMENT_JAVADOC	 Post tree build initialization. 
private	TokenNameprivate	
void	TokenNamevoid	
postTreeBuildInit	TokenNameIdentifier	 post Tree Build Init
(	TokenNameLPAREN	
CMNode	TokenNameIdentifier	 CM Node
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
throws	TokenNamethrows	
RuntimeException	TokenNameIdentifier	 Runtime Exception
{	TokenNameLBRACE	
// Set the maximum states on this node 	TokenNameCOMMENT_LINE	Set the maximum states on this node 
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
setMaxStates	TokenNameIdentifier	 set Max States
(	TokenNameLPAREN	
fLeafCount	TokenNameIdentifier	 f Leaf Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
leaf	TokenNameIdentifier	 leaf
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Recurse as required 	TokenNameCOMMENT_LINE	Recurse as required 
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
leaf	TokenNameIdentifier	 leaf
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
;	TokenNameSEMICOLON	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_CHOICE	TokenNameIdentifier	 MODELGROUP  CHOICE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSModelGroupImpl	TokenNameIdentifier	 XS Model Group Impl
.	TokenNameDOT	
MODELGROUP_SEQUENCE	TokenNameIdentifier	 MODELGROUP  SEQUENCE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
postTreeBuildInit	TokenNameIdentifier	 post Tree Build Init
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getLeft	TokenNameIdentifier	 get Left
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
postTreeBuildInit	TokenNameIdentifier	 post Tree Build Init
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMBinOp	TokenNameIdentifier	 XSCM Bin Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getRight	TokenNameIdentifier	 get Right
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier	 PARTICLE  ZERO  OR  MORE
||	TokenNameOR_OR	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ONE_OR_MORE	TokenNameIdentifier	 PARTICLE  ONE  OR  MORE
||	TokenNameOR_OR	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier	 PARTICLE  ZERO  OR  ONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
postTreeBuildInit	TokenNameIdentifier	 post Tree Build Init
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSCMUniOp	TokenNameIdentifier	 XSCM Uni Op
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
)	TokenNameRPAREN	
.	TokenNameDOT	
getChild	TokenNameIdentifier	 get Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
nodeCur	TokenNameIdentifier	 node Cur
.	TokenNameDOT	
type	TokenNameIdentifier	 type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Put this node in the leaf list at the current index if its 	TokenNameCOMMENT_LINE	Put this node in the leaf list at the current index if its 
// a non-epsilon leaf. 	TokenNameCOMMENT_LINE	a non-epsilon leaf. 
leaf	TokenNameIdentifier	 leaf
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSCMLeaf	TokenNameIdentifier	 XSCM Leaf
)	TokenNameRPAREN	
nodeCur	TokenNameIdentifier	 node Cur
;	TokenNameSEMICOLON	
pos	TokenNameIdentifier	 pos
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
.	TokenNameDOT	
getPosition	TokenNameIdentifier	 get Position
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLeafList	TokenNameIdentifier	 f Leaf List
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
leaf	TokenNameIdentifier	 leaf
;	TokenNameSEMICOLON	
fLeafListType	TokenNameIdentifier	 f Leaf List Type
[	TokenNameLBRACKET	
pos	TokenNameIdentifier	 pos
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_ELEMENT	TokenNameIdentifier	 PARTICLE  ELEMENT
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
RuntimeException	TokenNameIdentifier	 Runtime Exception
(	TokenNameLPAREN	
"ImplementationMessages.VAL_NIICM"	TokenNameStringLiteral	ImplementationMessages.VAL_NIICM
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * check whether this content violates UPA constraint. * * @param subGroupHandler the substitution group handler * @return true if this content model contains other or list wildcard */	TokenNameCOMMENT_JAVADOC	 check whether this content violates UPA constraint. * @param subGroupHandler the substitution group handler @return true if this content model contains other or list wildcard 
public	TokenNamepublic	
boolean	TokenNameboolean	
checkUniqueParticleAttribution	TokenNameIdentifier	 check Unique Particle Attribution
(	TokenNameLPAREN	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
{	TokenNameLBRACE	
// Unique Particle Attribution 	TokenNameCOMMENT_LINE	Unique Particle Attribution 
// store the conflict results between any two elements in fElemMap 	TokenNameCOMMENT_LINE	store the conflict results between any two elements in fElemMap 
// 0: not compared; -1: no conflict; 1: conflict 	TokenNameCOMMENT_LINE	0: not compared; -1: no conflict; 1: conflict 
// initialize the conflict table (all 0 initially) 	TokenNameCOMMENT_LINE	initialize the conflict table (all 0 initially) 
byte	TokenNamebyte	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
new	TokenNamenew	
byte	TokenNamebyte	
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// for each state, check whether it has overlap transitions 	TokenNameCOMMENT_LINE	for each state, check whether it has overlap transitions 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fTransTable	TokenNameIdentifier	 f Trans Table
.	TokenNameDOT	
length	TokenNameIdentifier	 length
&&	TokenNameAND_AND	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
overlapUPA	TokenNameIdentifier	 overlap UPA
(	TokenNameLPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
,	TokenNameCOMMA	
subGroupHandler	TokenNameIdentifier	 sub Group Handler
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCountingStates	TokenNameIdentifier	 f Counting States
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// If "i" is a counting state and exactly one of the transitions 	TokenNameCOMMENT_LINE	If "i" is a counting state and exactly one of the transitions 
// loops back to "i" then the two particles do not overlap if 	TokenNameCOMMENT_LINE	loops back to "i" then the two particles do not overlap if 
// minOccurs == maxOccurs. 	TokenNameCOMMENT_LINE	minOccurs == maxOccurs. 
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
i	TokenNameIdentifier	 i
^	TokenNameXOR	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
i	TokenNameIdentifier	 i
&&	TokenNameAND_AND	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
minOccurs	TokenNameIdentifier	 min Occurs
==	TokenNameEQUAL_EQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
byte	TokenNamebyte	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// report all errors 	TokenNameCOMMENT_LINE	report all errors 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
conflictTable	TokenNameIdentifier	 conflict Table
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//errors.newError("cos-nonambig", new Object[]{fElemMap[i].toString(), 	TokenNameCOMMENT_LINE	errors.newError("cos-nonambig", new Object[]{fElemMap[i].toString(), 
// fElemMap[j].toString()}); 	TokenNameCOMMENT_LINE	fElemMap[j].toString()}); 
// REVISIT: do we want to report all errors? or just one? 	TokenNameCOMMENT_LINE	REVISIT: do we want to report all errors? or just one? 
throw	TokenNamethrow	
new	TokenNamenew	
XMLSchemaException	TokenNameIdentifier	 XML Schema Exception
(	TokenNameLPAREN	
"cos-nonambig"	TokenNameStringLiteral	cos-nonambig
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if there is a other or list wildcard, we need to check this CM 	TokenNameCOMMENT_LINE	if there is a other or list wildcard, we need to check this CM 
// again, if this grammar is cached. 	TokenNameCOMMENT_LINE	again, if this grammar is cached. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElemMapType	TokenNameIdentifier	 f Elem Map Type
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
XSParticleDecl	TokenNameIdentifier	 XS Particle Decl
.	TokenNameDOT	
PARTICLE_WILDCARD	TokenNameIdentifier	 PARTICLE  WILDCARD
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
NSCONSTRAINT_LIST	TokenNameIdentifier	 NSCONSTRAINT  LIST
||	TokenNameOR_OR	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
NSCONSTRAINT_NOT	TokenNameIdentifier	 NSCONSTRAINT  NOT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Check which elements are valid to appear at this point. This method also * works if the state is in error, in which case it returns what should * have been seen. * * @param state the current state * @return a Vector whose entries are instances of * either XSWildcardDecl or XSElementDecl. */	TokenNameCOMMENT_JAVADOC	 Check which elements are valid to appear at this point. This method also works if the state is in error, in which case it returns what should have been seen. * @param state the current state @return a Vector whose entries are instances of either XSWildcardDecl or XSElementDecl. 
public	TokenNamepublic	
Vector	TokenNameIdentifier	 Vector
whatCanGoHere	TokenNameIdentifier	 what Can Go Here
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
(	TokenNameLPAREN	
fCountingStates	TokenNameIdentifier	 f Counting States
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
elemIndex	TokenNameIdentifier	 elem Index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
<	TokenNameLESS	
fElemMapSize	TokenNameIdentifier	 f Elem Map Size
;	TokenNameSEMICOLON	
elemIndex	TokenNameIdentifier	 elem Index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
nextState	TokenNameIdentifier	 next State
=	TokenNameEQUAL	
fTransTable	TokenNameIdentifier	 f Trans Table
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextState	TokenNameIdentifier	 next State
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
==	TokenNameEQUAL_EQUAL	
nextState	TokenNameIdentifier	 next State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Do not include transitions which loop back to the 	TokenNameCOMMENT_LINE	Do not include transitions which loop back to the 
// current state if we've looped the maximum number 	TokenNameCOMMENT_LINE	current state if we've looped the maximum number 
// of times or greater. 	TokenNameCOMMENT_LINE	of times or greater. 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
&&	TokenNameAND_AND	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Do not include transitions which advance past the 	TokenNameCOMMENT_LINE	Do not include transitions which advance past the 
// current state if we have not looped enough times. 	TokenNameCOMMENT_LINE	current state if we have not looped enough times. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
ret	TokenNameIdentifier	 ret
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
elemIndex	TokenNameIdentifier	 elem Index
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
occurenceInfo	TokenNameIdentifier	 occurence Info
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCountingStates	TokenNameIdentifier	 f Counting States
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curState	TokenNameIdentifier	 cur State
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
curState	TokenNameIdentifier	 cur State
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Occurence	TokenNameIdentifier	 Occurence
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
fCountingStates	TokenNameIdentifier	 f Counting States
[	TokenNameLBRACKET	
curState	TokenNameIdentifier	 cur State
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
occurenceInfo	TokenNameIdentifier	 occurence Info
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
minOccurs	TokenNameIdentifier	 min Occurs
;	TokenNameSEMICOLON	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
maxOccurs	TokenNameIdentifier	 max Occurs
;	TokenNameSEMICOLON	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
o	TokenNameIdentifier	 o
.	TokenNameDOT	
elemIndex	TokenNameIdentifier	 elem Index
;	TokenNameSEMICOLON	
return	TokenNamereturn	
occurenceInfo	TokenNameIdentifier	 occurence Info
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
String	TokenNameIdentifier	 String
getTermName	TokenNameIdentifier	 get Term Name
(	TokenNameLPAREN	
int	TokenNameint	
termId	TokenNameIdentifier	 term Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
term	TokenNameIdentifier	 term
=	TokenNameEQUAL	
fElemMap	TokenNameIdentifier	 f Elem Map
[	TokenNameLBRACKET	
termId	TokenNameIdentifier	 term Id
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
term	TokenNameIdentifier	 term
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
term	TokenNameIdentifier	 term
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
isCompactedForUPA	TokenNameIdentifier	 is Compacted For UPA
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fIsCompactedForUPA	TokenNameIdentifier	 f Is Compacted For UPA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class DFAContentModel 	TokenNameCOMMENT_LINE	class DFAContentModel 
