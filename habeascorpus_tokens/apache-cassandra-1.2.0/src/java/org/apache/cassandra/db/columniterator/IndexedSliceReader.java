/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
columniterator	TokenNameIdentifier	 columniterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
nio	TokenNameIdentifier	 nio
.	TokenNameDOT	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayDeque	TokenNameIdentifier	 Array Deque
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Deque	TokenNameIdentifier	 Deque
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
com	TokenNameIdentifier	 com
.	TokenNameDOT	
google	TokenNameIdentifier	 google
.	TokenNameDOT	
common	TokenNameIdentifier	 common
.	TokenNameDOT	
collect	TokenNameIdentifier	 collect
.	TokenNameDOT	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
ColumnFamily	TokenNameIdentifier	 Column Family
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
DecoratedKey	TokenNameIdentifier	 Decorated Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
DeletionInfo	TokenNameIdentifier	 Deletion Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
filter	TokenNameIdentifier	 filter
.	TokenNameDOT	
ColumnSlice	TokenNameIdentifier	 Column Slice
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
db	TokenNameIdentifier	 db
.	TokenNameDOT	
marshal	TokenNameIdentifier	 marshal
.	TokenNameDOT	
AbstractType	TokenNameIdentifier	 Abstract Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
CorruptSSTableException	TokenNameIdentifier	 Corrupt SS Table Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
IndexHelper	TokenNameIdentifier	 Index Helper
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
IndexHelper	TokenNameIdentifier	 Index Helper
.	TokenNameDOT	
IndexInfo	TokenNameIdentifier	 Index Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
SSTableReader	TokenNameIdentifier	 SS Table Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileDataInput	TokenNameIdentifier	 File Data Input
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FileMark	TokenNameIdentifier	 File Mark
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
cassandra	TokenNameIdentifier	 cassandra
.	TokenNameDOT	
utils	TokenNameIdentifier	 utils
.	TokenNameDOT	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
;	TokenNameSEMICOLON	
/** * This is a reader that finds the block for a starting column and returns blocks before/after it for each next call. * This function assumes that the CF is sorted by name and exploits the name index. */	TokenNameCOMMENT_JAVADOC	 This is a reader that finds the block for a starting column and returns blocks before/after it for each next call. This function assumes that the CF is sorted by name and exploits the name index. 
class	TokenNameclass	
IndexedSliceReader	TokenNameIdentifier	 Indexed Slice Reader
extends	TokenNameextends	
AbstractIterator	TokenNameIdentifier	 Abstract Iterator
<	TokenNameLESS	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
>	TokenNameGREATER	
implements	TokenNameimplements	
OnDiskAtomIterator	TokenNameIdentifier	 On Disk Atom Iterator
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
ColumnFamily	TokenNameIdentifier	 Column Family
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
List	TokenNameIdentifier	 List
<	TokenNameLESS	
IndexHelper	TokenNameIdentifier	 Index Helper
.	TokenNameDOT	
IndexInfo	TokenNameIdentifier	 Index Info
>	TokenNameGREATER	
indexes	TokenNameIdentifier	 indexes
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FileDataInput	TokenNameIdentifier	 File Data Input
originalInput	TokenNameIdentifier	 original Input
;	TokenNameSEMICOLON	
private	TokenNameprivate	
FileDataInput	TokenNameIdentifier	 File Data Input
file	TokenNameIdentifier	 file
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ColumnSlice	TokenNameIdentifier	 Column Slice
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
slices	TokenNameIdentifier	 slices
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
BlockFetcher	TokenNameIdentifier	 Block Fetcher
fetcher	TokenNameIdentifier	 fetcher
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Deque	TokenNameIdentifier	 Deque
<	TokenNameLESS	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
>	TokenNameGREATER	
blockColumns	TokenNameIdentifier	 block Columns
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayDeque	TokenNameIdentifier	 Array Deque
<	TokenNameLESS	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
AbstractType	TokenNameIdentifier	 Abstract Type
<	TokenNameLESS	
?	TokenNameQUESTION	
>	TokenNameGREATER	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
/** * This slice reader assumes that slices are sorted correctly, e.g. that for forward lookup slices are in * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of * finish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] reverse: [h,g],[e,d],[b,a]. This reader also * assumes that validation has been performed in terms of intervals (no overlapping intervals). */	TokenNameCOMMENT_JAVADOC	 This slice reader assumes that slices are sorted correctly, e.g. that for forward lookup slices are in lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of finish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] reverse: [h,g],[e,d],[b,a]. This reader also assumes that validation has been performed in terms of intervals (no overlapping intervals). 
public	TokenNamepublic	
IndexedSliceReader	TokenNameIdentifier	 Indexed Slice Reader
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
indexEntry	TokenNameIdentifier	 index Entry
,	TokenNameCOMMA	
FileDataInput	TokenNameIdentifier	 File Data Input
input	TokenNameIdentifier	 input
,	TokenNameCOMMA	
ColumnSlice	TokenNameIdentifier	 Column Slice
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
slices	TokenNameIdentifier	 slices
,	TokenNameCOMMA	
boolean	TokenNameboolean	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
sstable	TokenNameIdentifier	 sstable
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
originalInput	TokenNameIdentifier	 original Input
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
reversed	TokenNameIdentifier	 reversed
=	TokenNameEQUAL	
reversed	TokenNameIdentifier	 reversed
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
slices	TokenNameIdentifier	 slices
=	TokenNameEQUAL	
slices	TokenNameIdentifier	 slices
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
.	TokenNameDOT	
comparator	TokenNameIdentifier	 comparator
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
.	TokenNameDOT	
hasPromotedIndexes	TokenNameIdentifier	 has Promoted Indexes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
indexes	TokenNameIdentifier	 indexes
=	TokenNameEQUAL	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
columnsIndex	TokenNameIdentifier	 columns Index
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setToRowStart	TokenNameIdentifier	 set To Row Start
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
indexEntry	TokenNameIdentifier	 index Entry
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
=	TokenNameEQUAL	
ColumnFamily	TokenNameIdentifier	 Column Family
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
DeletionInfo	TokenNameIdentifier	 Deletion Info
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
deserializeFromSSTable	TokenNameIdentifier	 deserialize From SS Table
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fetcher	TokenNameIdentifier	 fetcher
=	TokenNameEQUAL	
new	TokenNamenew	
SimpleBlockFetcher	TokenNameIdentifier	 Simple Block Fetcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
=	TokenNameEQUAL	
ColumnFamily	TokenNameIdentifier	 Column Family
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
deletionInfo	TokenNameIdentifier	 deletion Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fetcher	TokenNameIdentifier	 fetcher
=	TokenNameEQUAL	
new	TokenNamenew	
IndexedBlockFetcher	TokenNameIdentifier	 Indexed Block Fetcher
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setToRowStart	TokenNameIdentifier	 set To Row Start
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
,	TokenNameCOMMA	
indexEntry	TokenNameIdentifier	 index Entry
,	TokenNameCOMMA	
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IndexHelper	TokenNameIdentifier	 Index Helper
.	TokenNameDOT	
skipBloomFilter	TokenNameIdentifier	 skip Bloom Filter
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
indexes	TokenNameIdentifier	 indexes
=	TokenNameEQUAL	
IndexHelper	TokenNameIdentifier	 Index Helper
.	TokenNameDOT	
deserializeIndex	TokenNameIdentifier	 deserialize Index
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
=	TokenNameEQUAL	
ColumnFamily	TokenNameIdentifier	 Column Family
.	TokenNameDOT	
create	TokenNameIdentifier	 create
(	TokenNameLPAREN	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
metadata	TokenNameIdentifier	 metadata
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
.	TokenNameDOT	
delete	TokenNameIdentifier	 delete
(	TokenNameLPAREN	
DeletionInfo	TokenNameIdentifier	 Deletion Info
.	TokenNameDOT	
serializer	TokenNameIdentifier	 serializer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
deserializeFromSSTable	TokenNameIdentifier	 deserialize From SS Table
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fetcher	TokenNameIdentifier	 fetcher
=	TokenNameEQUAL	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
new	TokenNamenew	
SimpleBlockFetcher	TokenNameIdentifier	 Simple Block Fetcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
new	TokenNamenew	
IndexedBlockFetcher	TokenNameIdentifier	 Indexed Block Fetcher
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getFilePointer	TokenNameIdentifier	 get File Pointer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We still have the column count to 	TokenNameCOMMENT_LINE	We still have the column count to 
// skip to get the basePosition 	TokenNameCOMMENT_LINE	skip to get the basePosition 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
markSuspect	TokenNameIdentifier	 mark Suspect
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptSSTableException	TokenNameIdentifier	 Corrupt SS Table Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets the seek position to the start of the row for column scanning. */	TokenNameCOMMENT_JAVADOC	 Sets the seek position to the start of the row for column scanning. 
private	TokenNameprivate	
void	TokenNamevoid	
setToRowStart	TokenNameIdentifier	 set To Row Start
(	TokenNameLPAREN	
SSTableReader	TokenNameIdentifier	 SS Table Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
RowIndexEntry	TokenNameIdentifier	 Row Index Entry
indexEntry	TokenNameIdentifier	 index Entry
,	TokenNameCOMMA	
FileDataInput	TokenNameIdentifier	 File Data Input
input	TokenNameIdentifier	 input
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
input	TokenNameIdentifier	 input
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getFileDataInput	TokenNameIdentifier	 get File Data Input
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
input	TokenNameIdentifier	 input
;	TokenNameSEMICOLON	
input	TokenNameIdentifier	 input
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
indexEntry	TokenNameIdentifier	 index Entry
.	TokenNameDOT	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
decodeKey	TokenNameIdentifier	 decode Key
(	TokenNameLPAREN	
ByteBufferUtil	TokenNameIdentifier	 Byte Buffer Util
.	TokenNameDOT	
readWithShortLength	TokenNameIdentifier	 read With Short Length
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SSTableReader	TokenNameIdentifier	 SS Table Reader
.	TokenNameDOT	
readRowSize	TokenNameIdentifier	 read Row Size
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
ColumnFamily	TokenNameIdentifier	 Column Family
getColumnFamily	TokenNameIdentifier	 get Column Family
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
DecoratedKey	TokenNameIdentifier	 Decorated Key
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
computeNext	TokenNameIdentifier	 compute Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
blockColumns	TokenNameIdentifier	 block Columns
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fetcher	TokenNameIdentifier	 fetcher
.	TokenNameDOT	
fetchMoreData	TokenNameIdentifier	 fetch More Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
endOfData	TokenNameIdentifier	 end Of Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
column	TokenNameIdentifier	 column
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
originalInput	TokenNameIdentifier	 original Input
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
file	TokenNameIdentifier	 file
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
close	TokenNameIdentifier	 close
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
void	TokenNamevoid	
addColumn	TokenNameIdentifier	 add Column
(	TokenNameLPAREN	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
col	TokenNameIdentifier	 col
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
blockColumns	TokenNameIdentifier	 block Columns
.	TokenNameDOT	
addFirst	TokenNameIdentifier	 add First
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
blockColumns	TokenNameIdentifier	 block Columns
.	TokenNameDOT	
addLast	TokenNameIdentifier	 add Last
(	TokenNameLPAREN	
col	TokenNameIdentifier	 col
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
abstract	TokenNameabstract	
class	TokenNameclass	
BlockFetcher	TokenNameIdentifier	 Block Fetcher
{	TokenNameLBRACE	
protected	TokenNameprotected	
int	TokenNameint	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
BlockFetcher	TokenNameIdentifier	 Block Fetcher
(	TokenNameLPAREN	
int	TokenNameint	
sliceIdx	TokenNameIdentifier	 slice Idx
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
=	TokenNameEQUAL	
sliceIdx	TokenNameIdentifier	 slice Idx
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Return the smallest key selected by the current ColumnSlice. */	TokenNameCOMMENT_BLOCK	 Return the smallest key selected by the current ColumnSlice. 
protected	TokenNameprotected	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
currentStart	TokenNameIdentifier	 current Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
reversed	TokenNameIdentifier	 reversed
?	TokenNameQUESTION	
slices	TokenNameIdentifier	 slices
[	TokenNameLBRACKET	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
:	TokenNameCOLON	
slices	TokenNameIdentifier	 slices
[	TokenNameLBRACKET	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
start	TokenNameIdentifier	 start
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * Return the biggest key selected by the current ColumnSlice. */	TokenNameCOMMENT_BLOCK	 Return the biggest key selected by the current ColumnSlice. 
protected	TokenNameprotected	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
currentFinish	TokenNameIdentifier	 current Finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
reversed	TokenNameIdentifier	 reversed
?	TokenNameQUESTION	
slices	TokenNameIdentifier	 slices
[	TokenNameLBRACKET	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
start	TokenNameIdentifier	 start
:	TokenNameCOLON	
slices	TokenNameIdentifier	 slices
[	TokenNameLBRACKET	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
finish	TokenNameIdentifier	 finish
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
abstract	TokenNameabstract	
boolean	TokenNameboolean	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
abstract	TokenNameabstract	
boolean	TokenNameboolean	
fetchMoreData	TokenNameIdentifier	 fetch More Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isColumnBeforeSliceStart	TokenNameIdentifier	 is Column Before Slice Start
(	TokenNameLPAREN	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
isBeforeSliceStart	TokenNameIdentifier	 is Before Slice Start
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isBeforeSliceStart	TokenNameIdentifier	 is Before Slice Start
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
start	TokenNameIdentifier	 start
=	TokenNameEQUAL	
currentStart	TokenNameIdentifier	 current Start
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
start	TokenNameIdentifier	 start
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isColumnBeforeSliceFinish	TokenNameIdentifier	 is Column Before Slice Finish
(	TokenNameLPAREN	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
finish	TokenNameIdentifier	 finish
=	TokenNameEQUAL	
currentFinish	TokenNameIdentifier	 current Finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
finish	TokenNameIdentifier	 finish
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
.	TokenNameDOT	
name	TokenNameIdentifier	 name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
finish	TokenNameIdentifier	 finish
)	TokenNameRPAREN	
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
isAfterSliceFinish	TokenNameIdentifier	 is After Slice Finish
(	TokenNameLPAREN	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ByteBuffer	TokenNameIdentifier	 Byte Buffer
finish	TokenNameIdentifier	 finish
=	TokenNameEQUAL	
currentFinish	TokenNameIdentifier	 current Finish
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
finish	TokenNameIdentifier	 finish
.	TokenNameDOT	
remaining	TokenNameIdentifier	 remaining
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
comparator	TokenNameIdentifier	 comparator
.	TokenNameDOT	
compare	TokenNameIdentifier	 compare
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
finish	TokenNameIdentifier	 finish
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
IndexedBlockFetcher	TokenNameIdentifier	 Indexed Block Fetcher
extends	TokenNameextends	
BlockFetcher	TokenNameIdentifier	 Block Fetcher
{	TokenNameLBRACE	
// where this row starts 	TokenNameCOMMENT_LINE	where this row starts 
private	TokenNameprivate	
final	TokenNamefinal	
long	TokenNamelong	
basePosition	TokenNameIdentifier	 base Position
;	TokenNameSEMICOLON	
// the index entry for the next block to deserialize 	TokenNameCOMMENT_LINE	the index entry for the next block to deserialize 
private	TokenNameprivate	
int	TokenNameint	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// index of the last block we've read from disk; 	TokenNameCOMMENT_LINE	index of the last block we've read from disk; 
private	TokenNameprivate	
int	TokenNameint	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// For reversed, keep columns at the beginning of the last deserialized block that 	TokenNameCOMMENT_LINE	For reversed, keep columns at the beginning of the last deserialized block that 
// may still match a slice 	TokenNameCOMMENT_LINE	may still match a slice 
private	TokenNameprivate	
final	TokenNamefinal	
Deque	TokenNameIdentifier	 Deque
<	TokenNameLESS	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
>	TokenNameGREATER	
prefetched	TokenNameIdentifier	 prefetched
;	TokenNameSEMICOLON	
public	TokenNamepublic	
IndexedBlockFetcher	TokenNameIdentifier	 Indexed Block Fetcher
(	TokenNameLPAREN	
long	TokenNamelong	
basePosition	TokenNameIdentifier	 base Position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
basePosition	TokenNameIdentifier	 base Position
=	TokenNameEQUAL	
basePosition	TokenNameIdentifier	 base Position
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
prefetched	TokenNameIdentifier	 prefetched
=	TokenNameEQUAL	
reversed	TokenNameIdentifier	 reversed
?	TokenNameQUESTION	
new	TokenNamenew	
ArrayDeque	TokenNameIdentifier	 Array Deque
<	TokenNameLESS	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
>	TokenNameGREATER	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
null	TokenNamenull	
;	TokenNameSEMICOLON	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
<	TokenNameLESS	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
=	TokenNameEQUAL	
IndexHelper	TokenNameIdentifier	 Index Helper
.	TokenNameDOT	
indexFor	TokenNameIdentifier	 index For
(	TokenNameLPAREN	
slices	TokenNameIdentifier	 slices
[	TokenNameLBRACKET	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
]	TokenNameRBRACKET	
.	TokenNameDOT	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
indexes	TokenNameIdentifier	 indexes
,	TokenNameCOMMA	
comparator	TokenNameIdentifier	 comparator
,	TokenNameCOMMA	
reversed	TokenNameIdentifier	 reversed
,	TokenNameCOMMA	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
>=	TokenNameGREATER_EQUAL	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
// no index block for that slice 	TokenNameCOMMENT_LINE	no index block for that slice 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// Check if we can exclude this slice entirely from the index 	TokenNameCOMMENT_LINE	Check if we can exclude this slice entirely from the index 
IndexInfo	TokenNameIdentifier	 Index Info
info	TokenNameIdentifier	 info
=	TokenNameEQUAL	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isBeforeSliceStart	TokenNameIdentifier	 is Before Slice Start
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
lastName	TokenNameIdentifier	 last Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isAfterSliceFinish	TokenNameIdentifier	 is After Slice Finish
(	TokenNameLPAREN	
info	TokenNameIdentifier	 info
.	TokenNameDOT	
firstName	TokenNameIdentifier	 first Name
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
hasMoreSlice	TokenNameIdentifier	 has More Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
<	TokenNameLESS	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fetchMoreData	TokenNameIdentifier	 fetch More Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
hasMoreSlice	TokenNameIdentifier	 has More Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// If we read blocks in reversed disk order, we may have columns from the previous block to handle. 	TokenNameCOMMENT_LINE	If we read blocks in reversed disk order, we may have columns from the previous block to handle. 
// Note that prefetched keeps columns in reversed disk order. 	TokenNameCOMMENT_LINE	Note that prefetched keeps columns in reversed disk order. 
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
&&	TokenNameAND_AND	
!	TokenNameNOT	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
gotSome	TokenNameIdentifier	 got Some
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Avoids some comparison when we know it's not useful 	TokenNameCOMMENT_LINE	Avoids some comparison when we know it's not useful 
boolean	TokenNameboolean	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
prefetchedCol	TokenNameIdentifier	 prefetched Col
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
prefetchedCol	TokenNameIdentifier	 prefetched Col
=	TokenNameEQUAL	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
peek	TokenNameIdentifier	 peek
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// col is before slice, we update the slice 	TokenNameCOMMENT_LINE	col is before slice, we update the slice 
if	TokenNameif	
(	TokenNameLPAREN	
isColumnBeforeSliceStart	TokenNameIdentifier	 is Column Before Slice Start
(	TokenNameLPAREN	
prefetchedCol	TokenNameIdentifier	 prefetched Col
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// col is within slice, all columns 	TokenNameCOMMENT_LINE	col is within slice, all columns 
// (we go in reverse, so as soon as we are in a slice, no need to check 	TokenNameCOMMENT_LINE	(we go in reverse, so as soon as we are in a slice, no need to check 
// we're after the slice until we change slice) 	TokenNameCOMMENT_LINE	we're after the slice until we change slice) 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
inSlice	TokenNameIdentifier	 in Slice
||	TokenNameOR_OR	
isColumnBeforeSliceFinish	TokenNameIdentifier	 is Column Before Slice Finish
(	TokenNameLPAREN	
prefetchedCol	TokenNameIdentifier	 prefetched Col
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
blockColumns	TokenNameIdentifier	 block Columns
.	TokenNameDOT	
addLast	TokenNameIdentifier	 add Last
(	TokenNameLPAREN	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
gotSome	TokenNameIdentifier	 got Some
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if col is after slice, ignore 	TokenNameCOMMENT_LINE	if col is after slice, ignore 
else	TokenNameelse	
{	TokenNameLBRACE	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
gotSome	TokenNameIdentifier	 got Some
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
return	TokenNamereturn	
getNextBlock	TokenNameIdentifier	 get Next Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
CorruptSSTableException	TokenNameIdentifier	 Corrupt SS Table Exception
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
,	TokenNameCOMMA	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
getPath	TokenNameIdentifier	 get Path
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
getNextBlock	TokenNameIdentifier	 get Next Block
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
==	TokenNameEQUAL_EQUAL	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
else	TokenNameelse	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
=	TokenNameEQUAL	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
;	TokenNameSEMICOLON	
// Are we done? 	TokenNameCOMMENT_LINE	Are we done? 
if	TokenNameif	
(	TokenNameLPAREN	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
>=	TokenNameGREATER_EQUAL	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
IndexInfo	TokenNameIdentifier	 Index Info
currentIndex	TokenNameIdentifier	 current Index
=	TokenNameEQUAL	
indexes	TokenNameIdentifier	 indexes
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* seek to the correct offset to the data, and calculate the data size */	TokenNameCOMMENT_BLOCK	 seek to the correct offset to the data, and calculate the data size 
long	TokenNamelong	
positionToSeek	TokenNameIdentifier	 position To Seek
=	TokenNameEQUAL	
basePosition	TokenNameIdentifier	 base Position
+	TokenNamePLUS	
currentIndex	TokenNameIdentifier	 current Index
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
// With new promoted indexes, our first seek in the data file will happen at that point. 	TokenNameCOMMENT_LINE	With new promoted indexes, our first seek in the data file will happen at that point. 
if	TokenNameif	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
file	TokenNameIdentifier	 file
=	TokenNameEQUAL	
originalInput	TokenNameIdentifier	 original Input
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
getFileDataInput	TokenNameIdentifier	 get File Data Input
(	TokenNameLPAREN	
positionToSeek	TokenNameIdentifier	 position To Seek
)	TokenNameRPAREN	
:	TokenNameCOLON	
originalInput	TokenNameIdentifier	 original Input
;	TokenNameSEMICOLON	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
.	TokenNameDOT	
Serializer	TokenNameIdentifier	 Serializer
atomSerializer	TokenNameIdentifier	 atom Serializer
=	TokenNameEQUAL	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
.	TokenNameDOT	
getOnDiskSerializer	TokenNameIdentifier	 get On Disk Serializer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
seek	TokenNameIdentifier	 seek
(	TokenNameLPAREN	
positionToSeek	TokenNameIdentifier	 position To Seek
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FileMark	TokenNameIdentifier	 File Mark
mark	TokenNameIdentifier	 mark
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
mark	TokenNameIdentifier	 mark
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We remenber when we are whithin a slice to avoid some comparison 	TokenNameCOMMENT_LINE	We remenber when we are whithin a slice to avoid some comparison 
boolean	TokenNameboolean	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// scan from index start 	TokenNameCOMMENT_LINE	scan from index start 
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
bytesPastMark	TokenNameIdentifier	 bytes Past Mark
(	TokenNameLPAREN	
mark	TokenNameIdentifier	 mark
)	TokenNameRPAREN	
<	TokenNameLESS	
currentIndex	TokenNameIdentifier	 current Index
.	TokenNameDOT	
width	TokenNameIdentifier	 width
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Only fetch a new column if we haven't dealt with the previous one. 	TokenNameCOMMENT_LINE	Only fetch a new column if we haven't dealt with the previous one. 
if	TokenNameif	
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
atomSerializer	TokenNameIdentifier	 atom Serializer
.	TokenNameDOT	
deserializeFromSSTable	TokenNameIdentifier	 deserialize From SS Table
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// col is before slice 	TokenNameCOMMENT_LINE	col is before slice 
// (If in slice, don't bother checking that until we change slice) 	TokenNameCOMMENT_LINE	(If in slice, don't bother checking that until we change slice) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inSlice	TokenNameIdentifier	 in Slice
&&	TokenNameAND_AND	
isColumnBeforeSliceStart	TokenNameIdentifier	 is Column Before Slice Start
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// the next slice select columns that are before the current one, so it may 	TokenNameCOMMENT_LINE	the next slice select columns that are before the current one, so it may 
// match this column, so keep it around. 	TokenNameCOMMENT_LINE	match this column, so keep it around. 
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
addFirst	TokenNameIdentifier	 add First
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// col is within slice 	TokenNameCOMMENT_LINE	col is within slice 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
isColumnBeforeSliceFinish	TokenNameIdentifier	 is Column Before Slice Finish
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
addColumn	TokenNameIdentifier	 add Column
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// col is after slice. 	TokenNameCOMMENT_LINE	col is after slice. 
else	TokenNameelse	
{	TokenNameLBRACE	
// When reading forward, if we hit a column that sorts after the current slice, it means we're done with this slice. 	TokenNameCOMMENT_LINE	When reading forward, if we hit a column that sorts after the current slice, it means we're done with this slice. 
// For reversed, this may either mean that we're done with the current slice, or that we need to read the previous 	TokenNameCOMMENT_LINE	For reversed, this may either mean that we're done with the current slice, or that we need to read the previous 
// index block. However, we can be sure that we are in the first case though (the current slice is done) if the first 	TokenNameCOMMENT_LINE	index block. However, we can be sure that we are in the first case though (the current slice is done) if the first 
// columns of the block were not part of the current slice, i.e. if we have columns in prefetched. 	TokenNameCOMMENT_LINE	columns of the block were not part of the current slice, i.e. if we have columns in prefetched. 
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
&&	TokenNameAND_AND	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// The next index block now corresponds to the first block that may have columns for the newly set slice. 	TokenNameCOMMENT_LINE	The next index block now corresponds to the first block that may have columns for the newly set slice. 
// So if it's different from the current block, we're done with this block. And in that case, we know 	TokenNameCOMMENT_LINE	So if it's different from the current block, we're done with this block. And in that case, we know 
// that our prefetched columns won't match. 	TokenNameCOMMENT_LINE	that our prefetched columns won't match. 
if	TokenNameif	
(	TokenNameLPAREN	
nextIndexIdx	TokenNameIdentifier	 next Index Idx
!=	TokenNameNOT_EQUAL	
lastDeserializedBlock	TokenNameIdentifier	 last Deserialized Block
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
prefetched	TokenNameIdentifier	 prefetched
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Even if the next slice may have column in this blocks, if we're reversed, those columns have been 	TokenNameCOMMENT_LINE	Even if the next slice may have column in this blocks, if we're reversed, those columns have been 
// prefetched and we're done with that block 	TokenNameCOMMENT_LINE	prefetched and we're done with that block 
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// otherwise, we will deal with that column at the next iteration 	TokenNameCOMMENT_LINE	otherwise, we will deal with that column at the next iteration 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
class	TokenNameclass	
SimpleBlockFetcher	TokenNameIdentifier	 Simple Block Fetcher
extends	TokenNameextends	
BlockFetcher	TokenNameIdentifier	 Block Fetcher
{	TokenNameLBRACE	
public	TokenNamepublic	
SimpleBlockFetcher	TokenNameIdentifier	 Simple Block Fetcher
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Since we have to deserialize in order and will read all slices might as well reverse the slices and 	TokenNameCOMMENT_LINE	Since we have to deserialize in order and will read all slices might as well reverse the slices and 
// behave as if it was not reversed 	TokenNameCOMMENT_LINE	behave as if it was not reversed 
super	TokenNamesuper	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
?	TokenNameQUESTION	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We remenber when we are whithin a slice to avoid some comparison 	TokenNameCOMMENT_LINE	We remenber when we are whithin a slice to avoid some comparison 
boolean	TokenNameboolean	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
.	TokenNameDOT	
Serializer	TokenNameIdentifier	 Serializer
atomSerializer	TokenNameIdentifier	 atom Serializer
=	TokenNameEQUAL	
emptyColumnFamily	TokenNameIdentifier	 empty Column Family
.	TokenNameDOT	
getOnDiskSerializer	TokenNameIdentifier	 get On Disk Serializer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
columns	TokenNameIdentifier	 columns
=	TokenNameEQUAL	
file	TokenNameIdentifier	 file
.	TokenNameDOT	
readInt	TokenNameIdentifier	 read Int
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
columns	TokenNameIdentifier	 columns
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
OnDiskAtom	TokenNameIdentifier	 On Disk Atom
column	TokenNameIdentifier	 column
=	TokenNameEQUAL	
atomSerializer	TokenNameIdentifier	 atom Serializer
.	TokenNameDOT	
deserializeFromSSTable	TokenNameIdentifier	 deserialize From SS Table
(	TokenNameLPAREN	
file	TokenNameIdentifier	 file
,	TokenNameCOMMA	
sstable	TokenNameIdentifier	 sstable
.	TokenNameDOT	
descriptor	TokenNameIdentifier	 descriptor
.	TokenNameDOT	
version	TokenNameIdentifier	 version
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// col is before slice 	TokenNameCOMMENT_LINE	col is before slice 
// (If in slice, don't bother checking that until we change slice) 	TokenNameCOMMENT_LINE	(If in slice, don't bother checking that until we change slice) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
inSlice	TokenNameIdentifier	 in Slice
&&	TokenNameAND_AND	
isColumnBeforeSliceStart	TokenNameIdentifier	 is Column Before Slice Start
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
// col is within slice 	TokenNameCOMMENT_LINE	col is within slice 
if	TokenNameif	
(	TokenNameLPAREN	
isColumnBeforeSliceFinish	TokenNameIdentifier	 is Column Before Slice Finish
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
addColumn	TokenNameIdentifier	 add Column
(	TokenNameLPAREN	
column	TokenNameIdentifier	 column
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// col is after slice. more slices? 	TokenNameCOMMENT_LINE	col is after slice. more slices? 
else	TokenNameelse	
{	TokenNameLBRACE	
inSlice	TokenNameIdentifier	 in Slice
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
setNextSlice	TokenNameIdentifier	 set Next Slice
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
reversed	TokenNameIdentifier	 reversed
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
>=	TokenNameGREATER_EQUAL	
slices	TokenNameIdentifier	 slices
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
currentSliceIdx	TokenNameIdentifier	 current Slice Idx
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fetchMoreData	TokenNameIdentifier	 fetch More Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
