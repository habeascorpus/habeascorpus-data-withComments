package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
join	TokenNameIdentifier	 join
;	TokenNameSEMICOLON	
/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_JAVADOC	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Set	TokenNameIdentifier	 Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexReader	TokenNameIdentifier	 Index Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
IndexWriter	TokenNameIdentifier	 Index Writer
;	TokenNameSEMICOLON	
// javadocs 	TokenNameCOMMENT_LINE	javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
CachingWrapperFilter	TokenNameIdentifier	 Caching Wrapper Filter
;	TokenNameSEMICOLON	
// javadocs 	TokenNameCOMMENT_LINE	javadocs 
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
DocIdSet	TokenNameIdentifier	 Doc Id Set
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
DocIdSetIterator	TokenNameIdentifier	 Doc Id Set Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Explanation	TokenNameIdentifier	 Explanation
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Filter	TokenNameIdentifier	 Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Scorer	TokenNameIdentifier	 Scorer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Searcher	TokenNameIdentifier	 Searcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Weight	TokenNameIdentifier	 Weight
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
grouping	TokenNameIdentifier	 grouping
.	TokenNameDOT	
TopGroups	TokenNameIdentifier	 Top Groups
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayUtil	TokenNameIdentifier	 Array Util
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
FixedBitSet	TokenNameIdentifier	 Fixed Bit Set
;	TokenNameSEMICOLON	
/** * This query requires that you index * children and parent docs as a single block, using the * {@link IndexWriter#addDocuments} or {@link * IndexWriter#updateDocuments} API. In each block, the * child documents must appear first, ending with the parent * document. At search time you provide a Filter * identifying the parents, however this Filter must provide * an {@link FixedBitSet} per sub-reader. * * <p><b>WARNING</b>: to create the parents filter, always use * {@link RawTermFilter} (so that the filter * includes deleted docs), wrapped with {@link * CachingWrapperFilter} (so that the returned bit set per * reader is a {@link FixedBitSet}), specifying * DeletesMode.IGNORE (so that on reopen, the filter still * includes deleted docs). Failure to do this can result in * completely wrong documents being returned! For example: * * <pre> * Filter parents = new CachingWrapperFilter( * new RawTermFilter(new Term("parent", "yes")), * CachingWrapperFilter.DeletesMode.IGNORE); * </pre> * * <p>Once the block index is built, use this query to wrap * any sub-query matching only child docs and join matches in that * child document space up to the parent document space. * You can then use this Query as a clause with * other queries in the parent document space.</p> * * <p>See {@link ToChildBlockJoinQuery} if you need to join * in the reverse order. * * <p>The child documents must be orthogonal to the parent * documents: the wrapped child query must never * return a parent document.</p> * * If you'd like to retrieve {@link TopGroups} for the * resulting query, use the {@link ToParentBlockJoinCollector}. * Note that this is not necessary, ie, if you simply want * to collect the parent documents and don't need to see * which child documents matched under that parent, then * you can use any collector. * * <p><b>NOTE</b>: If the overall query contains parent-only * matches, for example you OR a parent-only query with a * joined child-only query, then the resulting collected documents * will be correct, however the {@link TopGroups} you get * from {@link ToParentBlockJoinCollector} will not contain every * child for parents that had matched. * * <p>See {@link org.apache.lucene.search.join} for an * overview. </p> * * @lucene.experimental */	TokenNameCOMMENT_JAVADOC	 This query requires that you index children and parent docs as a single block, using the {@link IndexWriter#addDocuments} or {@link IndexWriter#updateDocuments} API. In each block, the child documents must appear first, ending with the parent document. At search time you provide a Filter identifying the parents, however this Filter must provide an {@link FixedBitSet} per sub-reader. * <p><b>WARNING</b>: to create the parents filter, always use {@link RawTermFilter} (so that the filter includes deleted docs), wrapped with {@link CachingWrapperFilter} (so that the returned bit set per reader is a {@link FixedBitSet}), specifying DeletesMode.IGNORE (so that on reopen, the filter still includes deleted docs). Failure to do this can result in completely wrong documents being returned! For example: * <pre> Filter parents = new CachingWrapperFilter( new RawTermFilter(new Term("parent", "yes")), CachingWrapperFilter.DeletesMode.IGNORE); </pre> * <p>Once the block index is built, use this query to wrap any sub-query matching only child docs and join matches in that child document space up to the parent document space. You can then use this Query as a clause with other queries in the parent document space.</p> * <p>See {@link ToChildBlockJoinQuery} if you need to join in the reverse order. * <p>The child documents must be orthogonal to the parent documents: the wrapped child query must never return a parent document.</p> * If you'd like to retrieve {@link TopGroups} for the resulting query, use the {@link ToParentBlockJoinCollector}. Note that this is not necessary, ie, if you simply want to collect the parent documents and don't need to see which child documents matched under that parent, then you can use any collector. * <p><b>NOTE</b>: If the overall query contains parent-only matches, for example you OR a parent-only query with a joined child-only query, then the resulting collected documents will be correct, however the {@link TopGroups} you get from {@link ToParentBlockJoinCollector} will not contain every child for parents that had matched. * <p>See {@link org.apache.lucene.search.join} for an overview. </p> * @lucene.experimental 
public	TokenNamepublic	
class	TokenNameclass	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
extends	TokenNameextends	
Query	TokenNameIdentifier	 Query
{	TokenNameLBRACE	
/** How to aggregate multiple child hit scores into a * single parent score. */	TokenNameCOMMENT_JAVADOC	 How to aggregate multiple child hit scores into a single parent score. 
public	TokenNamepublic	
static	TokenNamestatic	
enum	TokenNameenum	
ScoreMode	TokenNameIdentifier	 Score Mode
{	TokenNameLBRACE	
/** Do no scoring. */	TokenNameCOMMENT_JAVADOC	 Do no scoring. 
None	TokenNameIdentifier	 None
,	TokenNameCOMMA	
/** Parent hit's score is the average of all child scores. */	TokenNameCOMMENT_JAVADOC	 Parent hit's score is the average of all child scores. 
Avg	TokenNameIdentifier	 Avg
,	TokenNameCOMMA	
/** Parent hit's score is the max of all child scores. */	TokenNameCOMMENT_JAVADOC	 Parent hit's score is the max of all child scores. 
Max	TokenNameIdentifier	 Max
,	TokenNameCOMMA	
/** Parent hit's score is the sum of all child scores. */	TokenNameCOMMENT_JAVADOC	 Parent hit's score is the sum of all child scores. 
Total	TokenNameIdentifier	 Total
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Filter	TokenNameIdentifier	 Filter
parentsFilter	TokenNameIdentifier	 parents Filter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Query	TokenNameIdentifier	 Query
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
// If we are rewritten, this is the original childQuery we 	TokenNameCOMMENT_LINE	If we are rewritten, this is the original childQuery we 
// were passed; we use this for .equals() and 	TokenNameCOMMENT_LINE	were passed; we use this for .equals() and 
// .hashCode(). This makes rewritten query equal the 	TokenNameCOMMENT_LINE	.hashCode(). This makes rewritten query equal the 
// original, so that user does not have to .rewrite() their 	TokenNameCOMMENT_LINE	original, so that user does not have to .rewrite() their 
// query before searching: 	TokenNameCOMMENT_LINE	query before searching: 
private	TokenNameprivate	
final	TokenNamefinal	
Query	TokenNameIdentifier	 Query
origChildQuery	TokenNameIdentifier	 orig Child Query
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
/** Create a ToParentBlockJoinQuery. * * @param childQuery Query matching child documents. * @param parentsFilter Filter (must produce FixedBitSet * per-seegment) identifying the parent documents. * @param scoreMode How to aggregate multiple child scores * into a single parent score. **/	TokenNameCOMMENT_JAVADOC	 Create a ToParentBlockJoinQuery. * @param childQuery Query matching child documents. @param parentsFilter Filter (must produce FixedBitSet per-seegment) identifying the parent documents. @param scoreMode How to aggregate multiple child scores into a single parent score. *
public	TokenNamepublic	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
childQuery	TokenNameIdentifier	 child Query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
origChildQuery	TokenNameIdentifier	 orig Child Query
=	TokenNameEQUAL	
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
childQuery	TokenNameIdentifier	 child Query
=	TokenNameEQUAL	
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
parentsFilter	TokenNameIdentifier	 parents Filter
=	TokenNameEQUAL	
parentsFilter	TokenNameIdentifier	 parents Filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scoreMode	TokenNameIdentifier	 score Mode
=	TokenNameEQUAL	
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
origChildQuery	TokenNameIdentifier	 orig Child Query
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
childQuery	TokenNameIdentifier	 child Query
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
origChildQuery	TokenNameIdentifier	 orig Child Query
=	TokenNameEQUAL	
origChildQuery	TokenNameIdentifier	 orig Child Query
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
childQuery	TokenNameIdentifier	 child Query
=	TokenNameEQUAL	
childQuery	TokenNameIdentifier	 child Query
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
parentsFilter	TokenNameIdentifier	 parents Filter
=	TokenNameEQUAL	
parentsFilter	TokenNameIdentifier	 parents Filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scoreMode	TokenNameIdentifier	 score Mode
=	TokenNameEQUAL	
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Weight	TokenNameIdentifier	 Weight
createWeight	TokenNameIdentifier	 create Weight
(	TokenNameLPAREN	
Searcher	TokenNameIdentifier	 Searcher
searcher	TokenNameIdentifier	 searcher
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
BlockJoinWeight	TokenNameIdentifier	 Block Join Weight
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
childQuery	TokenNameIdentifier	 child Query
.	TokenNameDOT	
createWeight	TokenNameIdentifier	 create Weight
(	TokenNameLPAREN	
searcher	TokenNameIdentifier	 searcher
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
class	TokenNameclass	
BlockJoinWeight	TokenNameIdentifier	 Block Join Weight
extends	TokenNameextends	
Weight	TokenNameIdentifier	 Weight
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Query	TokenNameIdentifier	 Query
joinQuery	TokenNameIdentifier	 join Query
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Weight	TokenNameIdentifier	 Weight
childWeight	TokenNameIdentifier	 child Weight
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
Filter	TokenNameIdentifier	 Filter
parentsFilter	TokenNameIdentifier	 parents Filter
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
public	TokenNamepublic	
BlockJoinWeight	TokenNameIdentifier	 Block Join Weight
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
joinQuery	TokenNameIdentifier	 join Query
,	TokenNameCOMMA	
Weight	TokenNameIdentifier	 Weight
childWeight	TokenNameIdentifier	 child Weight
,	TokenNameCOMMA	
Filter	TokenNameIdentifier	 Filter
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
joinQuery	TokenNameIdentifier	 join Query
=	TokenNameEQUAL	
joinQuery	TokenNameIdentifier	 join Query
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
childWeight	TokenNameIdentifier	 child Weight
=	TokenNameEQUAL	
childWeight	TokenNameIdentifier	 child Weight
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
parentsFilter	TokenNameIdentifier	 parents Filter
=	TokenNameEQUAL	
parentsFilter	TokenNameIdentifier	 parents Filter
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scoreMode	TokenNameIdentifier	 score Mode
=	TokenNameEQUAL	
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
getQuery	TokenNameIdentifier	 get Query
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
joinQuery	TokenNameIdentifier	 join Query
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
childWeight	TokenNameIdentifier	 child Weight
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
sumOfSquaredWeights	TokenNameIdentifier	 sum Of Squared Weights
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
childWeight	TokenNameIdentifier	 child Weight
.	TokenNameDOT	
sumOfSquaredWeights	TokenNameIdentifier	 sum Of Squared Weights
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
joinQuery	TokenNameIdentifier	 join Query
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
*	TokenNameMULTIPLY	
joinQuery	TokenNameIdentifier	 join Query
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
float	TokenNamefloat	
norm	TokenNameIdentifier	 norm
)	TokenNameRPAREN	
{	TokenNameLBRACE	
childWeight	TokenNameIdentifier	 child Weight
.	TokenNameDOT	
normalize	TokenNameIdentifier	 normalize
(	TokenNameLPAREN	
norm	TokenNameIdentifier	 norm
*	TokenNameMULTIPLY	
joinQuery	TokenNameIdentifier	 join Query
.	TokenNameDOT	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Scorer	TokenNameIdentifier	 Scorer
scorer	TokenNameIdentifier	 scorer
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
boolean	TokenNameboolean	
scoreDocsInOrder	TokenNameIdentifier	 score Docs In Order
,	TokenNameCOMMA	
boolean	TokenNameboolean	
topScorer	TokenNameIdentifier	 top Scorer
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// Pass scoreDocsInOrder true, topScorer false to our sub: 	TokenNameCOMMENT_LINE	Pass scoreDocsInOrder true, topScorer false to our sub: 
final	TokenNamefinal	
Scorer	TokenNameIdentifier	 Scorer
childScorer	TokenNameIdentifier	 child Scorer
=	TokenNameEQUAL	
childWeight	TokenNameIdentifier	 child Weight
.	TokenNameDOT	
scorer	TokenNameIdentifier	 scorer
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childScorer	TokenNameIdentifier	 child Scorer
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No matches 	TokenNameCOMMENT_LINE	No matches 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
firstChildDoc	TokenNameIdentifier	 first Child Doc
=	TokenNameEQUAL	
childScorer	TokenNameIdentifier	 child Scorer
.	TokenNameDOT	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
firstChildDoc	TokenNameIdentifier	 first Child Doc
==	TokenNameEQUAL_EQUAL	
DocIdSetIterator	TokenNameIdentifier	 Doc Id Set Iterator
.	TokenNameDOT	
NO_MORE_DOCS	TokenNameIdentifier	 NO  MORE  DOCS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No matches 	TokenNameCOMMENT_LINE	No matches 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
DocIdSet	TokenNameIdentifier	 Doc Id Set
parents	TokenNameIdentifier	 parents
=	TokenNameEQUAL	
parentsFilter	TokenNameIdentifier	 parents Filter
.	TokenNameDOT	
getDocIdSet	TokenNameIdentifier	 get Doc Id Set
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// TODO: once we do random-access filters we can 	TokenNameCOMMENT_LINE	TODO: once we do random-access filters we can 
// generalize this: 	TokenNameCOMMENT_LINE	generalize this: 
if	TokenNameif	
(	TokenNameLPAREN	
parents	TokenNameIdentifier	 parents
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// No matches 	TokenNameCOMMENT_LINE	No matches 
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
parents	TokenNameIdentifier	 parents
instanceof	TokenNameinstanceof	
FixedBitSet	TokenNameIdentifier	 Fixed Bit Set
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"parentFilter must return FixedBitSet; got "	TokenNameStringLiteral	parentFilter must return FixedBitSet; got 
+	TokenNamePLUS	
parents	TokenNameIdentifier	 parents
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
childScorer	TokenNameIdentifier	 child Scorer
,	TokenNameCOMMA	
(	TokenNameLPAREN	
FixedBitSet	TokenNameIdentifier	 Fixed Bit Set
)	TokenNameRPAREN	
parents	TokenNameIdentifier	 parents
,	TokenNameCOMMA	
firstChildDoc	TokenNameIdentifier	 first Child Doc
,	TokenNameCOMMA	
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Explanation	TokenNameIdentifier	 Explanation
explain	TokenNameIdentifier	 explain
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
,	TokenNameCOMMA	
int	TokenNameint	
doc	TokenNameIdentifier	 doc
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
// TODO 	TokenNameCOMMENT_LINE	TODO 
throw	TokenNamethrow	
new	TokenNamenew	
UnsupportedOperationException	TokenNameIdentifier	 Unsupported Operation Exception
(	TokenNameLPAREN	
getClass	TokenNameIdentifier	 get Class
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
" cannot explain match on parent document"	TokenNameStringLiteral	 cannot explain match on parent document
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
scoresDocsOutOfOrder	TokenNameIdentifier	 scores Docs Out Of Order
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
class	TokenNameclass	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
extends	TokenNameextends	
Scorer	TokenNameIdentifier	 Scorer
{	TokenNameLBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
Scorer	TokenNameIdentifier	 Scorer
childScorer	TokenNameIdentifier	 child Scorer
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
FixedBitSet	TokenNameIdentifier	 Fixed Bit Set
parentBits	TokenNameIdentifier	 parent Bits
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
parentDoc	TokenNameIdentifier	 parent Doc
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
parentScore	TokenNameIdentifier	 parent Score
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
nextChildDoc	TokenNameIdentifier	 next Child Doc
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
childDocUpto	TokenNameIdentifier	 child Doc Upto
;	TokenNameSEMICOLON	
public	TokenNamepublic	
BlockJoinScorer	TokenNameIdentifier	 Block Join Scorer
(	TokenNameLPAREN	
Weight	TokenNameIdentifier	 Weight
weight	TokenNameIdentifier	 weight
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
childScorer	TokenNameIdentifier	 child Scorer
,	TokenNameCOMMA	
FixedBitSet	TokenNameIdentifier	 Fixed Bit Set
parentBits	TokenNameIdentifier	 parent Bits
,	TokenNameCOMMA	
int	TokenNameint	
firstChildDoc	TokenNameIdentifier	 first Child Doc
,	TokenNameCOMMA	
ScoreMode	TokenNameIdentifier	 Score Mode
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
weight	TokenNameIdentifier	 weight
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println("Q.init firstChildDoc=" + firstChildDoc); 	TokenNameCOMMENT_LINE	System.out.println("Q.init firstChildDoc=" + firstChildDoc); 
this	TokenNamethis	
.	TokenNameDOT	
parentBits	TokenNameIdentifier	 parent Bits
=	TokenNameEQUAL	
parentBits	TokenNameIdentifier	 parent Bits
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
childScorer	TokenNameIdentifier	 child Scorer
=	TokenNameEQUAL	
childScorer	TokenNameIdentifier	 child Scorer
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
scoreMode	TokenNameIdentifier	 score Mode
=	TokenNameEQUAL	
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scoreMode	TokenNameIdentifier	 score Mode
!=	TokenNameNOT_EQUAL	
ScoreMode	TokenNameIdentifier	 Score Mode
.	TokenNameDOT	
None	TokenNameIdentifier	 None
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nextChildDoc	TokenNameIdentifier	 next Child Doc
=	TokenNameEQUAL	
firstChildDoc	TokenNameIdentifier	 first Child Doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
visitSubScorers	TokenNameIdentifier	 visit Sub Scorers
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
BooleanClause	TokenNameIdentifier	 Boolean Clause
.	TokenNameDOT	
Occur	TokenNameIdentifier	 Occur
relationship	TokenNameIdentifier	 relationship
,	TokenNameCOMMA	
ScorerVisitor	TokenNameIdentifier	 Scorer Visitor
<	TokenNameLESS	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Query	TokenNameIdentifier	 Query
,	TokenNameCOMMA	
Scorer	TokenNameIdentifier	 Scorer
>	TokenNameGREATER	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
visitSubScorers	TokenNameIdentifier	 visit Sub Scorers
(	TokenNameLPAREN	
parent	TokenNameIdentifier	 parent
,	TokenNameCOMMA	
relationship	TokenNameIdentifier	 relationship
,	TokenNameCOMMA	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//childScorer.visitSubScorers(weight.getQuery(), BooleanClause.Occur.MUST, visitor); 	TokenNameCOMMENT_LINE	childScorer.visitSubScorers(weight.getQuery(), BooleanClause.Occur.MUST, visitor); 
childScorer	TokenNameIdentifier	 child Scorer
.	TokenNameDOT	
visitScorers	TokenNameIdentifier	 visit Scorers
(	TokenNameLPAREN	
visitor	TokenNameIdentifier	 visitor
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
getChildCount	TokenNameIdentifier	 get Child Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
childDocUpto	TokenNameIdentifier	 child Doc Upto
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
swapChildDocs	TokenNameIdentifier	 swap Child Docs
(	TokenNameLPAREN	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
swapChildScores	TokenNameIdentifier	 swap Child Scores
(	TokenNameLPAREN	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
scoreMode	TokenNameIdentifier	 score Mode
==	TokenNameEQUAL_EQUAL	
ScoreMode	TokenNameIdentifier	 Score Mode
.	TokenNameDOT	
None	TokenNameIdentifier	 None
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalStateException	TokenNameIdentifier	 Illegal State Exception
(	TokenNameLPAREN	
"ScoreMode is None; you must pass trackScores=false to ToParentBlockJoinCollector"	TokenNameStringLiteral	ScoreMode is None; you must pass trackScores=false to ToParentBlockJoinCollector
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
float	TokenNamefloat	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
=	TokenNameEQUAL	
new	TokenNamenew	
float	TokenNamefloat	
[	TokenNameLBRACKET	
5	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
=	TokenNameEQUAL	
other	TokenNameIdentifier	 other
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc); 	TokenNameCOMMENT_LINE	System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc); 
if	TokenNameif	
(	TokenNameLPAREN	
nextChildDoc	TokenNameIdentifier	 next Child Doc
==	TokenNameEQUAL_EQUAL	
NO_MORE_DOCS	TokenNameIdentifier	 NO  MORE  DOCS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//System.out.println(" end"); 	TokenNameCOMMENT_LINE	System.out.println(" end"); 
return	TokenNamereturn	
parentDoc	TokenNameIdentifier	 parent Doc
=	TokenNameEQUAL	
NO_MORE_DOCS	TokenNameIdentifier	 NO  MORE  DOCS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Gather all children sharing the same parent as nextChildDoc 	TokenNameCOMMENT_LINE	Gather all children sharing the same parent as nextChildDoc 
parentDoc	TokenNameIdentifier	 parent Doc
=	TokenNameEQUAL	
parentBits	TokenNameIdentifier	 parent Bits
.	TokenNameDOT	
nextSetBit	TokenNameIdentifier	 next Set Bit
(	TokenNameLPAREN	
nextChildDoc	TokenNameIdentifier	 next Child Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" parentDoc=" + parentDoc); 	TokenNameCOMMENT_LINE	System.out.println(" parentDoc=" + parentDoc); 
assert	TokenNameassert	
parentDoc	TokenNameIdentifier	 parent Doc
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
totalScore	TokenNameIdentifier	 total Score
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
float	TokenNamefloat	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Float	TokenNameIdentifier	 Float
.	TokenNameDOT	
NEGATIVE_INFINITY	TokenNameIdentifier	 NEGATIVE  INFINITY
;	TokenNameSEMICOLON	
childDocUpto	TokenNameIdentifier	 child Doc Upto
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
//System.out.println(" c=" + nextChildDoc); 	TokenNameCOMMENT_LINE	System.out.println(" c=" + nextChildDoc); 
if	TokenNameif	
(	TokenNameLPAREN	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
childDocUpto	TokenNameIdentifier	 child Doc Upto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
scoreMode	TokenNameIdentifier	 score Mode
!=	TokenNameNOT_EQUAL	
ScoreMode	TokenNameIdentifier	 Score Mode
.	TokenNameDOT	
None	TokenNameIdentifier	 None
&&	TokenNameAND_AND	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
.	TokenNameDOT	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
childDocUpto	TokenNameIdentifier	 child Doc Upto
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
=	TokenNameEQUAL	
ArrayUtil	TokenNameIdentifier	 Array Util
.	TokenNameDOT	
grow	TokenNameIdentifier	 grow
(	TokenNameLPAREN	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
pendingChildDocs	TokenNameIdentifier	 pending Child Docs
[	TokenNameLBRACKET	
childDocUpto	TokenNameIdentifier	 child Doc Upto
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
nextChildDoc	TokenNameIdentifier	 next Child Doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
scoreMode	TokenNameIdentifier	 score Mode
!=	TokenNameNOT_EQUAL	
ScoreMode	TokenNameIdentifier	 Score Mode
.	TokenNameDOT	
None	TokenNameIdentifier	 None
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// TODO: specialize this into dedicated classes per-scoreMode 	TokenNameCOMMENT_LINE	TODO: specialize this into dedicated classes per-scoreMode 
final	TokenNamefinal	
float	TokenNamefloat	
childScore	TokenNameIdentifier	 child Score
=	TokenNameEQUAL	
childScorer	TokenNameIdentifier	 child Scorer
.	TokenNameDOT	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
pendingChildScores	TokenNameIdentifier	 pending Child Scores
[	TokenNameLBRACKET	
childDocUpto	TokenNameIdentifier	 child Doc Upto
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
childScore	TokenNameIdentifier	 child Score
;	TokenNameSEMICOLON	
maxScore	TokenNameIdentifier	 max Score
=	TokenNameEQUAL	
Math	TokenNameIdentifier	 Math
.	TokenNameDOT	
max	TokenNameIdentifier	 max
(	TokenNameLPAREN	
childScore	TokenNameIdentifier	 child Score
,	TokenNameCOMMA	
maxScore	TokenNameIdentifier	 max Score
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
totalScore	TokenNameIdentifier	 total Score
+=	TokenNamePLUS_EQUAL	
childScore	TokenNameIdentifier	 child Score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
childDocUpto	TokenNameIdentifier	 child Doc Upto
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
nextChildDoc	TokenNameIdentifier	 next Child Doc
=	TokenNameEQUAL	
childScorer	TokenNameIdentifier	 child Scorer
.	TokenNameDOT	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
nextChildDoc	TokenNameIdentifier	 next Child Doc
<	TokenNameLESS	
parentDoc	TokenNameIdentifier	 parent Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" nextChildDoc=" + nextChildDoc); 	TokenNameCOMMENT_LINE	System.out.println(" nextChildDoc=" + nextChildDoc); 
// Parent & child docs are supposed to be orthogonal: 	TokenNameCOMMENT_LINE	Parent & child docs are supposed to be orthogonal: 
assert	TokenNameassert	
nextChildDoc	TokenNameIdentifier	 next Child Doc
!=	TokenNameNOT_EQUAL	
parentDoc	TokenNameIdentifier	 parent Doc
;	TokenNameSEMICOLON	
switch	TokenNameswitch	
(	TokenNameLPAREN	
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
Avg	TokenNameIdentifier	 Avg
:	TokenNameCOLON	
parentScore	TokenNameIdentifier	 parent Score
=	TokenNameEQUAL	
totalScore	TokenNameIdentifier	 total Score
/	TokenNameDIVIDE	
childDocUpto	TokenNameIdentifier	 child Doc Upto
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Max	TokenNameIdentifier	 Max
:	TokenNameCOLON	
parentScore	TokenNameIdentifier	 parent Score
=	TokenNameEQUAL	
maxScore	TokenNameIdentifier	 max Score
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
Total	TokenNameIdentifier	 Total
:	TokenNameCOLON	
parentScore	TokenNameIdentifier	 parent Score
=	TokenNameEQUAL	
totalScore	TokenNameIdentifier	 total Score
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
None	TokenNameIdentifier	 None
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//System.out.println(" return parentDoc=" + parentDoc); 	TokenNameCOMMENT_LINE	System.out.println(" return parentDoc=" + parentDoc); 
return	TokenNamereturn	
parentDoc	TokenNameIdentifier	 parent Doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
docID	TokenNameIdentifier	 doc ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
parentDoc	TokenNameIdentifier	 parent Doc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
float	TokenNamefloat	
score	TokenNameIdentifier	 score
(	TokenNameLPAREN	
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
return	TokenNamereturn	
parentScore	TokenNameIdentifier	 parent Score
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
int	TokenNameint	
parentTarget	TokenNameIdentifier	 parent Target
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
//System.out.println("Q.advance parentTarget=" + parentTarget); 	TokenNameCOMMENT_LINE	System.out.println("Q.advance parentTarget=" + parentTarget); 
if	TokenNameif	
(	TokenNameLPAREN	
parentTarget	TokenNameIdentifier	 parent Target
==	TokenNameEQUAL_EQUAL	
NO_MORE_DOCS	TokenNameIdentifier	 NO  MORE  DOCS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
parentDoc	TokenNameIdentifier	 parent Doc
=	TokenNameEQUAL	
NO_MORE_DOCS	TokenNameIdentifier	 NO  MORE  DOCS
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
parentTarget	TokenNameIdentifier	 parent Target
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Callers should only be passing in a docID from 	TokenNameCOMMENT_LINE	Callers should only be passing in a docID from 
// the parent space, so this means this parent 	TokenNameCOMMENT_LINE	the parent space, so this means this parent 
// has no children (it got docID 0), so it cannot 	TokenNameCOMMENT_LINE	has no children (it got docID 0), so it cannot 
// possibly match. We must handle this case 	TokenNameCOMMENT_LINE	possibly match. We must handle this case 
// separately otherwise we pass invalid -1 to 	TokenNameCOMMENT_LINE	separately otherwise we pass invalid -1 to 
// prevSetBit below: 	TokenNameCOMMENT_LINE	prevSetBit below: 
return	TokenNamereturn	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
prevParentDoc	TokenNameIdentifier	 prev Parent Doc
=	TokenNameEQUAL	
parentBits	TokenNameIdentifier	 parent Bits
.	TokenNameDOT	
prevSetBit	TokenNameIdentifier	 prev Set Bit
(	TokenNameLPAREN	
parentTarget	TokenNameIdentifier	 parent Target
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" rolled back to prevParentDoc=" + prevParentDoc + " vs parentDoc=" + parentDoc); 	TokenNameCOMMENT_LINE	System.out.println(" rolled back to prevParentDoc=" + prevParentDoc + " vs parentDoc=" + parentDoc); 
assert	TokenNameassert	
prevParentDoc	TokenNameIdentifier	 prev Parent Doc
>=	TokenNameGREATER_EQUAL	
parentDoc	TokenNameIdentifier	 parent Doc
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
prevParentDoc	TokenNameIdentifier	 prev Parent Doc
>	TokenNameGREATER	
nextChildDoc	TokenNameIdentifier	 next Child Doc
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nextChildDoc	TokenNameIdentifier	 next Child Doc
=	TokenNameEQUAL	
childScorer	TokenNameIdentifier	 child Scorer
.	TokenNameDOT	
advance	TokenNameIdentifier	 advance
(	TokenNameLPAREN	
prevParentDoc	TokenNameIdentifier	 prev Parent Doc
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// System.out.println(" childScorer advanced to child docID=" + nextChildDoc); 	TokenNameCOMMENT_LINE	System.out.println(" childScorer advanced to child docID=" + nextChildDoc); 
//} else { 	TokenNameCOMMENT_LINE	} else { 
//System.out.println(" skip childScorer advance"); 	TokenNameCOMMENT_LINE	System.out.println(" skip childScorer advance"); 
}	TokenNameRBRACE	
// Parent & child docs are supposed to be orthogonal: 	TokenNameCOMMENT_LINE	Parent & child docs are supposed to be orthogonal: 
assert	TokenNameassert	
nextChildDoc	TokenNameIdentifier	 next Child Doc
!=	TokenNameNOT_EQUAL	
prevParentDoc	TokenNameIdentifier	 prev Parent Doc
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
nd	TokenNameIdentifier	 nd
=	TokenNameEQUAL	
nextDoc	TokenNameIdentifier	 next Doc
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//System.out.println(" return nextParentDoc=" + nd); 	TokenNameCOMMENT_LINE	System.out.println(" return nextParentDoc=" + nd); 
return	TokenNamereturn	
nd	TokenNameIdentifier	 nd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
void	TokenNamevoid	
extractTerms	TokenNameIdentifier	 extract Terms
(	TokenNameLPAREN	
Set	TokenNameIdentifier	 Set
<	TokenNameLESS	
Term	TokenNameIdentifier	 Term
>	TokenNameGREATER	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
{	TokenNameLBRACE	
childQuery	TokenNameIdentifier	 child Query
.	TokenNameDOT	
extractTerms	TokenNameIdentifier	 extract Terms
(	TokenNameLPAREN	
terms	TokenNameIdentifier	 terms
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Query	TokenNameIdentifier	 Query
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
IndexReader	TokenNameIdentifier	 Index Reader
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
throws	TokenNamethrows	
IOException	TokenNameIdentifier	 IO Exception
{	TokenNameLBRACE	
final	TokenNamefinal	
Query	TokenNameIdentifier	 Query
childRewrite	TokenNameIdentifier	 child Rewrite
=	TokenNameEQUAL	
childQuery	TokenNameIdentifier	 child Query
.	TokenNameDOT	
rewrite	TokenNameIdentifier	 rewrite
(	TokenNameLPAREN	
reader	TokenNameIdentifier	 reader
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
childRewrite	TokenNameIdentifier	 child Rewrite
!=	TokenNameNOT_EQUAL	
childQuery	TokenNameIdentifier	 child Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Query	TokenNameIdentifier	 Query
rewritten	TokenNameIdentifier	 rewritten
=	TokenNameEQUAL	
new	TokenNamenew	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
(	TokenNameLPAREN	
childQuery	TokenNameIdentifier	 child Query
,	TokenNameCOMMA	
childRewrite	TokenNameIdentifier	 child Rewrite
,	TokenNameCOMMA	
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rewritten	TokenNameIdentifier	 rewritten
.	TokenNameDOT	
setBoost	TokenNameIdentifier	 set Boost
(	TokenNameLPAREN	
getBoost	TokenNameIdentifier	 get Boost
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
rewritten	TokenNameIdentifier	 rewritten
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
this	TokenNamethis	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
"ToParentBlockJoinQuery ("	TokenNameStringLiteral	ToParentBlockJoinQuery (
+	TokenNamePLUS	
childQuery	TokenNameIdentifier	 child Query
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
")"	TokenNameStringLiteral	)
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
_other	TokenNameIdentifier	 other
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
_other	TokenNameIdentifier	 other
instanceof	TokenNameinstanceof	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
other	TokenNameIdentifier	 other
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
)	TokenNameRPAREN	
_other	TokenNameIdentifier	 other
;	TokenNameSEMICOLON	
return	TokenNamereturn	
origChildQuery	TokenNameIdentifier	 orig Child Query
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
origChildQuery	TokenNameIdentifier	 orig Child Query
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
parentsFilter	TokenNameIdentifier	 parents Filter
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
parentsFilter	TokenNameIdentifier	 parents Filter
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
scoreMode	TokenNameIdentifier	 score Mode
==	TokenNameEQUAL_EQUAL	
other	TokenNameIdentifier	 other
.	TokenNameDOT	
scoreMode	TokenNameIdentifier	 score Mode
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
prime	TokenNameIdentifier	 prime
=	TokenNameEQUAL	
31	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
hash	TokenNameIdentifier	 hash
+	TokenNamePLUS	
origChildQuery	TokenNameIdentifier	 orig Child Query
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
hash	TokenNameIdentifier	 hash
+	TokenNamePLUS	
scoreMode	TokenNameIdentifier	 score Mode
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
hash	TokenNameIdentifier	 hash
=	TokenNameEQUAL	
prime	TokenNameIdentifier	 prime
*	TokenNameMULTIPLY	
hash	TokenNameIdentifier	 hash
+	TokenNamePLUS	
parentsFilter	TokenNameIdentifier	 parents Filter
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
hash	TokenNameIdentifier	 hash
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
@	TokenNameAT	
Override	TokenNameIdentifier	 Override
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
ToParentBlockJoinQuery	TokenNameIdentifier	 To Parent Block Join Query
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Query	TokenNameIdentifier	 Query
)	TokenNameRPAREN	
origChildQuery	TokenNameIdentifier	 orig Child Query
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
parentsFilter	TokenNameIdentifier	 parents Filter
,	TokenNameCOMMA	
scoreMode	TokenNameIdentifier	 score Mode
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
