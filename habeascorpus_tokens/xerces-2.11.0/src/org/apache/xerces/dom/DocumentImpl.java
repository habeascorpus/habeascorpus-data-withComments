/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
Serializable	TokenNameIdentifier	 Serializable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
Reference	TokenNameIdentifier	 Reference
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
lang	TokenNameIdentifier	 lang
.	TokenNameDOT	
ref	TokenNameIdentifier	 ref
.	TokenNameDOT	
WeakReference	TokenNameIdentifier	 Weak Reference
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
LinkedList	TokenNameIdentifier	 Linked List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
EventImpl	TokenNameIdentifier	 Event Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
MouseEventImpl	TokenNameIdentifier	 Mouse Event Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
UIEventImpl	TokenNameIdentifier	 UI Event Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Attr	TokenNameIdentifier	 Attr
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMException	TokenNameIdentifier	 DOM Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DOMImplementation	TokenNameIdentifier	 DOM Implementation
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
DocumentType	TokenNameIdentifier	 Document Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Element	TokenNameIdentifier	 Element
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
Node	TokenNameIdentifier	 Node
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
UserDataHandler	TokenNameIdentifier	 User Data Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
DocumentEvent	TokenNameIdentifier	 Document Event
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
Event	TokenNameIdentifier	 Event
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
EventException	TokenNameIdentifier	 Event Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
EventListener	TokenNameIdentifier	 Event Listener
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
events	TokenNameIdentifier	 events
.	TokenNameDOT	
MutationEvent	TokenNameIdentifier	 Mutation Event
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
DocumentRange	TokenNameIdentifier	 Document Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
Range	TokenNameIdentifier	 Range
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
traversal	TokenNameIdentifier	 traversal
.	TokenNameDOT	
DocumentTraversal	TokenNameIdentifier	 Document Traversal
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
traversal	TokenNameIdentifier	 traversal
.	TokenNameDOT	
NodeFilter	TokenNameIdentifier	 Node Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
traversal	TokenNameIdentifier	 traversal
.	TokenNameDOT	
NodeIterator	TokenNameIdentifier	 Node Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
w3c	TokenNameIdentifier	 w3c
.	TokenNameDOT	
dom	TokenNameIdentifier	 dom
.	TokenNameDOT	
traversal	TokenNameIdentifier	 traversal
.	TokenNameDOT	
TreeWalker	TokenNameIdentifier	 Tree Walker
;	TokenNameSEMICOLON	
/** * The Document interface represents the entire HTML or XML document. * Conceptually, it is the root of the document tree, and provides the * primary access to the document's data. * <P> * Since elements, text nodes, comments, processing instructions, * etc. cannot exist outside the context of a Document, the Document * interface also contains the factory methods needed to create these * objects. The Node objects created have a ownerDocument attribute * which associates them with the Document within whose context they * were created. * <p> * The DocumentImpl class also implements the DOM Level 2 DocumentTraversal * interface. This interface is comprised of factory methods needed to * create NodeIterators and TreeWalkers. The process of creating NodeIterator * objects also adds these references to this document. * After finishing with an iterator it is important to remove the object * using the remove methods in this implementation. This allows the release of * the references from the iterator objects to the DOM Nodes. * <p> * <b>Note:</b> When any node in the document is serialized, the * entire document is serialized along with it. * * @xerces.internal * * @author Arnaud Le Hors, IBM * @author Joe Kesselman, IBM * @author Andy Clark, IBM * @author Ralf Pfeiffer, IBM * @version $Id: DocumentImpl.java 890667 2009-12-15 06:41:08Z mrglavas $ * @since PR-DOM-Level-1-19980818. */	TokenNameCOMMENT_JAVADOC	 The Document interface represents the entire HTML or XML document. Conceptually, it is the root of the document tree, and provides the primary access to the document's data. <P> Since elements, text nodes, comments, processing instructions, etc. cannot exist outside the context of a Document, the Document interface also contains the factory methods needed to create these objects. The Node objects created have a ownerDocument attribute which associates them with the Document within whose context they were created. <p> The DocumentImpl class also implements the DOM Level 2 DocumentTraversal interface. This interface is comprised of factory methods needed to create NodeIterators and TreeWalkers. The process of creating NodeIterator objects also adds these references to this document. After finishing with an iterator it is important to remove the object using the remove methods in this implementation. This allows the release of the references from the iterator objects to the DOM Nodes. <p> <b>Note:</b> When any node in the document is serialized, the entire document is serialized along with it. * @xerces.internal * @author Arnaud Le Hors, IBM @author Joe Kesselman, IBM @author Andy Clark, IBM @author Ralf Pfeiffer, IBM @version $Id: DocumentImpl.java 890667 2009-12-15 06:41:08Z mrglavas $ @since PR-DOM-Level-1-19980818. 
public	TokenNamepublic	
class	TokenNameclass	
DocumentImpl	TokenNameIdentifier	 Document Impl
extends	TokenNameextends	
CoreDocumentImpl	TokenNameIdentifier	 Core Document Impl
implements	TokenNameimplements	
DocumentTraversal	TokenNameIdentifier	 Document Traversal
,	TokenNameCOMMA	
DocumentEvent	TokenNameIdentifier	 Document Event
,	TokenNameCOMMA	
DocumentRange	TokenNameIdentifier	 Document Range
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
/** Serialization version. */	TokenNameCOMMENT_JAVADOC	 Serialization version. 
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
515687835542616694L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Node Iterators */	TokenNameCOMMENT_JAVADOC	 Node Iterators 
protected	TokenNameprotected	
transient	TokenNametransient	
List	TokenNameIdentifier	 List
iterators	TokenNameIdentifier	 iterators
;	TokenNameSEMICOLON	
/** Reference queue for cleared Node Iterator references */	TokenNameCOMMENT_JAVADOC	 Reference queue for cleared Node Iterator references 
protected	TokenNameprotected	
transient	TokenNametransient	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
iteratorReferenceQueue	TokenNameIdentifier	 iterator Reference Queue
;	TokenNameSEMICOLON	
/** Ranges */	TokenNameCOMMENT_JAVADOC	 Ranges 
protected	TokenNameprotected	
transient	TokenNametransient	
List	TokenNameIdentifier	 List
ranges	TokenNameIdentifier	 ranges
;	TokenNameSEMICOLON	
/** Reference queue for cleared Range references */	TokenNameCOMMENT_JAVADOC	 Reference queue for cleared Range references 
protected	TokenNameprotected	
transient	TokenNametransient	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
rangeReferenceQueue	TokenNameIdentifier	 range Reference Queue
;	TokenNameSEMICOLON	
/** Table for event listeners registered to this document nodes. */	TokenNameCOMMENT_JAVADOC	 Table for event listeners registered to this document nodes. 
protected	TokenNameprotected	
Hashtable	TokenNameIdentifier	 Hashtable
eventListeners	TokenNameIdentifier	 event Listeners
;	TokenNameSEMICOLON	
/** Bypass mutation events firing. */	TokenNameCOMMENT_JAVADOC	 Bypass mutation events firing. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
mutationEvents	TokenNameIdentifier	 mutation Events
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** * NON-DOM: Actually creating a Document is outside the DOM's spec, * since it has to operate in terms of a particular implementation. */	TokenNameCOMMENT_JAVADOC	 NON-DOM: Actually creating a Document is outside the DOM's spec, since it has to operate in terms of a particular implementation. 
public	TokenNamepublic	
DocumentImpl	TokenNameIdentifier	 Document Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
DocumentImpl	TokenNameIdentifier	 Document Impl
(	TokenNameLPAREN	
boolean	TokenNameboolean	
grammarAccess	TokenNameIdentifier	 grammar Access
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
grammarAccess	TokenNameIdentifier	 grammar Access
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * For DOM2 support. * The createDocument factory method is in DOMImplementation. */	TokenNameCOMMENT_JAVADOC	 For DOM2 support. The createDocument factory method is in DOMImplementation. 
public	TokenNamepublic	
DocumentImpl	TokenNameIdentifier	 Document Impl
(	TokenNameLPAREN	
DocumentType	TokenNameIdentifier	 Document Type
doctype	TokenNameIdentifier	 doctype
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
doctype	TokenNameIdentifier	 doctype
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** For DOM2 support. */	TokenNameCOMMENT_JAVADOC	 For DOM2 support. 
public	TokenNamepublic	
DocumentImpl	TokenNameIdentifier	 Document Impl
(	TokenNameLPAREN	
DocumentType	TokenNameIdentifier	 Document Type
doctype	TokenNameIdentifier	 doctype
,	TokenNameCOMMA	
boolean	TokenNameboolean	
grammarAccess	TokenNameIdentifier	 grammar Access
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
doctype	TokenNameIdentifier	 doctype
,	TokenNameCOMMA	
grammarAccess	TokenNameIdentifier	 grammar Access
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Node methods 	TokenNameCOMMENT_LINE	Node methods 
// 	TokenNameCOMMENT_LINE	 
/** * Deep-clone a document, including fixing ownerDoc for the cloned * children. Note that this requires bypassing the WRONG_DOCUMENT_ERR * protection. I've chosen to implement it by calling importNode * which is DOM Level 2. * * @return org.w3c.dom.Node * @param deep boolean, iff true replicate children */	TokenNameCOMMENT_JAVADOC	 Deep-clone a document, including fixing ownerDoc for the cloned children. Note that this requires bypassing the WRONG_DOCUMENT_ERR protection. I've chosen to implement it by calling importNode which is DOM Level 2. * @return org.w3c.dom.Node @param deep boolean, iff true replicate children 
public	TokenNamepublic	
Node	TokenNameIdentifier	 Node
cloneNode	TokenNameIdentifier	 clone Node
(	TokenNameLPAREN	
boolean	TokenNameboolean	
deep	TokenNameIdentifier	 deep
)	TokenNameRPAREN	
{	TokenNameLBRACE	
DocumentImpl	TokenNameIdentifier	 Document Impl
newdoc	TokenNameIdentifier	 newdoc
=	TokenNameEQUAL	
new	TokenNamenew	
DocumentImpl	TokenNameIdentifier	 Document Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
callUserDataHandlers	TokenNameIdentifier	 call User Data Handlers
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
newdoc	TokenNameIdentifier	 newdoc
,	TokenNameCOMMA	
UserDataHandler	TokenNameIdentifier	 User Data Handler
.	TokenNameDOT	
NODE_CLONED	TokenNameIdentifier	 NODE  CLONED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
cloneNode	TokenNameIdentifier	 clone Node
(	TokenNameLPAREN	
newdoc	TokenNameIdentifier	 newdoc
,	TokenNameCOMMA	
deep	TokenNameIdentifier	 deep
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// experimental 	TokenNameCOMMENT_LINE	experimental 
newdoc	TokenNameIdentifier	 newdoc
.	TokenNameDOT	
mutationEvents	TokenNameIdentifier	 mutation Events
=	TokenNameEQUAL	
mutationEvents	TokenNameIdentifier	 mutation Events
;	TokenNameSEMICOLON	
return	TokenNamereturn	
newdoc	TokenNameIdentifier	 newdoc
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// cloneNode(boolean):Node 	TokenNameCOMMENT_LINE	cloneNode(boolean):Node 
/** * Retrieve information describing the abilities of this particular * DOM implementation. Intended to support applications that may be * using DOMs retrieved from several different sources, potentially * with different underlying representations. */	TokenNameCOMMENT_JAVADOC	 Retrieve information describing the abilities of this particular DOM implementation. Intended to support applications that may be using DOMs retrieved from several different sources, potentially with different underlying representations. 
public	TokenNamepublic	
DOMImplementation	TokenNameIdentifier	 DOM Implementation
getImplementation	TokenNameIdentifier	 get Implementation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Currently implemented as a singleton, since it's hardcoded 	TokenNameCOMMENT_LINE	Currently implemented as a singleton, since it's hardcoded 
// information anyway. 	TokenNameCOMMENT_LINE	information anyway. 
return	TokenNamereturn	
DOMImplementationImpl	TokenNameIdentifier	 DOM Implementation Impl
.	TokenNameDOT	
getDOMImplementation	TokenNameIdentifier	 get DOM Implementation
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// DocumentTraversal methods 	TokenNameCOMMENT_LINE	DocumentTraversal methods 
// 	TokenNameCOMMENT_LINE	 
/** * NON-DOM extension: * Create and return a NodeIterator. The NodeIterator is * added to a list of NodeIterators so that it can be * removed to free up the DOM Nodes it references. * * @param root The root of the iterator. * @param whatToShow The whatToShow mask. * @param filter The NodeFilter installed. Null means no filter. */	TokenNameCOMMENT_JAVADOC	 NON-DOM extension: Create and return a NodeIterator. The NodeIterator is added to a list of NodeIterators so that it can be removed to free up the DOM Nodes it references. * @param root The root of the iterator. @param whatToShow The whatToShow mask. @param filter The NodeFilter installed. Null means no filter. 
public	TokenNamepublic	
NodeIterator	TokenNameIdentifier	 Node Iterator
createNodeIterator	TokenNameIdentifier	 create Node Iterator
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
short	TokenNameshort	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
NodeFilter	TokenNameIdentifier	 Node Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createNodeIterator	TokenNameIdentifier	 create Node Iterator
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create and return a NodeIterator. The NodeIterator is * added to a list of NodeIterators so that it can be * removed to free up the DOM Nodes it references. * * @param root The root of the iterator. * @param whatToShow The whatToShow mask. * @param filter The NodeFilter installed. Null means no filter. * @param entityReferenceExpansion true to expand the contents of * EntityReference nodes * @since WD-DOM-Level-2-19990923 */	TokenNameCOMMENT_JAVADOC	 Create and return a NodeIterator. The NodeIterator is added to a list of NodeIterators so that it can be removed to free up the DOM Nodes it references. * @param root The root of the iterator. @param whatToShow The whatToShow mask. @param filter The NodeFilter installed. Null means no filter. @param entityReferenceExpansion true to expand the contents of EntityReference nodes @since WD-DOM-Level-2-19990923 
public	TokenNamepublic	
NodeIterator	TokenNameIdentifier	 Node Iterator
createNodeIterator	TokenNameIdentifier	 create Node Iterator
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
NodeFilter	TokenNameIdentifier	 Node Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
entityReferenceExpansion	TokenNameIdentifier	 entity Reference Expansion
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
DOM_DOMAIN	TokenNameIdentifier	 DOM  DOMAIN
,	TokenNameCOMMA	
"NOT_SUPPORTED_ERR"	TokenNameStringLiteral	NOT_SUPPORTED_ERR
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
DOMException	TokenNameIdentifier	 DOM Exception
(	TokenNameLPAREN	
DOMException	TokenNameIdentifier	 DOM Exception
.	TokenNameDOT	
NOT_SUPPORTED_ERR	TokenNameIdentifier	 NOT  SUPPORTED  ERR
,	TokenNameCOMMA	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
NodeIterator	TokenNameIdentifier	 Node Iterator
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
new	TokenNamenew	
NodeIteratorImpl	TokenNameIdentifier	 Node Iterator Impl
(	TokenNameLPAREN	
this	TokenNamethis	
,	TokenNameCOMMA	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
entityReferenceExpansion	TokenNameIdentifier	 entity Reference Expansion
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iterators	TokenNameIdentifier	 iterators
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iterators	TokenNameIdentifier	 iterators
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iteratorReferenceQueue	TokenNameIdentifier	 iterator Reference Queue
=	TokenNameEQUAL	
new	TokenNamenew	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
removeStaleIteratorReferences	TokenNameIdentifier	 remove Stale Iterator References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
iterators	TokenNameIdentifier	 iterators
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
WeakReference	TokenNameIdentifier	 Weak Reference
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
,	TokenNameCOMMA	
iteratorReferenceQueue	TokenNameIdentifier	 iterator Reference Queue
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
iterator	TokenNameIdentifier	 iterator
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * NON-DOM extension: * Create and return a TreeWalker. * * @param root The root of the iterator. * @param whatToShow The whatToShow mask. * @param filter The NodeFilter installed. Null means no filter. */	TokenNameCOMMENT_JAVADOC	 NON-DOM extension: Create and return a TreeWalker. * @param root The root of the iterator. @param whatToShow The whatToShow mask. @param filter The NodeFilter installed. Null means no filter. 
public	TokenNamepublic	
TreeWalker	TokenNameIdentifier	 Tree Walker
createTreeWalker	TokenNameIdentifier	 create Tree Walker
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
short	TokenNameshort	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
NodeFilter	TokenNameIdentifier	 Node Filter
filter	TokenNameIdentifier	 filter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
createTreeWalker	TokenNameIdentifier	 create Tree Walker
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Create and return a TreeWalker. * * @param root The root of the iterator. * @param whatToShow The whatToShow mask. * @param filter The NodeFilter installed. Null means no filter. * @param entityReferenceExpansion true to expand the contents of * EntityReference nodes * @since WD-DOM-Level-2-19990923 */	TokenNameCOMMENT_JAVADOC	 Create and return a TreeWalker. * @param root The root of the iterator. @param whatToShow The whatToShow mask. @param filter The NodeFilter installed. Null means no filter. @param entityReferenceExpansion true to expand the contents of EntityReference nodes @since WD-DOM-Level-2-19990923 
public	TokenNamepublic	
TreeWalker	TokenNameIdentifier	 Tree Walker
createTreeWalker	TokenNameIdentifier	 create Tree Walker
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
int	TokenNameint	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
NodeFilter	TokenNameIdentifier	 Node Filter
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
boolean	TokenNameboolean	
entityReferenceExpansion	TokenNameIdentifier	 entity Reference Expansion
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
DOM_DOMAIN	TokenNameIdentifier	 DOM  DOMAIN
,	TokenNameCOMMA	
"NOT_SUPPORTED_ERR"	TokenNameStringLiteral	NOT_SUPPORTED_ERR
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
DOMException	TokenNameIdentifier	 DOM Exception
(	TokenNameLPAREN	
DOMException	TokenNameIdentifier	 DOM Exception
.	TokenNameDOT	
NOT_SUPPORTED_ERR	TokenNameIdentifier	 NOT  SUPPORTED  ERR
,	TokenNameCOMMA	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
new	TokenNamenew	
TreeWalkerImpl	TokenNameIdentifier	 Tree Walker Impl
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
whatToShow	TokenNameIdentifier	 what To Show
,	TokenNameCOMMA	
filter	TokenNameIdentifier	 filter
,	TokenNameCOMMA	
entityReferenceExpansion	TokenNameIdentifier	 entity Reference Expansion
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Not DOM Level 2. Support DocumentTraversal methods. 	TokenNameCOMMENT_LINE	Not DOM Level 2. Support DocumentTraversal methods. 
// 	TokenNameCOMMENT_LINE	 
/** * This is not called by the developer client. The * developer client uses the detach() function on the * NodeIterator itself. <p> * * This function is called from the NodeIterator#detach(). */	TokenNameCOMMENT_JAVADOC	 This is not called by the developer client. The developer client uses the detach() function on the NodeIterator itself. <p> * This function is called from the NodeIterator#detach(). 
void	TokenNamevoid	
removeNodeIterator	TokenNameIdentifier	 remove Node Iterator
(	TokenNameLPAREN	
NodeIterator	TokenNameIdentifier	 Node Iterator
nodeIterator	TokenNameIdentifier	 node Iterator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nodeIterator	TokenNameIdentifier	 node Iterator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iterators	TokenNameIdentifier	 iterators
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
removeStaleIteratorReferences	TokenNameIdentifier	 remove Stale Iterator References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iterators	TokenNameIdentifier	 iterators
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
==	TokenNameEQUAL_EQUAL	
nodeIterator	TokenNameIdentifier	 node Iterator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove stale iterator references from the iterator list. */	TokenNameCOMMENT_JAVADOC	 Remove stale iterator references from the iterator list. 
private	TokenNameprivate	
void	TokenNamevoid	
removeStaleIteratorReferences	TokenNameIdentifier	 remove Stale Iterator References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleReferences	TokenNameIdentifier	 remove Stale References
(	TokenNameLPAREN	
iteratorReferenceQueue	TokenNameIdentifier	 iterator Reference Queue
,	TokenNameCOMMA	
iterators	TokenNameIdentifier	 iterators
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Remove stale references from the given list. */	TokenNameCOMMENT_JAVADOC	 Remove stale references from the given list. 
private	TokenNameprivate	
void	TokenNamevoid	
removeStaleReferences	TokenNameIdentifier	 remove Stale References
(	TokenNameLPAREN	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
queue	TokenNameIdentifier	 queue
,	TokenNameCOMMA	
List	TokenNameIdentifier	 List
list	TokenNameIdentifier	 list
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Reference	TokenNameIdentifier	 Reference
ref	TokenNameIdentifier	 ref
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
ref	TokenNameIdentifier	 ref
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
++	TokenNamePLUS_PLUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
ref	TokenNameIdentifier	 ref
=	TokenNameEQUAL	
queue	TokenNameIdentifier	 queue
.	TokenNameDOT	
poll	TokenNameIdentifier	 poll
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
list	TokenNameIdentifier	 list
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
o	TokenNameIdentifier	 o
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
o	TokenNameIdentifier	 o
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
--	TokenNameMINUS_MINUS	
count	TokenNameIdentifier	 count
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// DocumentRange methods 	TokenNameCOMMENT_LINE	DocumentRange methods 
// 	TokenNameCOMMENT_LINE	 
/** */	TokenNameCOMMENT_JAVADOC	 
public	TokenNamepublic	
Range	TokenNameIdentifier	 Range
createRange	TokenNameIdentifier	 create Range
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ranges	TokenNameIdentifier	 ranges
=	TokenNameEQUAL	
new	TokenNamenew	
LinkedList	TokenNameIdentifier	 Linked List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
rangeReferenceQueue	TokenNameIdentifier	 range Reference Queue
=	TokenNameEQUAL	
new	TokenNamenew	
ReferenceQueue	TokenNameIdentifier	 Reference Queue
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Range	TokenNameIdentifier	 Range
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
new	TokenNamenew	
RangeImpl	TokenNameIdentifier	 Range Impl
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
new	TokenNamenew	
WeakReference	TokenNameIdentifier	 Weak Reference
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
,	TokenNameCOMMA	
rangeReferenceQueue	TokenNameIdentifier	 range Reference Queue
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
range	TokenNameIdentifier	 range
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Not a client function. Called by Range.detach(), * so a Range can remove itself from the list of * Ranges. */	TokenNameCOMMENT_JAVADOC	 Not a client function. Called by Range.detach(), so a Range can remove itself from the list of Ranges. 
void	TokenNamevoid	
removeRange	TokenNameIdentifier	 remove Range
(	TokenNameLPAREN	
Range	TokenNameIdentifier	 Range
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
otherRange	TokenNameIdentifier	 other Range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
otherRange	TokenNameIdentifier	 other Range
==	TokenNameEQUAL_EQUAL	
range	TokenNameIdentifier	 range
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
otherRange	TokenNameIdentifier	 other Range
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when some text was changed in a text node, * so that live objects can be notified. */	TokenNameCOMMENT_JAVADOC	 A method to be called when some text was changed in a text node, so that live objects can be notified. 
void	TokenNamevoid	
replacedText	TokenNameIdentifier	 replaced Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify ranges 	TokenNameCOMMENT_LINE	notify ranges 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesReplacedText	TokenNameIdentifier	 notify Ranges Replaced Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesReplacedText	TokenNameIdentifier	 notify Ranges Replaced Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
receiveReplacedText	TokenNameIdentifier	 receive Replaced Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when some text was deleted from a text node, * so that live objects can be notified. */	TokenNameCOMMENT_JAVADOC	 A method to be called when some text was deleted from a text node, so that live objects can be notified. 
void	TokenNamevoid	
deletedText	TokenNameIdentifier	 deleted Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify ranges 	TokenNameCOMMENT_LINE	notify ranges 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesDeletedText	TokenNameIdentifier	 notify Ranges Deleted Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesDeletedText	TokenNameIdentifier	 notify Ranges Deleted Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
receiveDeletedText	TokenNameIdentifier	 receive Deleted Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when some text was inserted into a text node, * so that live objects can be notified. */	TokenNameCOMMENT_JAVADOC	 A method to be called when some text was inserted into a text node, so that live objects can be notified. 
void	TokenNamevoid	
insertedText	TokenNameIdentifier	 inserted Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify ranges 	TokenNameCOMMENT_LINE	notify ranges 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesInsertedText	TokenNameIdentifier	 notify Ranges Inserted Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesInsertedText	TokenNameIdentifier	 notify Ranges Inserted Text
(	TokenNameLPAREN	
CharacterDataImpl	TokenNameIdentifier	 Character Data Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
int	TokenNameint	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
receiveInsertedText	TokenNameIdentifier	 receive Inserted Text
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
count	TokenNameIdentifier	 count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when a text node has been split, * so that live objects can be notified. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a text node has been split, so that live objects can be notified. 
void	TokenNamevoid	
splitData	TokenNameIdentifier	 split Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
newNode	TokenNameIdentifier	 new Node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify ranges 	TokenNameCOMMENT_LINE	notify ranges 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesSplitData	TokenNameIdentifier	 notify Ranges Split Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
newNode	TokenNameIdentifier	 new Node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesSplitData	TokenNameIdentifier	 notify Ranges Split Data
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
Node	TokenNameIdentifier	 Node
newNode	TokenNameIdentifier	 new Node
,	TokenNameCOMMA	
int	TokenNameint	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
receiveSplitData	TokenNameIdentifier	 receive Split Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
newNode	TokenNameIdentifier	 new Node
,	TokenNameCOMMA	
offset	TokenNameIdentifier	 offset
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Remove stale range references from the range list. */	TokenNameCOMMENT_JAVADOC	 Remove stale range references from the range list. 
private	TokenNameprivate	
void	TokenNamevoid	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleReferences	TokenNameIdentifier	 remove Stale References
(	TokenNameLPAREN	
rangeReferenceQueue	TokenNameIdentifier	 range Reference Queue
,	TokenNameCOMMA	
ranges	TokenNameIdentifier	 ranges
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// DocumentEvent methods 	TokenNameCOMMENT_LINE	DocumentEvent methods 
// 	TokenNameCOMMENT_LINE	 
/** * Introduced in DOM Level 2. Optional. <p> * Create and return Event objects. * * @param type The eventType parameter specifies the type of Event * interface to be created. If the Event interface specified is supported * by the implementation this method will return a new Event of the * interface type requested. If the Event is to be dispatched via the * dispatchEvent method the appropriate event init method must be called * after creation in order to initialize the Event's values. As an * example, a user wishing to synthesize some kind of Event would call * createEvent with the parameter "Events". The initEvent method could then * be called on the newly created Event to set the specific type of Event * to be dispatched and set its context information. * @return Newly created Event * @exception DOMException NOT_SUPPORTED_ERR: Raised if the implementation * does not support the type of Event interface requested * @since WD-DOM-Level-2-19990923 */	TokenNameCOMMENT_JAVADOC	 Introduced in DOM Level 2. Optional. <p> Create and return Event objects. * @param type The eventType parameter specifies the type of Event interface to be created. If the Event interface specified is supported by the implementation this method will return a new Event of the interface type requested. If the Event is to be dispatched via the dispatchEvent method the appropriate event init method must be called after creation in order to initialize the Event's values. As an example, a user wishing to synthesize some kind of Event would call createEvent with the parameter "Events". The initEvent method could then be called on the newly created Event to set the specific type of Event to be dispatched and set its context information. @return Newly created Event @exception DOMException NOT_SUPPORTED_ERR: Raised if the implementation does not support the type of Event interface requested @since WD-DOM-Level-2-19990923 
public	TokenNamepublic	
Event	TokenNameIdentifier	 Event
createEvent	TokenNameIdentifier	 create Event
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
throws	TokenNamethrows	
DOMException	TokenNameIdentifier	 DOM Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"Events"	TokenNameStringLiteral	Events
)	TokenNameRPAREN	
||	TokenNameOR_OR	
"Event"	TokenNameStringLiteral	Event
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
EventImpl	TokenNameIdentifier	 Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"MutationEvents"	TokenNameStringLiteral	MutationEvents
)	TokenNameRPAREN	
||	TokenNameOR_OR	
"MutationEvent"	TokenNameStringLiteral	MutationEvent
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"UIEvents"	TokenNameStringLiteral	UIEvents
)	TokenNameRPAREN	
||	TokenNameOR_OR	
"UIEvent"	TokenNameStringLiteral	UIEvent
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
UIEventImpl	TokenNameIdentifier	 UI Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equalsIgnoreCase	TokenNameIdentifier	 equals Ignore Case
(	TokenNameLPAREN	
"MouseEvents"	TokenNameStringLiteral	MouseEvents
)	TokenNameRPAREN	
||	TokenNameOR_OR	
"MouseEvent"	TokenNameStringLiteral	MouseEvent
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
MouseEventImpl	TokenNameIdentifier	 Mouse Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
DOM_DOMAIN	TokenNameIdentifier	 DOM  DOMAIN
,	TokenNameCOMMA	
"NOT_SUPPORTED_ERR"	TokenNameStringLiteral	NOT_SUPPORTED_ERR
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
DOMException	TokenNameIdentifier	 DOM Exception
(	TokenNameLPAREN	
DOMException	TokenNameIdentifier	 DOM Exception
.	TokenNameDOT	
NOT_SUPPORTED_ERR	TokenNameIdentifier	 NOT  SUPPORTED  ERR
,	TokenNameCOMMA	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Sets whether the DOM implementation generates mutation events * upon operations. */	TokenNameCOMMENT_JAVADOC	 Sets whether the DOM implementation generates mutation events upon operations. 
void	TokenNamevoid	
setMutationEvents	TokenNameIdentifier	 set Mutation Events
(	TokenNameLPAREN	
boolean	TokenNameboolean	
set	TokenNameIdentifier	 set
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mutationEvents	TokenNameIdentifier	 mutation Events
=	TokenNameEQUAL	
set	TokenNameIdentifier	 set
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Returns true if the DOM implementation generates mutation events. */	TokenNameCOMMENT_JAVADOC	 Returns true if the DOM implementation generates mutation events. 
boolean	TokenNameboolean	
getMutationEvents	TokenNameIdentifier	 get Mutation Events
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
mutationEvents	TokenNameIdentifier	 mutation Events
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Store event listener registered on a given node * This is another place where we could use weak references! Indeed, the * node here won't be GC'ed as long as some listener is registered on it, * since the eventsListeners table will have a reference to the node. */	TokenNameCOMMENT_JAVADOC	 Store event listener registered on a given node This is another place where we could use weak references! Indeed, the node here won't be GC'ed as long as some listener is registered on it, since the eventsListeners table will have a reference to the node. 
protected	TokenNameprotected	
void	TokenNamevoid	
setEventListeners	TokenNameIdentifier	 set Event Listeners
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
Vector	TokenNameIdentifier	 Vector
listeners	TokenNameIdentifier	 listeners
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
eventListeners	TokenNameIdentifier	 event Listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eventListeners	TokenNameIdentifier	 event Listeners
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
listeners	TokenNameIdentifier	 listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eventListeners	TokenNameIdentifier	 event Listeners
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eventListeners	TokenNameIdentifier	 event Listeners
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// stop firing events when there isn't any listener 	TokenNameCOMMENT_LINE	stop firing events when there isn't any listener 
mutationEvents	TokenNameIdentifier	 mutation Events
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
eventListeners	TokenNameIdentifier	 event Listeners
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
listeners	TokenNameIdentifier	 listeners
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// turn mutation events on 	TokenNameCOMMENT_LINE	turn mutation events on 
mutationEvents	TokenNameIdentifier	 mutation Events
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * Retreive event listener registered on a given node */	TokenNameCOMMENT_JAVADOC	 Retreive event listener registered on a given node 
protected	TokenNameprotected	
Vector	TokenNameIdentifier	 Vector
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
eventListeners	TokenNameIdentifier	 event Listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
eventListeners	TokenNameIdentifier	 event Listeners
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// EventTarget support (public and internal) 	TokenNameCOMMENT_LINE	EventTarget support (public and internal) 
// 	TokenNameCOMMENT_LINE	 
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
/* * NON-DOM INTERNAL: Class LEntry is just a struct used to represent * event listeners registered with this node. Copies of this object * are hung from the nodeListeners Vector. * <p> * I considered using two vectors -- one for capture, * one for bubble -- but decided that since the list of listeners * is probably short in most cases, it might not be worth spending * the space. ***** REVISIT WHEN WE HAVE MORE EXPERIENCE. */	TokenNameCOMMENT_BLOCK	 NON-DOM INTERNAL: Class LEntry is just a struct used to represent event listeners registered with this node. Copies of this object are hung from the nodeListeners Vector. <p> I considered using two vectors -- one for capture, one for bubble -- but decided that since the list of listeners is probably short in most cases, it might not be worth spending the space. ***** REVISIT WHEN WE HAVE MORE EXPERIENCE. 
class	TokenNameclass	
LEntry	TokenNameIdentifier	 L Entry
implements	TokenNameimplements	
Serializable	TokenNameIdentifier	 Serializable
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
-	TokenNameMINUS	
8426757059492421631L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
EventListener	TokenNameIdentifier	 Event Listener
listener	TokenNameIdentifier	 listener
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
useCapture	TokenNameIdentifier	 use Capture
;	TokenNameSEMICOLON	
/** NON-DOM INTERNAL: Constructor for Listener list Entry * @param type Event name (NOT event group!) to listen for. * @param listener Who gets called when event is dispatched * @param useCaptue True iff listener is registered on * capturing phase rather than at-target or bubbling */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: Constructor for Listener list Entry @param type Event name (NOT event group!) to listen for. @param listener Who gets called when event is dispatched @param useCaptue True iff listener is registered on capturing phase rather than at-target or bubbling 
LEntry	TokenNameIdentifier	 L Entry
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
EventListener	TokenNameIdentifier	 Event Listener
listener	TokenNameIdentifier	 listener
,	TokenNameCOMMA	
boolean	TokenNameboolean	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
listener	TokenNameIdentifier	 listener
=	TokenNameEQUAL	
listener	TokenNameIdentifier	 listener
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
useCapture	TokenNameIdentifier	 use Capture
=	TokenNameEQUAL	
useCapture	TokenNameIdentifier	 use Capture
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// LEntry 	TokenNameCOMMENT_LINE	LEntry 
/** * Introduced in DOM Level 2. <p> Register an event listener with this * Node. A listener may be independently registered as both Capturing and * Bubbling, but may only be registered once per role; redundant * registrations are ignored. * @param node node to add listener to * @param type Event name (NOT event group!) to listen for. * @param listener Who gets called when event is dispatched * @param useCapture True iff listener is registered on * capturing phase rather than at-target or bubbling */	TokenNameCOMMENT_JAVADOC	 Introduced in DOM Level 2. <p> Register an event listener with this Node. A listener may be independently registered as both Capturing and Bubbling, but may only be registered once per role; redundant registrations are ignored. @param node node to add listener to @param type Event name (NOT event group!) to listen for. @param listener Who gets called when event is dispatched @param useCapture True iff listener is registered on capturing phase rather than at-target or bubbling 
protected	TokenNameprotected	
void	TokenNamevoid	
addEventListener	TokenNameIdentifier	 add Event Listener
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
EventListener	TokenNameIdentifier	 Event Listener
listener	TokenNameIdentifier	 listener
,	TokenNameCOMMA	
boolean	TokenNameboolean	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We can't dispatch to blank type-name, and of course we need 	TokenNameCOMMENT_LINE	We can't dispatch to blank type-name, and of course we need 
// a listener to dispatch to 	TokenNameCOMMENT_LINE	a listener to dispatch to 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
listener	TokenNameIdentifier	 listener
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// Each listener may be registered only once per type per phase. 	TokenNameCOMMENT_LINE	Each listener may be registered only once per type per phase. 
// Simplest way to code that is to zap the previous entry, if any. 	TokenNameCOMMENT_LINE	Simplest way to code that is to zap the previous entry, if any. 
removeEventListener	TokenNameIdentifier	 remove Event Listener
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
listener	TokenNameIdentifier	 listener
,	TokenNameCOMMA	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
setEventListeners	TokenNameIdentifier	 set Event Listeners
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
nodeListeners	TokenNameIdentifier	 node Listeners
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
new	TokenNamenew	
LEntry	TokenNameIdentifier	 L Entry
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
listener	TokenNameIdentifier	 listener
,	TokenNameCOMMA	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Record active listener 	TokenNameCOMMENT_LINE	Record active listener 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
{	TokenNameLBRACE	
++	TokenNamePLUS_PLUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
captures	TokenNameIdentifier	 captures
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
++	TokenNamePLUS_PLUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
bubbles	TokenNameIdentifier	 bubbles
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// addEventListener(NodeImpl,String,EventListener,boolean) :void 	TokenNameCOMMENT_LINE	addEventListener(NodeImpl,String,EventListener,boolean) :void 
/** * Introduced in DOM Level 2. <p> Deregister an event listener previously * registered with this Node. A listener must be independently removed * from the Capturing and Bubbling roles. Redundant removals (of listeners * not currently registered for this role) are ignored. * @param node node to remove listener from * @param type Event name (NOT event group!) to listen for. * @param listener Who gets called when event is dispatched * @param useCapture True iff listener is registered on * capturing phase rather than at-target or bubbling */	TokenNameCOMMENT_JAVADOC	 Introduced in DOM Level 2. <p> Deregister an event listener previously registered with this Node. A listener must be independently removed from the Capturing and Bubbling roles. Redundant removals (of listeners not currently registered for this role) are ignored. @param node node to remove listener from @param type Event name (NOT event group!) to listen for. @param listener Who gets called when event is dispatched @param useCapture True iff listener is registered on capturing phase rather than at-target or bubbling 
protected	TokenNameprotected	
void	TokenNamevoid	
removeEventListener	TokenNameIdentifier	 remove Event Listener
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
EventListener	TokenNameIdentifier	 Event Listener
listener	TokenNameIdentifier	 listener
,	TokenNameCOMMA	
boolean	TokenNameboolean	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If this couldn't be a valid listener registration, ignore request 	TokenNameCOMMENT_LINE	If this couldn't be a valid listener registration, ignore request 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
listener	TokenNameIdentifier	 listener
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// Note that addListener has previously ensured that 	TokenNameCOMMENT_LINE	Note that addListener has previously ensured that 
// each listener may be registered only once per type per phase. 	TokenNameCOMMENT_LINE	each listener may be registered only once per type per phase. 
// count-down is OK for deletions! 	TokenNameCOMMENT_LINE	count-down is OK for deletions! 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LEntry	TokenNameIdentifier	 L Entry
le	TokenNameIdentifier	 le
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LEntry	TokenNameIdentifier	 L Entry
)	TokenNameRPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
useCapture	TokenNameIdentifier	 use Capture
==	TokenNameEQUAL_EQUAL	
useCapture	TokenNameIdentifier	 use Capture
&&	TokenNameAND_AND	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
listener	TokenNameIdentifier	 listener
==	TokenNameEQUAL_EQUAL	
listener	TokenNameIdentifier	 listener
&&	TokenNameAND_AND	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
removeElementAt	TokenNameIdentifier	 remove Element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Storage management: Discard empty listener lists 	TokenNameCOMMENT_LINE	Storage management: Discard empty listener lists 
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
setEventListeners	TokenNameIdentifier	 set Event Listeners
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Remove active listener 	TokenNameCOMMENT_LINE	Remove active listener 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
useCapture	TokenNameIdentifier	 use Capture
)	TokenNameRPAREN	
{	TokenNameLBRACE	
--	TokenNameMINUS_MINUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
captures	TokenNameIdentifier	 captures
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
--	TokenNameMINUS_MINUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
bubbles	TokenNameIdentifier	 bubbles
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// Found it; no need to loop farther. 	TokenNameCOMMENT_LINE	Found it; no need to loop farther. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// removeEventListener(NodeImpl,String,EventListener,boolean) :void 	TokenNameCOMMENT_LINE	removeEventListener(NodeImpl,String,EventListener,boolean) :void 
protected	TokenNameprotected	
void	TokenNamevoid	
copyEventListeners	TokenNameIdentifier	 copy Event Listeners
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
tgt	TokenNameIdentifier	 tgt
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
setEventListeners	TokenNameIdentifier	 set Event Listeners
(	TokenNameLPAREN	
tgt	TokenNameIdentifier	 tgt
,	TokenNameCOMMA	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * Introduced in DOM Level 2. <p> * Distribution engine for DOM Level 2 Events. * <p> * Event propagation runs as follows: * <ol> * <li>Event is dispatched to a particular target node, which invokes * this code. Note that the event's stopPropagation flag is * cleared when dispatch begins; thereafter, if it has * been set before processing of a node commences, we instead * immediately advance to the DEFAULT phase. * <li>The node's ancestors are established as destinations for events. * For capture and bubble purposes, node ancestry is determined at * the time dispatch starts. If an event handler alters the document * tree, that does not change which nodes will be informed of the event. * <li>CAPTURING_PHASE: Ancestors are scanned, root to target, for * Capturing listeners. If found, they are invoked (see below). * <li>AT_TARGET: * Event is dispatched to NON-CAPTURING listeners on the * target node. Note that capturing listeners on this node are _not_ * invoked. * <li>BUBBLING_PHASE: Ancestors are scanned, target to root, for * non-capturing listeners. * <li>Default processing: Some DOMs have default behaviors bound to * specific nodes. If this DOM does, and if the event's preventDefault * flag has not been set, we now return to the target node and process * its default handler for this event, if any. * </ol> * <p> * Note that registration of handlers during processing of an event does * not take effect during this phase of this event; they will not be called * until the next time this node is visited by dispatchEvent. On the other * hand, removals take effect immediately. * <p> * If an event handler itself causes events to be dispatched, they are * processed synchronously, before processing resumes * on the event which triggered them. Please be aware that this may * result in events arriving at listeners "out of order" relative * to the actual sequence of requests. * <p> * Note that our implementation resets the event's stop/prevent flags * when dispatch begins. * I believe the DOM's intent is that event objects be redispatchable, * though it isn't stated in those terms. * @param node node to dispatch to * @param event the event object to be dispatched to * registered EventListeners * @return true if the event's <code>preventDefault()</code> * method was invoked by an EventListener; otherwise false. */	TokenNameCOMMENT_JAVADOC	 Introduced in DOM Level 2. <p> Distribution engine for DOM Level 2 Events. <p> Event propagation runs as follows: <ol> <li>Event is dispatched to a particular target node, which invokes this code. Note that the event's stopPropagation flag is cleared when dispatch begins; thereafter, if it has been set before processing of a node commences, we instead immediately advance to the DEFAULT phase. <li>The node's ancestors are established as destinations for events. For capture and bubble purposes, node ancestry is determined at the time dispatch starts. If an event handler alters the document tree, that does not change which nodes will be informed of the event. <li>CAPTURING_PHASE: Ancestors are scanned, root to target, for Capturing listeners. If found, they are invoked (see below). <li>AT_TARGET: Event is dispatched to NON-CAPTURING listeners on the target node. Note that capturing listeners on this node are _not_ invoked. <li>BUBBLING_PHASE: Ancestors are scanned, target to root, for non-capturing listeners. <li>Default processing: Some DOMs have default behaviors bound to specific nodes. If this DOM does, and if the event's preventDefault flag has not been set, we now return to the target node and process its default handler for this event, if any. </ol> <p> Note that registration of handlers during processing of an event does not take effect during this phase of this event; they will not be called until the next time this node is visited by dispatchEvent. On the other hand, removals take effect immediately. <p> If an event handler itself causes events to be dispatched, they are processed synchronously, before processing resumes on the event which triggered them. Please be aware that this may result in events arriving at listeners "out of order" relative to the actual sequence of requests. <p> Note that our implementation resets the event's stop/prevent flags when dispatch begins. I believe the DOM's intent is that event objects be redispatchable, though it isn't stated in those terms. @param node node to dispatch to @param event the event object to be dispatched to registered EventListeners @return true if the event's <code>preventDefault()</code> method was invoked by an EventListener; otherwise false. 
protected	TokenNameprotected	
boolean	TokenNameboolean	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
Event	TokenNameIdentifier	 Event
event	TokenNameIdentifier	 event
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
event	TokenNameIdentifier	 event
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Can't use anyone else's implementation, since there's no public 	TokenNameCOMMENT_LINE	Can't use anyone else's implementation, since there's no public 
// API for setting the event's processing-state fields. 	TokenNameCOMMENT_LINE	API for setting the event's processing-state fields. 
EventImpl	TokenNameIdentifier	 Event Impl
evt	TokenNameIdentifier	 evt
=	TokenNameEQUAL	
(	TokenNameLPAREN	
EventImpl	TokenNameIdentifier	 Event Impl
)	TokenNameRPAREN	
event	TokenNameIdentifier	 event
;	TokenNameSEMICOLON	
// VALIDATE -- must have been initialized at least once, must have 	TokenNameCOMMENT_LINE	VALIDATE -- must have been initialized at least once, must have 
// a non-null non-blank name. 	TokenNameCOMMENT_LINE	a non-null non-blank name. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
initialized	TokenNameIdentifier	 initialized
||	TokenNameOR_OR	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
msg	TokenNameIdentifier	 msg
=	TokenNameEQUAL	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
formatMessage	TokenNameIdentifier	 format Message
(	TokenNameLPAREN	
DOMMessageFormatter	TokenNameIdentifier	 DOM Message Formatter
.	TokenNameDOT	
DOM_DOMAIN	TokenNameIdentifier	 DOM  DOMAIN
,	TokenNameCOMMA	
"UNSPECIFIED_EVENT_TYPE_ERR"	TokenNameStringLiteral	UNSPECIFIED_EVENT_TYPE_ERR
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
throw	TokenNamethrow	
new	TokenNamenew	
EventException	TokenNameIdentifier	 Event Exception
(	TokenNameLPAREN	
EventException	TokenNameIdentifier	 Event Exception
.	TokenNameDOT	
UNSPECIFIED_EVENT_TYPE_ERR	TokenNameIdentifier	 UNSPECIFIED  EVENT  TYPE  ERR
,	TokenNameCOMMA	
msg	TokenNameIdentifier	 msg
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If nobody is listening for this event, discard immediately 	TokenNameCOMMENT_LINE	If nobody is listening for this event, discard immediately 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
getType	TokenNameIdentifier	 get Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
preventDefault	TokenNameIdentifier	 prevent Default
;	TokenNameSEMICOLON	
// INITIALIZE THE EVENT'S DISPATCH STATUS 	TokenNameCOMMENT_LINE	INITIALIZE THE EVENT'S DISPATCH STATUS 
// (Note that Event objects are reusable in our implementation; 	TokenNameCOMMENT_LINE	(Note that Event objects are reusable in our implementation; 
// that doesn't seem to be explicitly guaranteed in the DOM, but 	TokenNameCOMMENT_LINE	that doesn't seem to be explicitly guaranteed in the DOM, but 
// I believe it is the intent.) 	TokenNameCOMMENT_LINE	I believe it is the intent.) 
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
target	TokenNameIdentifier	 target
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
stopPropagation	TokenNameIdentifier	 stop Propagation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
preventDefault	TokenNameIdentifier	 prevent Default
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Capture pre-event parentage chain, not including target; 	TokenNameCOMMENT_LINE	Capture pre-event parentage chain, not including target; 
// use pre-event-dispatch ancestors even if event handlers mutate 	TokenNameCOMMENT_LINE	use pre-event-dispatch ancestors even if event handlers mutate 
// document and change the target's context. 	TokenNameCOMMENT_LINE	document and change the target's context. 
// Note that this is parents ONLY; events do not 	TokenNameCOMMENT_LINE	Note that this is parents ONLY; events do not 
// cross the Attr/Element "blood/brain barrier". 	TokenNameCOMMENT_LINE	cross the Attr/Element "blood/brain barrier". 
// DOMAttrModified. which looks like an exception, 	TokenNameCOMMENT_LINE	DOMAttrModified. which looks like an exception, 
// is issued to the Element rather than the Attr 	TokenNameCOMMENT_LINE	is issued to the Element rather than the Attr 
// and causes a _second_ DOMSubtreeModified in the Element's 	TokenNameCOMMENT_LINE	and causes a _second_ DOMSubtreeModified in the Element's 
// tree. 	TokenNameCOMMENT_LINE	tree. 
ArrayList	TokenNameIdentifier	 Array List
pv	TokenNameIdentifier	 pv
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
pv	TokenNameIdentifier	 pv
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
;	TokenNameSEMICOLON	
n	TokenNameIdentifier	 n
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getParentNode	TokenNameIdentifier	 get Parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// CAPTURING_PHASE: 	TokenNameCOMMENT_LINE	CAPTURING_PHASE: 
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
captures	TokenNameIdentifier	 captures
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
eventPhase	TokenNameIdentifier	 event Phase
=	TokenNameEQUAL	
Event	TokenNameIdentifier	 Event
.	TokenNameDOT	
CAPTURING_PHASE	TokenNameIdentifier	 CAPTURING  PHASE
;	TokenNameSEMICOLON	
// Ancestors are scanned, root to target, for 	TokenNameCOMMENT_LINE	Ancestors are scanned, root to target, for 
// Capturing listeners. 	TokenNameCOMMENT_LINE	Capturing listeners. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
pv	TokenNameIdentifier	 pv
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
stopPropagation	TokenNameIdentifier	 stop Propagation
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// Someone set the flag. Phase ends. 	TokenNameCOMMENT_LINE	Someone set the flag. Phase ends. 
// Handle all capturing listeners on this node 	TokenNameCOMMENT_LINE	Handle all capturing listeners on this node 
NodeImpl	TokenNameIdentifier	 Node Impl
nn	TokenNameIdentifier	 nn
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
pv	TokenNameIdentifier	 pv
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
currentTarget	TokenNameIdentifier	 current Target
=	TokenNameEQUAL	
nn	TokenNameIdentifier	 nn
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
nn	TokenNameIdentifier	 nn
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
nl	TokenNameIdentifier	 nl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call listeners in the order in which they got registered 	TokenNameCOMMENT_LINE	call listeners in the order in which they got registered 
int	TokenNameint	
nlsize	TokenNameIdentifier	 nlsize
=	TokenNameEQUAL	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nlsize	TokenNameIdentifier	 nlsize
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LEntry	TokenNameIdentifier	 L Entry
le	TokenNameIdentifier	 le
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LEntry	TokenNameIdentifier	 L Entry
)	TokenNameRPAREN	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
useCapture	TokenNameIdentifier	 use Capture
&&	TokenNameAND_AND	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
le	TokenNameIdentifier	 le
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
listener	TokenNameIdentifier	 listener
.	TokenNameDOT	
handleEvent	TokenNameIdentifier	 handle Event
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// All exceptions are ignored. 	TokenNameCOMMENT_LINE	All exceptions are ignored. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Both AT_TARGET and BUBBLE use non-capturing listeners. 	TokenNameCOMMENT_LINE	Both AT_TARGET and BUBBLE use non-capturing listeners. 
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
bubbles	TokenNameIdentifier	 bubbles
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// AT_TARGET PHASE: Event is dispatched to NON-CAPTURING listeners 	TokenNameCOMMENT_LINE	AT_TARGET PHASE: Event is dispatched to NON-CAPTURING listeners 
// on the target node. Note that capturing listeners on the target 	TokenNameCOMMENT_LINE	on the target node. Note that capturing listeners on the target 
// node are _not_ invoked, even during the capture phase. 	TokenNameCOMMENT_LINE	node are _not_ invoked, even during the capture phase. 
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
eventPhase	TokenNameIdentifier	 event Phase
=	TokenNameEQUAL	
Event	TokenNameIdentifier	 Event
.	TokenNameDOT	
AT_TARGET	TokenNameIdentifier	 AT  TARGET
;	TokenNameSEMICOLON	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
currentTarget	TokenNameIdentifier	 current Target
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
Vector	TokenNameIdentifier	 Vector
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
stopPropagation	TokenNameIdentifier	 stop Propagation
&&	TokenNameAND_AND	
nodeListeners	TokenNameIdentifier	 node Listeners
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
nl	TokenNameIdentifier	 nl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call listeners in the order in which they got registered 	TokenNameCOMMENT_LINE	call listeners in the order in which they got registered 
int	TokenNameint	
nlsize	TokenNameIdentifier	 nlsize
=	TokenNameEQUAL	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nlsize	TokenNameIdentifier	 nlsize
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LEntry	TokenNameIdentifier	 L Entry
le	TokenNameIdentifier	 le
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LEntry	TokenNameIdentifier	 L Entry
)	TokenNameRPAREN	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
useCapture	TokenNameIdentifier	 use Capture
&&	TokenNameAND_AND	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
le	TokenNameIdentifier	 le
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
listener	TokenNameIdentifier	 listener
.	TokenNameDOT	
handleEvent	TokenNameIdentifier	 handle Event
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// All exceptions are ignored. 	TokenNameCOMMENT_LINE	All exceptions are ignored. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// BUBBLING_PHASE: Ancestors are scanned, target to root, for 	TokenNameCOMMENT_LINE	BUBBLING_PHASE: Ancestors are scanned, target to root, for 
// non-capturing listeners. If the event's preventBubbling flag 	TokenNameCOMMENT_LINE	non-capturing listeners. If the event's preventBubbling flag 
// has been set before processing of a node commences, we 	TokenNameCOMMENT_LINE	has been set before processing of a node commences, we 
// instead immediately advance to the default phase. 	TokenNameCOMMENT_LINE	instead immediately advance to the default phase. 
// Note that not all events bubble. 	TokenNameCOMMENT_LINE	Note that not all events bubble. 
if	TokenNameif	
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
bubbles	TokenNameIdentifier	 bubbles
)	TokenNameRPAREN	
{	TokenNameLBRACE	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
eventPhase	TokenNameIdentifier	 event Phase
=	TokenNameEQUAL	
Event	TokenNameIdentifier	 Event
.	TokenNameDOT	
BUBBLING_PHASE	TokenNameIdentifier	 BUBBLING  PHASE
;	TokenNameSEMICOLON	
int	TokenNameint	
pvsize	TokenNameIdentifier	 pvsize
=	TokenNameEQUAL	
pv	TokenNameIdentifier	 pv
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
pvsize	TokenNameIdentifier	 pvsize
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
stopPropagation	TokenNameIdentifier	 stop Propagation
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
// Someone set the flag. Phase ends. 	TokenNameCOMMENT_LINE	Someone set the flag. Phase ends. 
// Handle all bubbling listeners on this node 	TokenNameCOMMENT_LINE	Handle all bubbling listeners on this node 
NodeImpl	TokenNameIdentifier	 Node Impl
nn	TokenNameIdentifier	 nn
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
pv	TokenNameIdentifier	 pv
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
currentTarget	TokenNameIdentifier	 current Target
=	TokenNameEQUAL	
nn	TokenNameIdentifier	 nn
;	TokenNameSEMICOLON	
nodeListeners	TokenNameIdentifier	 node Listeners
=	TokenNameEQUAL	
getEventListeners	TokenNameIdentifier	 get Event Listeners
(	TokenNameLPAREN	
nn	TokenNameIdentifier	 nn
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Vector	TokenNameIdentifier	 Vector
nl	TokenNameIdentifier	 nl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
)	TokenNameRPAREN	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call listeners in the order in which they got 	TokenNameCOMMENT_LINE	call listeners in the order in which they got 
// registered 	TokenNameCOMMENT_LINE	registered 
int	TokenNameint	
nlsize	TokenNameIdentifier	 nlsize
=	TokenNameEQUAL	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
nlsize	TokenNameIdentifier	 nlsize
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LEntry	TokenNameIdentifier	 L Entry
le	TokenNameIdentifier	 le
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LEntry	TokenNameIdentifier	 L Entry
)	TokenNameRPAREN	
nl	TokenNameIdentifier	 nl
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
useCapture	TokenNameIdentifier	 use Capture
&&	TokenNameAND_AND	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
type	TokenNameIdentifier	 type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
nodeListeners	TokenNameIdentifier	 node Listeners
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
le	TokenNameIdentifier	 le
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
le	TokenNameIdentifier	 le
.	TokenNameDOT	
listener	TokenNameIdentifier	 listener
.	TokenNameDOT	
handleEvent	TokenNameIdentifier	 handle Event
(	TokenNameLPAREN	
evt	TokenNameIdentifier	 evt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
Exception	TokenNameIdentifier	 Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// All exceptions are ignored. 	TokenNameCOMMENT_LINE	All exceptions are ignored. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// DEFAULT PHASE: Some DOMs have default behaviors bound to specific 	TokenNameCOMMENT_LINE	DEFAULT PHASE: Some DOMs have default behaviors bound to specific 
// nodes. If this DOM does, and if the event's preventDefault flag has 	TokenNameCOMMENT_LINE	nodes. If this DOM does, and if the event's preventDefault flag has 
// not been set, we now return to the target node and process its 	TokenNameCOMMENT_LINE	not been set, we now return to the target node and process its 
// default handler for this event, if any. 	TokenNameCOMMENT_LINE	default handler for this event, if any. 
// No specific phase value defined, since this is DOM-internal 	TokenNameCOMMENT_LINE	No specific phase value defined, since this is DOM-internal 
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
defaults	TokenNameIdentifier	 defaults
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
cancelable	TokenNameIdentifier	 cancelable
||	TokenNameOR_OR	
!	TokenNameNOT	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
preventDefault	TokenNameIdentifier	 prevent Default
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// evt.eventPhase = Event.DEFAULT_PHASE; 	TokenNameCOMMENT_LINE	evt.eventPhase = Event.DEFAULT_PHASE; 
// evt.currentTarget = node; 	TokenNameCOMMENT_LINE	evt.currentTarget = node; 
// DO_DEFAULT_OPERATION 	TokenNameCOMMENT_LINE	DO_DEFAULT_OPERATION 
}	TokenNameRBRACE	
return	TokenNamereturn	
evt	TokenNameIdentifier	 evt
.	TokenNameDOT	
preventDefault	TokenNameIdentifier	 prevent Default
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// dispatchEvent(NodeImpl,Event) :boolean 	TokenNameCOMMENT_LINE	dispatchEvent(NodeImpl,Event) :boolean 
/** * NON-DOM INTERNAL: DOMNodeInsertedIntoDocument and ...RemovedFrom... * are dispatched to an entire subtree. This is the distribution code * therefor. They DO NOT bubble, thanks be, but may be captured. * <p> * Similar to code in dispatchingEventToSubtree however this method * is only used on the target node and does not start a dispatching chain * on the sibling of the target node as this is not part of the subtree * ***** At the moment I'm being sloppy and using the normal * capture dispatcher on every node. This could be optimized hugely * by writing a capture engine that tracks our position in the tree to * update the capture chain without repeated chases up to root. * @param n target node (that was directly inserted or removed) * @param e event to be sent to that node and its subtree */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: DOMNodeInsertedIntoDocument and ...RemovedFrom... are dispatched to an entire subtree. This is the distribution code therefor. They DO NOT bubble, thanks be, but may be captured. <p> Similar to code in dispatchingEventToSubtree however this method is only used on the target node and does not start a dispatching chain on the sibling of the target node as this is not part of the subtree ***** At the moment I'm being sloppy and using the normal capture dispatcher on every node. This could be optimized hugely by writing a capture engine that tracks our position in the tree to update the capture chain without repeated chases up to root. @param n target node (that was directly inserted or removed) @param e event to be sent to that node and its subtree 
protected	TokenNameprotected	
void	TokenNamevoid	
dispatchEventToSubtree	TokenNameIdentifier	 dispatch Event To Subtree
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
Event	TokenNameIdentifier	 Event
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
.	TokenNameDOT	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// dispatchEventToSubtree(NodeImpl,Node,Event) :void 	TokenNameCOMMENT_LINE	dispatchEventToSubtree(NodeImpl,Node,Event) :void 
/** * Dispatches event to the target node's descendents recursively * * @param n node to dispatch to * @param e event to be sent to that node and its subtree */	TokenNameCOMMENT_JAVADOC	 Dispatches event to the target node's descendents recursively * @param n node to dispatch to @param e event to be sent to that node and its subtree 
protected	TokenNameprotected	
void	TokenNamevoid	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
Node	TokenNameIdentifier	 Node
n	TokenNameIdentifier	 n
,	TokenNameCOMMA	
Event	TokenNameIdentifier	 Event
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// ***** Recursive implementation. This is excessively expensive, 	TokenNameCOMMENT_LINE	***** Recursive implementation. This is excessively expensive, 
// and should be replaced in conjunction with optimization 	TokenNameCOMMENT_LINE	and should be replaced in conjunction with optimization 
// mentioned above. 	TokenNameCOMMENT_LINE	mentioned above. 
(	TokenNameLPAREN	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
n	TokenNameIdentifier	 n
)	TokenNameRPAREN	
.	TokenNameDOT	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ELEMENT_NODE	TokenNameIdentifier	 ELEMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NamedNodeMap	TokenNameIdentifier	 Named Node Map
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getAttributes	TokenNameIdentifier	 get Attributes
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getFirstChild	TokenNameIdentifier	 get First Child
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchingEventToSubtree	TokenNameIdentifier	 dispatching Event To Subtree
(	TokenNameLPAREN	
n	TokenNameIdentifier	 n
.	TokenNameDOT	
getNextSibling	TokenNameIdentifier	 get Next Sibling
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * NON-DOM INTERNAL: Return object for getEnclosingAttr. Carries * (two values, the Attr node affected (if any) and its previous * string value. Simple struct, no methods. */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: Return object for getEnclosingAttr. Carries (two values, the Attr node affected (if any) and its previous string value. Simple struct, no methods. 
class	TokenNameclass	
EnclosingAttr	TokenNameIdentifier	 Enclosing Attr
implements	TokenNameimplements	
Serializable	TokenNameIdentifier	 Serializable
{	TokenNameLBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
serialVersionUID	TokenNameIdentifier	 serial Version UID
=	TokenNameEQUAL	
5208387723391647216L	TokenNameLongLiteral	
;	TokenNameSEMICOLON	
AttrImpl	TokenNameIdentifier	 Attr Impl
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
EnclosingAttr	TokenNameIdentifier	 Enclosing Attr
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
;	TokenNameSEMICOLON	
/** * NON-DOM INTERNAL: Convenience wrapper for calling * dispatchAggregateEvents when the context was established * by <code>savedEnclosingAttr</code>. * @param node node to dispatch to * @param ea description of Attr affected by current operation */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: Convenience wrapper for calling dispatchAggregateEvents when the context was established by <code>savedEnclosingAttr</code>. @param node node to dispatch to @param ea description of Attr affected by current operation 
protected	TokenNameprotected	
void	TokenNamevoid	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
EnclosingAttr	TokenNameIdentifier	 Enclosing Attr
ea	TokenNameIdentifier	 ea
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ea	TokenNameIdentifier	 ea
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
ea	TokenNameIdentifier	 ea
.	TokenNameDOT	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
ea	TokenNameIdentifier	 ea
.	TokenNameDOT	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
MutationEvent	TokenNameIdentifier	 Mutation Event
.	TokenNameDOT	
MODIFICATION	TokenNameIdentifier	 MODIFICATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// dispatchAggregateEvents(NodeImpl,EnclosingAttr) :void 	TokenNameCOMMENT_LINE	dispatchAggregateEvents(NodeImpl,EnclosingAttr) :void 
/** * NON-DOM INTERNAL: Generate the "aggregated" post-mutation events * DOMAttrModified and DOMSubtreeModified. * Both of these should be issued only once for each user-requested * mutation operation, even if that involves multiple changes to * the DOM. * For example, if a DOM operation makes multiple changes to a single * Attr before returning, it would be nice to generate only one * DOMAttrModified, and multiple changes over larger scope but within * a recognizable single subtree might want to generate only one * DOMSubtreeModified, sent to their lowest common ancestor. * <p> * To manage this, use the "internal" versions of insert and remove * with MUTATION_LOCAL, then make an explicit call to this routine * at the higher level. Some examples now exist in our code. * * @param node The node to dispatch to * @param enclosingAttr The Attr node (if any) whose value has been changed * as a result of the DOM operation. Null if none such. * @param oldvalue The String value previously held by the * enclosingAttr. Ignored if none such. * @param change Type of modification to the attr. See * MutationEvent.attrChange */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: Generate the "aggregated" post-mutation events DOMAttrModified and DOMSubtreeModified. Both of these should be issued only once for each user-requested mutation operation, even if that involves multiple changes to the DOM. For example, if a DOM operation makes multiple changes to a single Attr before returning, it would be nice to generate only one DOMAttrModified, and multiple changes over larger scope but within a recognizable single subtree might want to generate only one DOMSubtreeModified, sent to their lowest common ancestor. <p> To manage this, use the "internal" versions of insert and remove with MUTATION_LOCAL, then make an explicit call to this routine at the higher level. Some examples now exist in our code. * @param node The node to dispatch to @param enclosingAttr The Attr node (if any) whose value has been changed as a result of the DOM operation. Null if none such. @param oldvalue The String value previously held by the enclosingAttr. Ignored if none such. @param change Type of modification to the attr. See MutationEvent.attrChange 
protected	TokenNameprotected	
void	TokenNamevoid	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
AttrImpl	TokenNameIdentifier	 Attr Impl
enclosingAttr	TokenNameIdentifier	 enclosing Attr
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
short	TokenNameshort	
change	TokenNameIdentifier	 change
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We have to send DOMAttrModified. 	TokenNameCOMMENT_LINE	We have to send DOMAttrModified. 
NodeImpl	TokenNameIdentifier	 Node Impl
owner	TokenNameIdentifier	 owner
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_ATTR_MODIFIED	TokenNameIdentifier	 DOM  ATTR  MODIFIED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
owner	TokenNameIdentifier	 owner
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
owner	TokenNameIdentifier	 owner
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_ATTR_MODIFIED	TokenNameIdentifier	 DOM  ATTR  MODIFIED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
,	TokenNameCOMMA	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
.	TokenNameDOT	
getNodeName	TokenNameIdentifier	 get Node Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
change	TokenNameIdentifier	 change
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
owner	TokenNameIdentifier	 owner
.	TokenNameDOT	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// DOMSubtreeModified gets sent to the lowest common root of a 	TokenNameCOMMENT_LINE	DOMSubtreeModified gets sent to the lowest common root of a 
// set of changes. 	TokenNameCOMMENT_LINE	set of changes. 
// "This event is dispatched after all other events caused by the 	TokenNameCOMMENT_LINE	"This event is dispatched after all other events caused by the 
// mutation have been fired." 	TokenNameCOMMENT_LINE	mutation have been fired." 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_SUBTREE_MODIFIED	TokenNameIdentifier	 DOM  SUBTREE  MODIFIED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEvent	TokenNameIdentifier	 Mutation Event
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_SUBTREE_MODIFIED	TokenNameIdentifier	 DOM  SUBTREE  MODIFIED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If we're within an Attr, DStM gets sent to the Attr 	TokenNameCOMMENT_LINE	If we're within an Attr, DStM gets sent to the Attr 
// and to its owningElement. Otherwise we dispatch it 	TokenNameCOMMENT_LINE	and to its owningElement. Otherwise we dispatch it 
// locally. 	TokenNameCOMMENT_LINE	locally. 
if	TokenNameif	
(	TokenNameLPAREN	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
enclosingAttr	TokenNameIdentifier	 enclosing Attr
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
owner	TokenNameIdentifier	 owner
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
owner	TokenNameIdentifier	 owner
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// dispatchAggregateEvents(NodeImpl, AttrImpl,String) :void 	TokenNameCOMMENT_LINE	dispatchAggregateEvents(NodeImpl, AttrImpl,String) :void 
/** * NON-DOM INTERNAL: Pre-mutation context check, in * preparation for later generating DOMAttrModified events. * Determines whether this node is within an Attr * @param node node to get enclosing attribute for */	TokenNameCOMMENT_JAVADOC	 NON-DOM INTERNAL: Pre-mutation context check, in preparation for later generating DOMAttrModified events. Determines whether this node is within an Attr @param node node to get enclosing attribute for 
protected	TokenNameprotected	
void	TokenNamevoid	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// MUTATION PREPROCESSING AND PRE-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION PREPROCESSING AND PRE-EVENTS: 
// If we're within the scope of an Attr and DOMAttrModified 	TokenNameCOMMENT_LINE	If we're within the scope of an Attr and DOMAttrModified 
// was requested, we need to preserve its previous value for 	TokenNameCOMMENT_LINE	was requested, we need to preserve its previous value for 
// that event. 	TokenNameCOMMENT_LINE	that event. 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_ATTR_MODIFIED	TokenNameIdentifier	 DOM  ATTR  MODIFIED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeImpl	TokenNameIdentifier	 Node Impl
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
int	TokenNameint	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
EnclosingAttr	TokenNameIdentifier	 Enclosing Attr
retval	TokenNameIdentifier	 retval
=	TokenNameEQUAL	
new	TokenNamenew	
EnclosingAttr	TokenNameIdentifier	 Enclosing Attr
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
node	TokenNameIdentifier	 node
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
)	TokenNameRPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
;	TokenNameSEMICOLON	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
oldvalue	TokenNameIdentifier	 oldvalue
=	TokenNameEQUAL	
retval	TokenNameIdentifier	 retval
.	TokenNameDOT	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
=	TokenNameEQUAL	
retval	TokenNameIdentifier	 retval
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
ENTITY_REFERENCE_NODE	TokenNameIdentifier	 ENTITY  REFERENCE  NODE
)	TokenNameRPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
parentNode	TokenNameIdentifier	 parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
TEXT_NODE	TokenNameIdentifier	 TEXT  NODE
)	TokenNameRPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
parentNode	TokenNameIdentifier	 parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// Any other parent means we're not in an Attr 	TokenNameCOMMENT_LINE	Any other parent means we're not in an Attr 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// saveEnclosingAttr(NodeImpl) :void 	TokenNameCOMMENT_LINE	saveEnclosingAttr(NodeImpl) :void 
/** * A method to be called when a character data node has been modified */	TokenNameCOMMENT_JAVADOC	 A method to be called when a character data node has been modified 
void	TokenNamevoid	
modifyingCharacterData	TokenNameIdentifier	 modifying Character Data
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when a character data node has been modified */	TokenNameCOMMENT_JAVADOC	 A method to be called when a character data node has been modified 
void	TokenNamevoid	
modifiedCharacterData	TokenNameIdentifier	 modified Character Data
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mutationEventsModifiedCharacterData	TokenNameIdentifier	 mutation Events Modified Character Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
mutationEventsModifiedCharacterData	TokenNameIdentifier	 mutation Events Modified Character Data
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION POST-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION POST-EVENTS: 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_CHARACTER_DATA_MODIFIED	TokenNameIdentifier	 DOM  CHARACTER  DATA  MODIFIED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEvent	TokenNameIdentifier	 Mutation Event
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_CHARACTER_DATA_MODIFIED	TokenNameIdentifier	 DOM  CHARACTER  DATA  MODIFIED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Subroutine: Transmit DOMAttrModified and DOMSubtreeModified, 	TokenNameCOMMENT_LINE	Subroutine: Transmit DOMAttrModified and DOMSubtreeModified, 
// if required. (Common to most kinds of mutation) 	TokenNameCOMMENT_LINE	if required. (Common to most kinds of mutation) 
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// End mutation postprocessing 	TokenNameCOMMENT_LINE	End mutation postprocessing 
}	TokenNameRBRACE	
/** * A method to be called when a character data node has been replaced */	TokenNameCOMMENT_JAVADOC	 A method to be called when a character data node has been replaced 
void	TokenNamevoid	
replacedCharacterData	TokenNameIdentifier	 replaced Character Data
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//now that we have finished replacing data, we need to perform the same actions 	TokenNameCOMMENT_LINE	now that we have finished replacing data, we need to perform the same actions 
//that are required after a character data node has been modified 	TokenNameCOMMENT_LINE	that are required after a character data node has been modified 
//send the value of false for replace parameter so that mutation 	TokenNameCOMMENT_LINE	send the value of false for replace parameter so that mutation 
//events if appropriate will be initiated 	TokenNameCOMMENT_LINE	events if appropriate will be initiated 
modifiedCharacterData	TokenNameIdentifier	 modified Character Data
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A method to be called when a node is about to be inserted in the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node is about to be inserted in the tree. 
void	TokenNamevoid	
insertingNode	TokenNameIdentifier	 inserting Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when a node has been inserted in the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node has been inserted in the tree. 
void	TokenNamevoid	
insertedNode	TokenNameIdentifier	 inserted Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
newInternal	TokenNameIdentifier	 new Internal
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mutationEventsInsertedNode	TokenNameIdentifier	 mutation Events Inserted Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
newInternal	TokenNameIdentifier	 new Internal
,	TokenNameCOMMA	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// notify the range of insertions 	TokenNameCOMMENT_LINE	notify the range of insertions 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesInsertedNode	TokenNameIdentifier	 notify Ranges Inserted Node
(	TokenNameLPAREN	
newInternal	TokenNameIdentifier	 new Internal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
mutationEventsInsertedNode	TokenNameIdentifier	 mutation Events Inserted Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
newInternal	TokenNameIdentifier	 new Internal
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION POST-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION POST-EVENTS: 
// "Local" events (non-aggregated) 	TokenNameCOMMENT_LINE	"Local" events (non-aggregated) 
// New child is told it was inserted, and where 	TokenNameCOMMENT_LINE	New child is told it was inserted, and where 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_INSERTED	TokenNameIdentifier	 DOM  NODE  INSERTED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_INSERTED	TokenNameIdentifier	 DOM  NODE  INSERTED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
newInternal	TokenNameIdentifier	 new Internal
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If within the Document, tell the subtree it's been added 	TokenNameCOMMENT_LINE	If within the Document, tell the subtree it's been added 
// to the Doc. 	TokenNameCOMMENT_LINE	to the Doc. 
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_INSERTED_INTO_DOCUMENT	TokenNameIdentifier	 DOM  NODE  INSERTED  INTO  DOCUMENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeImpl	TokenNameIdentifier	 Node Impl
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
node	TokenNameIdentifier	 node
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
.	TokenNameDOT	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Might have been orphan Attr 	TokenNameCOMMENT_LINE	Might have been orphan Attr 
NodeImpl	TokenNameIdentifier	 Node Impl
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
eventAncestor	TokenNameIdentifier	 event Ancestor
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
// Last non-null ancestor 	TokenNameCOMMENT_LINE	Last non-null ancestor 
// In this context, ancestry includes 	TokenNameCOMMENT_LINE	In this context, ancestry includes 
// walking back from Attr to Element 	TokenNameCOMMENT_LINE	walking back from Attr to Element 
if	TokenNameif	
(	TokenNameLPAREN	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
ATTRIBUTE_NODE	TokenNameIdentifier	 ATTRIBUTE  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
)	TokenNameRPAREN	
p	TokenNameIdentifier	 p
)	TokenNameRPAREN	
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
parentNode	TokenNameIdentifier	 parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_INSERTED_INTO_DOCUMENT	TokenNameIdentifier	 DOM  NODE  INSERTED  INTO  DOCUMENT
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEventToSubtree	TokenNameIdentifier	 dispatch Event To Subtree
(	TokenNameLPAREN	
newInternal	TokenNameIdentifier	 new Internal
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Subroutine: Transmit DOMAttrModified and DOMSubtreeModified 	TokenNameCOMMENT_LINE	Subroutine: Transmit DOMAttrModified and DOMSubtreeModified 
// (Common to most kinds of mutation) 	TokenNameCOMMENT_LINE	(Common to most kinds of mutation) 
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesInsertedNode	TokenNameIdentifier	 notify Ranges Inserted Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
newInternal	TokenNameIdentifier	 new Internal
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
insertedNodeFromDOM	TokenNameIdentifier	 inserted Node From DOM
(	TokenNameLPAREN	
newInternal	TokenNameIdentifier	 new Internal
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when a node is about to be removed from the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node is about to be removed from the tree. 
void	TokenNamevoid	
removingNode	TokenNameIdentifier	 removing Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
oldChild	TokenNameIdentifier	 old Child
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// notify iterators 	TokenNameCOMMENT_LINE	notify iterators 
if	TokenNameif	
(	TokenNameLPAREN	
iterators	TokenNameIdentifier	 iterators
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyIteratorsRemovingNode	TokenNameIdentifier	 notify Iterators Removing Node
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// notify ranges 	TokenNameCOMMENT_LINE	notify ranges 
if	TokenNameif	
(	TokenNameLPAREN	
ranges	TokenNameIdentifier	 ranges
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
notifyRangesRemovingNode	TokenNameIdentifier	 notify Ranges Removing Node
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// mutation events 	TokenNameCOMMENT_LINE	mutation events 
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mutationEventsRemovingNode	TokenNameIdentifier	 mutation Events Removing Node
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
oldChild	TokenNameIdentifier	 old Child
,	TokenNameCOMMA	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyIteratorsRemovingNode	TokenNameIdentifier	 notify Iterators Removing Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleIteratorReferences	TokenNameIdentifier	 remove Stale Iterator References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
iterators	TokenNameIdentifier	 iterators
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeIteratorImpl	TokenNameIdentifier	 Node Iterator Impl
iterator	TokenNameIdentifier	 iterator
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeIteratorImpl	TokenNameIdentifier	 Node Iterator Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
iterator	TokenNameIdentifier	 iterator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
iterator	TokenNameIdentifier	 iterator
.	TokenNameDOT	
removeNode	TokenNameIdentifier	 remove Node
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
notifyRangesRemovingNode	TokenNameIdentifier	 notify Ranges Removing Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
{	TokenNameLBRACE	
removeStaleRangeReferences	TokenNameIdentifier	 remove Stale Range References
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Iterator	TokenNameIdentifier	 Iterator
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
ranges	TokenNameIdentifier	 ranges
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
RangeImpl	TokenNameIdentifier	 Range Impl
range	TokenNameIdentifier	 range
=	TokenNameEQUAL	
(	TokenNameLPAREN	
RangeImpl	TokenNameIdentifier	 Range Impl
)	TokenNameRPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
Reference	TokenNameIdentifier	 Reference
)	TokenNameRPAREN	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
range	TokenNameIdentifier	 range
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
range	TokenNameIdentifier	 range
.	TokenNameDOT	
removeNode	TokenNameIdentifier	 remove Node
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Remove stale reference from the list. 	TokenNameCOMMENT_LINE	Remove stale reference from the list. 
else	TokenNameelse	
{	TokenNameLBRACE	
i	TokenNameIdentifier	 i
.	TokenNameDOT	
remove	TokenNameIdentifier	 remove
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
mutationEventsRemovingNode	TokenNameIdentifier	 mutation Events Removing Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
oldChild	TokenNameIdentifier	 old Child
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION PREPROCESSING AND PRE-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION PREPROCESSING AND PRE-EVENTS: 
// If we're within the scope of an Attr and DOMAttrModified 	TokenNameCOMMENT_LINE	If we're within the scope of an Attr and DOMAttrModified 
// was requested, we need to preserve its previous value for 	TokenNameCOMMENT_LINE	was requested, we need to preserve its previous value for 
// that event. 	TokenNameCOMMENT_LINE	that event. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Child is told that it is about to be removed 	TokenNameCOMMENT_LINE	Child is told that it is about to be removed 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_REMOVED	TokenNameIdentifier	 DOM  NODE  REMOVED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_REMOVED	TokenNameIdentifier	 DOM  NODE  REMOVED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// If within Document, child's subtree is informed that it's 	TokenNameCOMMENT_LINE	If within Document, child's subtree is informed that it's 
// losing that status 	TokenNameCOMMENT_LINE	losing that status 
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_REMOVED_FROM_DOCUMENT	TokenNameIdentifier	 DOM  NODE  REMOVED  FROM  DOCUMENT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
NodeImpl	TokenNameIdentifier	 Node Impl
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
)	TokenNameRPAREN	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
.	TokenNameDOT	
node	TokenNameIdentifier	 node
.	TokenNameDOT	
getOwnerElement	TokenNameIdentifier	 get Owner Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Might have been orphan Attr 	TokenNameCOMMENT_LINE	Might have been orphan Attr 
for	TokenNamefor	
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
parentNode	TokenNameIdentifier	 parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
p	TokenNameIdentifier	 p
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
.	TokenNameDOT	
parentNode	TokenNameIdentifier	 parent Node
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
eventAncestor	TokenNameIdentifier	 event Ancestor
=	TokenNameEQUAL	
p	TokenNameIdentifier	 p
;	TokenNameSEMICOLON	
// Last non-null ancestor 	TokenNameCOMMENT_LINE	Last non-null ancestor 
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
eventAncestor	TokenNameIdentifier	 event Ancestor
.	TokenNameDOT	
getNodeType	TokenNameIdentifier	 get Node Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
Node	TokenNameIdentifier	 Node
.	TokenNameDOT	
DOCUMENT_NODE	TokenNameIdentifier	 DOCUMENT  NODE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_NODE_REMOVED_FROM_DOCUMENT	TokenNameIdentifier	 DOM  NODE  REMOVED  FROM  DOCUMENT
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEventToSubtree	TokenNameIdentifier	 dispatch Event To Subtree
(	TokenNameLPAREN	
oldChild	TokenNameIdentifier	 old Child
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// End mutation preprocessing 	TokenNameCOMMENT_LINE	End mutation preprocessing 
}	TokenNameRBRACE	
/** * A method to be called when a node has been removed from the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node has been removed from the tree. 
void	TokenNamevoid	
removedNode	TokenNameIdentifier	 removed Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
boolean	TokenNameboolean	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION POST-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION POST-EVENTS: 
// Subroutine: Transmit DOMAttrModified and DOMSubtreeModified, 	TokenNameCOMMENT_LINE	Subroutine: Transmit DOMAttrModified and DOMSubtreeModified, 
// if required. (Common to most kinds of mutation) 	TokenNameCOMMENT_LINE	if required. (Common to most kinds of mutation) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
replace	TokenNameIdentifier	 replace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// End mutation postprocessing 	TokenNameCOMMENT_LINE	End mutation postprocessing 
}	TokenNameRBRACE	
/** * A method to be called when a node is about to be replaced in the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node is about to be replaced in the tree. 
void	TokenNamevoid	
replacingNode	TokenNameIdentifier	 replacing Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when character data is about to be replaced in the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when character data is about to be replaced in the tree. 
void	TokenNamevoid	
replacingData	TokenNameIdentifier	 replacing Data
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
saveEnclosingAttr	TokenNameIdentifier	 save Enclosing Attr
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when a node has been replaced in the tree. */	TokenNameCOMMENT_JAVADOC	 A method to be called when a node has been replaced in the tree. 
void	TokenNamevoid	
replacedNode	TokenNameIdentifier	 replaced Node
(	TokenNameLPAREN	
NodeImpl	TokenNameIdentifier	 Node Impl
node	TokenNameIdentifier	 node
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
node	TokenNameIdentifier	 node
,	TokenNameCOMMA	
savedEnclosingAttr	TokenNameIdentifier	 saved Enclosing Attr
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when an attribute value has been modified */	TokenNameCOMMENT_JAVADOC	 A method to be called when an attribute value has been modified 
void	TokenNamevoid	
modifiedAttrValue	TokenNameIdentifier	 modified Attr Value
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
oldvalue	TokenNameIdentifier	 oldvalue
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION POST-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION POST-EVENTS: 
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
oldvalue	TokenNameIdentifier	 oldvalue
,	TokenNameCOMMA	
MutationEvent	TokenNameIdentifier	 Mutation Event
.	TokenNameDOT	
MODIFICATION	TokenNameIdentifier	 MODIFICATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when an attribute node has been set */	TokenNameCOMMENT_JAVADOC	 A method to be called when an attribute node has been set 
void	TokenNamevoid	
setAttrNode	TokenNameIdentifier	 set Attr Node
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
AttrImpl	TokenNameIdentifier	 Attr Impl
previous	TokenNameIdentifier	 previous
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// MUTATION POST-EVENTS: 	TokenNameCOMMENT_LINE	MUTATION POST-EVENTS: 
if	TokenNameif	
(	TokenNameLPAREN	
previous	TokenNameIdentifier	 previous
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
ownerNode	TokenNameIdentifier	 owner Node
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
MutationEvent	TokenNameIdentifier	 Mutation Event
.	TokenNameDOT	
ADDITION	TokenNameIdentifier	 ADDITION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
ownerNode	TokenNameIdentifier	 owner Node
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
previous	TokenNameIdentifier	 previous
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
MutationEvent	TokenNameIdentifier	 Mutation Event
.	TokenNameDOT	
MODIFICATION	TokenNameIdentifier	 MODIFICATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** * A method to be called when an attribute node has been removed */	TokenNameCOMMENT_JAVADOC	 A method to be called when an attribute node has been removed 
void	TokenNamevoid	
removedAttrNode	TokenNameIdentifier	 removed Attr Node
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
oldOwner	TokenNameIdentifier	 old Owner
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// We can't use the standard dispatchAggregate, since it assumes 	TokenNameCOMMENT_LINE	We can't use the standard dispatchAggregate, since it assumes 
// that the Attr is still attached to an owner. This code is 	TokenNameCOMMENT_LINE	that the Attr is still attached to an owner. This code is 
// similar but dispatches to the previous owner, "element". 	TokenNameCOMMENT_LINE	similar but dispatches to the previous owner, "element". 
if	TokenNameif	
(	TokenNameLPAREN	
mutationEvents	TokenNameIdentifier	 mutation Events
)	TokenNameRPAREN	
{	TokenNameLBRACE	
mutationEventsRemovedAttrNode	TokenNameIdentifier	 mutation Events Removed Attr Node
(	TokenNameLPAREN	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
oldOwner	TokenNameIdentifier	 old Owner
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
mutationEventsRemovedAttrNode	TokenNameIdentifier	 mutation Events Removed Attr Node
(	TokenNameLPAREN	
AttrImpl	TokenNameIdentifier	 Attr Impl
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
NodeImpl	TokenNameIdentifier	 Node Impl
oldOwner	TokenNameIdentifier	 old Owner
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// If we have to send DOMAttrModified (determined earlier), 	TokenNameCOMMENT_LINE	If we have to send DOMAttrModified (determined earlier), 
// do so. 	TokenNameCOMMENT_LINE	do so. 
LCount	TokenNameIdentifier	 L Count
lc	TokenNameIdentifier	 lc
=	TokenNameEQUAL	
LCount	TokenNameIdentifier	 L Count
.	TokenNameDOT	
lookup	TokenNameIdentifier	 lookup
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_ATTR_MODIFIED	TokenNameIdentifier	 DOM  ATTR  MODIFIED
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
lc	TokenNameIdentifier	 lc
.	TokenNameDOT	
total	TokenNameIdentifier	 total
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
me	TokenNameIdentifier	 me
=	TokenNameEQUAL	
new	TokenNamenew	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
me	TokenNameIdentifier	 me
.	TokenNameDOT	
initMutationEvent	TokenNameIdentifier	 init Mutation Event
(	TokenNameLPAREN	
MutationEventImpl	TokenNameIdentifier	 Mutation Event Impl
.	TokenNameDOT	
DOM_ATTR_MODIFIED	TokenNameIdentifier	 DOM  ATTR  MODIFIED
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
,	TokenNameCOMMA	
attr	TokenNameIdentifier	 attr
.	TokenNameDOT	
getNodeValue	TokenNameIdentifier	 get Node Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
MutationEvent	TokenNameIdentifier	 Mutation Event
.	TokenNameDOT	
REMOVAL	TokenNameIdentifier	 REMOVAL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dispatchEvent	TokenNameIdentifier	 dispatch Event
(	TokenNameLPAREN	
oldOwner	TokenNameIdentifier	 old Owner
,	TokenNameCOMMA	
me	TokenNameIdentifier	 me
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We can hand off to process DOMSubtreeModified, though. 	TokenNameCOMMENT_LINE	We can hand off to process DOMSubtreeModified, though. 
// Note that only the Element needs to be informed; the 	TokenNameCOMMENT_LINE	Note that only the Element needs to be informed; the 
// Attr's subtree has not been changed by this operation. 	TokenNameCOMMENT_LINE	Attr's subtree has not been changed by this operation. 
dispatchAggregateEvents	TokenNameIdentifier	 dispatch Aggregate Events
(	TokenNameLPAREN	
oldOwner	TokenNameIdentifier	 old Owner
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
(	TokenNameLPAREN	
short	TokenNameshort	
)	TokenNameRPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** * A method to be called when an attribute node has been renamed */	TokenNameCOMMENT_JAVADOC	 A method to be called when an attribute node has been renamed 
void	TokenNamevoid	
renamedAttrNode	TokenNameIdentifier	 renamed Attr Node
(	TokenNameLPAREN	
Attr	TokenNameIdentifier	 Attr
oldAt	TokenNameIdentifier	 old At
,	TokenNameCOMMA	
Attr	TokenNameIdentifier	 Attr
newAt	TokenNameIdentifier	 new At
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: To be implemented!!! 	TokenNameCOMMENT_LINE	REVISIT: To be implemented!!! 
}	TokenNameRBRACE	
/** * A method to be called when an element has been renamed */	TokenNameCOMMENT_JAVADOC	 A method to be called when an element has been renamed 
void	TokenNamevoid	
renamedElement	TokenNameIdentifier	 renamed Element
(	TokenNameLPAREN	
Element	TokenNameIdentifier	 Element
oldEl	TokenNameIdentifier	 old El
,	TokenNameCOMMA	
Element	TokenNameIdentifier	 Element
newEl	TokenNameIdentifier	 new El
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: To be implemented!!! 	TokenNameCOMMENT_LINE	REVISIT: To be implemented!!! 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class DocumentImpl 	TokenNameCOMMENT_LINE	class DocumentImpl 
