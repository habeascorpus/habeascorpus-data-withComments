/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */	TokenNameCOMMENT_BLOCK	 Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
queryParser	TokenNameIdentifier	 query Parser
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
StringReader	TokenNameIdentifier	 String Reader
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
Collator	TokenNameIdentifier	 Collator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
DateFormat	TokenNameIdentifier	 Date Format
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Calendar	TokenNameIdentifier	 Calendar
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Date	TokenNameIdentifier	 Date
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
List	TokenNameIdentifier	 List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Locale	TokenNameIdentifier	 Locale
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
Analyzer	TokenNameIdentifier	 Analyzer
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
CachingTokenFilter	TokenNameIdentifier	 Caching Token Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
TokenStream	TokenNameIdentifier	 Token Stream
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
PositionIncrementAttribute	TokenNameIdentifier	 Position Increment Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
analysis	TokenNameIdentifier	 analysis
.	TokenNameDOT	
tokenattributes	TokenNameIdentifier	 tokenattributes
.	TokenNameDOT	
CharTermAttribute	TokenNameIdentifier	 Char Term Attribute
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
DateField	TokenNameIdentifier	 Date Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
document	TokenNameIdentifier	 document
.	TokenNameDOT	
DateTools	TokenNameIdentifier	 Date Tools
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
index	TokenNameIdentifier	 index
.	TokenNameDOT	
Term	TokenNameIdentifier	 Term
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanClause	TokenNameIdentifier	 Boolean Clause
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
BooleanQuery	TokenNameIdentifier	 Boolean Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
FuzzyQuery	TokenNameIdentifier	 Fuzzy Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiTermQuery	TokenNameIdentifier	 Multi Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MatchAllDocsQuery	TokenNameIdentifier	 Match All Docs Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
MultiPhraseQuery	TokenNameIdentifier	 Multi Phrase Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PhraseQuery	TokenNameIdentifier	 Phrase Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
PrefixQuery	TokenNameIdentifier	 Prefix Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
Query	TokenNameIdentifier	 Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermRangeQuery	TokenNameIdentifier	 Term Range Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
TermQuery	TokenNameIdentifier	 Term Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
search	TokenNameIdentifier	 search
.	TokenNameDOT	
WildcardQuery	TokenNameIdentifier	 Wildcard Query
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Version	TokenNameIdentifier	 Version
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
lucene	TokenNameIdentifier	 lucene
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
VirtualMethod	TokenNameIdentifier	 Virtual Method
;	TokenNameSEMICOLON	
/** Token Manager. */	TokenNameCOMMENT_JAVADOC	 Token Manager. 
public	TokenNamepublic	
class	TokenNameclass	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
implements	TokenNameimplements	
QueryParserConstants	TokenNameIdentifier	 Query Parser Constants
{	TokenNameLBRACE	
/** Debug output. */	TokenNameCOMMENT_JAVADOC	 Debug output. 
public	TokenNamepublic	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
;	TokenNameSEMICOLON	
/** Set debug output. */	TokenNameCOMMENT_JAVADOC	 Set debug output. 
public	TokenNamepublic	
void	TokenNamevoid	
setDebugStream	TokenNameIdentifier	 set Debug Stream
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
PrintStream	TokenNameIdentifier	 Print Stream
ds	TokenNameIdentifier	 ds
)	TokenNameRPAREN	
{	TokenNameLBRACE	
debugStream	TokenNameIdentifier	 debug Stream
=	TokenNameEQUAL	
ds	TokenNameIdentifier	 ds
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_3	TokenNameIdentifier	 jj Stop String Literal Dfa 3
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_3	TokenNameIdentifier	 jj Start Nfa 3
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
jjStopStringLiteralDfa_3	TokenNameIdentifier	 jj Stop String Literal Dfa 3
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_3	TokenNameIdentifier	 jj Move String Literal Dfa0 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
40	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
14	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
41	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
42	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStartNfaWithStates_3	TokenNameIdentifier	 jj Start Nfa With States 3
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
38	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
43	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStartNfaWithStates_3	TokenNameIdentifier	 jj Start Nfa With States 3
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
11	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
45	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStartNfaWithStates_3	TokenNameIdentifier	 jj Start Nfa With States 3
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
58	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
16	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
91	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
94	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
123	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
25	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStartNfaWithStates_3	TokenNameIdentifier	 jj Start Nfa With States 3
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x1L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec1	TokenNameIdentifier	 jjbit Vec1
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0xfffffffffffffffeL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec3	TokenNameIdentifier	 jjbit Vec3
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0x0L	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjbitVec4	TokenNameIdentifier	 jjbit Vec4
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0xfffefffffffffffeL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
,	TokenNameCOMMA	
0xffffffffffffffffL	TokenNameLongLiteral	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_3	TokenNameIdentifier	 jj Move Nfa 3
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfbffd4f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x280200000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffd0f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
42	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
38	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
38	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfbfffcf8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
38	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
38	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
4	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
13	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
33	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
14	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x280200000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
15	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
15	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
13	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
16	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
17	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
19	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
20	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
19	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
22	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
8	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
23	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
46	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
24	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
25	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
42	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
22	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfbffd4f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
29	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
30	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bffd0f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
31	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bfff8f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
33	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x7bfff8f8ffffd9ffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
13	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
126	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
124	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
65	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
38	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
29	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
29	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
68	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
65	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
82	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
7	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
8	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
124	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
9	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
9	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
9	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
124	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
10	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
84	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
10	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
11	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
79	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
10	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
12	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
78	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
11	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
17	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffefffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
18	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
19	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
19	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
21	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
!=	TokenNameNOT_EQUAL	
126	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
21	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
21	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
22	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
28	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
29	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
29	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
29	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
30	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
31	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
32	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
33	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
33	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x97ffffff87ffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
35	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
36	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
36	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
37	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
13	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
15	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
38	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
27	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
15	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
13	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
13	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
17	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
19	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
26	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
29	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
23	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
23	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
30	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
31	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
33	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
34	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
36	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
10	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
12	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_1	TokenNameIdentifier	 jj Stop String Literal Dfa 1
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x80000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_1	TokenNameIdentifier	 jj Start Nfa 1
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
jjStopStringLiteralDfa_1	TokenNameIdentifier	 jj Stop String Literal Dfa 1
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
84	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa1_1	TokenNameIdentifier	 jj Move String Literal Dfa1 1
(	TokenNameLPAREN	
0x80000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
125	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa1_1	TokenNameIdentifier	 jj Move String Literal Dfa1 1
(	TokenNameLPAREN	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_1	TokenNameIdentifier	 jj Stop String Literal Dfa 1
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
79	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x80000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfaWithStates_1	TokenNameIdentifier	 jj Start Nfa With States 1
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_1	TokenNameIdentifier	 jj Start Nfa 1
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStartNfaWithStates_1	TokenNameIdentifier	 jj Start Nfa With States 1
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_1	TokenNameIdentifier	 jj Move Nfa 1
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffeffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
33	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
33	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffeffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xdfffffffffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
34	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_0	TokenNameIdentifier	 jj Move Nfa 0
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
26	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
26	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
19	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
46	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x3ff000000000000L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
26	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
26	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStopStringLiteralDfa_2	TokenNameIdentifier	 jj Stop String Literal Dfa 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x8000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
jjStartNfa_2	TokenNameIdentifier	 jj Start Nfa 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
jjStopStringLiteralDfa_2	TokenNameIdentifier	 jj Stop String Literal Dfa 2
(	TokenNameLPAREN	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa0_2	TokenNameIdentifier	 jj Move String Literal Dfa0 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
84	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveStringLiteralDfa1_2	TokenNameIdentifier	 jj Move String Literal Dfa1 2
(	TokenNameLPAREN	
0x8000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
93	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
jjStopAtPos	TokenNameIdentifier	 jj Stop At Pos
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
28	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveStringLiteralDfa1_2	TokenNameIdentifier	 jj Move String Literal Dfa1 2
(	TokenNameLPAREN	
long	TokenNamelong	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjStopStringLiteralDfa_2	TokenNameIdentifier	 jj Stop String Literal Dfa 2
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
79	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
active0	TokenNameIdentifier	 active0
&	TokenNameAND	
0x8000000L	TokenNameLongLiteral	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
jjStartNfaWithStates_2	TokenNameIdentifier	 jj Start Nfa With States 2
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
27	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjStartNfa_2	TokenNameIdentifier	 jj Start Nfa 2
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
active0	TokenNameIdentifier	 active0
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjStartNfaWithStates_2	TokenNameIdentifier	 jj Start Nfa With States 2
(	TokenNameLPAREN	
int	TokenNameint	
pos	TokenNameIdentifier	 pos
,	TokenNameCOMMA	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
,	TokenNameCOMMA	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
pos	TokenNameIdentifier	 pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
state	TokenNameIdentifier	 state
,	TokenNameCOMMA	
pos	TokenNameIdentifier	 pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
int	TokenNameint	
jjMoveNfa_2	TokenNameIdentifier	 jj Move Nfa 2
(	TokenNameLPAREN	
int	TokenNameint	
startState	TokenNameIdentifier	 start State
,	TokenNameCOMMA	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
startState	TokenNameIdentifier	 start State
;	TokenNameSEMICOLON	
int	TokenNameint	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
++	TokenNamePLUS_PLUS	
jjround	TokenNameIdentifier	 jjround
==	TokenNameEQUAL_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
64	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffeffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0x100002600L	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffbffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
5	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
34	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
29	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
29	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xfffffffeffffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
<	TokenNameLESS	
128	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
long	TokenNamelong	
l	TokenNameIdentifier	 l
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
0xffffffffdfffffffL	TokenNameLongLiteral	
&	TokenNameAND	
l	TokenNameIdentifier	 l
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
4	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
92	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
=	TokenNameEQUAL	
(	TokenNameLPAREN	
int	TokenNameint	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
>>	TokenNameRIGHT_SHIFT	
8	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
=	TokenNameEQUAL	
hiByte	TokenNameIdentifier	 hi Byte
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
=	TokenNameEQUAL	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
=	TokenNameEQUAL	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
do	TokenNamedo	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
7	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
16	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
6	TokenNameIntegerLiteral	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
>	TokenNameGREATER	
30	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
30	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
6	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
!=	TokenNameNOT_EQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
kind	TokenNameIdentifier	 kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
kind	TokenNameIdentifier	 kind
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
kind	TokenNameIdentifier	 kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
++	TokenNamePLUS_PLUS	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
(	TokenNameLPAREN	
startsAt	TokenNameIdentifier	 starts At
=	TokenNameEQUAL	
7	TokenNameIntegerLiteral	
-	TokenNameMINUS	
(	TokenNameLPAREN	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
startsAt	TokenNameIdentifier	 starts At
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
curPos	TokenNameIdentifier	 cur Pos
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnextStates	TokenNameIdentifier	 jjnext States
=	TokenNameEQUAL	
{	TokenNameLBRACE	
17	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
18	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
20	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
31	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
25	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
32	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
22	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
23	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
34	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
25	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
35	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
33	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
36	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
29	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
4	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
5	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
jjCanMove_0	TokenNameIdentifier	 jj Can Move 0
(	TokenNameLPAREN	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
48	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec0	TokenNameIdentifier	 jjbit Vec0
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
jjCanMove_1	TokenNameIdentifier	 jj Can Move 1
(	TokenNameLPAREN	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec3	TokenNameIdentifier	 jjbit Vec3
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec1	TokenNameIdentifier	 jjbit Vec1
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
&	TokenNameAND	
l1	TokenNameIdentifier	 l1
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
jjCanMove_2	TokenNameIdentifier	 jj Can Move 2
(	TokenNameLPAREN	
int	TokenNameint	
hiByte	TokenNameIdentifier	 hi Byte
,	TokenNameCOMMA	
int	TokenNameint	
i1	TokenNameIdentifier	 i1
,	TokenNameCOMMA	
int	TokenNameint	
i2	TokenNameIdentifier	 i2
,	TokenNameCOMMA	
long	TokenNamelong	
l1	TokenNameIdentifier	 l1
,	TokenNameCOMMA	
long	TokenNamelong	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
hiByte	TokenNameIdentifier	 hi Byte
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec3	TokenNameIdentifier	 jjbit Vec3
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
case	TokenNamecase	
48	TokenNameIntegerLiteral	
:	TokenNameCOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec1	TokenNameIdentifier	 jjbit Vec1
[	TokenNameLBRACKET	
i2	TokenNameIdentifier	 i2
]	TokenNameRBRACKET	
&	TokenNameAND	
l2	TokenNameIdentifier	 l2
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
default	TokenNamedefault	
:	TokenNameCOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjbitVec4	TokenNameIdentifier	 jjbit Vec4
[	TokenNameLBRACKET	
i1	TokenNameIdentifier	 i1
]	TokenNameRBRACKET	
&	TokenNameAND	
l1	TokenNameIdentifier	 l1
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Token literal values. */	TokenNameCOMMENT_JAVADOC	 Token literal values. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
=	TokenNameEQUAL	
{	TokenNameLBRACE	
""	TokenNameStringLiteral	 
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"+"	TokenNameStringLiteral	+
,	TokenNameCOMMA	
"-"	TokenNameStringLiteral	-
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"("	TokenNameStringLiteral	(
,	TokenNameCOMMA	
")"	TokenNameStringLiteral	)
,	TokenNameCOMMA	
":"	TokenNameStringLiteral	:
,	TokenNameCOMMA	
"*"	TokenNameStringLiteral	*
,	TokenNameCOMMA	
"^"	TokenNameStringLiteral	^
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"["	TokenNameStringLiteral	[
,	TokenNameCOMMA	
"{"	TokenNameStringLiteral	{
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"TO"	TokenNameStringLiteral	TO
,	TokenNameCOMMA	
"]"	TokenNameStringLiteral	]
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
"TO"	TokenNameStringLiteral	TO
,	TokenNameCOMMA	
"}"	TokenNameStringLiteral	}
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lexer state names. */	TokenNameCOMMENT_JAVADOC	 Lexer state names. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
lexStateNames	TokenNameIdentifier	 lex State Names
=	TokenNameEQUAL	
{	TokenNameLBRACE	
"Boost"	TokenNameStringLiteral	Boost
,	TokenNameCOMMA	
"RangeEx"	TokenNameStringLiteral	RangeEx
,	TokenNameCOMMA	
"RangeIn"	TokenNameStringLiteral	RangeIn
,	TokenNameCOMMA	
"DEFAULT"	TokenNameStringLiteral	DEFAULT
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Lex State array. */	TokenNameCOMMENT_JAVADOC	 Lex State array. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
=	TokenNameEQUAL	
{	TokenNameLBRACE	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
2	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
3	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoToken	TokenNameIdentifier	 jjto Token
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x7ffffff01L	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
long	TokenNamelong	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjtoSkip	TokenNameIdentifier	 jjto Skip
=	TokenNameEQUAL	
{	TokenNameLBRACE	
0x80L	TokenNameLongLiteral	
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
CharStream	TokenNameIdentifier	 Char Stream
input_stream	TokenNameIdentifier	 input stream
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjrounds	TokenNameIdentifier	 jjrounds
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
38	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
jjstateSet	TokenNameIdentifier	 jjstate Set
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
76	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
char	TokenNamechar	
curChar	TokenNameIdentifier	 cur Char
;	TokenNameSEMICOLON	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Constructor. */	TokenNameCOMMENT_JAVADOC	 Constructor. 
public	TokenNamepublic	
QueryParserTokenManager	TokenNameIdentifier	 Query Parser Token Manager
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
this	TokenNamethis	
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
defaultLexState	TokenNameIdentifier	 default Lex State
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
=	TokenNameEQUAL	
stream	TokenNameIdentifier	 stream
;	TokenNameSEMICOLON	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
ReInitRounds	TokenNameIdentifier	 Re Init Rounds
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
jjround	TokenNameIdentifier	 jjround
=	TokenNameEQUAL	
0x80000001	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
38	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0x80000000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Reinitialise parser. */	TokenNameCOMMENT_JAVADOC	 Reinitialise parser. 
public	TokenNamepublic	
void	TokenNamevoid	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
CharStream	TokenNameIdentifier	 Char Stream
stream	TokenNameIdentifier	 stream
,	TokenNameCOMMA	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ReInit	TokenNameIdentifier	 Re Init
(	TokenNameLPAREN	
stream	TokenNameIdentifier	 stream
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Switch to specified lex state. */	TokenNameCOMMENT_JAVADOC	 Switch to specified lex state. 
public	TokenNamepublic	
void	TokenNamevoid	
SwitchTo	TokenNameIdentifier	 Switch To
(	TokenNameLPAREN	
int	TokenNameint	
lexState	TokenNameIdentifier	 lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
lexState	TokenNameIdentifier	 lex State
>=	TokenNameGREATER_EQUAL	
4	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
lexState	TokenNameIdentifier	 lex State
<	TokenNameLESS	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
"Error: Ignoring invalid lexical state : "	TokenNameStringLiteral	Error: Ignoring invalid lexical state : 
+	TokenNamePLUS	
lexState	TokenNameIdentifier	 lex State
+	TokenNamePLUS	
". State unchanged."	TokenNameStringLiteral	. State unchanged.
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
INVALID_LEXICAL_STATE	TokenNameIdentifier	 INVALID  LEXICAL  STATE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
lexState	TokenNameIdentifier	 lex State
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
protected	TokenNameprotected	
Token	TokenNameIdentifier	 Token
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Token	TokenNameIdentifier	 Token
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
curTokenImage	TokenNameIdentifier	 cur Token Image
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
im	TokenNameIdentifier	 im
=	TokenNameEQUAL	
jjstrLiteralImages	TokenNameIdentifier	 jjstr Literal Images
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
curTokenImage	TokenNameIdentifier	 cur Token Image
=	TokenNameEQUAL	
(	TokenNameLPAREN	
im	TokenNameIdentifier	 im
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
im	TokenNameIdentifier	 im
;	TokenNameSEMICOLON	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginLine	TokenNameIdentifier	 get Begin Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getBeginColumn	TokenNameIdentifier	 get Begin Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
=	TokenNameEQUAL	
Token	TokenNameIdentifier	 Token
.	TokenNameDOT	
newToken	TokenNameIdentifier	 new Token
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
,	TokenNameCOMMA	
curTokenImage	TokenNameIdentifier	 cur Token Image
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginLine	TokenNameIdentifier	 begin Line
=	TokenNameEQUAL	
beginLine	TokenNameIdentifier	 begin Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endLine	TokenNameIdentifier	 end Line
=	TokenNameEQUAL	
endLine	TokenNameIdentifier	 end Line
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
beginColumn	TokenNameIdentifier	 begin Column
=	TokenNameEQUAL	
beginColumn	TokenNameIdentifier	 begin Column
;	TokenNameSEMICOLON	
t	TokenNameIdentifier	 t
.	TokenNameDOT	
endColumn	TokenNameIdentifier	 end Column
=	TokenNameEQUAL	
endColumn	TokenNameIdentifier	 end Column
;	TokenNameSEMICOLON	
return	TokenNamereturn	
t	TokenNameIdentifier	 t
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
defaultLexState	TokenNameIdentifier	 default Lex State
=	TokenNameEQUAL	
3	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
;	TokenNameSEMICOLON	
int	TokenNameint	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
;	TokenNameSEMICOLON	
int	TokenNameint	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
;	TokenNameSEMICOLON	
/** Get the next Token. */	TokenNameCOMMENT_JAVADOC	 Get the next Token. 
public	TokenNamepublic	
Token	TokenNameIdentifier	 Token
getNextToken	TokenNameIdentifier	 get Next Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Token	TokenNameIdentifier	 Token
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
int	TokenNameint	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
EOFLoop	TokenNameIdentifier	 EOF Loop
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
;	TokenNameSEMICOLON	
;	TokenNameSEMICOLON	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
curChar	TokenNameIdentifier	 cur Char
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
BeginToken	TokenNameIdentifier	 Begin Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_0	TokenNameIdentifier	 jj Move String Literal Dfa0 0
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_1	TokenNameIdentifier	 jj Move String Literal Dfa0 1
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
2	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_2	TokenNameIdentifier	 jj Move String Literal Dfa0 2
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
3	TokenNameIntegerLiteral	
:	TokenNameCOLON	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
=	TokenNameEQUAL	
0x7fffffff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
curPos	TokenNameIdentifier	 cur Pos
=	TokenNameEQUAL	
jjMoveStringLiteralDfa0_3	TokenNameIdentifier	 jj Move String Literal Dfa0 3
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
!=	TokenNameNOT_EQUAL	
0x7fffffff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
<	TokenNameLESS	
curPos	TokenNameIdentifier	 cur Pos
)	TokenNameRPAREN	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
curPos	TokenNameIdentifier	 cur Pos
-	TokenNameMINUS	
jjmatchedPos	TokenNameIdentifier	 jjmatched Pos
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
jjtoToken	TokenNameIdentifier	 jjto Token
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
>>	TokenNameRIGHT_SHIFT	
6	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
&	TokenNameAND	
(	TokenNameLPAREN	
1L	TokenNameLongLiteral	
<<	TokenNameLEFT_SHIFT	
(	TokenNameLPAREN	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
&	TokenNameAND	
077	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0L	TokenNameLongLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matchedToken	TokenNameIdentifier	 matched Token
=	TokenNameEQUAL	
jjFillToken	TokenNameIdentifier	 jj Fill Token
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matchedToken	TokenNameIdentifier	 matched Token
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
curLexState	TokenNameIdentifier	 cur Lex State
=	TokenNameEQUAL	
jjnewLexState	TokenNameIdentifier	 jjnew Lex State
[	TokenNameLBRACKET	
jjmatchedKind	TokenNameIdentifier	 jjmatched Kind
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
EOFLoop	TokenNameIdentifier	 EOF Loop
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
int	TokenNameint	
error_line	TokenNameIdentifier	 error line
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndLine	TokenNameIdentifier	 get End Line
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
getEndColumn	TokenNameIdentifier	 get End Column
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
readChar	TokenNameIdentifier	 read Char
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
e1	TokenNameIdentifier	 e1
)	TokenNameRPAREN	
{	TokenNameLBRACE	
EOFSeen	TokenNameIdentifier	 EOF Seen
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\n'	TokenNameCharacterLiteral	
||	TokenNameOR_OR	
curChar	TokenNameIdentifier	 cur Char
==	TokenNameEQUAL_EQUAL	
'\r'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
error_line	TokenNameIdentifier	 error line
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
error_column	TokenNameIdentifier	 error column
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
error_column	TokenNameIdentifier	 error column
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
EOFSeen	TokenNameIdentifier	 EOF Seen
)	TokenNameRPAREN	
{	TokenNameLBRACE	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
backup	TokenNameIdentifier	 backup
(	TokenNameLPAREN	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
error_after	TokenNameIdentifier	 error after
=	TokenNameEQUAL	
curPos	TokenNameIdentifier	 cur Pos
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
?	TokenNameQUESTION	
""	TokenNameStringLiteral	 
:	TokenNameCOLON	
input_stream	TokenNameIdentifier	 input stream
.	TokenNameDOT	
GetImage	TokenNameIdentifier	 Get Image
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
(	TokenNameLPAREN	
EOFSeen	TokenNameIdentifier	 EOF Seen
,	TokenNameCOMMA	
curLexState	TokenNameIdentifier	 cur Lex State
,	TokenNameCOMMA	
error_line	TokenNameIdentifier	 error line
,	TokenNameCOMMA	
error_column	TokenNameIdentifier	 error column
,	TokenNameCOMMA	
error_after	TokenNameIdentifier	 error after
,	TokenNameCOMMA	
curChar	TokenNameIdentifier	 cur Char
,	TokenNameCOMMA	
TokenMgrError	TokenNameIdentifier	 Token Mgr Error
.	TokenNameDOT	
LEXICAL_ERROR	TokenNameIdentifier	 LEXICAL  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
int	TokenNameint	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
!=	TokenNameNOT_EQUAL	
jjround	TokenNameIdentifier	 jjround
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
state	TokenNameIdentifier	 state
;	TokenNameSEMICOLON	
jjrounds	TokenNameIdentifier	 jjrounds
[	TokenNameLBRACKET	
state	TokenNameIdentifier	 state
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjround	TokenNameIdentifier	 jjround
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjAddStates	TokenNameIdentifier	 jj Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjstateSet	TokenNameIdentifier	 jjstate Set
[	TokenNameLBRACKET	
jjnewStateCnt	TokenNameIdentifier	 jjnew State Cnt
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddTwoStates	TokenNameIdentifier	 jj Check N Add Two States
(	TokenNameLPAREN	
int	TokenNameint	
state1	TokenNameIdentifier	 state1
,	TokenNameCOMMA	
int	TokenNameint	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state1	TokenNameIdentifier	 state1
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
state2	TokenNameIdentifier	 state2
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
jjCheckNAddStates	TokenNameIdentifier	 jj Check N Add States
(	TokenNameLPAREN	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
{	TokenNameLBRACE	
do	TokenNamedo	
{	TokenNameLBRACE	
jjCheckNAdd	TokenNameIdentifier	 jj Check N Add
(	TokenNameLPAREN	
jjnextStates	TokenNameIdentifier	 jjnext States
[	TokenNameLBRACKET	
start	TokenNameIdentifier	 start
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
while	TokenNamewhile	
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
++	TokenNamePLUS_PLUS	
!=	TokenNameNOT_EQUAL	
end	TokenNameIdentifier	 end
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
