/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
rendered	TokenNameIdentifier	 rendered
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
Rectangle	TokenNameIdentifier	 Rectangle
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
RenderingHints	TokenNameIdentifier	 Rendering Hints
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
color	TokenNameIdentifier	 color
.	TokenNameDOT	
ColorSpace	TokenNameIdentifier	 Color Space
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Point2D	TokenNameIdentifier	 Point2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
geom	TokenNameIdentifier	 geom
.	TokenNameDOT	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
BufferedImage	TokenNameIdentifier	 Buffered Image
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
BufferedImageOp	TokenNameIdentifier	 Buffered Image Op
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
ColorModel	TokenNameIdentifier	 Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBuffer	TokenNameIdentifier	 Data Buffer
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
Raster	TokenNameIdentifier	 Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
RasterOp	TokenNameIdentifier	 Raster Op
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SampleModel	TokenNameIdentifier	 Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
WritableRaster	TokenNameIdentifier	 Writable Raster
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
batik	TokenNameIdentifier	 batik
.	TokenNameDOT	
ext	TokenNameIdentifier	 ext
.	TokenNameDOT	
awt	TokenNameIdentifier	 awt
.	TokenNameDOT	
image	TokenNameIdentifier	 image
.	TokenNameDOT	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
;	TokenNameSEMICOLON	
/** * This class provides an implementation for the SVG * feMorphology filter, as defined in Chapter 15, section 20 * of the SVG specification. * * @author <a href="mailto:sheng.pei@sun.com">Sheng Pei</a> * @version $Id: MorphologyOp.java 489226 2006-12-21 00:05:36Z cam $ */	TokenNameCOMMENT_JAVADOC	 This class provides an implementation for the SVG feMorphology filter, as defined in Chapter 15, section 20 of the SVG specification. * @author <a href="mailto:sheng.pei@sun.com">Sheng Pei</a> @version $Id: MorphologyOp.java 489226 2006-12-21 00:05:36Z cam $ 
public	TokenNamepublic	
class	TokenNameclass	
MorphologyOp	TokenNameIdentifier	 Morphology Op
implements	TokenNameimplements	
BufferedImageOp	TokenNameIdentifier	 Buffered Image Op
,	TokenNameCOMMA	
RasterOp	TokenNameIdentifier	 Raster Op
{	TokenNameLBRACE	
/** * The radius of the operation on X axis */	TokenNameCOMMENT_JAVADOC	 The radius of the operation on X axis 
private	TokenNameprivate	
int	TokenNameint	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
/** * The radius of the operation on Y axis */	TokenNameCOMMENT_JAVADOC	 The radius of the operation on Y axis 
private	TokenNameprivate	
int	TokenNameint	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
/* * Determine whether to do the dilation or erosion operation. * Will do dilation when it's true and erosion when it's false. */	TokenNameCOMMENT_BLOCK	 Determine whether to do the dilation or erosion operation. Will do dilation when it's true and erosion when it's false. 
private	TokenNameprivate	
boolean	TokenNameboolean	
doDilation	TokenNameIdentifier	 do Dilation
;	TokenNameSEMICOLON	
/* * rangeX is 2*radiusX+1, which is the width of the Kernel */	TokenNameCOMMENT_BLOCK	 rangeX is 2*radiusX+1, which is the width of the Kernel 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
/* * rangeY is 2*radiusY+1, which is the height of the Kernel */	TokenNameCOMMENT_BLOCK	 rangeY is 2*radiusY+1, which is the height of the Kernel 
private	TokenNameprivate	
final	TokenNamefinal	
int	TokenNameint	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
/* * sRGB ColorSpace instance used for compatibility checking */	TokenNameCOMMENT_BLOCK	 sRGB ColorSpace instance used for compatibility checking 
private	TokenNameprivate	
final	TokenNamefinal	
ColorSpace	TokenNameIdentifier	 Color Space
sRGB	TokenNameIdentifier	 s RGB
=	TokenNameEQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/* * Linear RGB ColorSpace instance used for compatibility checking */	TokenNameCOMMENT_BLOCK	 Linear RGB ColorSpace instance used for compatibility checking 
private	TokenNameprivate	
final	TokenNamefinal	
ColorSpace	TokenNameIdentifier	 Color Space
lRGB	TokenNameIdentifier	 l RGB
=	TokenNameEQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * @param radiusX defines the radius of filter operation on X-axis. Should not be negative. * A value of zero will disable the effect of the operation on X-axis, as described * in the SVG specification. * @param radiusY defines the radius of filter operation on Y-axis. Should not be negative. * A value of zero will disable the effect of the operation on Y-axis, as described * in the SVG specification. * @param doDilation defines whether to do dilation or erosion operation. Will do dilation * when the value is true, erosion when false. */	TokenNameCOMMENT_JAVADOC	 @param radiusX defines the radius of filter operation on X-axis. Should not be negative. A value of zero will disable the effect of the operation on X-axis, as described in the SVG specification. @param radiusY defines the radius of filter operation on Y-axis. Should not be negative. A value of zero will disable the effect of the operation on Y-axis, as described in the SVG specification. @param doDilation defines whether to do dilation or erosion operation. Will do dilation when the value is true, erosion when false. 
public	TokenNamepublic	
MorphologyOp	TokenNameIdentifier	 Morphology Op
(	TokenNameLPAREN	
int	TokenNameint	
radiusX	TokenNameIdentifier	 radius X
,	TokenNameCOMMA	
int	TokenNameint	
radiusY	TokenNameIdentifier	 radius Y
,	TokenNameCOMMA	
boolean	TokenNameboolean	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
radiusX	TokenNameIdentifier	 radius X
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
||	TokenNameOR_OR	
radiusY	TokenNameIdentifier	 radius Y
<=	TokenNameLESS_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"The radius of X-axis or Y-axis should not be Zero or Negatives."	TokenNameStringLiteral	The radius of X-axis or Y-axis should not be Zero or Negatives.
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
this	TokenNamethis	
.	TokenNameDOT	
radiusX	TokenNameIdentifier	 radius X
=	TokenNameEQUAL	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
radiusY	TokenNameIdentifier	 radius Y
=	TokenNameEQUAL	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
this	TokenNamethis	
.	TokenNameDOT	
doDilation	TokenNameIdentifier	 do Dilation
=	TokenNameEQUAL	
doDilation	TokenNameIdentifier	 do Dilation
;	TokenNameSEMICOLON	
rangeX	TokenNameIdentifier	 range X
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusX	TokenNameIdentifier	 radius X
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
rangeY	TokenNameIdentifier	 range Y
=	TokenNameEQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Rectangle2D	TokenNameIdentifier	 Rectangle2 D
getBounds2D	TokenNameIdentifier	 get Bounds2 D
(	TokenNameLPAREN	
BufferedImage	TokenNameIdentifier	 Buffered Image
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
new	TokenNamenew	
Rectangle	TokenNameIdentifier	 Rectangle
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
Point2D	TokenNameIdentifier	 Point2 D
getPoint2D	TokenNameIdentifier	 get Point2 D
(	TokenNameLPAREN	
Point2D	TokenNameIdentifier	 Point2 D
srcPt	TokenNameIdentifier	 src Pt
,	TokenNameCOMMA	
Point2D	TokenNameIdentifier	 Point2 D
destPt	TokenNameIdentifier	 dest Pt
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This operation does not affect pixel location 	TokenNameCOMMENT_LINE	This operation does not affect pixel location 
if	TokenNameif	
(	TokenNameLPAREN	
destPt	TokenNameIdentifier	 dest Pt
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
destPt	TokenNameIdentifier	 dest Pt
=	TokenNameEQUAL	
new	TokenNamenew	
Point2D	TokenNameIdentifier	 Point2 D
.	TokenNameDOT	
Float	TokenNameIdentifier	 Float
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
destPt	TokenNameIdentifier	 dest Pt
.	TokenNameDOT	
setLocation	TokenNameIdentifier	 set Location
(	TokenNameLPAREN	
srcPt	TokenNameIdentifier	 src Pt
.	TokenNameDOT	
getX	TokenNameIdentifier	 get X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
srcPt	TokenNameIdentifier	 src Pt
.	TokenNameDOT	
getY	TokenNameIdentifier	 get Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
destPt	TokenNameIdentifier	 dest Pt
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
ColorModel	TokenNameIdentifier	 Color Model
colorModel	TokenNameIdentifier	 color Model
,	TokenNameCOMMA	
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColorSpace	TokenNameIdentifier	 Color Space
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check that model is sRGB or linear RGB 	TokenNameCOMMENT_LINE	Check that model is sRGB or linear RGB 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
!	TokenNameNOT	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
sRGB	TokenNameIdentifier	 s RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
cs	TokenNameIdentifier	 cs
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
lRGB	TokenNameIdentifier	 l RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"Expected CS_sRGB or CS_LINEAR_RGB color model"	TokenNameStringLiteral	Expected CS_sRGB or CS_LINEAR_RGB color model
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check ColorModel is of type DirectColorModel 	TokenNameCOMMENT_LINE	Check ColorModel is of type DirectColorModel 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
instanceof	TokenNameinstanceof	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"colorModel should be an instance of DirectColorModel"	TokenNameStringLiteral	colorModel should be an instance of DirectColorModel
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check transfer type 	TokenNameCOMMENT_LINE	Check transfer type 
if	TokenNameif	
(	TokenNameLPAREN	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getDataType	TokenNameIdentifier	 get Data Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"colorModel's transferType should be DataBuffer.TYPE_INT"	TokenNameStringLiteral	colorModel's transferType should be DataBuffer.TYPE_INT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check red, green, blue and alpha mask 	TokenNameCOMMENT_LINE	Check red, green, blue and alpha mask 
DirectColorModel	TokenNameIdentifier	 Direct Color Model
dcm	TokenNameIdentifier	 dcm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
)	TokenNameRPAREN	
colorModel	TokenNameIdentifier	 color Model
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getRedMask	TokenNameIdentifier	 get Red Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x00ff0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"red mask in source should be 0x00ff0000"	TokenNameStringLiteral	red mask in source should be 0x00ff0000
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getGreenMask	TokenNameIdentifier	 get Green Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x0000ff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"green mask in source should be 0x0000ff00"	TokenNameStringLiteral	green mask in source should be 0x0000ff00
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getBlueMask	TokenNameIdentifier	 get Blue Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x000000ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"blue mask in source should be 0x000000ff"	TokenNameStringLiteral	blue mask in source should be 0x000000ff
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getAlphaMask	TokenNameIdentifier	 get Alpha Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0xff000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"alpha mask in source should be 0xff000000"	TokenNameStringLiteral	alpha mask in source should be 0xff000000
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
isCompatible	TokenNameIdentifier	 is Compatible
(	TokenNameLPAREN	
ColorModel	TokenNameIdentifier	 Color Model
colorModel	TokenNameIdentifier	 color Model
,	TokenNameCOMMA	
SampleModel	TokenNameIdentifier	 Sample Model
sampleModel	TokenNameIdentifier	 sample Model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ColorSpace	TokenNameIdentifier	 Color Space
cs	TokenNameIdentifier	 cs
=	TokenNameEQUAL	
colorModel	TokenNameIdentifier	 color Model
.	TokenNameDOT	
getColorSpace	TokenNameIdentifier	 get Color Space
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check that model is sRGB or linear RGB 	TokenNameCOMMENT_LINE	Check that model is sRGB or linear RGB 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
cs	TokenNameIdentifier	 cs
!=	TokenNameNOT_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_sRGB	TokenNameIdentifier	 CS s RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
cs	TokenNameIdentifier	 cs
!=	TokenNameNOT_EQUAL	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
getInstance	TokenNameIdentifier	 get Instance
(	TokenNameLPAREN	
ColorSpace	TokenNameIdentifier	 Color Space
.	TokenNameDOT	
CS_LINEAR_RGB	TokenNameIdentifier	 CS  LINEAR  RGB
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Check ColorModel is of type DirectColorModel 	TokenNameCOMMENT_LINE	Check ColorModel is of type DirectColorModel 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
colorModel	TokenNameIdentifier	 color Model
instanceof	TokenNameinstanceof	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
)	TokenNameRPAREN	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Check transfer type 	TokenNameCOMMENT_LINE	Check transfer type 
if	TokenNameif	
(	TokenNameLPAREN	
sampleModel	TokenNameIdentifier	 sample Model
.	TokenNameDOT	
getDataType	TokenNameIdentifier	 get Data Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Check red, green, blue and alpha mask 	TokenNameCOMMENT_LINE	Check red, green, blue and alpha mask 
DirectColorModel	TokenNameIdentifier	 Direct Color Model
dcm	TokenNameIdentifier	 dcm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DirectColorModel	TokenNameIdentifier	 Direct Color Model
)	TokenNameRPAREN	
colorModel	TokenNameIdentifier	 color Model
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getRedMask	TokenNameIdentifier	 get Red Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x00ff0000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getGreenMask	TokenNameIdentifier	 get Green Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x0000ff00	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getBlueMask	TokenNameIdentifier	 get Blue Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0x000000ff	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dcm	TokenNameIdentifier	 dcm
.	TokenNameDOT	
getAlphaMask	TokenNameIdentifier	 get Alpha Mask
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
0xff000000	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
SampleModel	TokenNameIdentifier	 Sample Model
model	TokenNameIdentifier	 model
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check model is ok: should be SinglePixelPackedSampleModel 	TokenNameCOMMENT_LINE	Check model is ok: should be SinglePixelPackedSampleModel 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
model	TokenNameIdentifier	 model
instanceof	TokenNameinstanceof	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"MorphologyOp only works with Rasters "	TokenNameStringLiteral	MorphologyOp only works with Rasters 
+	TokenNamePLUS	
"using SinglePixelPackedSampleModels"	TokenNameStringLiteral	using SinglePixelPackedSampleModels
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check number of bands 	TokenNameCOMMENT_LINE	Check number of bands 
int	TokenNameint	
nBands	TokenNameIdentifier	 n Bands
=	TokenNameEQUAL	
model	TokenNameIdentifier	 model
.	TokenNameDOT	
getNumBands	TokenNameIdentifier	 get Num Bands
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
nBands	TokenNameIdentifier	 n Bands
!=	TokenNameNOT_EQUAL	
4	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"MorphologyOp only words with Rasters having 4 bands"	TokenNameStringLiteral	MorphologyOp only words with Rasters having 4 bands
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check that integer packed. 	TokenNameCOMMENT_LINE	Check that integer packed. 
if	TokenNameif	
(	TokenNameLPAREN	
model	TokenNameIdentifier	 model
.	TokenNameDOT	
getDataType	TokenNameIdentifier	 get Data Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
DataBuffer	TokenNameIdentifier	 Data Buffer
.	TokenNameDOT	
TYPE_INT	TokenNameIdentifier	 TYPE  INT
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"MorphologyOp only works with Rasters using DataBufferInt"	TokenNameStringLiteral	MorphologyOp only works with Rasters using DataBufferInt
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check bit masks 	TokenNameCOMMENT_LINE	Check bit masks 
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bitOffsets	TokenNameIdentifier	 bit Offsets
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
model	TokenNameIdentifier	 model
)	TokenNameRPAREN	
.	TokenNameDOT	
getBitOffsets	TokenNameIdentifier	 get Bit Offsets
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
bitOffsets	TokenNameIdentifier	 bit Offsets
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
bitOffsets	TokenNameIdentifier	 bit Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
%	TokenNameREMAINDER	
8	TokenNameIntegerLiteral	
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"MorphologyOp only works with Rasters using 8 bits "	TokenNameStringLiteral	MorphologyOp only works with Rasters using 8 bits 
+	TokenNamePLUS	
"per band : "	TokenNameStringLiteral	per band : 
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
" : "	TokenNameStringLiteral	 : 
+	TokenNamePLUS	
bitOffsets	TokenNameIdentifier	 bit Offsets
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
RenderingHints	TokenNameIdentifier	 Rendering Hints
getRenderingHints	TokenNameIdentifier	 get Rendering Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
WritableRaster	TokenNameIdentifier	 Writable Raster
createCompatibleDestRaster	TokenNameIdentifier	 create Compatible Dest Raster
(	TokenNameLPAREN	
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Src Raster is OK: create a similar Raster for destination. 	TokenNameCOMMENT_LINE	Src Raster is OK: create a similar Raster for destination. 
return	TokenNamereturn	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
createCompatibleWritableRaster	TokenNameIdentifier	 create Compatible Writable Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
BufferedImage	TokenNameIdentifier	 Buffered Image
createCompatibleDestImage	TokenNameIdentifier	 create Compatible Dest Image
(	TokenNameLPAREN	
BufferedImage	TokenNameIdentifier	 Buffered Image
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
ColorModel	TokenNameIdentifier	 Color Model
destCM	TokenNameIdentifier	 dest CM
)	TokenNameRPAREN	
{	TokenNameLBRACE	
BufferedImage	TokenNameIdentifier	 Buffered Image
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
destCM	TokenNameIdentifier	 dest CM
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
destCM	TokenNameIdentifier	 dest CM
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
WritableRaster	TokenNameIdentifier	 Writable Raster
wr	TokenNameIdentifier	 wr
;	TokenNameSEMICOLON	
wr	TokenNameIdentifier	 wr
=	TokenNameEQUAL	
destCM	TokenNameIdentifier	 dest CM
.	TokenNameDOT	
createCompatibleWritableRaster	TokenNameIdentifier	 create Compatible Writable Raster
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
destCM	TokenNameIdentifier	 dest CM
,	TokenNameCOMMA	
wr	TokenNameIdentifier	 wr
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedImage	TokenNameIdentifier	 Buffered Image
(	TokenNameLPAREN	
destCM	TokenNameIdentifier	 dest CM
,	TokenNameCOMMA	
wr	TokenNameIdentifier	 wr
,	TokenNameCOMMA	
destCM	TokenNameIdentifier	 dest CM
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
dest	TokenNameIdentifier	 dest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * This method compares the two input variables according * to the doDilation boolean variable. */	TokenNameCOMMENT_BLOCK	 This method compares the two input variables according to the doDilation boolean variable. 
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
final	TokenNamefinal	
int	TokenNameint	
v1	TokenNameIdentifier	 v1
,	TokenNameCOMMA	
final	TokenNamefinal	
int	TokenNameint	
v2	TokenNameIdentifier	 v2
,	TokenNameCOMMA	
final	TokenNamefinal	
boolean	TokenNameboolean	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
v1	TokenNameIdentifier	 v1
>	TokenNameGREATER	
v2	TokenNameIdentifier	 v2
)	TokenNameRPAREN	
return	TokenNamereturn	
doDilation	TokenNameIdentifier	 do Dilation
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
v1	TokenNameIdentifier	 v1
<	TokenNameLESS	
v2	TokenNameIdentifier	 v2
)	TokenNameRPAREN	
return	TokenNamereturn	
!	TokenNameNOT	
doDilation	TokenNameIdentifier	 do Dilation
;	TokenNameSEMICOLON	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * This method deals with the condition that the Kernel is wider than * the Image */	TokenNameCOMMENT_BLOCK	 This method deals with the condition that the Kernel is wider than the Image 
private	TokenNameprivate	
void	TokenNamevoid	
specialProcessRow	TokenNameIdentifier	 special Process Row
(	TokenNameLPAREN	
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
WritableRaster	TokenNameIdentifier	 Writable Raster
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
h	TokenNameIdentifier	 h
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the integer buffer for each image. 	TokenNameCOMMENT_LINE	Access the integer buffer for each image. 
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
srcDB	TokenNameIdentifier	 src DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
dstDB	TokenNameIdentifier	 dst DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Offset defines where in the stack the real data begin 	TokenNameCOMMENT_LINE	Offset defines where in the stack the real data begin 
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
sppsm	TokenNameIdentifier	 sppsm
;	TokenNameSEMICOLON	
sppsm	TokenNameIdentifier	 sppsm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
srcOff	TokenNameIdentifier	 src Off
=	TokenNameEQUAL	
srcDB	TokenNameIdentifier	 src DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
sppsm	TokenNameIdentifier	 sppsm
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateX	TokenNameIdentifier	 get Sample Model Translate X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModelTranslateY	TokenNameIdentifier	 get Sample Model Translate Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
sppsm	TokenNameIdentifier	 sppsm
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
dstOff	TokenNameIdentifier	 dst Off
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
sppsm	TokenNameIdentifier	 sppsm
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getMinX	TokenNameIdentifier	 get Min X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModelTranslateX	TokenNameIdentifier	 get Sample Model Translate X
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getMinY	TokenNameIdentifier	 get Min Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModelTranslateY	TokenNameIdentifier	 get Sample Model Translate Y
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Stride is the distance between two consecutive column elements, 	TokenNameCOMMENT_LINE	Stride is the distance between two consecutive column elements, 
// in the one-dimention dataBuffer 	TokenNameCOMMENT_LINE	in the one-dimention dataBuffer 
final	TokenNamefinal	
int	TokenNameint	
srcScanStride	TokenNameIdentifier	 src Scan Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the pixel value array 	TokenNameCOMMENT_LINE	Access the pixel value array 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcPixels	TokenNameIdentifier	 src Pixels
=	TokenNameEQUAL	
srcDB	TokenNameIdentifier	 src DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
destPixels	TokenNameIdentifier	 dest Pixels
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The pointer of src and dest indicating where the pixel values are 	TokenNameCOMMENT_LINE	The pointer of src and dest indicating where the pixel values are 
int	TokenNameint	
sp	TokenNameIdentifier	 sp
,	TokenNameCOMMA	
dp	TokenNameIdentifier	 dp
;	TokenNameSEMICOLON	
// Declaration for the circular buffer's implementation 	TokenNameCOMMENT_LINE	Declaration for the circular buffer's implementation 
// These are the circular buffers' head pointer and 	TokenNameCOMMENT_LINE	These are the circular buffers' head pointer and 
// the index pointers 	TokenNameCOMMENT_LINE	the index pointers 
// bufferHead points to the leftmost element in the circular buffer 	TokenNameCOMMENT_LINE	bufferHead points to the leftmost element in the circular buffer 
int	TokenNameint	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexA	TokenNameIdentifier	 max Index A
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexR	TokenNameIdentifier	 max Index R
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexG	TokenNameIdentifier	 max Index G
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexB	TokenNameIdentifier	 max Index B
;	TokenNameSEMICOLON	
// Temp variables 	TokenNameCOMMENT_LINE	Temp variables 
int	TokenNameint	
pel	TokenNameIdentifier	 pel
,	TokenNameCOMMA	
currentPixel	TokenNameIdentifier	 current Pixel
,	TokenNameCOMMA	
lastPixel	TokenNameIdentifier	 last Pixel
;	TokenNameSEMICOLON	
int	TokenNameint	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
int	TokenNameint	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// If image width is less than or equal to the radiusX, 	TokenNameCOMMENT_LINE	If image width is less than or equal to the radiusX, 
// all the pixels share the same max/min value 	TokenNameCOMMENT_LINE	all the pixels share the same max/min value 
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
<=	TokenNameLESS_EQUAL	
radiusX	TokenNameIdentifier	 radius X
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// pointing to the first pixels of each row 	TokenNameCOMMENT_LINE	pointing to the first pixels of each row 
sp	TokenNameIdentifier	 sp
=	TokenNameEQUAL	
srcOff	TokenNameIdentifier	 src Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
srcScanStride	TokenNameIdentifier	 src Scan Stride
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// all the element share the same max/min value 	TokenNameCOMMENT_LINE	all the element share the same max/min value 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// When radiusX < w <= 2*radiusX 	TokenNameCOMMENT_LINE	When radiusX < w <= 2*radiusX 
else	TokenNameelse	
{	TokenNameLBRACE	
// The width of the circular buffer is w 	TokenNameCOMMENT_LINE	The width of the circular buffer is w 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferA	TokenNameIdentifier	 buffer A
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
w	TokenNameIdentifier	 w
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferR	TokenNameIdentifier	 buffer R
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
w	TokenNameIdentifier	 w
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferG	TokenNameIdentifier	 buffer G
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
w	TokenNameIdentifier	 w
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferB	TokenNameIdentifier	 buffer B
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
w	TokenNameIdentifier	 w
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialization of pointers, indice 	TokenNameCOMMENT_LINE	initialization of pointers, indice 
// at the head of each row 	TokenNameCOMMENT_LINE	at the head of each row 
sp	TokenNameIdentifier	 sp
=	TokenNameEQUAL	
srcOff	TokenNameIdentifier	 src Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
srcScanStride	TokenNameIdentifier	 src Scan Stride
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g	TokenNameIdentifier	 g
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<=	TokenNameLESS_EQUAL	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// 1 <= j <= w-radiusX-1 : The left margin of each row. 	TokenNameCOMMENT_LINE	1 <= j <= w-radiusX-1 : The left margin of each row. 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<=	TokenNameLESS_EQUAL	
w	TokenNameIdentifier	 w
-	TokenNameMINUS	
radiusX	TokenNameIdentifier	 radius X
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// here is the Alpha channel 	TokenNameCOMMENT_LINE	here is the Alpha channel 
// we retrieve the previous max/min value 	TokenNameCOMMENT_LINE	we retrieve the previous max/min value 
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Red channel 	TokenNameCOMMENT_LINE	now we deal with the Red channel 
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Green channel 	TokenNameCOMMENT_LINE	now we deal with the Green channel 
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Blue channel 	TokenNameCOMMENT_LINE	now we deal with the Blue channel 
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we have gone through the four channels and 	TokenNameCOMMENT_LINE	now we have gone through the four channels and 
// updated the index array. then we'll pack the 	TokenNameCOMMENT_LINE	updated the index array. then we'll pack the 
// new max/min value according to each channel's 	TokenNameCOMMENT_LINE	new max/min value according to each channel's 
// max/min vlue 	TokenNameCOMMENT_LINE	max/min vlue 
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now is the inner body of the row: 	TokenNameCOMMENT_LINE	Now is the inner body of the row: 
// all elements in this segment share the same max/min value 	TokenNameCOMMENT_LINE	all elements in this segment share the same max/min value 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
w	TokenNameIdentifier	 w
-	TokenNameMINUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<=	TokenNameLESS_EQUAL	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now the circular buffer is full 	TokenNameCOMMENT_LINE	Now the circular buffer is full 
// Now is the right margin of the row when radiusX < w <= 2*radiusX 	TokenNameCOMMENT_LINE	Now is the right margin of the row when radiusX < w <= 2*radiusX 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
radiusX	TokenNameIdentifier	 radius X
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// discard the leftmost element 	TokenNameCOMMENT_LINE	discard the leftmost element 
bufferHead	TokenNameIdentifier	 buffer Head
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// return to the first pixel of the next row 	TokenNameCOMMENT_LINE	return to the first pixel of the next row 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// When radiusX < w <=2*radiusX 	TokenNameCOMMENT_LINE	When radiusX < w <=2*radiusX 
}	TokenNameRBRACE	
/* * This method deals with the condition when the Kernel is * higher than the image. */	TokenNameCOMMENT_BLOCK	 This method deals with the condition when the Kernel is higher than the image. 
private	TokenNameprivate	
void	TokenNamevoid	
specialProcessColumn	TokenNameIdentifier	 special Process Column
(	TokenNameLPAREN	
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
WritableRaster	TokenNameIdentifier	 Writable Raster
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
h	TokenNameIdentifier	 h
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the integer buffer for each image. 	TokenNameCOMMENT_LINE	Access the integer buffer for each image. 
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
dstDB	TokenNameIdentifier	 dst DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Offset defines where in the stack the real data begin 	TokenNameCOMMENT_LINE	Offset defines where in the stack the real data begin 
final	TokenNamefinal	
int	TokenNameint	
dstOff	TokenNameIdentifier	 dst Off
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Stride is the distance between two consecutive column elements, 	TokenNameCOMMENT_LINE	Stride is the distance between two consecutive column elements, 
// in the one-dimention dataBuffer 	TokenNameCOMMENT_LINE	in the one-dimention dataBuffer 
final	TokenNamefinal	
int	TokenNameint	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the pixel value array 	TokenNameCOMMENT_LINE	Access the pixel value array 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
destPixels	TokenNameIdentifier	 dest Pixels
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The pointer of src and dest indicating where the pixel values are 	TokenNameCOMMENT_LINE	The pointer of src and dest indicating where the pixel values are 
int	TokenNameint	
dp	TokenNameIdentifier	 dp
,	TokenNameCOMMA	
cp	TokenNameIdentifier	 cp
;	TokenNameSEMICOLON	
// Declaration for the circular buffer's implementation 	TokenNameCOMMENT_LINE	Declaration for the circular buffer's implementation 
// These are the circular buffers' head pointer and 	TokenNameCOMMENT_LINE	These are the circular buffers' head pointer and 
// the index pointers 	TokenNameCOMMENT_LINE	the index pointers 
// bufferHead points to the leftmost element in the circular buffer 	TokenNameCOMMENT_LINE	bufferHead points to the leftmost element in the circular buffer 
int	TokenNameint	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexA	TokenNameIdentifier	 max Index A
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexR	TokenNameIdentifier	 max Index R
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexG	TokenNameIdentifier	 max Index G
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexB	TokenNameIdentifier	 max Index B
;	TokenNameSEMICOLON	
// Temp variables 	TokenNameCOMMENT_LINE	Temp variables 
int	TokenNameint	
pel	TokenNameIdentifier	 pel
,	TokenNameCOMMA	
currentPixel	TokenNameIdentifier	 current Pixel
,	TokenNameCOMMA	
lastPixel	TokenNameIdentifier	 last Pixel
;	TokenNameSEMICOLON	
int	TokenNameint	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
int	TokenNameint	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// Here all the pixels share the same 	TokenNameCOMMENT_LINE	Here all the pixels share the same 
// max/min value 	TokenNameCOMMENT_LINE	max/min value 
if	TokenNameif	
(	TokenNameLPAREN	
h	TokenNameIdentifier	 h
<=	TokenNameLESS_EQUAL	
radiusY	TokenNameIdentifier	 radius Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// return to the first pixel of the next column 	TokenNameCOMMENT_LINE	return to the first pixel of the next column 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// When radiusY < h <= 2*radiusY 	TokenNameCOMMENT_LINE	When radiusY < h <= 2*radiusY 
else	TokenNameelse	
{	TokenNameLBRACE	
// The height of the circular buffer is h 	TokenNameCOMMENT_LINE	The height of the circular buffer is h 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferA	TokenNameIdentifier	 buffer A
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
h	TokenNameIdentifier	 h
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferR	TokenNameIdentifier	 buffer R
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
h	TokenNameIdentifier	 h
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferG	TokenNameIdentifier	 buffer G
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
h	TokenNameIdentifier	 h
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferB	TokenNameIdentifier	 buffer B
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
h	TokenNameIdentifier	 h
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialization of pointers, indice 	TokenNameCOMMENT_LINE	initialization of pointers, indice 
// at the head of each column 	TokenNameCOMMENT_LINE	at the head of each column 
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g	TokenNameIdentifier	 g
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<=	TokenNameLESS_EQUAL	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// fill the first pixel of each column 	TokenNameCOMMENT_LINE	fill the first pixel of each column 
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// 1 <= i <= h-1-radiusY : The upper margin of each column. 	TokenNameCOMMENT_LINE	1 <= i <= h-1-radiusY : The upper margin of each column. 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
h	TokenNameIdentifier	 h
-	TokenNameMINUS	
radiusY	TokenNameIdentifier	 radius Y
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
// here is the Alpha channel 	TokenNameCOMMENT_LINE	here is the Alpha channel 
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Red channel 	TokenNameCOMMENT_LINE	now we deal with the Red channel 
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Green channel 	TokenNameCOMMENT_LINE	now we deal with the Green channel 
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Blue channel 	TokenNameCOMMENT_LINE	now we deal with the Blue channel 
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we have gone through the four channels and 	TokenNameCOMMENT_LINE	now we have gone through the four channels and 
// updated the index array. then we'll pack the 	TokenNameCOMMENT_LINE	updated the index array. then we'll pack the 
// new max/min value according to each channel's 	TokenNameCOMMENT_LINE	new max/min value according to each channel's 
// max/min vlue 	TokenNameCOMMENT_LINE	max/min vlue 
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Now is the inner body of the column 	TokenNameCOMMENT_LINE	Now is the inner body of the column 
// when radiusY < h <= 2*radiusY 	TokenNameCOMMENT_LINE	when radiusY < h <= 2*radiusY 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
h	TokenNameIdentifier	 h
-	TokenNameMINUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
-	TokenNameMINUS	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// The circular buffer is full now 	TokenNameCOMMENT_LINE	The circular buffer is full now 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
radiusY	TokenNameIdentifier	 radius Y
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// discard the leftmost element 	TokenNameCOMMENT_LINE	discard the leftmost element 
bufferHead	TokenNameIdentifier	 buffer Head
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// return to the first pixel of the next column 	TokenNameCOMMENT_LINE	return to the first pixel of the next column 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// when radiusY < h <= 2*radiusY 	TokenNameCOMMENT_LINE	when radiusY < h <= 2*radiusY 
}	TokenNameRBRACE	
/** * Filters src and writes result into dest. If dest if null, then * a Raster is created. If dest and src refer to the same object, * then the source is modified. * <p> * The filtering kernel(the operation range for each pixel) is a * rectangle of width 2*radiusX+1 and height radiusY+1 * <p> * @param src the Raster to be filtered * @param dest stores the filtered image. If null, a destination will * be created. src and dest can refer to the same Raster, in * which situation the src will be modified. */	TokenNameCOMMENT_JAVADOC	 Filters src and writes result into dest. If dest if null, then a Raster is created. If dest and src refer to the same object, then the source is modified. <p> The filtering kernel(the operation range for each pixel) is a rectangle of width 2*radiusX+1 and height radiusY+1 <p> @param src the Raster to be filtered @param dest stores the filtered image. If null, a destination will be created. src and dest can refer to the same Raster, in which situation the src will be modified. 
public	TokenNamepublic	
WritableRaster	TokenNameIdentifier	 Writable Raster
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
Raster	TokenNameIdentifier	 Raster
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
WritableRaster	TokenNameIdentifier	 Writable Raster
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
//This method sorts the pixel values in the kernel window in two steps: 	TokenNameCOMMENT_LINE	This method sorts the pixel values in the kernel window in two steps: 
// 1. sort by row and store the result into an intermediate matrix 	TokenNameCOMMENT_LINE	1. sort by row and store the result into an intermediate matrix 
// 2. sort the intermediate matrix by column and output the max/min value 	TokenNameCOMMENT_LINE	2. sort the intermediate matrix by column and output the max/min value 
// into the destination matrix element 	TokenNameCOMMENT_LINE	into the destination matrix element 
//check destation 	TokenNameCOMMENT_LINE	check destation 
if	TokenNameif	
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
checkCompatible	TokenNameIdentifier	 check Compatible
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
IllegalArgumentException	TokenNameIdentifier	 Illegal Argument Exception
(	TokenNameLPAREN	
"src should not be null when dest is null"	TokenNameStringLiteral	src should not be null when dest is null
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
createCompatibleDestRaster	TokenNameIdentifier	 create Compatible Dest Raster
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
int	TokenNameint	
w	TokenNameIdentifier	 w
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
h	TokenNameIdentifier	 h
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the integer buffer for each image. 	TokenNameCOMMENT_LINE	Access the integer buffer for each image. 
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
srcDB	TokenNameIdentifier	 src DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
dstDB	TokenNameIdentifier	 dst DB
=	TokenNameEQUAL	
(	TokenNameLPAREN	
DataBufferInt	TokenNameIdentifier	 Data Buffer Int
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getDataBuffer	TokenNameIdentifier	 get Data Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Offset defines where in the stack the real data begin 	TokenNameCOMMENT_LINE	Offset defines where in the stack the real data begin 
final	TokenNamefinal	
int	TokenNameint	
srcOff	TokenNameIdentifier	 src Off
=	TokenNameEQUAL	
srcDB	TokenNameIdentifier	 src DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
dstOff	TokenNameIdentifier	 dst Off
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getOffset	TokenNameIdentifier	 get Offset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Stride is the distance between two consecutive column elements, 	TokenNameCOMMENT_LINE	Stride is the distance between two consecutive column elements, 
// in the one-dimention dataBuffer 	TokenNameCOMMENT_LINE	in the one-dimention dataBuffer 
final	TokenNamefinal	
int	TokenNameint	
srcScanStride	TokenNameIdentifier	 src Scan Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
SinglePixelPackedSampleModel	TokenNameIdentifier	 Single Pixel Packed Sample Model
)	TokenNameRPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
getScanlineStride	TokenNameIdentifier	 get Scanline Stride
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Access the pixel value array 	TokenNameCOMMENT_LINE	Access the pixel value array 
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
srcPixels	TokenNameIdentifier	 src Pixels
=	TokenNameEQUAL	
srcDB	TokenNameIdentifier	 src DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
destPixels	TokenNameIdentifier	 dest Pixels
=	TokenNameEQUAL	
dstDB	TokenNameIdentifier	 dst DB
.	TokenNameDOT	
getBankData	TokenNameIdentifier	 get Bank Data
(	TokenNameLPAREN	
)	TokenNameRPAREN	
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// The pointer of src and dest indicating where the pixel values are 	TokenNameCOMMENT_LINE	The pointer of src and dest indicating where the pixel values are 
int	TokenNameint	
sp	TokenNameIdentifier	 sp
,	TokenNameCOMMA	
dp	TokenNameIdentifier	 dp
,	TokenNameCOMMA	
cp	TokenNameIdentifier	 cp
;	TokenNameSEMICOLON	
// Declaration for the circular buffer's implementation 	TokenNameCOMMENT_LINE	Declaration for the circular buffer's implementation 
// These are the circular buffers' head pointer and 	TokenNameCOMMENT_LINE	These are the circular buffers' head pointer and 
// the index pointers 	TokenNameCOMMENT_LINE	the index pointers 
// bufferHead points to the leftmost element in the circular buffer 	TokenNameCOMMENT_LINE	bufferHead points to the leftmost element in the circular buffer 
int	TokenNameint	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexA	TokenNameIdentifier	 max Index A
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexR	TokenNameIdentifier	 max Index R
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexG	TokenNameIdentifier	 max Index G
;	TokenNameSEMICOLON	
int	TokenNameint	
maxIndexB	TokenNameIdentifier	 max Index B
;	TokenNameSEMICOLON	
// Temp variables 	TokenNameCOMMENT_LINE	Temp variables 
int	TokenNameint	
pel	TokenNameIdentifier	 pel
,	TokenNameCOMMA	
currentPixel	TokenNameIdentifier	 current Pixel
,	TokenNameCOMMA	
lastPixel	TokenNameIdentifier	 last Pixel
;	TokenNameSEMICOLON	
int	TokenNameint	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
int	TokenNameint	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// In both round, we are using an optimization approach 	TokenNameCOMMENT_LINE	In both round, we are using an optimization approach 
// to reduce excessive computation to sort values around 	TokenNameCOMMENT_LINE	to reduce excessive computation to sort values around 
// the current pixel. The idea is as follows: 	TokenNameCOMMENT_LINE	the current pixel. The idea is as follows: 
// ---------------- 	TokenNameCOMMENT_LINE	---------------- 
// |*|V|V|$|N|V|V|&| 	TokenNameCOMMENT_LINE	|*|V|V|$|N|V|V|&| 
// ---------------- 	TokenNameCOMMENT_LINE	---------------- 
// For example, suppose we've finished pixel"$" and come 	TokenNameCOMMENT_LINE	For example, suppose we've finished pixel"$" and come 
// to "N", the radius is 3. Then we must have got the max/min 	TokenNameCOMMENT_LINE	to "N", the radius is 3. Then we must have got the max/min 
// value and index array for "$". If the max/min is at 	TokenNameCOMMENT_LINE	value and index array for "$". If the max/min is at 
// "*"(using the index array to judge this), 	TokenNameCOMMENT_LINE	"*"(using the index array to judge this), 
// we need to recompute a max/min and the index array 	TokenNameCOMMENT_LINE	we need to recompute a max/min and the index array 
// for "N"; if the max/min is not at "*", we can 	TokenNameCOMMENT_LINE	for "N"; if the max/min is not at "*", we can 
// reuse the current max/min: we simply compare it with 	TokenNameCOMMENT_LINE	reuse the current max/min: we simply compare it with 
// "&", and update the max/min and the index array. 	TokenNameCOMMENT_LINE	"&", and update the max/min and the index array. 
// 	TokenNameCOMMENT_LINE	 
// The first round: sort by row 	TokenNameCOMMENT_LINE	The first round: sort by row 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
w	TokenNameIdentifier	 w
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusX	TokenNameIdentifier	 radius X
)	TokenNameRPAREN	
{	TokenNameLBRACE	
specialProcessRow	TokenNameIdentifier	 special Process Row
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// when the size is large enough, we can 	TokenNameCOMMENT_LINE	when the size is large enough, we can 
// use standard optimization method 	TokenNameCOMMENT_LINE	use standard optimization method 
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferA	TokenNameIdentifier	 buffer A
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeX	TokenNameIdentifier	 range X
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferR	TokenNameIdentifier	 buffer R
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeX	TokenNameIdentifier	 range X
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferG	TokenNameIdentifier	 buffer G
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeX	TokenNameIdentifier	 range X
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferB	TokenNameIdentifier	 buffer B
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeX	TokenNameIdentifier	 range X
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
h	TokenNameIdentifier	 h
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialization of pointers, indice 	TokenNameCOMMENT_LINE	initialization of pointers, indice 
// at the head of each row 	TokenNameCOMMENT_LINE	at the head of each row 
sp	TokenNameIdentifier	 sp
=	TokenNameEQUAL	
srcOff	TokenNameIdentifier	 src Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
srcScanStride	TokenNameIdentifier	 src Scan Stride
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
*	TokenNameMULTIPLY	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// j=0 : Initialization, compute the max/min and 	TokenNameCOMMENT_LINE	j=0 : Initialization, compute the max/min and 
// index array for the use of other pixels. 	TokenNameCOMMENT_LINE	index array for the use of other pixels. 
// 	TokenNameCOMMENT_LINE	 
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g	TokenNameIdentifier	 g
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<=	TokenNameLESS_EQUAL	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// 1 <= j <= radiusX : The left margin of each row. 	TokenNameCOMMENT_LINE	1 <= j <= radiusX : The left margin of each row. 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<=	TokenNameLESS_EQUAL	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// here is the Alpha channel 	TokenNameCOMMENT_LINE	here is the Alpha channel 
// we retrieve the previous max/min value 	TokenNameCOMMENT_LINE	we retrieve the previous max/min value 
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Red channel 	TokenNameCOMMENT_LINE	now we deal with the Red channel 
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Green channel 	TokenNameCOMMENT_LINE	now we deal with the Green channel 
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Blue channel 	TokenNameCOMMENT_LINE	now we deal with the Blue channel 
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we have gone through the four channels and 	TokenNameCOMMENT_LINE	now we have gone through the four channels and 
// updated the index array. then we'll pack the 	TokenNameCOMMENT_LINE	updated the index array. then we'll pack the 
// new max/min value according to each channel's 	TokenNameCOMMENT_LINE	new max/min value according to each channel's 
// max/min vlue 	TokenNameCOMMENT_LINE	max/min vlue 
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// radiusX <= j <= w-1-radiusX : Inner body of the row, between 	TokenNameCOMMENT_LINE	radiusX <= j <= w-1-radiusX : Inner body of the row, between 
// left and right margins 	TokenNameCOMMENT_LINE	left and right margins 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
radiusX	TokenNameIdentifier	 radius X
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<=	TokenNameLESS_EQUAL	
w	TokenNameIdentifier	 w
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
srcPixels	TokenNameIdentifier	 src Pixels
[	TokenNameLBRACKET	
sp	TokenNameIdentifier	 sp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// Alpha channel: 	TokenNameCOMMENT_LINE	Alpha channel: 
// we need to recompute a local max/min 	TokenNameCOMMENT_LINE	we need to recompute a local max/min 
// and update the max/min index 	TokenNameCOMMENT_LINE	and update the max/min index 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Red channel 	TokenNameCOMMENT_LINE	Red channel 
// we need to recompute a local max/min 	TokenNameCOMMENT_LINE	we need to recompute a local max/min 
// and update the index array 	TokenNameCOMMENT_LINE	and update the index array 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Green channel 	TokenNameCOMMENT_LINE	Green channel 
// we need to recompute a local max/min 	TokenNameCOMMENT_LINE	we need to recompute a local max/min 
// and update the index array 	TokenNameCOMMENT_LINE	and update the index array 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Blue channel 	TokenNameCOMMENT_LINE	Blue channel 
// we need to recompute a local max/min 	TokenNameCOMMENT_LINE	we need to recompute a local max/min 
// and update the index array 	TokenNameCOMMENT_LINE	and update the index array 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// w-radiusX <= j < w : The right margin of the row 	TokenNameCOMMENT_LINE	w-radiusX <= j < w : The right margin of the row 
// 	TokenNameCOMMENT_LINE	 
// Head will be updated to indicate the current head 	TokenNameCOMMENT_LINE	Head will be updated to indicate the current head 
// of the remaining buffer 	TokenNameCOMMENT_LINE	of the remaining buffer 
int	TokenNameint	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
// Tail is where the last element is 	TokenNameCOMMENT_LINE	Tail is where the last element is 
final	TokenNamefinal	
int	TokenNameint	
tail	TokenNameIdentifier	 tail
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
rangeX	TokenNameIdentifier	 range X
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
:	TokenNameCOLON	
bufferHead	TokenNameIdentifier	 buffer Head
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
rangeX	TokenNameIdentifier	 range X
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
w	TokenNameIdentifier	 w
-	TokenNameMINUS	
radiusX	TokenNameIdentifier	 radius X
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
head	TokenNameIdentifier	 head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
// Dealing with Alpha Channel: 	TokenNameCOMMENT_LINE	Dealing with Alpha Channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Dealing with Red Channel: 	TokenNameCOMMENT_LINE	Dealing with Red Channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Dealing with Green Channel: 	TokenNameCOMMENT_LINE	Dealing with Green Channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Dealing with Blue Channel: 	TokenNameCOMMENT_LINE	Dealing with Blue Channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeX	TokenNameIdentifier	 range X
;	TokenNameSEMICOLON	
// we throw another element 	TokenNameCOMMENT_LINE	we throw another element 
count	TokenNameIdentifier	 count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end of the right margin of this row 	TokenNameCOMMENT_LINE	end of the right margin of this row 
// return to the beginning of the next row 	TokenNameCOMMENT_LINE	return to the beginning of the next row 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end of the first round! 	TokenNameCOMMENT_LINE	end of the first round! 
// 	TokenNameCOMMENT_LINE	 
// Second round: sort by column 	TokenNameCOMMENT_LINE	Second round: sort by column 
// the difference from the first round is that 	TokenNameCOMMENT_LINE	the difference from the first round is that 
// now we are accessing the intermediate matrix 	TokenNameCOMMENT_LINE	now we are accessing the intermediate matrix 
// 	TokenNameCOMMENT_LINE	 
// When the image size is smaller than the 	TokenNameCOMMENT_LINE	When the image size is smaller than the 
// Kernel size 	TokenNameCOMMENT_LINE	Kernel size 
if	TokenNameif	
(	TokenNameLPAREN	
h	TokenNameIdentifier	 h
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
)	TokenNameRPAREN	
{	TokenNameLBRACE	
specialProcessColumn	TokenNameIdentifier	 special Process Column
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// when the size is large enough, we can 	TokenNameCOMMENT_LINE	when the size is large enough, we can 
// use standard optimization method 	TokenNameCOMMENT_LINE	use standard optimization method 
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferA	TokenNameIdentifier	 buffer A
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeY	TokenNameIdentifier	 range Y
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferR	TokenNameIdentifier	 buffer R
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeY	TokenNameIdentifier	 range Y
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferG	TokenNameIdentifier	 buffer G
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeY	TokenNameIdentifier	 range Y
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
bufferB	TokenNameIdentifier	 buffer B
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
rangeY	TokenNameIdentifier	 range Y
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
w	TokenNameIdentifier	 w
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialization of pointers, indice 	TokenNameCOMMENT_LINE	initialization of pointers, indice 
// at the head of each column 	TokenNameCOMMENT_LINE	at the head of each column 
dp	TokenNameIdentifier	 dp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
=	TokenNameEQUAL	
dstOff	TokenNameIdentifier	 dst Off
+	TokenNamePLUS	
j	TokenNameIdentifier	 j
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// i=0 : The first pixel 	TokenNameCOMMENT_LINE	i=0 : The first pixel 
pel	TokenNameIdentifier	 pel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
pel	TokenNameIdentifier	 pel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a	TokenNameIdentifier	 a
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r	TokenNameIdentifier	 r
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g	TokenNameIdentifier	 g
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<=	TokenNameLESS_EQUAL	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currentPixel	TokenNameIdentifier	 current Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
currentPixel	TokenNameIdentifier	 current Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
k	TokenNameIdentifier	 k
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
// go to the next element in the column. 	TokenNameCOMMENT_LINE	go to the next element in the column. 
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
// 1 <= i <= radiusY : The upper margin of each row 	TokenNameCOMMENT_LINE	1 <= i <= radiusY : The upper margin of each row 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
maxI	TokenNameIdentifier	 max I
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
// here is the Alpha channel 	TokenNameCOMMENT_LINE	here is the Alpha channel 
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxI	TokenNameIdentifier	 max I
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
maxI	TokenNameIdentifier	 max I
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Red channel 	TokenNameCOMMENT_LINE	now we deal with the Red channel 
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxI	TokenNameIdentifier	 max I
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
maxI	TokenNameIdentifier	 max I
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Green channel 	TokenNameCOMMENT_LINE	now we deal with the Green channel 
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxI	TokenNameIdentifier	 max I
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
maxI	TokenNameIdentifier	 max I
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now we deal with the Blue channel 	TokenNameCOMMENT_LINE	now we deal with the Blue channel 
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxI	TokenNameIdentifier	 max I
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
maxI	TokenNameIdentifier	 max I
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// radiusY +1 <= i <= h-1-radiusY: 	TokenNameCOMMENT_LINE	radiusY +1 <= i <= h-1-radiusY: 
// inner body of the column between upper and lower margins 	TokenNameCOMMENT_LINE	inner body of the column between upper and lower margins 
// 	TokenNameCOMMENT_LINE	 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
radiusY	TokenNameIdentifier	 radius Y
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<=	TokenNameLESS_EQUAL	
h	TokenNameIdentifier	 h
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
-	TokenNameMINUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
lastPixel	TokenNameIdentifier	 last Pixel
=	TokenNameEQUAL	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
cp	TokenNameIdentifier	 cp
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
cp	TokenNameIdentifier	 cp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
>>>	TokenNameUNSIGNED_RIGHT_SHIFT	
24	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff0000	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff00	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
lastPixel	TokenNameIdentifier	 last Pixel
&	TokenNameAND	
0xff	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
bufferHead	TokenNameIdentifier	 buffer Head
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
// here we check if the previous max/min value can be 	TokenNameCOMMENT_LINE	here we check if the previous max/min value can be 
// reused safely and, if possible, reuse the previous 	TokenNameCOMMENT_LINE	reused safely and, if possible, reuse the previous 
// maximum value 	TokenNameCOMMENT_LINE	maximum value 
// Alpha channel: 	TokenNameCOMMENT_LINE	Alpha channel: 
// Recompute the local max/min 	TokenNameCOMMENT_LINE	Recompute the local max/min 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
maxIndexA	TokenNameIdentifier	 max Index A
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Red channel: 	TokenNameCOMMENT_LINE	Red channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
maxIndexR	TokenNameIdentifier	 max Index R
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Green channel 	TokenNameCOMMENT_LINE	Green channel 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
maxIndexG	TokenNameIdentifier	 max Index G
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Blue channel: 	TokenNameCOMMENT_LINE	Blue channel: 
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<=	TokenNameLESS_EQUAL	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
m	TokenNameIdentifier	 m
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
m	TokenNameIdentifier	 m
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// we can reuse the previous max/min value 	TokenNameCOMMENT_LINE	we can reuse the previous max/min value 
else	TokenNameelse	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
maxIndexB	TokenNameIdentifier	 max Index B
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// h-radiusY <= i <= h-1 : The lower margin of the column 	TokenNameCOMMENT_LINE	h-radiusY <= i <= h-1 : The lower margin of the column 
// 	TokenNameCOMMENT_LINE	 
// head will be updated to indicate the current head 	TokenNameCOMMENT_LINE	head will be updated to indicate the current head 
// of the remaining buffer: 	TokenNameCOMMENT_LINE	of the remaining buffer: 
int	TokenNameint	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
// tail is where the last element in the buffer is 	TokenNameCOMMENT_LINE	tail is where the last element in the buffer is 
final	TokenNamefinal	
int	TokenNameint	
tail	TokenNameIdentifier	 tail
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
2	TokenNameIntegerLiteral	
*	TokenNameMULTIPLY	
radiusY	TokenNameIdentifier	 radius Y
:	TokenNameCOLON	
bufferHead	TokenNameIdentifier	 buffer Head
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
rangeY	TokenNameIdentifier	 range Y
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
h	TokenNameIdentifier	 h
-	TokenNameMINUS	
radiusY	TokenNameIdentifier	 radius Y
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
h	TokenNameIdentifier	 h
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
head	TokenNameIdentifier	 head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexA	TokenNameIdentifier	 max Index A
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a1	TokenNameIdentifier	 a1
=	TokenNameEQUAL	
bufferA	TokenNameIdentifier	 buffer A
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
a1	TokenNameIdentifier	 a1
,	TokenNameCOMMA	
a	TokenNameIdentifier	 a
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
a	TokenNameIdentifier	 a
=	TokenNameEQUAL	
a1	TokenNameIdentifier	 a1
;	TokenNameSEMICOLON	
maxIndexA	TokenNameIdentifier	 max Index A
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexR	TokenNameIdentifier	 max Index R
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r1	TokenNameIdentifier	 r1
=	TokenNameEQUAL	
bufferR	TokenNameIdentifier	 buffer R
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
r1	TokenNameIdentifier	 r1
,	TokenNameCOMMA	
r	TokenNameIdentifier	 r
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
r	TokenNameIdentifier	 r
=	TokenNameEQUAL	
r1	TokenNameIdentifier	 r1
;	TokenNameSEMICOLON	
maxIndexR	TokenNameIdentifier	 max Index R
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexG	TokenNameIdentifier	 max Index G
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g1	TokenNameIdentifier	 g1
=	TokenNameEQUAL	
bufferG	TokenNameIdentifier	 buffer G
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
g1	TokenNameIdentifier	 g1
,	TokenNameCOMMA	
g	TokenNameIdentifier	 g
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
g	TokenNameIdentifier	 g
=	TokenNameEQUAL	
g1	TokenNameIdentifier	 g1
;	TokenNameSEMICOLON	
maxIndexG	TokenNameIdentifier	 max Index G
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
maxIndexB	TokenNameIdentifier	 max Index B
==	TokenNameEQUAL_EQUAL	
bufferHead	TokenNameIdentifier	 buffer Head
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
tail	TokenNameIdentifier	 tail
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
head	TokenNameIdentifier	 head
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
m	TokenNameIdentifier	 m
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
m	TokenNameIdentifier	 m
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b1	TokenNameIdentifier	 b1
=	TokenNameEQUAL	
bufferB	TokenNameIdentifier	 buffer B
[	TokenNameLBRACKET	
hd	TokenNameIdentifier	 hd
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
isBetter	TokenNameIdentifier	 is Better
(	TokenNameLPAREN	
b1	TokenNameIdentifier	 b1
,	TokenNameCOMMA	
b	TokenNameIdentifier	 b
,	TokenNameCOMMA	
doDilation	TokenNameIdentifier	 do Dilation
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
b	TokenNameIdentifier	 b
=	TokenNameEQUAL	
b1	TokenNameIdentifier	 b1
;	TokenNameSEMICOLON	
maxIndexB	TokenNameIdentifier	 max Index B
=	TokenNameEQUAL	
hd	TokenNameIdentifier	 hd
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
hd	TokenNameIdentifier	 hd
=	TokenNameEQUAL	
(	TokenNameLPAREN	
hd	TokenNameIdentifier	 hd
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
destPixels	TokenNameIdentifier	 dest Pixels
[	TokenNameLBRACKET	
dp	TokenNameIdentifier	 dp
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
a	TokenNameIdentifier	 a
<<	TokenNameLEFT_SHIFT	
24	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
|	TokenNameOR	
r	TokenNameIdentifier	 r
|	TokenNameOR	
g	TokenNameIdentifier	 g
|	TokenNameOR	
b	TokenNameIdentifier	 b
;	TokenNameSEMICOLON	
dp	TokenNameIdentifier	 dp
+=	TokenNamePLUS_EQUAL	
dstScanStride	TokenNameIdentifier	 dst Scan Stride
;	TokenNameSEMICOLON	
bufferHead	TokenNameIdentifier	 buffer Head
=	TokenNameEQUAL	
(	TokenNameLPAREN	
bufferHead	TokenNameIdentifier	 buffer Head
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
%	TokenNameREMAINDER	
rangeY	TokenNameIdentifier	 range Y
;	TokenNameSEMICOLON	
// we throw out this useless element 	TokenNameCOMMENT_LINE	we throw out this useless element 
count	TokenNameIdentifier	 count
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// return to the beginning of the next column 	TokenNameCOMMENT_LINE	return to the beginning of the next column 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end of the second round! 	TokenNameCOMMENT_LINE	end of the second round! 
return	TokenNamereturn	
dest	TokenNameIdentifier	 dest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end of the filter() method for Raster 	TokenNameCOMMENT_LINE	end of the filter() method for Raster 
/** * This implementation of filter does the morphology operation * on a premultiplied alpha image. This tends to muddy the * colors. so something that is supposed to be a mostly * transparent bright red may well become a muddy opaque red. * Where as I think it should become a bright opaque red. Which * is the result you would get if you were using unpremult data. */	TokenNameCOMMENT_JAVADOC	 This implementation of filter does the morphology operation on a premultiplied alpha image. This tends to muddy the colors. so something that is supposed to be a mostly transparent bright red may well become a muddy opaque red. Where as I think it should become a bright opaque red. Which is the result you would get if you were using unpremult data. 
public	TokenNamepublic	
BufferedImage	TokenNameIdentifier	 Buffered Image
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
BufferedImage	TokenNameIdentifier	 Buffered Image
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
BufferedImage	TokenNameIdentifier	 Buffered Image
dest	TokenNameIdentifier	 dest
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
throw	TokenNamethrow	
new	TokenNamenew	
NullPointerException	TokenNameIdentifier	 Null Pointer Exception
(	TokenNameLPAREN	
"Source image should not be null"	TokenNameStringLiteral	Source image should not be null
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
BufferedImage	TokenNameIdentifier	 Buffered Image
origSrc	TokenNameIdentifier	 orig Src
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
;	TokenNameSEMICOLON	
BufferedImage	TokenNameIdentifier	 Buffered Image
finalDest	TokenNameIdentifier	 final Dest
=	TokenNameEQUAL	
dest	TokenNameIdentifier	 dest
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isCompatible	TokenNameIdentifier	 is Compatible
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedImage	TokenNameIdentifier	 Buffered Image
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getWidth	TokenNameIdentifier	 get Width
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getHeight	TokenNameIdentifier	 get Height
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
BufferedImage	TokenNameIdentifier	 Buffered Image
.	TokenNameDOT	
TYPE_INT_ARGB_PRE	TokenNameIdentifier	 TYPE  INT  ARGB  PRE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
copyData	TokenNameIdentifier	 copy Data
(	TokenNameLPAREN	
origSrc	TokenNameIdentifier	 orig Src
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get a Premultipled CM. 	TokenNameCOMMENT_LINE	Get a Premultipled CM. 
ColorModel	TokenNameIdentifier	 Color Model
srcCM	TokenNameIdentifier	 src CM
,	TokenNameCOMMA	
srcCMPre	TokenNameIdentifier	 src CM Pre
;	TokenNameSEMICOLON	
srcCM	TokenNameIdentifier	 src CM
=	TokenNameEQUAL	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
srcCMPre	TokenNameIdentifier	 src CM Pre
=	TokenNameEQUAL	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
coerceColorModel	TokenNameIdentifier	 coerce Color Model
(	TokenNameLPAREN	
srcCM	TokenNameIdentifier	 src CM
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
src	TokenNameIdentifier	 src
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedImage	TokenNameIdentifier	 Buffered Image
(	TokenNameLPAREN	
srcCMPre	TokenNameIdentifier	 src CM Pre
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
copyData	TokenNameIdentifier	 copy Data
(	TokenNameLPAREN	
origSrc	TokenNameIdentifier	 orig Src
,	TokenNameCOMMA	
src	TokenNameIdentifier	 src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
createCompatibleDestImage	TokenNameIdentifier	 create Compatible Dest Image
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
finalDest	TokenNameIdentifier	 final Dest
=	TokenNameEQUAL	
dest	TokenNameIdentifier	 dest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isCompatible	TokenNameIdentifier	 is Compatible
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getSampleModel	TokenNameIdentifier	 get Sample Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
createCompatibleDestImage	TokenNameIdentifier	 create Compatible Dest Image
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Get a Premultipled CM. 	TokenNameCOMMENT_LINE	Get a Premultipled CM. 
ColorModel	TokenNameIdentifier	 Color Model
dstCM	TokenNameIdentifier	 dst CM
,	TokenNameCOMMA	
dstCMPre	TokenNameIdentifier	 dst CM Pre
;	TokenNameSEMICOLON	
dstCM	TokenNameIdentifier	 dst CM
=	TokenNameEQUAL	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getColorModel	TokenNameIdentifier	 get Color Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dstCMPre	TokenNameIdentifier	 dst CM Pre
=	TokenNameEQUAL	
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
coerceColorModel	TokenNameIdentifier	 coerce Color Model
(	TokenNameLPAREN	
dstCM	TokenNameIdentifier	 dst CM
,	TokenNameCOMMA	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
dest	TokenNameIdentifier	 dest
=	TokenNameEQUAL	
new	TokenNamenew	
BufferedImage	TokenNameIdentifier	 Buffered Image
(	TokenNameLPAREN	
dstCMPre	TokenNameIdentifier	 dst CM Pre
,	TokenNameCOMMA	
finalDest	TokenNameIdentifier	 final Dest
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
filter	TokenNameIdentifier	 filter
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Check to see if we need to 'fix' our source (divide out alpha). 	TokenNameCOMMENT_LINE	Check to see if we need to 'fix' our source (divide out alpha). 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
origSrc	TokenNameIdentifier	 orig Src
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
origSrc	TokenNameIdentifier	 orig Src
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Copy our source back the way it was... 	TokenNameCOMMENT_LINE	Copy our source back the way it was... 
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
copyData	TokenNameIdentifier	 copy Data
(	TokenNameLPAREN	
src	TokenNameIdentifier	 src
,	TokenNameCOMMA	
origSrc	TokenNameIdentifier	 orig Src
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check to see if we need to store our result... 	TokenNameCOMMENT_LINE	Check to see if we need to store our result... 
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
finalDest	TokenNameIdentifier	 final Dest
.	TokenNameDOT	
getRaster	TokenNameIdentifier	 get Raster
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
finalDest	TokenNameIdentifier	 final Dest
.	TokenNameDOT	
isAlphaPremultiplied	TokenNameIdentifier	 is Alpha Premultiplied
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Coerce our source back the way it was requested... 	TokenNameCOMMENT_LINE	Coerce our source back the way it was requested... 
GraphicsUtil	TokenNameIdentifier	 Graphics Util
.	TokenNameDOT	
copyData	TokenNameIdentifier	 copy Data
(	TokenNameLPAREN	
dest	TokenNameIdentifier	 dest
,	TokenNameCOMMA	
finalDest	TokenNameIdentifier	 final Dest
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
finalDest	TokenNameIdentifier	 final Dest
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/* * This commented out implementation of filter does the * morphology operation on unpremultiplied alpha image data. * This tends to leave colors bright. */	TokenNameCOMMENT_BLOCK	 This commented out implementation of filter does the morphology operation on unpremultiplied alpha image data. This tends to leave colors bright. 
/* public BufferedImage filter(BufferedImage src, BufferedImage dest){ if (src == null && dest == null) throw new NullPointerException("Source image should not be null"); BufferedImage origSrc = src; BufferedImage finalDest = dest; if (!isCompatible(src.getColorModel(), src.getSampleModel())) { src = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); GraphicsUtil.copyData(origSrc, src); } else if (src.isAlphaPremultiplied()) { ColorModel srcCM, srcCMUnpre; srcCM = src.getColorModel(); srcCMUnpre = GraphicsUtil.coerceColorModel(srcCM, false); src = new BufferedImage(srcCMUnpre, src.getRaster(), false, null); GraphicsUtil.copyData(origSrc, src); } if (dest == null) { dest = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); finalDest = dest; } else if (!isCompatible(dest.getColorModel(), dest.getSampleModel())) { dest = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); } else if (dest.isAlphaPremultiplied()) { ColorModel dstCM, dstCMUnpre; dstCM = dest.getColorModel(); dstCMUnpre = GraphicsUtil.coerceColorModel(dstCM, false); dest = new BufferedImage(dstCMUnpre, finalDest.getRaster(), false, null); } // We now have two compatible images. We can safely filter the rasters filter(src.getRaster(), dest.getRaster()); // Check to see if we need to 'fix' our source (divide out alpha). if ((src.getRaster() == origSrc.getRaster()) && (src.isAlphaPremultiplied() != origSrc.isAlphaPremultiplied())) { GraphicsUtil.copyData(src, origSrc); } // Check to see if we need to store our result... if ((dest.getRaster() != finalDest.getRaster()) || (dest.isAlphaPremultiplied() != finalDest.isAlphaPremultiplied())){ // Coerce our source back the way it was... System.out.println("Dest: " + dest.isAlphaPremultiplied() + " finalDest: " + finalDest.isAlphaPremultiplied()); GraphicsUtil.copyData(dest, finalDest); } return finalDest; } */	TokenNameCOMMENT_BLOCK	 public BufferedImage filter(BufferedImage src, BufferedImage dest){ if (src == null && dest == null) throw new NullPointerException("Source image should not be null"); BufferedImage origSrc = src; BufferedImage finalDest = dest; if (!isCompatible(src.getColorModel(), src.getSampleModel())) { src = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); GraphicsUtil.copyData(origSrc, src); } else if (src.isAlphaPremultiplied()) { ColorModel srcCM, srcCMUnpre; srcCM = src.getColorModel(); srcCMUnpre = GraphicsUtil.coerceColorModel(srcCM, false); src = new BufferedImage(srcCMUnpre, src.getRaster(), false, null); GraphicsUtil.copyData(origSrc, src); } if (dest == null) { dest = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); finalDest = dest; } else if (!isCompatible(dest.getColorModel(), dest.getSampleModel())) { dest = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_ARGB); } else if (dest.isAlphaPremultiplied()) { ColorModel dstCM, dstCMUnpre; dstCM = dest.getColorModel(); dstCMUnpre = GraphicsUtil.coerceColorModel(dstCM, false); dest = new BufferedImage(dstCMUnpre, finalDest.getRaster(), false, null); } // We now have two compatible images. We can safely filter the rasters filter(src.getRaster(), dest.getRaster()); // Check to see if we need to 'fix' our source (divide out alpha). if ((src.getRaster() == origSrc.getRaster()) && (src.isAlphaPremultiplied() != origSrc.isAlphaPremultiplied())) { GraphicsUtil.copyData(src, origSrc); } // Check to see if we need to store our result... if ((dest.getRaster() != finalDest.getRaster()) || (dest.isAlphaPremultiplied() != finalDest.isAlphaPremultiplied())){ // Coerce our source back the way it was... System.out.println("Dest: " + dest.isAlphaPremultiplied() + " finalDest: " + finalDest.isAlphaPremultiplied()); GraphicsUtil.copyData(dest, finalDest); } return finalDest; } 
}	TokenNameRBRACE	
