/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */	TokenNameCOMMENT_BLOCK	 Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 
package	TokenNamepackage	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
io	TokenNameIdentifier	 io
.	TokenNameDOT	
IOException	TokenNameIdentifier	 IO Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
ArrayList	TokenNameIdentifier	 Array List
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
HashMap	TokenNameIdentifier	 Hash Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Hashtable	TokenNameIdentifier	 Hashtable
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Iterator	TokenNameIdentifier	 Iterator
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Map	TokenNameIdentifier	 Map
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Stack	TokenNameIdentifier	 Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
java	TokenNameIdentifier	 java
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
Vector	TokenNameIdentifier	 Vector
;	TokenNameSEMICOLON	
import	TokenNameimport	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
XMLConstants	TokenNameIdentifier	 XML Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
Constants	TokenNameIdentifier	 Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
RevalidationHandler	TokenNameIdentifier	 Revalidation Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
DatatypeException	TokenNameIdentifier	 Datatype Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
ConfigurableValidationState	TokenNameIdentifier	 Configurable Validation State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
ValidationManager	TokenNameIdentifier	 Validation Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
validation	TokenNameIdentifier	 validation
.	TokenNameDOT	
ValidationState	TokenNameIdentifier	 Validation State
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
Field	TokenNameIdentifier	 Field
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
FieldActivator	TokenNameIdentifier	 Field Activator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
KeyRef	TokenNameIdentifier	 Key Ref
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
Selector	TokenNameIdentifier	 Selector
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
ValueStore	TokenNameIdentifier	 Value Store
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
identity	TokenNameIdentifier	 identity
.	TokenNameDOT	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMBuilder	TokenNameIdentifier	 CM Builder
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
CMNodeFactory	TokenNameIdentifier	 CM Node Factory
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
impl	TokenNameIdentifier	 impl
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
models	TokenNameIdentifier	 models
.	TokenNameDOT	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
IntStack	TokenNameIdentifier	 Int Stack
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
SymbolTable	TokenNameIdentifier	 Symbol Table
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLChar	TokenNameIdentifier	 XML Char
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
XMLSymbols	TokenNameIdentifier	 XML Symbols
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
util	TokenNameIdentifier	 util
.	TokenNameDOT	
URI	TokenNameIdentifier	 URI
.	TokenNameDOT	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
Augmentations	TokenNameIdentifier	 Augmentations
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
NamespaceContext	TokenNameIdentifier	 Namespace Context
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLAttributes	TokenNameIdentifier	 XML Attributes
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLLocator	TokenNameIdentifier	 XML Locator
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XMLString	TokenNameIdentifier	 XML String
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
XNIException	TokenNameIdentifier	 XNI Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponent	TokenNameIdentifier	 XML Component
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xni	TokenNameIdentifier	 xni
.	TokenNameDOT	
parser	TokenNameIdentifier	 parser
.	TokenNameDOT	
XMLInputSource	TokenNameIdentifier	 XML Input Source
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
ElementPSVI	TokenNameIdentifier	 Element PSVI
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
ShortList	TokenNameIdentifier	 Short List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
StringList	TokenNameIdentifier	 String List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSConstants	TokenNameIdentifier	 XS Constants
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSObjectList	TokenNameIdentifier	 XS Object List
;	TokenNameSEMICOLON	
import	TokenNameimport	
org	TokenNameIdentifier	 org
.	TokenNameDOT	
apache	TokenNameIdentifier	 apache
.	TokenNameDOT	
xerces	TokenNameIdentifier	 xerces
.	TokenNameDOT	
xs	TokenNameIdentifier	 xs
.	TokenNameDOT	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
;	TokenNameSEMICOLON	
/** * The XML Schema validator. The validator implements a document * filter: receiving document events from the scanner; validating * the content and structure; augmenting the InfoSet, if applicable; * and notifying the parser of the information resulting from the * validation process. * <p> * This component requires the following features and properties from the * component manager that uses it: * <ul> * <li>http://xml.org/sax/features/validation</li> * <li>http://apache.org/xml/properties/internal/symbol-table</li> * <li>http://apache.org/xml/properties/internal/error-reporter</li> * <li>http://apache.org/xml/properties/internal/entity-resolver</li> * </ul> * * @xerces.internal * * @author Sandy Gao IBM * @author Elena Litani IBM * @author Andy Clark IBM * @author Neeraj Bajaj, Sun Microsystems, inc. * @version $Id: XMLSchemaValidator.java 1024038 2010-10-18 22:06:35Z sandygao $ */	TokenNameCOMMENT_JAVADOC	 The XML Schema validator. The validator implements a document filter: receiving document events from the scanner; validating the content and structure; augmenting the InfoSet, if applicable; and notifying the parser of the information resulting from the validation process. <p> This component requires the following features and properties from the component manager that uses it: <ul> <li>http://xml.org/sax/features/validation</li> <li>http://apache.org/xml/properties/internal/symbol-table</li> <li>http://apache.org/xml/properties/internal/error-reporter</li> <li>http://apache.org/xml/properties/internal/entity-resolver</li> </ul> * @xerces.internal * @author Sandy Gao IBM @author Elena Litani IBM @author Andy Clark IBM @author Neeraj Bajaj, Sun Microsystems, inc. @version $Id: XMLSchemaValidator.java 1024038 2010-10-18 22:06:35Z sandygao $ 
public	TokenNamepublic	
class	TokenNameclass	
XMLSchemaValidator	TokenNameIdentifier	 XML Schema Validator
implements	TokenNameimplements	
XMLComponent	TokenNameIdentifier	 XML Component
,	TokenNameCOMMA	
XMLDocumentFilter	TokenNameIdentifier	 XML Document Filter
,	TokenNameCOMMA	
FieldActivator	TokenNameIdentifier	 Field Activator
,	TokenNameCOMMA	
RevalidationHandler	TokenNameIdentifier	 Revalidation Handler
,	TokenNameCOMMA	
XSElementDeclHelper	TokenNameIdentifier	 XS Element Decl Helper
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constants 	TokenNameCOMMENT_LINE	Constants 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG	TokenNameIdentifier	 DEBUG
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// feature identifiers 	TokenNameCOMMENT_LINE	feature identifiers 
/** Feature identifier: validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION	TokenNameIdentifier	 VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SAX_FEATURE_PREFIX	TokenNameIdentifier	 SAX  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_FEATURE	TokenNameIdentifier	 VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_VALIDATION_FEATURE	TokenNameIdentifier	 SCHEMA  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: schema full checking*/	TokenNameCOMMENT_JAVADOC	 Feature identifier: schema full checking
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_FULL_CHECKING	TokenNameIdentifier	 SCHEMA  FULL  CHECKING
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_FULL_CHECKING	TokenNameIdentifier	 SCHEMA  FULL  CHECKING
;	TokenNameSEMICOLON	
/** Feature identifier: dynamic validation. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: dynamic validation. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
DYNAMIC_VALIDATION_FEATURE	TokenNameIdentifier	 DYNAMIC  VALIDATION  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: expose schema normalized value */	TokenNameCOMMENT_JAVADOC	 Feature identifier: expose schema normalized value 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NORMALIZE_DATA	TokenNameIdentifier	 NORMALIZE  DATA
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_NORMALIZED_VALUE	TokenNameIdentifier	 SCHEMA  NORMALIZED  VALUE
;	TokenNameSEMICOLON	
/** Feature identifier: send element default value via characters() */	TokenNameCOMMENT_JAVADOC	 Feature identifier: send element default value via characters() 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_ELEMENT_DEFAULT	TokenNameIdentifier	 SCHEMA  ELEMENT  DEFAULT
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_ELEMENT_DEFAULT	TokenNameIdentifier	 SCHEMA  ELEMENT  DEFAULT
;	TokenNameSEMICOLON	
/** Feature identifier: augment PSVI */	TokenNameCOMMENT_JAVADOC	 Feature identifier: augment PSVI 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_AUGMENT_PSVI	TokenNameIdentifier	 SCHEMA  AUGMENT  PSVI
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_AUGMENT_PSVI	TokenNameIdentifier	 SCHEMA  AUGMENT  PSVI
;	TokenNameSEMICOLON	
/** Feature identifier: whether to recognize java encoding names */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to recognize java encoding names 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ALLOW_JAVA_ENCODINGS	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ALLOW_JAVA_ENCODINGS_FEATURE	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: standard uri conformant feature. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: standard uri conformant feature. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
;	TokenNameSEMICOLON	
/** Feature: generate synthetic annotations */	TokenNameCOMMENT_JAVADOC	 Feature: generate synthetic annotations 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
GENERATE_SYNTHETIC_ANNOTATIONS	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: validate annotations. */	TokenNameCOMMENT_JAVADOC	 Feature identifier: validate annotations. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATE_ANNOTATIONS	TokenNameIdentifier	 VALIDATE  ANNOTATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATE_ANNOTATIONS_FEATURE	TokenNameIdentifier	 VALIDATE  ANNOTATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: honour all schemaLocations */	TokenNameCOMMENT_JAVADOC	 Feature identifier: honour all schemaLocations 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
HONOUR_ALL_SCHEMALOCATIONS	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
HONOUR_ALL_SCHEMALOCATIONS_FEATURE	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: use grammar pool only */	TokenNameCOMMENT_JAVADOC	 Feature identifier: use grammar pool only 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
USE_GRAMMAR_POOL_ONLY	TokenNameIdentifier	 USE  GRAMMAR  POOL  ONLY
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
USE_GRAMMAR_POOL_ONLY_FEATURE	TokenNameIdentifier	 USE  GRAMMAR  POOL  ONLY  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: whether to continue parsing a schema after a fatal error is encountered */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to continue parsing a schema after a fatal error is encountered 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
CONTINUE_AFTER_FATAL_ERROR	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
CONTINUE_AFTER_FATAL_ERROR_FEATURE	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR  FEATURE
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
;	TokenNameSEMICOLON	
/** Feature identifier: namespace growth */	TokenNameCOMMENT_JAVADOC	 Feature identifier: namespace growth 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
NAMESPACE_GROWTH	TokenNameIdentifier	 NAMESPACE  GROWTH
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
NAMESPACE_GROWTH_FEATURE	TokenNameIdentifier	 NAMESPACE  GROWTH  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: tolerate duplicates */	TokenNameCOMMENT_JAVADOC	 Feature identifier: tolerate duplicates 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
TOLERATE_DUPLICATES	TokenNameIdentifier	 TOLERATE  DUPLICATES
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
TOLERATE_DUPLICATES_FEATURE	TokenNameIdentifier	 TOLERATE  DUPLICATES  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: whether to ignore xsi:type attributes until a global element declaration is encountered */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to ignore xsi:type attributes until a global element declaration is encountered 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
IGNORE_XSI_TYPE	TokenNameIdentifier	 IGNORE  XSI  TYPE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
IGNORE_XSI_TYPE_FEATURE	TokenNameIdentifier	 IGNORE  XSI  TYPE  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: whether to ignore ID/IDREF errors */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to ignore ID/IDREF errors 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ID_IDREF_CHECKING	TokenNameIdentifier	 ID  IDREF  CHECKING
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ID_IDREF_CHECKING_FEATURE	TokenNameIdentifier	 ID  IDREF  CHECKING  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: whether to ignore unparsed entity errors */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to ignore unparsed entity errors 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
UNPARSED_ENTITY_CHECKING	TokenNameIdentifier	 UNPARSED  ENTITY  CHECKING
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
UNPARSED_ENTITY_CHECKING_FEATURE	TokenNameIdentifier	 UNPARSED  ENTITY  CHECKING  FEATURE
;	TokenNameSEMICOLON	
/** Feature identifier: whether to ignore identity constraint errors */	TokenNameCOMMENT_JAVADOC	 Feature identifier: whether to ignore identity constraint errors 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
IDENTITY_CONSTRAINT_CHECKING	TokenNameIdentifier	 IDENTITY  CONSTRAINT  CHECKING
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_FEATURE_PREFIX	TokenNameIdentifier	 XERCES  FEATURE  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
IDC_CHECKING_FEATURE	TokenNameIdentifier	 IDC  CHECKING  FEATURE
;	TokenNameSEMICOLON	
// property identifiers 	TokenNameCOMMENT_LINE	property identifiers 
/** Property identifier: symbol table. */	TokenNameCOMMENT_JAVADOC	 Property identifier: symbol table. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SYMBOL_TABLE_PROPERTY	TokenNameIdentifier	 SYMBOL  TABLE  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: error reporter. */	TokenNameCOMMENT_JAVADOC	 Property identifier: error reporter. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ERROR_REPORTER_PROPERTY	TokenNameIdentifier	 ERROR  REPORTER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: entity resolver. */	TokenNameCOMMENT_JAVADOC	 Property identifier: entity resolver. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_RESOLVER_PROPERTY	TokenNameIdentifier	 ENTITY  RESOLVER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: grammar pool. */	TokenNameCOMMENT_JAVADOC	 Property identifier: grammar pool. 
public	TokenNamepublic	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
XMLGRAMMAR_POOL	TokenNameIdentifier	 XMLGRAMMAR  POOL
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XMLGRAMMAR_POOL_PROPERTY	TokenNameIdentifier	 XMLGRAMMAR  POOL  PROPERTY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
VALIDATION_MANAGER_PROPERTY	TokenNameIdentifier	 VALIDATION  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ENTITY_MANAGER	TokenNameIdentifier	 ENTITY  MANAGER
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ENTITY_MANAGER_PROPERTY	TokenNameIdentifier	 ENTITY  MANAGER  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: schema location. */	TokenNameCOMMENT_JAVADOC	 Property identifier: schema location. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_LOCATION	TokenNameIdentifier	 SCHEMA  LOCATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_LOCATION	TokenNameIdentifier	 SCHEMA  LOCATION
;	TokenNameSEMICOLON	
/** Property identifier: no namespace schema location. */	TokenNameCOMMENT_JAVADOC	 Property identifier: no namespace schema location. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_NONS_LOCATION	TokenNameIdentifier	 SCHEMA  NONS  LOCATION
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_NONS_LOCATION	TokenNameIdentifier	 SCHEMA  NONS  LOCATION
;	TokenNameSEMICOLON	
/** Property identifier: JAXP schema source. */	TokenNameCOMMENT_JAVADOC	 Property identifier: JAXP schema source. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
JAXP_SCHEMA_SOURCE	TokenNameIdentifier	 JAXP  SCHEMA  SOURCE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_SOURCE	TokenNameIdentifier	 SCHEMA  SOURCE
;	TokenNameSEMICOLON	
/** Property identifier: JAXP schema language. */	TokenNameCOMMENT_JAVADOC	 Property identifier: JAXP schema language. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
JAXP_SCHEMA_LANGUAGE	TokenNameIdentifier	 JAXP  SCHEMA  LANGUAGE
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_LANGUAGE	TokenNameIdentifier	 SCHEMA  LANGUAGE
;	TokenNameSEMICOLON	
/** Property identifier: root type definition. */	TokenNameCOMMENT_JAVADOC	 Property identifier: root type definition. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ROOT_TYPE_DEF	TokenNameIdentifier	 ROOT  TYPE  DEF
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ROOT_TYPE_DEFINITION_PROPERTY	TokenNameIdentifier	 ROOT  TYPE  DEFINITION  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: root element declaration. */	TokenNameCOMMENT_JAVADOC	 Property identifier: root element declaration. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
ROOT_ELEMENT_DECL	TokenNameIdentifier	 ROOT  ELEMENT  DECL
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ROOT_ELEMENT_DECLARATION_PROPERTY	TokenNameIdentifier	 ROOT  ELEMENT  DECLARATION  PROPERTY
;	TokenNameSEMICOLON	
/** Property identifier: Schema DV Factory */	TokenNameCOMMENT_JAVADOC	 Property identifier: Schema DV Factory 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
SCHEMA_DV_FACTORY	TokenNameIdentifier	 SCHEMA  DV  FACTORY
=	TokenNameEQUAL	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
XERCES_PROPERTY_PREFIX	TokenNameIdentifier	 XERCES  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_DV_FACTORY_PROPERTY	TokenNameIdentifier	 SCHEMA  DV  FACTORY  PROPERTY
;	TokenNameSEMICOLON	
// recognized features and properties 	TokenNameCOMMENT_LINE	recognized features and properties 
/** Recognized features. */	TokenNameCOMMENT_JAVADOC	 Recognized features. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
VALIDATION	TokenNameIdentifier	 VALIDATION
,	TokenNameCOMMA	
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
,	TokenNameCOMMA	
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
,	TokenNameCOMMA	
SCHEMA_FULL_CHECKING	TokenNameIdentifier	 SCHEMA  FULL  CHECKING
,	TokenNameCOMMA	
ALLOW_JAVA_ENCODINGS	TokenNameIdentifier	 ALLOW  JAVA  ENCODINGS
,	TokenNameCOMMA	
CONTINUE_AFTER_FATAL_ERROR	TokenNameIdentifier	 CONTINUE  AFTER  FATAL  ERROR
,	TokenNameCOMMA	
STANDARD_URI_CONFORMANT_FEATURE	TokenNameIdentifier	 STANDARD  URI  CONFORMANT  FEATURE
,	TokenNameCOMMA	
GENERATE_SYNTHETIC_ANNOTATIONS	TokenNameIdentifier	 GENERATE  SYNTHETIC  ANNOTATIONS
,	TokenNameCOMMA	
VALIDATE_ANNOTATIONS	TokenNameIdentifier	 VALIDATE  ANNOTATIONS
,	TokenNameCOMMA	
HONOUR_ALL_SCHEMALOCATIONS	TokenNameIdentifier	 HONOUR  ALL  SCHEMALOCATIONS
,	TokenNameCOMMA	
USE_GRAMMAR_POOL_ONLY	TokenNameIdentifier	 USE  GRAMMAR  POOL  ONLY
,	TokenNameCOMMA	
IGNORE_XSI_TYPE	TokenNameIdentifier	 IGNORE  XSI  TYPE
,	TokenNameCOMMA	
ID_IDREF_CHECKING	TokenNameIdentifier	 ID  IDREF  CHECKING
,	TokenNameCOMMA	
IDENTITY_CONSTRAINT_CHECKING	TokenNameIdentifier	 IDENTITY  CONSTRAINT  CHECKING
,	TokenNameCOMMA	
UNPARSED_ENTITY_CHECKING	TokenNameIdentifier	 UNPARSED  ENTITY  CHECKING
,	TokenNameCOMMA	
NAMESPACE_GROWTH	TokenNameIdentifier	 NAMESPACE  GROWTH
,	TokenNameCOMMA	
TOLERATE_DUPLICATES	TokenNameIdentifier	 TOLERATE  DUPLICATES
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Feature defaults. */	TokenNameCOMMENT_JAVADOC	 Feature defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Boolean	TokenNameIdentifier	 Boolean
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
// NOTE: The following defaults are nulled out on purpose. 	TokenNameCOMMENT_LINE	NOTE: The following defaults are nulled out on purpose. 
// If they are set, then when the XML Schema validator 	TokenNameCOMMENT_LINE	If they are set, then when the XML Schema validator 
// is constructed dynamically, these values may override 	TokenNameCOMMENT_LINE	is constructed dynamically, these values may override 
// those set by the application. This goes against the 	TokenNameCOMMENT_LINE	those set by the application. This goes against the 
// whole purpose of XMLComponent#getFeatureDefault but 	TokenNameCOMMENT_LINE	whole purpose of XMLComponent#getFeatureDefault but 
// it can't be helped in this case. -Ac 	TokenNameCOMMENT_LINE	it can't be helped in this case. -Ac 
// NOTE: Instead of adding default values here, add them (and 	TokenNameCOMMENT_LINE	NOTE: Instead of adding default values here, add them (and 
// the corresponding recognized features) to the objects 	TokenNameCOMMENT_LINE	the corresponding recognized features) to the objects 
// that have an XMLSchemaValidator instance as a member, 	TokenNameCOMMENT_LINE	that have an XMLSchemaValidator instance as a member, 
// such as the parser configurations. -PM 	TokenNameCOMMENT_LINE	such as the parser configurations. -PM 
null	TokenNamenull	
,	TokenNameCOMMA	
//Boolean.FALSE, 	TokenNameCOMMENT_LINE	Boolean.FALSE, 
null	TokenNamenull	
,	TokenNameCOMMA	
//Boolean.FALSE, 	TokenNameCOMMENT_LINE	Boolean.FALSE, 
null	TokenNamenull	
,	TokenNameCOMMA	
//Boolean.FALSE, 	TokenNameCOMMENT_LINE	Boolean.FALSE, 
null	TokenNamenull	
,	TokenNameCOMMA	
//Boolean.FALSE, 	TokenNameCOMMENT_LINE	Boolean.FALSE, 
null	TokenNamenull	
,	TokenNameCOMMA	
//Boolean.FALSE, 	TokenNameCOMMENT_LINE	Boolean.FALSE, 
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Recognized properties. */	TokenNameCOMMENT_JAVADOC	 Recognized properties. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
=	TokenNameEQUAL	
{	TokenNameLBRACE	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
,	TokenNameCOMMA	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
,	TokenNameCOMMA	
ENTITY_RESOLVER	TokenNameIdentifier	 ENTITY  RESOLVER
,	TokenNameCOMMA	
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
,	TokenNameCOMMA	
SCHEMA_LOCATION	TokenNameIdentifier	 SCHEMA  LOCATION
,	TokenNameCOMMA	
SCHEMA_NONS_LOCATION	TokenNameIdentifier	 SCHEMA  NONS  LOCATION
,	TokenNameCOMMA	
JAXP_SCHEMA_SOURCE	TokenNameIdentifier	 JAXP  SCHEMA  SOURCE
,	TokenNameCOMMA	
JAXP_SCHEMA_LANGUAGE	TokenNameIdentifier	 JAXP  SCHEMA  LANGUAGE
,	TokenNameCOMMA	
ROOT_TYPE_DEF	TokenNameIdentifier	 ROOT  TYPE  DEF
,	TokenNameCOMMA	
ROOT_ELEMENT_DECL	TokenNameIdentifier	 ROOT  ELEMENT  DECL
,	TokenNameCOMMA	
SCHEMA_DV_FACTORY	TokenNameIdentifier	 SCHEMA  DV  FACTORY
,	TokenNameCOMMA	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
/** Property defaults. */	TokenNameCOMMENT_JAVADOC	 Property defaults. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
=	TokenNameEQUAL	
{	TokenNameLBRACE	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
}	TokenNameRBRACE	
;	TokenNameSEMICOLON	
// this is the number of valuestores of each kind 	TokenNameCOMMENT_LINE	this is the number of valuestores of each kind 
// we expect an element to have. It's almost 	TokenNameCOMMENT_LINE	we expect an element to have. It's almost 
// never > 1; so leave it at that. 	TokenNameCOMMENT_LINE	never > 1; so leave it at that. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
ID_CONSTRAINT_NUM	TokenNameIdentifier	 ID  CONSTRAINT  NUM
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// xsi:* attribute declarations 	TokenNameCOMMENT_LINE	xsi:* attribute declarations 
static	TokenNamestatic	
final	TokenNamefinal	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_XSI	TokenNameIdentifier	 SG  XSI
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
XSI_NIL	TokenNameIdentifier	 XSI  NIL
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_XSI	TokenNameIdentifier	 SG  XSI
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
XSI_SCHEMALOCATION	TokenNameIdentifier	 XSI  SCHEMALOCATION
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_XSI	TokenNameIdentifier	 SG  XSI
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_SCHEMALOCATION	TokenNameIdentifier	 XSI  SCHEMALOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
XSI_NONAMESPACESCHEMALOCATION	TokenNameIdentifier	 XSI  NONAMESPACESCHEMALOCATION
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_XSI	TokenNameIdentifier	 SG  XSI
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NONAMESPACESCHEMALOCATION	TokenNameIdentifier	 XSI  NONAMESPACESCHEMALOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
Hashtable	TokenNameIdentifier	 Hashtable
EMPTY_TABLE	TokenNameIdentifier	 EMPTY  TABLE
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** current PSVI element info */	TokenNameCOMMENT_JAVADOC	 current PSVI element info 
protected	TokenNameprotected	
ElementPSVImpl	TokenNameIdentifier	 Element PSV Impl
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
=	TokenNameEQUAL	
new	TokenNamenew	
ElementPSVImpl	TokenNameIdentifier	 Element PSV Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// since it is the responsibility of each component to an 	TokenNameCOMMENT_LINE	since it is the responsibility of each component to an 
// Augmentations parameter if one is null, to save ourselves from 	TokenNameCOMMENT_LINE	Augmentations parameter if one is null, to save ourselves from 
// having to create this object continually, it is created here. 	TokenNameCOMMENT_LINE	having to create this object continually, it is created here. 
// If it is not present in calls that we're passing on, we *must* 	TokenNameCOMMENT_LINE	If it is not present in calls that we're passing on, we *must* 
// clear this before we introduce it into the pipeline. 	TokenNameCOMMENT_LINE	clear this before we introduce it into the pipeline. 
protected	TokenNameprotected	
final	TokenNamefinal	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
fAugmentations	TokenNameIdentifier	 f Augmentations
=	TokenNameEQUAL	
new	TokenNamenew	
AugmentationsImpl	TokenNameIdentifier	 Augmentations Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// this is included for the convenience of handleEndElement 	TokenNameCOMMENT_LINE	this is included for the convenience of handleEndElement 
protected	TokenNameprotected	
XMLString	TokenNameIdentifier	 XML String
fDefaultValue	TokenNameIdentifier	 f Default Value
;	TokenNameSEMICOLON	
// Validation features 	TokenNameCOMMENT_LINE	Validation features 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fSchemaDynamicValidation	TokenNameIdentifier	 f Schema Dynamic Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fDoValidation	TokenNameIdentifier	 f Do Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fFullChecking	TokenNameIdentifier	 f Full Checking
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fSchemaElementDefault	TokenNameIdentifier	 f Schema Element Default
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fIdConstraint	TokenNameIdentifier	 f Id Constraint
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Namespace growth feature 	TokenNameCOMMENT_LINE	Namespace growth feature 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Schema type: None, DTD, Schema */	TokenNameCOMMENT_JAVADOC	 Schema type: None, DTD, Schema 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fSchemaType	TokenNameIdentifier	 f Schema Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// to indicate whether we are in the scope of entity reference or CData 	TokenNameCOMMENT_LINE	to indicate whether we are in the scope of entity reference or CData 
protected	TokenNameprotected	
boolean	TokenNameboolean	
fEntityRef	TokenNameIdentifier	 f Entity Ref
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
boolean	TokenNameboolean	
fInCDATA	TokenNameIdentifier	 f In CDATA
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// properties 	TokenNameCOMMENT_LINE	properties 
/** Symbol table. */	TokenNameCOMMENT_JAVADOC	 Symbol table. 
protected	TokenNameprotected	
SymbolTable	TokenNameIdentifier	 Symbol Table
fSymbolTable	TokenNameIdentifier	 f Symbol Table
;	TokenNameSEMICOLON	
/** * While parsing a document, keep the location of the document. */	TokenNameCOMMENT_JAVADOC	 While parsing a document, keep the location of the document. 
private	TokenNameprivate	
XMLLocator	TokenNameIdentifier	 XML Locator
fLocator	TokenNameIdentifier	 f Locator
;	TokenNameSEMICOLON	
/** * A wrapper of the standard error reporter. We'll store all schema errors * in this wrapper object, so that we can get all errors (error codes) of * a specific element. This is useful for PSVI. */	TokenNameCOMMENT_JAVADOC	 A wrapper of the standard error reporter. We'll store all schema errors in this wrapper object, so that we can get all errors (error codes) of a specific element. This is useful for PSVI. 
protected	TokenNameprotected	
final	TokenNamefinal	
class	TokenNameclass	
XSIErrorReporter	TokenNameIdentifier	 XSI Error Reporter
{	TokenNameLBRACE	
// the error reporter property 	TokenNameCOMMENT_LINE	the error reporter property 
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
fErrorReporter	TokenNameIdentifier	 f Error Reporter
;	TokenNameSEMICOLON	
// store error codes; starting position of the errors for each element; 	TokenNameCOMMENT_LINE	store error codes; starting position of the errors for each element; 
// number of element (depth); and whether to record error 	TokenNameCOMMENT_LINE	number of element (depth); and whether to record error 
Vector	TokenNameIdentifier	 Vector
fErrors	TokenNameIdentifier	 f Errors
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fContext	TokenNameIdentifier	 f Context
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
fContextCount	TokenNameIdentifier	 f Context Count
;	TokenNameSEMICOLON	
// set the external error reporter, clear errors 	TokenNameCOMMENT_LINE	set the external error reporter, clear errors 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
errorReporter	TokenNameIdentifier	 error Reporter
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
=	TokenNameEQUAL	
errorReporter	TokenNameIdentifier	 error Reporter
;	TokenNameSEMICOLON	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContextCount	TokenNameIdentifier	 f Context Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// should be called when starting process an element or an attribute. 	TokenNameCOMMENT_LINE	should be called when starting process an element or an attribute. 
// store the starting position for the current context 	TokenNameCOMMENT_LINE	store the starting position for the current context 
public	TokenNamepublic	
void	TokenNamevoid	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// resize array if necessary 	TokenNameCOMMENT_LINE	resize array if necessary 
if	TokenNameif	
(	TokenNameLPAREN	
fContextCount	TokenNameIdentifier	 f Context Count
==	TokenNameEQUAL_EQUAL	
fContext	TokenNameIdentifier	 f Context
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
fContextCount	TokenNameIdentifier	 f Context Count
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArray	TokenNameIdentifier	 new Array
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fContext	TokenNameIdentifier	 f Context
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArray	TokenNameIdentifier	 new Array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fContextCount	TokenNameIdentifier	 f Context Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fContext	TokenNameIdentifier	 f Context
=	TokenNameEQUAL	
newArray	TokenNameIdentifier	 new Array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fContext	TokenNameIdentifier	 f Context
[	TokenNameLBRACKET	
fContextCount	TokenNameIdentifier	 f Context Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// should be called on endElement: get all errors of the current element 	TokenNameCOMMENT_LINE	should be called on endElement: get all errors of the current element 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
popContext	TokenNameIdentifier	 pop Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get starting position of the current element 	TokenNameCOMMENT_LINE	get starting position of the current element 
int	TokenNameint	
contextPos	TokenNameIdentifier	 context Pos
=	TokenNameEQUAL	
fContext	TokenNameIdentifier	 f Context
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fContextCount	TokenNameIdentifier	 f Context Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// number of errors of the current element 	TokenNameCOMMENT_LINE	number of errors of the current element 
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
contextPos	TokenNameIdentifier	 context Pos
;	TokenNameSEMICOLON	
// if no errors, return null 	TokenNameCOMMENT_LINE	if no errors, return null 
if	TokenNameif	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// copy errors from the list to an string array 	TokenNameCOMMENT_LINE	copy errors from the list to an string array 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errors	TokenNameIdentifier	 errors
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
errors	TokenNameIdentifier	 errors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
contextPos	TokenNameIdentifier	 context Pos
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// remove errors of the current element 	TokenNameCOMMENT_LINE	remove errors of the current element 
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
contextPos	TokenNameIdentifier	 context Pos
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
errors	TokenNameIdentifier	 errors
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// should be called when an attribute is done: get all errors of 	TokenNameCOMMENT_LINE	should be called when an attribute is done: get all errors of 
// this attribute, but leave the errors to the containing element 	TokenNameCOMMENT_LINE	this attribute, but leave the errors to the containing element 
// also called after an element was strictly assessed. 	TokenNameCOMMENT_LINE	also called after an element was strictly assessed. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
mergeContext	TokenNameIdentifier	 merge Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get starting position of the current element 	TokenNameCOMMENT_LINE	get starting position of the current element 
int	TokenNameint	
contextPos	TokenNameIdentifier	 context Pos
=	TokenNameEQUAL	
fContext	TokenNameIdentifier	 f Context
[	TokenNameLBRACKET	
--	TokenNameMINUS_MINUS	
fContextCount	TokenNameIdentifier	 f Context Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// number of errors of the current element 	TokenNameCOMMENT_LINE	number of errors of the current element 
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
-	TokenNameMINUS	
contextPos	TokenNameIdentifier	 context Pos
;	TokenNameSEMICOLON	
// if no errors, return null 	TokenNameCOMMENT_LINE	if no errors, return null 
if	TokenNameif	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// copy errors from the list to an string array 	TokenNameCOMMENT_LINE	copy errors from the list to an string array 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errors	TokenNameIdentifier	 errors
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
errors	TokenNameIdentifier	 errors
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
contextPos	TokenNameIdentifier	 context Pos
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// don't resize the vector: leave the errors for this attribute 	TokenNameCOMMENT_LINE	don't resize the vector: leave the errors for this attribute 
// to the containing element 	TokenNameCOMMENT_LINE	to the containing element 
return	TokenNamereturn	
errors	TokenNameIdentifier	 errors
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
domain	TokenNameIdentifier	 domain
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
short	TokenNameshort	
severity	TokenNameIdentifier	 severity
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
domain	TokenNameIdentifier	 domain
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
severity	TokenNameIdentifier	 severity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reportError(String,String,Object[],short) 	TokenNameCOMMENT_LINE	reportError(String,String,Object[],short) 
public	TokenNamepublic	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
domain	TokenNameIdentifier	 domain
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
short	TokenNameshort	
severity	TokenNameIdentifier	 severity
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
message	TokenNameIdentifier	 message
=	TokenNameEQUAL	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
location	TokenNameIdentifier	 location
,	TokenNameCOMMA	
domain	TokenNameIdentifier	 domain
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
severity	TokenNameIdentifier	 severity
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fErrors	TokenNameIdentifier	 f Errors
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
message	TokenNameIdentifier	 message
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// reportError(XMLLocator,String,String,Object[],short) 	TokenNameCOMMENT_LINE	reportError(XMLLocator,String,String,Object[],short) 
}	TokenNameRBRACE	
/** Error reporter. */	TokenNameCOMMENT_JAVADOC	 Error reporter. 
protected	TokenNameprotected	
final	TokenNamefinal	
XSIErrorReporter	TokenNameIdentifier	 XSI Error Reporter
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
=	TokenNameEQUAL	
new	TokenNamenew	
XSIErrorReporter	TokenNameIdentifier	 XSI Error Reporter
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Entity resolver */	TokenNameCOMMENT_JAVADOC	 Entity resolver 
protected	TokenNameprotected	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
;	TokenNameSEMICOLON	
// updated during reset 	TokenNameCOMMENT_LINE	updated during reset 
protected	TokenNameprotected	
ValidationManager	TokenNameIdentifier	 Validation Manager
fValidationManager	TokenNameIdentifier	 f Validation Manager
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
ConfigurableValidationState	TokenNameIdentifier	 Configurable Validation State
fValidationState	TokenNameIdentifier	 f Validation State
=	TokenNameEQUAL	
new	TokenNamenew	
ConfigurableValidationState	TokenNameIdentifier	 Configurable Validation State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
;	TokenNameSEMICOLON	
// schema location property values 	TokenNameCOMMENT_LINE	schema location property values 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
fExternalSchemas	TokenNameIdentifier	 f External Schemas
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
fExternalNoNamespaceSchema	TokenNameIdentifier	 f External No Namespace Schema
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
//JAXP Schema Source property 	TokenNameCOMMENT_LINE	JAXP Schema Source property 
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
fJaxpSchemaSource	TokenNameIdentifier	 f Jaxp Schema Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Schema Grammar Description passed, to give a chance to application to supply the Grammar */	TokenNameCOMMENT_JAVADOC	 Schema Grammar Description passed, to give a chance to application to supply the Grammar 
protected	TokenNameprotected	
final	TokenNamefinal	
XSDDescription	TokenNameIdentifier	 XSD Description
fXSDDescription	TokenNameIdentifier	 f XSD Description
=	TokenNameEQUAL	
new	TokenNamenew	
XSDDescription	TokenNameIdentifier	 XSD Description
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Hashtable	TokenNameIdentifier	 Hashtable
fLocationPairs	TokenNameIdentifier	 f Location Pairs
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
Hashtable	TokenNameIdentifier	 Hashtable
fExpandedLocationPairs	TokenNameIdentifier	 f Expanded Location Pairs
=	TokenNameEQUAL	
new	TokenNamenew	
Hashtable	TokenNameIdentifier	 Hashtable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
fUnparsedLocations	TokenNameIdentifier	 f Unparsed Locations
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// handlers 	TokenNameCOMMENT_LINE	handlers 
/** Document handler. */	TokenNameCOMMENT_JAVADOC	 Document handler. 
protected	TokenNameprotected	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// XMLComponent methods 	TokenNameCOMMENT_LINE	XMLComponent methods 
// 	TokenNameCOMMENT_LINE	 
/** * Returns a list of feature identifiers that are recognized by * this component. This method may return null if no features * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of feature identifiers that are recognized by this component. This method may return null if no features are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedFeatures	TokenNameIdentifier	 get Recognized Features
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedFeatures():String[] 	TokenNameCOMMENT_LINE	getRecognizedFeatures():String[] 
/** * Sets the state of a feature. This method is called by the component * manager any time after reset when a feature changes state. * <p> * <strong>Note:</strong> Components should silently ignore features * that do not affect the operation of the component. * * @param featureId The feature identifier. * @param state The state of the feature. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the state of a feature. This method is called by the component manager any time after reset when a feature changes state. <p> <strong>Note:</strong> Components should silently ignore features that do not affect the operation of the component. * @param featureId The feature identifier. @param state The state of the feature. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setFeature	TokenNameIdentifier	 set Feature
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
,	TokenNameCOMMA	
boolean	TokenNameboolean	
state	TokenNameIdentifier	 state
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// setFeature(String,boolean) 	TokenNameCOMMENT_LINE	setFeature(String,boolean) 
/** * Returns a list of property identifiers that are recognized by * this component. This method may return null if no properties * are recognized by this component. */	TokenNameCOMMENT_JAVADOC	 Returns a list of property identifiers that are recognized by this component. This method may return null if no properties are recognized by this component. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
getRecognizedProperties	TokenNameIdentifier	 get Recognized Properties
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getRecognizedProperties():String[] 	TokenNameCOMMENT_LINE	getRecognizedProperties():String[] 
/** * Sets the value of a property. This method is called by the component * manager any time after reset when a property changes value. * <p> * <strong>Note:</strong> Components should silently ignore properties * that do not affect the operation of the component. * * @param propertyId The property identifier. * @param value The value of the property. * * @throws SAXNotRecognizedException The component should not throw * this exception. * @throws SAXNotSupportedException The component should not throw * this exception. */	TokenNameCOMMENT_JAVADOC	 Sets the value of a property. This method is called by the component manager any time after reset when a property changes value. <p> <strong>Note:</strong> Components should silently ignore properties that do not affect the operation of the component. * @param propertyId The property identifier. @param value The value of the property. * @throws SAXNotRecognizedException The component should not throw this exception. @throws SAXNotSupportedException The component should not throw this exception. 
public	TokenNamepublic	
void	TokenNamevoid	
setProperty	TokenNameIdentifier	 set Property
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ROOT_TYPE_DEF	TokenNameIdentifier	 ROOT  TYPE  DEF
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
instanceof	TokenNameinstanceof	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
ROOT_ELEMENT_DECL	TokenNameIdentifier	 ROOT  ELEMENT  DECL
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
instanceof	TokenNameinstanceof	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// setProperty(String,Object) 	TokenNameCOMMENT_LINE	setProperty(String,Object) 
/** * Returns the default state for a feature, or null if this * component does not want to report a default value for this * feature. * * @param featureId The feature identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a feature, or null if this component does not want to report a default value for this feature. * @param featureId The feature identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Boolean	TokenNameIdentifier	 Boolean
getFeatureDefault	TokenNameIdentifier	 get Feature Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_FEATURES	TokenNameIdentifier	 RECOGNIZED  FEATURES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
featureId	TokenNameIdentifier	 feature Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
FEATURE_DEFAULTS	TokenNameIdentifier	 FEATURE  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getFeatureDefault(String):Boolean 	TokenNameCOMMENT_LINE	getFeatureDefault(String):Boolean 
/** * Returns the default state for a property, or null if this * component does not want to report a default value for this * property. * * @param propertyId The property identifier. * * @since Xerces 2.2.0 */	TokenNameCOMMENT_JAVADOC	 Returns the default state for a property, or null if this component does not want to report a default value for this property. * @param propertyId The property identifier. * @since Xerces 2.2.0 
public	TokenNamepublic	
Object	TokenNameIdentifier	 Object
getPropertyDefault	TokenNameIdentifier	 get Property Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
RECOGNIZED_PROPERTIES	TokenNameIdentifier	 RECOGNIZED  PROPERTIES
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
propertyId	TokenNameIdentifier	 property Id
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
PROPERTY_DEFAULTS	TokenNameIdentifier	 PROPERTY  DEFAULTS
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getPropertyDefault(String):Object 	TokenNameCOMMENT_LINE	getPropertyDefault(String):Object 
// 	TokenNameCOMMENT_LINE	 
// XMLDocumentSource methods 	TokenNameCOMMENT_LINE	XMLDocumentSource methods 
// 	TokenNameCOMMENT_LINE	 
/** Sets the document handler to receive information about the document. */	TokenNameCOMMENT_JAVADOC	 Sets the document handler to receive information about the document. 
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
documentHandler	TokenNameIdentifier	 document Handler
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
=	TokenNameEQUAL	
documentHandler	TokenNameIdentifier	 document Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDocumentHandler(XMLDocumentHandler) 	TokenNameCOMMENT_LINE	setDocumentHandler(XMLDocumentHandler) 
/** Returns the document handler */	TokenNameCOMMENT_JAVADOC	 Returns the document handler 
public	TokenNamepublic	
XMLDocumentHandler	TokenNameIdentifier	 XML Document Handler
getDocumentHandler	TokenNameIdentifier	 get Document Handler
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDocumentHandler(XMLDocumentHandler) 	TokenNameCOMMENT_LINE	setDocumentHandler(XMLDocumentHandler) 
// 	TokenNameCOMMENT_LINE	 
// XMLDocumentHandler methods 	TokenNameCOMMENT_LINE	XMLDocumentHandler methods 
// 	TokenNameCOMMENT_LINE	 
/** Sets the document source */	TokenNameCOMMENT_JAVADOC	 Sets the document source 
public	TokenNamepublic	
void	TokenNamevoid	
setDocumentSource	TokenNameIdentifier	 set Document Source
(	TokenNameLPAREN	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
source	TokenNameIdentifier	 source
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentSource	TokenNameIdentifier	 f Document Source
=	TokenNameEQUAL	
source	TokenNameIdentifier	 source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// setDocumentSource 	TokenNameCOMMENT_LINE	setDocumentSource 
/** Returns the document source */	TokenNameCOMMENT_JAVADOC	 Returns the document source 
public	TokenNamepublic	
XMLDocumentSource	TokenNameIdentifier	 XML Document Source
getDocumentSource	TokenNameIdentifier	 get Document Source
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fDocumentSource	TokenNameIdentifier	 f Document Source
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getDocumentSource 	TokenNameCOMMENT_LINE	getDocumentSource 
/** * The start of the document. * * @param locator The system identifier of the entity if the entity * is external, null otherwise. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal entities or a document entity that is * parsed from a java.io.Reader). * @param namespaceContext * The namespace context in effect at the * start of this document. * This object represents the current context. * Implementors of this class are responsible * for copying the namespace bindings from the * the current context (and its parent contexts) * if that information is important. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of the document. * @param locator The system identifier of the entity if the entity is external, null otherwise. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal entities or a document entity that is parsed from a java.io.Reader). @param namespaceContext The namespace context in effect at the start of this document. This object represents the current context. Implementors of this class are responsible for copying the namespace bindings from the the current context (and its parent contexts) if that information is important. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
NamespaceContext	TokenNameIdentifier	 Namespace Context
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fState4XsiType	TokenNameIdentifier	 f State4 Xsi Type
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fState4ApplyDefault	TokenNameIdentifier	 f State4 Apply Default
.	TokenNameDOT	
setNamespaceSupport	TokenNameIdentifier	 set Namespace Support
(	TokenNameLPAREN	
namespaceContext	TokenNameIdentifier	 namespace Context
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLocator	TokenNameIdentifier	 f Locator
=	TokenNameEQUAL	
locator	TokenNameIdentifier	 locator
;	TokenNameSEMICOLON	
handleStartDocument	TokenNameIdentifier	 handle Start Document
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
namespaceContext	TokenNameIdentifier	 namespace Context
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startDocument(XMLLocator,String) 	TokenNameCOMMENT_LINE	startDocument(XMLLocator,String) 
/** * Notifies of the presence of an XMLDecl line in the document. If * present, this method will be called immediately following the * startDocument call. * * @param version The XML version. * @param encoding The IANA encoding name of the document, or null if * not specified. * @param standalone The standalone value, or null if not specified. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of an XMLDecl line in the document. If present, this method will be called immediately following the startDocument call. * @param version The XML version. @param encoding The IANA encoding name of the document, or null if not specified. @param standalone The standalone value, or null if not specified. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
xmlDecl	TokenNameIdentifier	 xml Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
standalone	TokenNameIdentifier	 standalone
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// xmlDecl(String,String,String) 	TokenNameCOMMENT_LINE	xmlDecl(String,String,String) 
/** * Notifies of the presence of the DOCTYPE line in the document. * * @param rootElement The name of the root element. * @param publicId The public identifier if an external DTD or null * if the external DTD is specified using SYSTEM. * @param systemId The system identifier if an external DTD, null * otherwise. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of the DOCTYPE line in the document. * @param rootElement The name of the root element. @param publicId The public identifier if an external DTD or null if the external DTD is specified using SYSTEM. @param systemId The system identifier if an external DTD, null otherwise. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
doctypeDecl	TokenNameIdentifier	 doctype Decl
(	TokenNameLPAREN	
rootElement	TokenNameIdentifier	 root Element
,	TokenNameCOMMA	
publicId	TokenNameIdentifier	 public Id
,	TokenNameCOMMA	
systemId	TokenNameIdentifier	 system Id
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// doctypeDecl(String,String,String) 	TokenNameCOMMENT_LINE	doctypeDecl(String,String,String) 
/** * The start of an element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of an element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
Augmentations	TokenNameIdentifier	 Augmentations
modifiedAugs	TokenNameIdentifier	 modified Augs
=	TokenNameEQUAL	
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startElement(QName,XMLAttributes, Augmentations) 	TokenNameCOMMENT_LINE	startElement(QName,XMLAttributes, Augmentations) 
/** * An empty element. * * @param element The name of the element. * @param attributes The element attributes. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 An empty element. * @param element The name of the element. @param attributes The element attributes. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
Augmentations	TokenNameIdentifier	 Augmentations
modifiedAugs	TokenNameIdentifier	 modified Augs
=	TokenNameEQUAL	
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// in the case where there is a {value constraint}, and the element 	TokenNameCOMMENT_LINE	in the case where there is a {value constraint}, and the element 
// doesn't have any text content, change emptyElement call to 	TokenNameCOMMENT_LINE	doesn't have any text content, change emptyElement call to 
// start + characters + end 	TokenNameCOMMENT_LINE	start + characters + end 
fDefaultValue	TokenNameIdentifier	 f Default Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// fElementDepth == -2 indicates that the schema validator was removed 	TokenNameCOMMENT_LINE	fElementDepth == -2 indicates that the schema validator was removed 
// from the pipeline. then we don't need to call handleEndElement. 	TokenNameCOMMENT_LINE	from the pipeline. then we don't need to call handleEndElement. 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
modifiedAugs	TokenNameIdentifier	 modified Augs
=	TokenNameEQUAL	
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fSchemaElementDefault	TokenNameIdentifier	 f Schema Element Default
||	TokenNameOR_OR	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
emptyElement	TokenNameIdentifier	 empty Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
fDefaultValue	TokenNameIdentifier	 f Default Value
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// emptyElement(QName,XMLAttributes, Augmentations) 	TokenNameCOMMENT_LINE	emptyElement(QName,XMLAttributes, Augmentations) 
/** * Character content. * * @param text The content. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Character content. * @param text The content. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
handleCharacters	TokenNameIdentifier	 handle Characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
&&	TokenNameAND_AND	
fUnionType	TokenNameIdentifier	 f Union Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for union types we can't normalize data 	TokenNameCOMMENT_LINE	for union types we can't normalize data 
// thus we only need to send augs information if any; 	TokenNameCOMMENT_LINE	thus we only need to send augs information if any; 
// the normalized data for union will be send 	TokenNameCOMMENT_LINE	the normalized data for union will be send 
// after normalization is performed (at the endElement()) 	TokenNameCOMMENT_LINE	after normalization is performed (at the endElement()) 
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
fEmptyXMLStr	TokenNameIdentifier	 f Empty XML Str
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// characters(XMLString) 	TokenNameCOMMENT_LINE	characters(XMLString) 
/** * Ignorable whitespace. For this method to be called, the document * source must have some way of determining that the text containing * only whitespace characters should be considered ignorable. For * example, the validator can determine if a length of whitespace * characters in the document are ignorable based on the element * content model. * * @param text The ignorable whitespace. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Ignorable whitespace. For this method to be called, the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable. For example, the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model. * @param text The ignorable whitespace. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
handleIgnorableWhitespace	TokenNameIdentifier	 handle Ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
ignorableWhitespace	TokenNameIdentifier	 ignorable Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ignorableWhitespace(XMLString) 	TokenNameCOMMENT_LINE	ignorableWhitespace(XMLString) 
/** * The end of an element. * * @param element The name of the element. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of an element. * @param element The name of the element. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// in the case where there is a {value constraint}, and the element 	TokenNameCOMMENT_LINE	in the case where there is a {value constraint}, and the element 
// doesn't have any text content, add a characters call. 	TokenNameCOMMENT_LINE	doesn't have any text content, add a characters call. 
fDefaultValue	TokenNameIdentifier	 f Default Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Augmentations	TokenNameIdentifier	 Augmentations
modifiedAugs	TokenNameIdentifier	 modified Augs
=	TokenNameEQUAL	
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fSchemaElementDefault	TokenNameIdentifier	 f Schema Element Default
||	TokenNameOR_OR	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
fDefaultValue	TokenNameIdentifier	 f Default Value
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
modifiedAugs	TokenNameIdentifier	 modified Augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endElement(QName, Augmentations) 	TokenNameCOMMENT_LINE	endElement(QName, Augmentations) 
/** * The start of a CDATA section. * * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The start of a CDATA section. * @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// REVISIT: what should we do here if schema normalization is on?? 	TokenNameCOMMENT_LINE	REVISIT: what should we do here if schema normalization is on?? 
fInCDATA	TokenNameIdentifier	 f In CDATA
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startCDATA	TokenNameIdentifier	 start CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startCDATA() 	TokenNameCOMMENT_LINE	startCDATA() 
/** * The end of a CDATA section. * * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of a CDATA section. * @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
fInCDATA	TokenNameIdentifier	 f In CDATA
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endCDATA	TokenNameIdentifier	 end CDATA
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endCDATA() 	TokenNameCOMMENT_LINE	endCDATA() 
/** * The end of the document. * * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 The end of the document. * @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
handleEndDocument	TokenNameIdentifier	 handle End Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLocator	TokenNameIdentifier	 f Locator
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endDocument(Augmentations) 	TokenNameCOMMENT_LINE	endDocument(Augmentations) 
// 	TokenNameCOMMENT_LINE	 
// DOMRevalidationHandler methods 	TokenNameCOMMENT_LINE	DOMRevalidationHandler methods 
// 	TokenNameCOMMENT_LINE	 
public	TokenNamepublic	
boolean	TokenNameboolean	
characterData	TokenNameIdentifier	 character Data
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
fSawText	TokenNameIdentifier	 f Saw Text
||	TokenNameOR_OR	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// REVISIT: this methods basically duplicates implementation of 	TokenNameCOMMENT_LINE	REVISIT: this methods basically duplicates implementation of 
// handleCharacters(). We should be able to reuse some code 	TokenNameCOMMENT_LINE	handleCharacters(). We should be able to reuse some code 
// if whitespace == -1 skip normalization, because it is a complexType 	TokenNameCOMMENT_LINE	if whitespace == -1 skip normalization, because it is a complexType 
// or a union type. 	TokenNameCOMMENT_LINE	or a union type. 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
&&	TokenNameAND_AND	
fWhiteSpace	TokenNameIdentifier	 f White Space
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fWhiteSpace	TokenNameIdentifier	 f White Space
!=	TokenNameNOT_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// normalize data 	TokenNameCOMMENT_LINE	normalize data 
normalizeWhitespace	TokenNameIdentifier	 normalize Whitespace
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
)	TokenNameRPAREN	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// When it's a complex type with element-only content, we need to 	TokenNameCOMMENT_LINE	When it's a complex type with element-only content, we need to 
// find out whether the content contains any non-whitespace character. 	TokenNameCOMMENT_LINE	find out whether the content contains any non-whitespace character. 
boolean	TokenNameboolean	
allWhiteSpace	TokenNameIdentifier	 all White Space
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// data outside of element content 	TokenNameCOMMENT_LINE	data outside of element content 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
data	TokenNameIdentifier	 data
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
allWhiteSpace	TokenNameIdentifier	 all White Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
allWhiteSpace	TokenNameIdentifier	 all White Space
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
void	TokenNamevoid	
elementDefault	TokenNameIdentifier	 element Default
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
data	TokenNameIdentifier	 data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no-op 	TokenNameCOMMENT_LINE	no-op 
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// XMLDocumentHandler and XMLDTDHandler methods 	TokenNameCOMMENT_LINE	XMLDocumentHandler and XMLDTDHandler methods 
// 	TokenNameCOMMENT_LINE	 
/** * This method notifies the start of a general entity. * <p> * <strong>Note:</strong> This method is not called for entity references * appearing as part of attribute values. * * @param name The name of the general entity. * @param identifier The resource identifier. * @param encoding The auto-detected IANA encoding name of the entity * stream. This value will be null in those situations * where the entity encoding is not auto-detected (e.g. * internal entities or a document entity that is * parsed from a java.io.Reader). * @param augs Additional information that may include infoset augmentations * * @exception XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the start of a general entity. <p> <strong>Note:</strong> This method is not called for entity references appearing as part of attribute values. * @param name The name of the general entity. @param identifier The resource identifier. @param encoding The auto-detected IANA encoding name of the entity stream. This value will be null in those situations where the entity encoding is not auto-detected (e.g. internal entities or a document entity that is parsed from a java.io.Reader). @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
XMLResourceIdentifier	TokenNameIdentifier	 XML Resource Identifier
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// REVISIT: what should happen if normalize_data_ is on?? 	TokenNameCOMMENT_LINE	REVISIT: what should happen if normalize_data_ is on?? 
fEntityRef	TokenNameIdentifier	 f Entity Ref
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
startGeneralEntity	TokenNameIdentifier	 start General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
identifier	TokenNameIdentifier	 identifier
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startEntity(String,String,String,String,String) 	TokenNameCOMMENT_LINE	startEntity(String,String,String,String,String) 
/** * Notifies of the presence of a TextDecl line in an entity. If present, * this method will be called immediately following the startEntity call. * <p> * <strong>Note:</strong> This method will never be called for the * document entity; it is only called for external general entities * referenced in document content. * <p> * <strong>Note:</strong> This method is not called for entity references * appearing as part of attribute values. * * @param version The XML version, or null if not specified. * @param encoding The IANA encoding name of the entity. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 Notifies of the presence of a TextDecl line in an entity. If present, this method will be called immediately following the startEntity call. <p> <strong>Note:</strong> This method will never be called for the document entity; it is only called for external general entities referenced in document content. <p> <strong>Note:</strong> This method is not called for entity references appearing as part of attribute values. * @param version The XML version, or null if not specified. @param encoding The IANA encoding name of the entity. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
textDecl	TokenNameIdentifier	 text Decl
(	TokenNameLPAREN	
version	TokenNameIdentifier	 version
,	TokenNameCOMMA	
encoding	TokenNameIdentifier	 encoding
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// textDecl(String,String) 	TokenNameCOMMENT_LINE	textDecl(String,String) 
/** * A comment. * * @param text The text in the comment. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by application to signal an error. */	TokenNameCOMMENT_JAVADOC	 A comment. * @param text The text in the comment. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by application to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
comment	TokenNameIdentifier	 comment
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// comment(XMLString) 	TokenNameCOMMENT_LINE	comment(XMLString) 
/** * A processing instruction. Processing instructions consist of a * target name and, optionally, text data. The data is only meaningful * to the application. * <p> * Typically, a processing instruction's data will contain a series * of pseudo-attributes. These pseudo-attributes follow the form of * element attributes but are <strong>not</strong> parsed or presented * to the application as anything other than text. The application is * responsible for parsing the data. * * @param target The target. * @param data The data or null if none specified. * @param augs Additional information that may include infoset augmentations * * @throws XNIException Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 A processing instruction. Processing instructions consist of a target name and, optionally, text data. The data is only meaningful to the application. <p> Typically, a processing instruction's data will contain a series of pseudo-attributes. These pseudo-attributes follow the form of element attributes but are <strong>not</strong> parsed or presented to the application as anything other than text. The application is responsible for parsing the data. * @param target The target. @param data The data or null if none specified. @param augs Additional information that may include infoset augmentations * @throws XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
XMLString	TokenNameIdentifier	 XML String
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
processingInstruction	TokenNameIdentifier	 processing Instruction
(	TokenNameLPAREN	
target	TokenNameIdentifier	 target
,	TokenNameCOMMA	
data	TokenNameIdentifier	 data
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// processingInstruction(String,XMLString) 	TokenNameCOMMENT_LINE	processingInstruction(String,XMLString) 
/** * This method notifies the end of a general entity. * <p> * <strong>Note:</strong> This method is not called for entity references * appearing as part of attribute values. * * @param name The name of the entity. * @param augs Additional information that may include infoset augmentations * * @exception XNIException * Thrown by handler to signal an error. */	TokenNameCOMMENT_JAVADOC	 This method notifies the end of a general entity. <p> <strong>Note:</strong> This method is not called for entity references appearing as part of attribute values. * @param name The name of the entity. @param augs Additional information that may include infoset augmentations * @exception XNIException Thrown by handler to signal an error. 
public	TokenNamepublic	
void	TokenNamevoid	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
throws	TokenNamethrows	
XNIException	TokenNameIdentifier	 XNI Exception
{	TokenNameLBRACE	
// call handlers 	TokenNameCOMMENT_LINE	call handlers 
fEntityRef	TokenNameIdentifier	 f Entity Ref
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
endGeneralEntity	TokenNameIdentifier	 end General Entity
(	TokenNameLPAREN	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endEntity(String) 	TokenNameCOMMENT_LINE	endEntity(String) 
// constants 	TokenNameCOMMENT_LINE	constants 
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
=	TokenNameEQUAL	
8	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
// Schema Normalization 	TokenNameCOMMENT_LINE	Schema Normalization 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
boolean	TokenNameboolean	
DEBUG_NORMALIZATION	TokenNameIdentifier	 DEBUG  NORMALIZATION
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// temporary empty string buffer. 	TokenNameCOMMENT_LINE	temporary empty string buffer. 
private	TokenNameprivate	
final	TokenNamefinal	
XMLString	TokenNameIdentifier	 XML String
fEmptyXMLStr	TokenNameIdentifier	 f Empty XML Str
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// temporary character buffer, and empty string buffer. 	TokenNameCOMMENT_LINE	temporary character buffer, and empty string buffer. 
private	TokenNameprivate	
static	TokenNamestatic	
final	TokenNamefinal	
int	TokenNameint	
BUFFER_SIZE	TokenNameIdentifier	 BUFFER  SIZE
=	TokenNameEQUAL	
20	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
XMLString	TokenNameIdentifier	 XML String
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
=	TokenNameEQUAL	
new	TokenNamenew	
XMLString	TokenNameIdentifier	 XML String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fFirstChunk	TokenNameIdentifier	 f First Chunk
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// got first chunk in characters() (SAX) 	TokenNameCOMMENT_LINE	got first chunk in characters() (SAX) 
private	TokenNameprivate	
boolean	TokenNameboolean	
fTrailing	TokenNameIdentifier	 f Trailing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// Previous chunk had a trailing space 	TokenNameCOMMENT_LINE	Previous chunk had a trailing space 
private	TokenNameprivate	
short	TokenNameshort	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
//whiteSpace: preserve/replace/collapse 	TokenNameCOMMENT_LINE	whiteSpace: preserve/replace/collapse 
private	TokenNameprivate	
boolean	TokenNameboolean	
fUnionType	TokenNameIdentifier	 f Union Type
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Schema grammar resolver. */	TokenNameCOMMENT_JAVADOC	 Schema grammar resolver. 
private	TokenNameprivate	
final	TokenNamefinal	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
=	TokenNameEQUAL	
new	TokenNamenew	
XSGrammarBucket	TokenNameIdentifier	 XS Grammar Bucket
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
fSubGroupHandler	TokenNameIdentifier	 f Sub Group Handler
=	TokenNameEQUAL	
new	TokenNamenew	
SubstitutionGroupHandler	TokenNameIdentifier	 Substitution Group Handler
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** the DV usd to convert xsi:type to a QName */	TokenNameCOMMENT_JAVADOC	 the DV usd to convert xsi:type to a QName 
// REVISIT: in new simple type design, make things in DVs static, 	TokenNameCOMMENT_LINE	REVISIT: in new simple type design, make things in DVs static, 
// so that we can QNameDV.getCompiledForm() 	TokenNameCOMMENT_LINE	so that we can QNameDV.getCompiledForm() 
private	TokenNameprivate	
final	TokenNamefinal	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
fQNameDV	TokenNameIdentifier	 f Q Name DV
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_QNAME	TokenNameIdentifier	 ATTVAL  QNAME
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
final	TokenNamefinal	
CMNodeFactory	TokenNameIdentifier	 CM Node Factory
nodeFactory	TokenNameIdentifier	 node Factory
=	TokenNameEQUAL	
new	TokenNamenew	
CMNodeFactory	TokenNameIdentifier	 CM Node Factory
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** used to build content models */	TokenNameCOMMENT_JAVADOC	 used to build content models 
// REVISIT: create decl pool, and pass it to each traversers 	TokenNameCOMMENT_LINE	REVISIT: create decl pool, and pass it to each traversers 
private	TokenNameprivate	
final	TokenNamefinal	
CMBuilder	TokenNameIdentifier	 CM Builder
fCMBuilder	TokenNameIdentifier	 f CM Builder
=	TokenNameEQUAL	
new	TokenNamenew	
CMBuilder	TokenNameIdentifier	 CM Builder
(	TokenNameLPAREN	
nodeFactory	TokenNameIdentifier	 node Factory
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Schema grammar loader 	TokenNameCOMMENT_LINE	Schema grammar loader 
private	TokenNameprivate	
final	TokenNamefinal	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
fSchemaLoader	TokenNameIdentifier	 f Schema Loader
=	TokenNameEQUAL	
new	TokenNamenew	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
(	TokenNameLPAREN	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
,	TokenNameCOMMA	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
,	TokenNameCOMMA	
fSubGroupHandler	TokenNameIdentifier	 f Sub Group Handler
,	TokenNameCOMMA	
fCMBuilder	TokenNameIdentifier	 f CM Builder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// state 	TokenNameCOMMENT_LINE	state 
/** String representation of the validation root. */	TokenNameCOMMENT_JAVADOC	 String representation of the validation root. 
// REVISIT: what do we store here? QName, XPATH, some ID? use rawname now. 	TokenNameCOMMENT_LINE	REVISIT: what do we store here? QName, XPATH, some ID? use rawname now. 
private	TokenNameprivate	
String	TokenNameIdentifier	 String
fValidationRoot	TokenNameIdentifier	 f Validation Root
;	TokenNameSEMICOLON	
/** Skip validation: anything below this level should be skipped */	TokenNameCOMMENT_JAVADOC	 Skip validation: anything below this level should be skipped 
private	TokenNameprivate	
int	TokenNameint	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
;	TokenNameSEMICOLON	
/** anything above this level has validation_attempted != full */	TokenNameCOMMENT_JAVADOC	 anything above this level has validation_attempted != full 
private	TokenNameprivate	
int	TokenNameint	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
;	TokenNameSEMICOLON	
/** anything above this level has validation_attempted != none */	TokenNameCOMMENT_JAVADOC	 anything above this level has validation_attempted != none 
private	TokenNameprivate	
int	TokenNameint	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
;	TokenNameSEMICOLON	
/** Element depth: -2: validator not in pipeline; >= -1 current depth. */	TokenNameCOMMENT_JAVADOC	 Element depth: -2: validator not in pipeline; >= -1 current depth. 
private	TokenNameprivate	
int	TokenNameint	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
/** Seen sub elements. */	TokenNameCOMMENT_JAVADOC	 Seen sub elements. 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSubElement	TokenNameIdentifier	 f Sub Element
;	TokenNameSEMICOLON	
/** Seen sub elements stack. */	TokenNameCOMMENT_JAVADOC	 Seen sub elements stack. 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Current element declaration. */	TokenNameCOMMENT_JAVADOC	 Current element declaration. 
private	TokenNameprivate	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
;	TokenNameSEMICOLON	
/** Element decl stack. */	TokenNameCOMMENT_JAVADOC	 Element decl stack. 
private	TokenNameprivate	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** nil value of the current element */	TokenNameCOMMENT_JAVADOC	 nil value of the current element 
private	TokenNameprivate	
boolean	TokenNameboolean	
fNil	TokenNameIdentifier	 f Nil
;	TokenNameSEMICOLON	
/** nil value stack */	TokenNameCOMMENT_JAVADOC	 nil value stack 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNilStack	TokenNameIdentifier	 f Nil Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** notation value of the current element */	TokenNameCOMMENT_JAVADOC	 notation value of the current element 
private	TokenNameprivate	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
fNotation	TokenNameIdentifier	 f Notation
;	TokenNameSEMICOLON	
/** notation stack */	TokenNameCOMMENT_JAVADOC	 notation stack 
private	TokenNameprivate	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fNotationStack	TokenNameIdentifier	 f Notation Stack
=	TokenNameEQUAL	
new	TokenNamenew	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Current type. */	TokenNameCOMMENT_JAVADOC	 Current type. 
private	TokenNameprivate	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
/** type stack. */	TokenNameCOMMENT_JAVADOC	 type stack. 
private	TokenNameprivate	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fTypeStack	TokenNameIdentifier	 f Type Stack
=	TokenNameEQUAL	
new	TokenNamenew	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Current content model. */	TokenNameCOMMENT_JAVADOC	 Current content model. 
private	TokenNameprivate	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
fCurrentCM	TokenNameIdentifier	 f Current CM
;	TokenNameSEMICOLON	
/** Content model stack. */	TokenNameCOMMENT_JAVADOC	 Content model stack. 
private	TokenNameprivate	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fCMStack	TokenNameIdentifier	 f CM Stack
=	TokenNameEQUAL	
new	TokenNamenew	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** the current state of the current content model */	TokenNameCOMMENT_JAVADOC	 the current state of the current content model 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
;	TokenNameSEMICOLON	
/** stack to hold content model states */	TokenNameCOMMENT_JAVADOC	 stack to hold content model states 
private	TokenNameprivate	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** whether the curret element is strictly assessed */	TokenNameCOMMENT_JAVADOC	 whether the curret element is strictly assessed 
private	TokenNameprivate	
boolean	TokenNameboolean	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** strict assess stack */	TokenNameCOMMENT_JAVADOC	 strict assess stack 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Temporary string buffers. */	TokenNameCOMMENT_JAVADOC	 Temporary string buffers. 
private	TokenNameprivate	
final	TokenNamefinal	
StringBuffer	TokenNameIdentifier	 String Buffer
fBuffer	TokenNameIdentifier	 f Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Whether need to append characters to fBuffer */	TokenNameCOMMENT_JAVADOC	 Whether need to append characters to fBuffer 
private	TokenNameprivate	
boolean	TokenNameboolean	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
/** Did we see any character data? */	TokenNameCOMMENT_JAVADOC	 Did we see any character data? 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** stack to record if we saw character data */	TokenNameCOMMENT_JAVADOC	 stack to record if we saw character data 
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Did we see non-whitespace character data? */	TokenNameCOMMENT_JAVADOC	 Did we see non-whitespace character data? 
private	TokenNameprivate	
boolean	TokenNameboolean	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
/** Stack to record if we saw character data outside of element content*/	TokenNameCOMMENT_JAVADOC	 Stack to record if we saw character data outside of element content
private	TokenNameprivate	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fStringContent	TokenNameIdentifier	 f String Content
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
INITIAL_STACK_SIZE	TokenNameIdentifier	 INITIAL  STACK  SIZE
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** temporary qname */	TokenNameCOMMENT_JAVADOC	 temporary qname 
private	TokenNameprivate	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
fTempQName	TokenNameIdentifier	 f Temp Q Name
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** value of the "root-type-definition" property. */	TokenNameCOMMENT_JAVADOC	 value of the "root-type-definition" property. 
private	TokenNameprivate	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** value of the "root-element-declaration" property. */	TokenNameCOMMENT_JAVADOC	 value of the "root-element-declaration" property. 
private	TokenNameprivate	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
;	TokenNameSEMICOLON	
/** temporary validated info */	TokenNameCOMMENT_JAVADOC	 temporary validated info 
private	TokenNameprivate	
ValidatedInfo	TokenNameIdentifier	 Validated Info
fValidatedInfo	TokenNameIdentifier	 f Validated Info
=	TokenNameEQUAL	
new	TokenNamenew	
ValidatedInfo	TokenNameIdentifier	 Validated Info
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// used to validate default/fixed values against xsi:type 	TokenNameCOMMENT_LINE	used to validate default/fixed values against xsi:type 
// only need to check facets, so we set extraChecking to false (in reset) 	TokenNameCOMMENT_LINE	only need to check facets, so we set extraChecking to false (in reset) 
private	TokenNameprivate	
ValidationState	TokenNameIdentifier	 Validation State
fState4XsiType	TokenNameIdentifier	 f State4 Xsi Type
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationState	TokenNameIdentifier	 Validation State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// used to apply default/fixed values 	TokenNameCOMMENT_LINE	used to apply default/fixed values 
// only need to check id/idref/entity, so we set checkFacets to false 	TokenNameCOMMENT_LINE	only need to check id/idref/entity, so we set checkFacets to false 
private	TokenNameprivate	
ValidationState	TokenNameIdentifier	 Validation State
fState4ApplyDefault	TokenNameIdentifier	 f State4 Apply Default
=	TokenNameEQUAL	
new	TokenNamenew	
ValidationState	TokenNameIdentifier	 Validation State
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// identity constraint information 	TokenNameCOMMENT_LINE	identity constraint information 
/** * Stack of active XPath matchers for identity constraints. All * active XPath matchers are notified of startElement * and endElement callbacks in order to perform their matches. * <p> * For each element with identity constraints, the selector of * each identity constraint is activated. When the selector matches * its XPath, then all the fields of the identity constraint are * activated. * <p> * <strong>Note:</strong> Once the activation scope is left, the * XPath matchers are automatically removed from the stack of * active matchers and no longer receive callbacks. */	TokenNameCOMMENT_JAVADOC	 Stack of active XPath matchers for identity constraints. All active XPath matchers are notified of startElement and endElement callbacks in order to perform their matches. <p> For each element with identity constraints, the selector of each identity constraint is activated. When the selector matches its XPath, then all the fields of the identity constraint are activated. <p> <strong>Note:</strong> Once the activation scope is left, the XPath matchers are automatically removed from the stack of active matchers and no longer receive callbacks. 
protected	TokenNameprotected	
XPathMatcherStack	TokenNameIdentifier	 X Path Matcher Stack
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
=	TokenNameEQUAL	
new	TokenNamenew	
XPathMatcherStack	TokenNameIdentifier	 X Path Matcher Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Cache of value stores for identity constraint fields. */	TokenNameCOMMENT_JAVADOC	 Cache of value stores for identity constraint fields. 
protected	TokenNameprotected	
ValueStoreCache	TokenNameIdentifier	 Value Store Cache
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
=	TokenNameEQUAL	
new	TokenNamenew	
ValueStoreCache	TokenNameIdentifier	 Value Store Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Default constructor. */	TokenNameCOMMENT_JAVADOC	 Default constructor. 
public	TokenNamepublic	
XMLSchemaValidator	TokenNameIdentifier	 XML Schema Validator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fState4XsiType	TokenNameIdentifier	 f State4 Xsi Type
.	TokenNameDOT	
setExtraChecking	TokenNameIdentifier	 set Extra Checking
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fState4ApplyDefault	TokenNameIdentifier	 f State4 Apply Default
.	TokenNameDOT	
setFacetChecking	TokenNameIdentifier	 set Facet Checking
(	TokenNameLPAREN	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>() 	TokenNameCOMMENT_LINE	<init>() 
/* * Resets the component. The component can query the component manager * about any features and properties that affect the operation of the * component. * * @param componentManager The component manager. * * @throws SAXException Thrown by component on finitialization error. * For example, if a feature or property is * required for the operation of the component, the * component manager may throw a * SAXNotRecognizedException or a * SAXNotSupportedException. */	TokenNameCOMMENT_BLOCK	 Resets the component. The component can query the component manager about any features and properties that affect the operation of the component. * @param componentManager The component manager. * @throws SAXException Thrown by component on finitialization error. For example, if a feature or property is required for the operation of the component, the component manager may throw a SAXNotRecognizedException or a SAXNotSupportedException. 
public	TokenNamepublic	
void	TokenNamevoid	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
XMLComponentManager	TokenNameIdentifier	 XML Component Manager
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
throws	TokenNamethrows	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
{	TokenNameLBRACE	
fIdConstraint	TokenNameIdentifier	 f Id Constraint
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
//reset XSDDescription 	TokenNameCOMMENT_LINE	reset XSDDescription 
fLocationPairs	TokenNameIdentifier	 f Location Pairs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExpandedLocationPairs	TokenNameIdentifier	 f Expanded Location Pairs
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// cleanup id table 	TokenNameCOMMENT_LINE	cleanup id table 
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
resetIDTables	TokenNameIdentifier	 reset ID Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// reset schema loader 	TokenNameCOMMENT_LINE	reset schema loader 
fSchemaLoader	TokenNameIdentifier	 f Schema Loader
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// initialize state 	TokenNameCOMMENT_LINE	initialize state 
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fCurrentCM	TokenNameIdentifier	 f Current CM
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fElementDepth	TokenNameIdentifier	 f Element Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fSubElement	TokenNameIdentifier	 f Sub Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSchemaDynamicValidation	TokenNameIdentifier	 f Schema Dynamic Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// datatype normalization 	TokenNameCOMMENT_LINE	datatype normalization 
fEntityRef	TokenNameIdentifier	 f Entity Ref
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fInCDATA	TokenNameIdentifier	 f In CDATA
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get error reporter 	TokenNameCOMMENT_LINE	get error reporter 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ERROR_REPORTER	TokenNameIdentifier	 ERROR  REPORTER
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
parser_settings	TokenNameIdentifier	 parser settings
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
parser_settings	TokenNameIdentifier	 parser settings
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
PARSER_SETTINGS	TokenNameIdentifier	 PARSER  SETTINGS
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
parser_settings	TokenNameIdentifier	 parser settings
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
parser_settings	TokenNameIdentifier	 parser settings
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// parser settings have not been changed 	TokenNameCOMMENT_LINE	parser settings have not been changed 
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
addValidationState	TokenNameIdentifier	 add Validation State
(	TokenNameLPAREN	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the node limit on the SecurityManager may have changed so need to refresh. 	TokenNameCOMMENT_LINE	the node limit on the SecurityManager may have changed so need to refresh. 
nodeFactory	TokenNameIdentifier	 node Factory
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Re-parse external schema location properties. 	TokenNameCOMMENT_LINE	Re-parse external schema location properties. 
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
processExternalHints	TokenNameIdentifier	 process External Hints
(	TokenNameLPAREN	
fExternalSchemas	TokenNameIdentifier	 f External Schemas
,	TokenNameCOMMA	
fExternalNoNamespaceSchema	TokenNameIdentifier	 f External No Namespace Schema
,	TokenNameCOMMA	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
,	TokenNameCOMMA	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// pass the component manager to the factory.. 	TokenNameCOMMENT_LINE	pass the component manager to the factory.. 
nodeFactory	TokenNameIdentifier	 node Factory
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get symbol table. if it's a new one, add symbols to it. 	TokenNameCOMMENT_LINE	get symbol table. if it's a new one, add symbols to it. 
SymbolTable	TokenNameIdentifier	 Symbol Table
symbolTable	TokenNameIdentifier	 symbol Table
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SymbolTable	TokenNameIdentifier	 Symbol Table
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SYMBOL_TABLE	TokenNameIdentifier	 SYMBOL  TABLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
symbolTable	TokenNameIdentifier	 symbol Table
!=	TokenNameNOT_EQUAL	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
=	TokenNameEQUAL	
symbolTable	TokenNameIdentifier	 symbol Table
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
NAMESPACE_GROWTH	TokenNameIdentifier	 NAMESPACE  GROWTH
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
DYNAMIC_VALIDATION	TokenNameIdentifier	 DYNAMIC  VALIDATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDoValidation	TokenNameIdentifier	 f Do Validation
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fDoValidation	TokenNameIdentifier	 f Do Validation
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
VALIDATION	TokenNameIdentifier	 VALIDATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDoValidation	TokenNameIdentifier	 f Do Validation
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDoValidation	TokenNameIdentifier	 f Do Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fDoValidation	TokenNameIdentifier	 f Do Validation
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
XMLSchemaValidator	TokenNameIdentifier	 XML Schema Validator
.	TokenNameDOT	
SCHEMA_VALIDATION	TokenNameIdentifier	 SCHEMA  VALIDATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fFullChecking	TokenNameIdentifier	 f Full Checking
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
SCHEMA_FULL_CHECKING	TokenNameIdentifier	 SCHEMA  FULL  CHECKING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFullChecking	TokenNameIdentifier	 f Full Checking
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
NORMALIZE_DATA	TokenNameIdentifier	 NORMALIZE  DATA
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaElementDefault	TokenNameIdentifier	 f Schema Element Default
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
SCHEMA_ELEMENT_DEFAULT	TokenNameIdentifier	 SCHEMA  ELEMENT  DEFAULT
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaElementDefault	TokenNameIdentifier	 f Schema Element Default
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
SCHEMA_AUGMENT_PSVI	TokenNameIdentifier	 SCHEMA  AUGMENT  PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fSchemaType	TokenNameIdentifier	 f Schema Type
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
JAXP_PROPERTY_PREFIX	TokenNameIdentifier	 JAXP  PROPERTY  PREFIX
+	TokenNamePLUS	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
SCHEMA_LANGUAGE	TokenNameIdentifier	 SCHEMA  LANGUAGE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSchemaType	TokenNameIdentifier	 f Schema Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
USE_GRAMMAR_POOL_ONLY	TokenNameIdentifier	 USE  GRAMMAR  POOL  ONLY
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLEntityResolver	TokenNameIdentifier	 XML Entity Resolver
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ENTITY_MANAGER	TokenNameIdentifier	 ENTITY  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationManager	TokenNameIdentifier	 f Validation Manager
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValidationManager	TokenNameIdentifier	 Validation Manager
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
VALIDATION_MANAGER	TokenNameIdentifier	 VALIDATION  MANAGER
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
addValidationState	TokenNameIdentifier	 add Validation State
(	TokenNameLPAREN	
fValidationState	TokenNameIdentifier	 f Validation State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setSymbolTable	TokenNameIdentifier	 set Symbol Table
(	TokenNameLPAREN	
fSymbolTable	TokenNameIdentifier	 f Symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
rootType	TokenNameIdentifier	 root Type
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ROOT_TYPE_DEF	TokenNameIdentifier	 ROOT  TYPE  DEF
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rootType	TokenNameIdentifier	 root Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
rootType	TokenNameIdentifier	 root Type
instanceof	TokenNameinstanceof	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
rootType	TokenNameIdentifier	 root Type
;	TokenNameSEMICOLON	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
)	TokenNameRPAREN	
rootType	TokenNameIdentifier	 root Type
;	TokenNameSEMICOLON	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
rootDecl	TokenNameIdentifier	 root Decl
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
ROOT_ELEMENT_DECL	TokenNameIdentifier	 ROOT  ELEMENT  DECL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rootDecl	TokenNameIdentifier	 root Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
rootDecl	TokenNameIdentifier	 root Decl
instanceof	TokenNameinstanceof	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
rootDecl	TokenNameIdentifier	 root Decl
;	TokenNameSEMICOLON	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
rootDecl	TokenNameIdentifier	 root Decl
;	TokenNameSEMICOLON	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
boolean	TokenNameboolean	
ignoreXSIType	TokenNameIdentifier	 ignore XSI Type
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
ignoreXSIType	TokenNameIdentifier	 ignore XSI Type
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
IGNORE_XSI_TYPE	TokenNameIdentifier	 IGNORE  XSI  TYPE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ignoreXSIType	TokenNameIdentifier	 ignore XSI Type
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// An initial value of -1 means that the root element considers itself 	TokenNameCOMMENT_LINE	An initial value of -1 means that the root element considers itself 
// below the depth where xsi:type stopped being ignored (which means that 	TokenNameCOMMENT_LINE	below the depth where xsi:type stopped being ignored (which means that 
// xsi:type attributes will not be ignored for the entire document) 	TokenNameCOMMENT_LINE	xsi:type attributes will not be ignored for the entire document) 
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
=	TokenNameEQUAL	
ignoreXSIType	TokenNameIdentifier	 ignore XSI Type
?	TokenNameQUESTION	
0	TokenNameIntegerLiteral	
:	TokenNameCOLON	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
IDENTITY_CONSTRAINT_CHECKING	TokenNameIdentifier	 IDENTITY  CONSTRAINT  CHECKING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setIdIdrefChecking	TokenNameIdentifier	 set Id Idref Checking
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
ID_IDREF_CHECKING	TokenNameIdentifier	 ID  IDREF  CHECKING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setIdIdrefChecking	TokenNameIdentifier	 set Id Idref Checking
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setUnparsedEntityChecking	TokenNameIdentifier	 set Unparsed Entity Checking
(	TokenNameLPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getFeature	TokenNameIdentifier	 get Feature
(	TokenNameLPAREN	
UNPARSED_ENTITY_CHECKING	TokenNameIdentifier	 UNPARSED  ENTITY  CHECKING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setUnparsedEntityChecking	TokenNameIdentifier	 set Unparsed Entity Checking
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get schema location properties 	TokenNameCOMMENT_LINE	get schema location properties 
try	TokenNametry	
{	TokenNameLBRACE	
fExternalSchemas	TokenNameIdentifier	 f External Schemas
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SCHEMA_LOCATION	TokenNameIdentifier	 SCHEMA  LOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fExternalNoNamespaceSchema	TokenNameIdentifier	 f External No Namespace Schema
=	TokenNameEQUAL	
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
SCHEMA_NONS_LOCATION	TokenNameIdentifier	 SCHEMA  NONS  LOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fExternalSchemas	TokenNameIdentifier	 f External Schemas
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fExternalNoNamespaceSchema	TokenNameIdentifier	 f External No Namespace Schema
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// store the external schema locations. they are set when reset is called, 	TokenNameCOMMENT_LINE	store the external schema locations. they are set when reset is called, 
// so any other schemaLocation declaration for the same namespace will be 	TokenNameCOMMENT_LINE	so any other schemaLocation declaration for the same namespace will be 
// effectively ignored. becuase we choose to take first location hint 	TokenNameCOMMENT_LINE	effectively ignored. becuase we choose to take first location hint 
// available for a particular namespace. 	TokenNameCOMMENT_LINE	available for a particular namespace. 
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
processExternalHints	TokenNameIdentifier	 process External Hints
(	TokenNameLPAREN	
fExternalSchemas	TokenNameIdentifier	 f External Schemas
,	TokenNameCOMMA	
fExternalNoNamespaceSchema	TokenNameIdentifier	 f External No Namespace Schema
,	TokenNameCOMMA	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
,	TokenNameCOMMA	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
fJaxpSchemaSource	TokenNameIdentifier	 f Jaxp Schema Source
=	TokenNameEQUAL	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
JAXP_SCHEMA_SOURCE	TokenNameIdentifier	 JAXP  SCHEMA  SOURCE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fJaxpSchemaSource	TokenNameIdentifier	 f Jaxp Schema Source
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// clear grammars, and put the one for schema namespace there 	TokenNameCOMMENT_LINE	clear grammars, and put the one for schema namespace there 
try	TokenNametry	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLGrammarPool	TokenNameIdentifier	 XML Grammar Pool
)	TokenNameRPAREN	
componentManager	TokenNameIdentifier	 component Manager
.	TokenNameDOT	
getProperty	TokenNameIdentifier	 get Property
(	TokenNameLPAREN	
XMLGRAMMAR_POOL	TokenNameIdentifier	 XMLGRAMMAR  POOL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
XMLConfigurationException	TokenNameIdentifier	 XML Configuration Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fState4XsiType	TokenNameIdentifier	 f State4 Xsi Type
.	TokenNameDOT	
setSymbolTable	TokenNameIdentifier	 set Symbol Table
(	TokenNameLPAREN	
symbolTable	TokenNameIdentifier	 symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fState4ApplyDefault	TokenNameIdentifier	 f State4 Apply Default
.	TokenNameDOT	
setSymbolTable	TokenNameIdentifier	 set Symbol Table
(	TokenNameLPAREN	
symbolTable	TokenNameIdentifier	 symbol Table
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reset(XMLComponentManager) 	TokenNameCOMMENT_LINE	reset(XMLComponentManager) 
// 	TokenNameCOMMENT_LINE	 
// FieldActivator methods 	TokenNameCOMMENT_LINE	FieldActivator methods 
// 	TokenNameCOMMENT_LINE	 
/** * Start the value scope for the specified identity constraint. This * method is called when the selector matches in order to initialize * the value store. * * @param identityConstraint The identity constraint. */	TokenNameCOMMENT_JAVADOC	 Start the value scope for the specified identity constraint. This method is called when the selector matches in order to initialize the value store. * @param identityConstraint The identity constraint. 
public	TokenNamepublic	
void	TokenNamevoid	
startValueScopeFor	TokenNameIdentifier	 start Value Scope For
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
identityConstraint	TokenNameIdentifier	 identity Constraint
,	TokenNameCOMMA	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
valueStore	TokenNameIdentifier	 value Store
=	TokenNameEQUAL	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
getValueStoreFor	TokenNameIdentifier	 get Value Store For
(	TokenNameLPAREN	
identityConstraint	TokenNameIdentifier	 identity Constraint
,	TokenNameCOMMA	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
valueStore	TokenNameIdentifier	 value Store
.	TokenNameDOT	
startValueScope	TokenNameIdentifier	 start Value Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startValueScopeFor(IdentityConstraint identityConstraint) 	TokenNameCOMMENT_LINE	startValueScopeFor(IdentityConstraint identityConstraint) 
/** * Request to activate the specified field. This method returns the * matcher for the field. * * @param field The field to activate. */	TokenNameCOMMENT_JAVADOC	 Request to activate the specified field. This method returns the matcher for the field. * @param field The field to activate. 
public	TokenNamepublic	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
activateField	TokenNameIdentifier	 activate Field
(	TokenNameLPAREN	
Field	TokenNameIdentifier	 Field
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStore	TokenNameIdentifier	 Value Store
valueStore	TokenNameIdentifier	 value Store
=	TokenNameEQUAL	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
getValueStoreFor	TokenNameIdentifier	 get Value Store For
(	TokenNameLPAREN	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
getIdentityConstraint	TokenNameIdentifier	 get Identity Constraint
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
createMatcher	TokenNameIdentifier	 create Matcher
(	TokenNameLPAREN	
valueStore	TokenNameIdentifier	 value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
addMatcher	TokenNameIdentifier	 add Matcher
(	TokenNameLPAREN	
matcher	TokenNameIdentifier	 matcher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
matcher	TokenNameIdentifier	 matcher
.	TokenNameDOT	
startDocumentFragment	TokenNameIdentifier	 start Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
matcher	TokenNameIdentifier	 matcher
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// activateField(Field):XPathMatcher 	TokenNameCOMMENT_LINE	activateField(Field):XPathMatcher 
/** * Ends the value scope for the specified identity constraint. * * @param identityConstraint The identity constraint. */	TokenNameCOMMENT_JAVADOC	 Ends the value scope for the specified identity constraint. * @param identityConstraint The identity constraint. 
public	TokenNamepublic	
void	TokenNamevoid	
endValueScopeFor	TokenNameIdentifier	 end Value Scope For
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
identityConstraint	TokenNameIdentifier	 identity Constraint
,	TokenNameCOMMA	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
valueStore	TokenNameIdentifier	 value Store
=	TokenNameEQUAL	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
getValueStoreFor	TokenNameIdentifier	 get Value Store For
(	TokenNameLPAREN	
identityConstraint	TokenNameIdentifier	 identity Constraint
,	TokenNameCOMMA	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
valueStore	TokenNameIdentifier	 value Store
.	TokenNameDOT	
endValueScope	TokenNameIdentifier	 end Value Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endValueScopeFor(IdentityConstraint) 	TokenNameCOMMENT_LINE	endValueScopeFor(IdentityConstraint) 
// a utility method for Identity constraints 	TokenNameCOMMENT_LINE	a utility method for Identity constraints 
private	TokenNameprivate	
void	TokenNamevoid	
activateSelectorFor	TokenNameIdentifier	 activate Selector For
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
ic	TokenNameIdentifier	 ic
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Selector	TokenNameIdentifier	 Selector
selector	TokenNameIdentifier	 selector
=	TokenNameEQUAL	
ic	TokenNameIdentifier	 ic
.	TokenNameDOT	
getSelector	TokenNameIdentifier	 get Selector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
FieldActivator	TokenNameIdentifier	 Field Activator
activator	TokenNameIdentifier	 activator
=	TokenNameEQUAL	
this	TokenNamethis	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
selector	TokenNameIdentifier	 selector
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
selector	TokenNameIdentifier	 selector
.	TokenNameDOT	
createMatcher	TokenNameIdentifier	 create Matcher
(	TokenNameLPAREN	
activator	TokenNameIdentifier	 activator
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
addMatcher	TokenNameIdentifier	 add Matcher
(	TokenNameLPAREN	
matcher	TokenNameIdentifier	 matcher
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
matcher	TokenNameIdentifier	 matcher
.	TokenNameDOT	
startDocumentFragment	TokenNameIdentifier	 start Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Implements XSElementDeclHelper interface 	TokenNameCOMMENT_LINE	Implements XSElementDeclHelper interface 
public	TokenNamepublic	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sGrammar	TokenNameIdentifier	 s Grammar
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ELEMENT	TokenNameIdentifier	 CONTEXT  ELEMENT
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sGrammar	TokenNameIdentifier	 s Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Protected methods 	TokenNameCOMMENT_LINE	Protected methods 
// 	TokenNameCOMMENT_LINE	 
/** ensure element stack capacity */	TokenNameCOMMENT_JAVADOC	 ensure element stack capacity 
void	TokenNamevoid	
ensureStackCapacity	TokenNameIdentifier	 ensure Stack Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
newSize	TokenNameIdentifier	 new Size
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
+	TokenNamePLUS	
INC_STACK_SIZE	TokenNameIdentifier	 INC  STACK  SIZE
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayB	TokenNameIdentifier	 new Array B
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayB	TokenNameIdentifier	 new Array B
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
=	TokenNameEQUAL	
newArrayB	TokenNameIdentifier	 new Array B
;	TokenNameSEMICOLON	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayE	TokenNameIdentifier	 new Array E
=	TokenNameEQUAL	
new	TokenNamenew	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayE	TokenNameIdentifier	 new Array E
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
=	TokenNameEQUAL	
newArrayE	TokenNameIdentifier	 new Array E
;	TokenNameSEMICOLON	
newArrayB	TokenNameIdentifier	 new Array B
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fNilStack	TokenNameIdentifier	 f Nil Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayB	TokenNameIdentifier	 new Array B
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNilStack	TokenNameIdentifier	 f Nil Stack
=	TokenNameEQUAL	
newArrayB	TokenNameIdentifier	 new Array B
;	TokenNameSEMICOLON	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayN	TokenNameIdentifier	 new Array N
=	TokenNameEQUAL	
new	TokenNamenew	
XSNotationDecl	TokenNameIdentifier	 XS Notation Decl
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fNotationStack	TokenNameIdentifier	 f Notation Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayN	TokenNameIdentifier	 new Array N
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNotationStack	TokenNameIdentifier	 f Notation Stack
=	TokenNameEQUAL	
newArrayN	TokenNameIdentifier	 new Array N
;	TokenNameSEMICOLON	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayT	TokenNameIdentifier	 new Array T
=	TokenNameEQUAL	
new	TokenNamenew	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fTypeStack	TokenNameIdentifier	 f Type Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayT	TokenNameIdentifier	 new Array T
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fTypeStack	TokenNameIdentifier	 f Type Stack
=	TokenNameEQUAL	
newArrayT	TokenNameIdentifier	 new Array T
;	TokenNameSEMICOLON	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayC	TokenNameIdentifier	 new Array C
=	TokenNameEQUAL	
new	TokenNamenew	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fCMStack	TokenNameIdentifier	 f CM Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayC	TokenNameIdentifier	 new Array C
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCMStack	TokenNameIdentifier	 f CM Stack
=	TokenNameEQUAL	
newArrayC	TokenNameIdentifier	 new Array C
;	TokenNameSEMICOLON	
newArrayB	TokenNameIdentifier	 new Array B
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayB	TokenNameIdentifier	 new Array B
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
=	TokenNameEQUAL	
newArrayB	TokenNameIdentifier	 new Array B
;	TokenNameSEMICOLON	
newArrayB	TokenNameIdentifier	 new Array B
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fStringContent	TokenNameIdentifier	 f String Content
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayB	TokenNameIdentifier	 new Array B
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStringContent	TokenNameIdentifier	 f String Content
=	TokenNameEQUAL	
newArrayB	TokenNameIdentifier	 new Array B
;	TokenNameSEMICOLON	
newArrayB	TokenNameIdentifier	 new Array B
=	TokenNameEQUAL	
new	TokenNamenew	
boolean	TokenNameboolean	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayB	TokenNameIdentifier	 new Array B
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
=	TokenNameEQUAL	
newArrayB	TokenNameIdentifier	 new Array B
;	TokenNameSEMICOLON	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newArrayIA	TokenNameIdentifier	 new Array IA
=	TokenNameEQUAL	
new	TokenNamenew	
int	TokenNameint	
[	TokenNameLBRACKET	
newSize	TokenNameIdentifier	 new Size
]	TokenNameRBRACKET	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newArrayIA	TokenNameIdentifier	 new Array IA
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
=	TokenNameEQUAL	
newArrayIA	TokenNameIdentifier	 new Array IA
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ensureStackCapacity 	TokenNameCOMMENT_LINE	ensureStackCapacity 
// handle start document 	TokenNameCOMMENT_LINE	handle start document 
void	TokenNamevoid	
handleStartDocument	TokenNameIdentifier	 handle Start Document
(	TokenNameLPAREN	
XMLLocator	TokenNameIdentifier	 XML Locator
locator	TokenNameIdentifier	 locator
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
encoding	TokenNameIdentifier	 encoding
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fGrammars	TokenNameIdentifier	 f Grammars
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fSchemaInformation	TokenNameIdentifier	 f Schema Information
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// handleStartDocument(XMLLocator,String) 	TokenNameCOMMENT_LINE	handleStartDocument(XMLLocator,String) 
void	TokenNamevoid	
handleEndDocument	TokenNameIdentifier	 handle End Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// handleEndDocument() 	TokenNameCOMMENT_LINE	handleEndDocument() 
// handle character contents 	TokenNameCOMMENT_LINE	handle character contents 
// returns the normalized string if possible, otherwise the original string 	TokenNameCOMMENT_LINE	returns the normalized string if possible, otherwise the original string 
XMLString	TokenNameIdentifier	 XML String
handleCharacters	TokenNameIdentifier	 handle Characters
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
fSawText	TokenNameIdentifier	 f Saw Text
||	TokenNameOR_OR	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Note: data in EntityRef and CDATA is normalized as well 	TokenNameCOMMENT_LINE	Note: data in EntityRef and CDATA is normalized as well 
// if whitespace == -1 skip normalization, because it is a complexType 	TokenNameCOMMENT_LINE	if whitespace == -1 skip normalization, because it is a complexType 
// or a union type. 	TokenNameCOMMENT_LINE	or a union type. 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
&&	TokenNameAND_AND	
fWhiteSpace	TokenNameIdentifier	 f White Space
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fWhiteSpace	TokenNameIdentifier	 f White Space
!=	TokenNameNOT_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
WS_PRESERVE	TokenNameIdentifier	 WS  PRESERVE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// normalize data 	TokenNameCOMMENT_LINE	normalize data 
normalizeWhitespace	TokenNameIdentifier	 normalize Whitespace
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
,	TokenNameCOMMA	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
text	TokenNameIdentifier	 text
=	TokenNameEQUAL	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
)	TokenNameRPAREN	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
,	TokenNameCOMMA	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// When it's a complex type with element-only content, we need to 	TokenNameCOMMENT_LINE	When it's a complex type with element-only content, we need to 
// find out whether the content contains any non-whitespace character. 	TokenNameCOMMENT_LINE	find out whether the content contains any non-whitespace character. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// data outside of element content 	TokenNameCOMMENT_LINE	data outside of element content 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
text	TokenNameIdentifier	 text
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
text	TokenNameIdentifier	 text
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handleCharacters(XMLString) 	TokenNameCOMMENT_LINE	handleCharacters(XMLString) 
/** * Normalize whitespace in an XMLString according to the rules defined * in XML Schema specifications. * @param value The string to normalize. * @param collapse replace or collapse */	TokenNameCOMMENT_JAVADOC	 Normalize whitespace in an XMLString according to the rules defined in XML Schema specifications. @param value The string to normalize. @param collapse replace or collapse 
private	TokenNameprivate	
void	TokenNamevoid	
normalizeWhitespace	TokenNameIdentifier	 normalize Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
collapse	TokenNameIdentifier	 collapse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
collapse	TokenNameIdentifier	 collapse
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
sawNonWS	TokenNameIdentifier	 saw Non WS
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
leading	TokenNameIdentifier	 leading
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
trailing	TokenNameIdentifier	 trailing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
+	TokenNamePLUS	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
// ensure the ch array is big enough 	TokenNameCOMMENT_LINE	ensure the ch array is big enough 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// don't include the leading ' ' for now. might include it later. 	TokenNameCOMMENT_LINE	don't include the leading ' ' for now. might include it later. 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSpace	TokenNameIdentifier	 skip Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// take the first whitespace as a space and skip the others 	TokenNameCOMMENT_LINE	take the first whitespace as a space and skip the others 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
' '	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
collapse	TokenNameIdentifier	 collapse
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
sawNonWS	TokenNameIdentifier	 saw Non WS
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// this is a leading whitespace, record it 	TokenNameCOMMENT_LINE	this is a leading whitespace, record it 
leading	TokenNameIdentifier	 leading
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
sawNonWS	TokenNameIdentifier	 saw Non WS
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
skipSpace	TokenNameIdentifier	 skip Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if we finished on a space trim it but also record it 	TokenNameCOMMENT_LINE	if we finished on a space trim it but also record it 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
trailing	TokenNameIdentifier	 trailing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
leading	TokenNameIdentifier	 leading
&&	TokenNameAND_AND	
!	TokenNameNOT	
fFirstChunk	TokenNameIdentifier	 f First Chunk
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if all we had was whitespace we skipped record it as 	TokenNameCOMMENT_LINE	if all we had was whitespace we skipped record it as 
// trailing whitespace as well 	TokenNameCOMMENT_LINE	trailing whitespace as well 
trailing	TokenNameIdentifier	 trailing
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fFirstChunk	TokenNameIdentifier	 f First Chunk
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fWhiteSpace	TokenNameIdentifier	 f White Space
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
WS_COLLAPSE	TokenNameIdentifier	 WS  COLLAPSE
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fTrailing	TokenNameIdentifier	 f Trailing
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// previous chunk ended on whitespace 	TokenNameCOMMENT_LINE	previous chunk ended on whitespace 
// insert whitespace 	TokenNameCOMMENT_LINE	insert whitespace 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
' '	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
leading	TokenNameIdentifier	 leading
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// previous chunk ended on character, 	TokenNameCOMMENT_LINE	previous chunk ended on character, 
// this chunk starts with whitespace 	TokenNameCOMMENT_LINE	this chunk starts with whitespace 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
' '	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// The length includes the leading ' '. Now removing it. 	TokenNameCOMMENT_LINE	The length includes the leading ' '. Now removing it. 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
-=	TokenNameMINUS_EQUAL	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
;	TokenNameSEMICOLON	
fTrailing	TokenNameIdentifier	 f Trailing
=	TokenNameEQUAL	
trailing	TokenNameIdentifier	 trailing
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
trailing	TokenNameIdentifier	 trailing
||	TokenNameOR_OR	
sawNonWS	TokenNameIdentifier	 saw Non WS
)	TokenNameRPAREN	
fFirstChunk	TokenNameIdentifier	 f First Chunk
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
normalizeWhitespace	TokenNameIdentifier	 normalize Whitespace
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
boolean	TokenNameboolean	
collapse	TokenNameIdentifier	 collapse
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
collapse	TokenNameIdentifier	 collapse
;	TokenNameSEMICOLON	
char	TokenNamechar	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// ensure the ch array is big enough 	TokenNameCOMMENT_LINE	ensure the ch array is big enough 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
size	TokenNameIdentifier	 size
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
c	TokenNameIdentifier	 c
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
charAt	TokenNameIdentifier	 char At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
isSpace	TokenNameIdentifier	 is Space
(	TokenNameLPAREN	
c	TokenNameIdentifier	 c
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
skipSpace	TokenNameIdentifier	 skip Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// take the first whitespace as a space and skip the others 	TokenNameCOMMENT_LINE	take the first whitespace as a space and skip the others 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
' '	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
collapse	TokenNameIdentifier	 collapse
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
[	TokenNameLBRACKET	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
c	TokenNameIdentifier	 c
;	TokenNameSEMICOLON	
skipSpace	TokenNameIdentifier	 skip Space
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
skipSpace	TokenNameIdentifier	 skip Space
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
// if we finished on a space trim it but also record it 	TokenNameCOMMENT_LINE	if we finished on a space trim it but also record it 
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// handle ignorable whitespace 	TokenNameCOMMENT_LINE	handle ignorable whitespace 
void	TokenNamevoid	
handleIgnorableWhitespace	TokenNameIdentifier	 handle Ignorable Whitespace
(	TokenNameLPAREN	
XMLString	TokenNameIdentifier	 XML String
text	TokenNameIdentifier	 text
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// REVISIT: the same process needs to be performed as handleCharacters. 	TokenNameCOMMENT_LINE	REVISIT: the same process needs to be performed as handleCharacters. 
// only it's simpler here: we know all characters are whitespaces. 	TokenNameCOMMENT_LINE	only it's simpler here: we know all characters are whitespaces. 
}	TokenNameRBRACE	
// handleIgnorableWhitespace(XMLString) 	TokenNameCOMMENT_LINE	handleIgnorableWhitespace(XMLString) 
/** Handle element. */	TokenNameCOMMENT_JAVADOC	 Handle element. 
Augmentations	TokenNameIdentifier	 Augmentations
handleStartElement	TokenNameIdentifier	 handle Start Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"==>handleStartElement: "	TokenNameStringLiteral	==>handleStartElement: 
+	TokenNamePLUS	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// root element 	TokenNameCOMMENT_LINE	root element 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fValidationManager	TokenNameIdentifier	 f Validation Manager
.	TokenNameDOT	
isGrammarFound	TokenNameIdentifier	 is Grammar Found
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSchemaType	TokenNameIdentifier	 f Schema Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// schemaType is not specified 	TokenNameCOMMENT_LINE	schemaType is not specified 
// if a DTD grammar is found, we do the same thing as Dynamic: 	TokenNameCOMMENT_LINE	if a DTD grammar is found, we do the same thing as Dynamic: 
// if a schema grammar is found, validation is performed; 	TokenNameCOMMENT_LINE	if a schema grammar is found, validation is performed; 
// otherwise, skip the whole document. 	TokenNameCOMMENT_LINE	otherwise, skip the whole document. 
fSchemaDynamicValidation	TokenNameIdentifier	 f Schema Dynamic Validation
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// [1] Either schemaType is DTD, and in this case validate/schema is turned off 	TokenNameCOMMENT_LINE	[1] Either schemaType is DTD, and in this case validate/schema is turned off 
// [2] Validating against XML Schemas only 	TokenNameCOMMENT_LINE	[2] Validating against XML Schemas only 
// [a] dynamic validation is false: report error if SchemaGrammar is not found 	TokenNameCOMMENT_LINE	[a] dynamic validation is false: report error if SchemaGrammar is not found 
// [b] dynamic validation is true: if grammar is not found ignore. 	TokenNameCOMMENT_LINE	[b] dynamic validation is true: if grammar is not found ignore. 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes, 	TokenNameCOMMENT_LINE	get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes, 
// parse them to get the grammars. But only do this if the grammar can grow. 	TokenNameCOMMENT_LINE	parse them to get the grammars. But only do this if the grammar can grow. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
sLocation	TokenNameIdentifier	 s Location
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_SCHEMALOCATION	TokenNameIdentifier	 XSI  SCHEMALOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
nsLocation	TokenNameIdentifier	 ns Location
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NONAMESPACESCHEMALOCATION	TokenNameIdentifier	 XSI  NONAMESPACESCHEMALOCATION
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//store the location hints.. we need to do it so that we can defer the loading of grammar until 	TokenNameCOMMENT_LINE	store the location hints.. we need to do it so that we can defer the loading of grammar until 
//there is a reference to a component from that namespace. To provide location hints to the 	TokenNameCOMMENT_LINE	there is a reference to a component from that namespace. To provide location hints to the 
//application for a namespace 	TokenNameCOMMENT_LINE	application for a namespace 
storeLocations	TokenNameIdentifier	 store Locations
(	TokenNameLPAREN	
sLocation	TokenNameIdentifier	 s Location
,	TokenNameCOMMA	
nsLocation	TokenNameIdentifier	 ns Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we are in the content of "skip", then just skip this element 	TokenNameCOMMENT_LINE	if we are in the content of "skip", then just skip this element 
// REVISIT: is this the correct behaviour for ID constraints? -NG 	TokenNameCOMMENT_LINE	REVISIT: is this the correct behaviour for ID constraints? -NG 
if	TokenNameif	
(	TokenNameLPAREN	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fElementDepth	TokenNameIdentifier	 f Element Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we are not skipping this element, and there is a content model, 	TokenNameCOMMENT_LINE	if we are not skipping this element, and there is a content model, 
// we try to find the corresponding decl object for this element. 	TokenNameCOMMENT_LINE	we try to find the corresponding decl object for this element. 
// the reason we move this part of code here is to make sure the 	TokenNameCOMMENT_LINE	the reason we move this part of code here is to make sure the 
// error reported here (if any) is stored within the parent element's 	TokenNameCOMMENT_LINE	error reported here (if any) is stored within the parent element's 
// context, instead of that of the current element. 	TokenNameCOMMENT_LINE	context, instead of that of the current element. 
Object	TokenNameIdentifier	 Object
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentCM	TokenNameIdentifier	 f Current CM
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
decl	TokenNameIdentifier	 decl
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
oneTransition	TokenNameIdentifier	 one Transition
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
,	TokenNameCOMMA	
fSubGroupHandler	TokenNameIdentifier	 f Sub Group Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// it could be an element decl or a wildcard decl 	TokenNameCOMMENT_LINE	it could be an element decl or a wildcard decl 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
XSCMValidator	TokenNameIdentifier	 XSCM Validator
.	TokenNameDOT	
FIRST_ERROR	TokenNameIdentifier	 FIRST  ERROR
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
//REVISIT: is it the only case we will have particle = null? 	TokenNameCOMMENT_LINE	REVISIT: is it the only case we will have particle = null? 
Vector	TokenNameIdentifier	 Vector
next	TokenNameIdentifier	 next
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fParticle	TokenNameIdentifier	 f Particle
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
whatCanGoHere	TokenNameIdentifier	 what Can Go Here
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
expectedStr	TokenNameIdentifier	 expected Str
(	TokenNameLPAREN	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
occurenceInfo	TokenNameIdentifier	 occurence Info
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
occurenceInfo	TokenNameIdentifier	 occurence Info
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
minOccurs	TokenNameIdentifier	 min Occurs
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
maxOccurs	TokenNameIdentifier	 max Occurs
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Check if this is a violation of minOccurs 	TokenNameCOMMENT_LINE	Check if this is a violation of minOccurs 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
minOccurs	TokenNameIdentifier	 min Occurs
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.h"	TokenNameStringLiteral	cvc-complex-type.2.4.h
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
getTermName	TokenNameIdentifier	 get Term Name
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.g"	TokenNameStringLiteral	cvc-complex-type.2.4.g
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
getTermName	TokenNameIdentifier	 get Term Name
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Check if this is a violation of maxOccurs 	TokenNameCOMMENT_LINE	Check if this is a violation of maxOccurs 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
maxOccurs	TokenNameIdentifier	 max Occurs
&&	TokenNameAND_AND	
maxOccurs	TokenNameIdentifier	 max Occurs
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.e"	TokenNameStringLiteral	cvc-complex-type.2.4.e
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
maxOccurs	TokenNameIdentifier	 max Occurs
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.a"	TokenNameStringLiteral	cvc-complex-type.2.4.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.a"	TokenNameStringLiteral	cvc-complex-type.2.4.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
occurenceInfo	TokenNameIdentifier	 occurence Info
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
occurenceInfo	TokenNameIdentifier	 occurence Info
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
maxOccurs	TokenNameIdentifier	 max Occurs
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
1	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Check if this is a violation of maxOccurs 	TokenNameCOMMENT_LINE	Check if this is a violation of maxOccurs 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
>=	TokenNameGREATER_EQUAL	
maxOccurs	TokenNameIdentifier	 max Occurs
&&	TokenNameAND_AND	
maxOccurs	TokenNameIdentifier	 max Occurs
!=	TokenNameNOT_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
OCCURRENCE_UNBOUNDED	TokenNameIdentifier	 OCCURRENCE  UNBOUNDED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.f"	TokenNameStringLiteral	cvc-complex-type.2.4.f
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
maxOccurs	TokenNameIdentifier	 max Occurs
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.d"	TokenNameStringLiteral	cvc-complex-type.2.4.d
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.d"	TokenNameStringLiteral	cvc-complex-type.2.4.d
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if it's not the root element, we push the current states in the stacks 	TokenNameCOMMENT_LINE	if it's not the root element, we push the current states in the stacks 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureStackCapacity	TokenNameIdentifier	 ensure Stack Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fSubElement	TokenNameIdentifier	 f Sub Element
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
;	TokenNameSEMICOLON	
fNilStack	TokenNameIdentifier	 f Nil Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fNil	TokenNameIdentifier	 f Nil
;	TokenNameSEMICOLON	
fNotationStack	TokenNameIdentifier	 f Notation Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fNotation	TokenNameIdentifier	 f Notation
;	TokenNameSEMICOLON	
fTypeStack	TokenNameIdentifier	 f Type Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
;	TokenNameSEMICOLON	
fCMStack	TokenNameIdentifier	 f CM Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
;	TokenNameSEMICOLON	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
;	TokenNameSEMICOLON	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fSawText	TokenNameIdentifier	 f Saw Text
;	TokenNameSEMICOLON	
fStringContent	TokenNameIdentifier	 f String Content
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// increase the element depth after we've saved 	TokenNameCOMMENT_LINE	increase the element depth after we've saved 
// all states for the parent element 	TokenNameCOMMENT_LINE	all states for the parent element 
fElementDepth	TokenNameIdentifier	 f Element Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// and the buffer to hold the value of the element 	TokenNameCOMMENT_LINE	and the buffer to hold the value of the element 
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// check what kind of declaration the "decl" from 	TokenNameCOMMENT_LINE	check what kind of declaration the "decl" from 
// oneTransition() maps to 	TokenNameCOMMENT_LINE	oneTransition() maps to 
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
decl	TokenNameIdentifier	 decl
instanceof	TokenNameinstanceof	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
)	TokenNameRPAREN	
decl	TokenNameIdentifier	 decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
wildcard	TokenNameIdentifier	 wildcard
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
)	TokenNameRPAREN	
decl	TokenNameIdentifier	 decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if the wildcard is skip, then return 	TokenNameCOMMENT_LINE	if the wildcard is skip, then return 
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
PC_SKIP	TokenNameIdentifier	 PC  SKIP
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1.1.1.1 An element declaration was stipulated by the processor 	TokenNameCOMMENT_LINE	1.1.1.1 An element declaration was stipulated by the processor 
if	TokenNameif	
(	TokenNameLPAREN	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
fRootElementDeclaration	TokenNameIdentifier	 f Root Element Declaration
;	TokenNameSEMICOLON	
checkElementMatchesRootElementDecl	TokenNameIdentifier	 check Element Matches Root Element Decl
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processRootElementDeclQName	TokenNameIdentifier	 process Root Element Decl Q Name
(	TokenNameLPAREN	
fRootElementDeclQName	TokenNameIdentifier	 f Root Element Decl Q Name
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 1.2.1.1 A type definition was stipulated by the processor 	TokenNameCOMMENT_LINE	1.2.1.1 A type definition was stipulated by the processor 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
fRootTypeDefinition	TokenNameIdentifier	 f Root Type Definition
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processRootTypeQName	TokenNameIdentifier	 process Root Type Q Name
(	TokenNameLPAREN	
fRootTypeQName	TokenNameIdentifier	 f Root Type Q Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// if there was no processor stipulated type 	TokenNameCOMMENT_LINE	if there was no processor stipulated type 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// try again to get the element decl: 	TokenNameCOMMENT_LINE	try again to get the element decl: 
// case 1: find declaration for root element 	TokenNameCOMMENT_LINE	case 1: find declaration for root element 
// case 2: find declaration for element from another namespace 	TokenNameCOMMENT_LINE	case 2: find declaration for element from another namespace 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// try to find schema grammar by different means.. 	TokenNameCOMMENT_LINE	try to find schema grammar by different means.. 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
sGrammar	TokenNameIdentifier	 s Grammar
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ELEMENT	TokenNameIdentifier	 CONTEXT  ELEMENT
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
sGrammar	TokenNameIdentifier	 s Grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
sGrammar	TokenNameIdentifier	 s Grammar
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// then get the type 	TokenNameCOMMENT_LINE	then get the type 
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// check if we should be ignoring xsi:type on this element 	TokenNameCOMMENT_LINE	check if we should be ignoring xsi:type on this element 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// process xsi:type attribute information 	TokenNameCOMMENT_LINE	process xsi:type attribute information 
String	TokenNameIdentifier	 String
xsiType	TokenNameIdentifier	 xsi Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
>=	TokenNameGREATER_EQUAL	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
xsiType	TokenNameIdentifier	 xsi Type
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if no decl/type found for the current element 	TokenNameCOMMENT_LINE	if no decl/type found for the current element 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
xsiType	TokenNameIdentifier	 xsi Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if this is the validation root, report an error, because 	TokenNameCOMMENT_LINE	if this is the validation root, report an error, because 
// we can't find eith decl or type for this element 	TokenNameCOMMENT_LINE	we can't find eith decl or type for this element 
// REVISIT: should we report error, or warning? 	TokenNameCOMMENT_LINE	REVISIT: should we report error, or warning? 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for dynamic validation, skip the whole content, 	TokenNameCOMMENT_LINE	for dynamic validation, skip the whole content, 
// because no grammar was found. 	TokenNameCOMMENT_LINE	because no grammar was found. 
if	TokenNameif	
(	TokenNameLPAREN	
fDynamicValidation	TokenNameIdentifier	 f Dynamic Validation
||	TokenNameOR_OR	
fSchemaDynamicValidation	TokenNameIdentifier	 f Schema Dynamic Validation
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no schema grammar was found, but it's either dynamic 	TokenNameCOMMENT_LINE	no schema grammar was found, but it's either dynamic 
// validation, or another kind of grammar was found (DTD, 	TokenNameCOMMENT_LINE	validation, or another kind of grammar was found (DTD, 
// for example). The intended behavior here is to skip 	TokenNameCOMMENT_LINE	for example). The intended behavior here is to skip 
// the whole document. To improve performance, we try to 	TokenNameCOMMENT_LINE	the whole document. To improve performance, we try to 
// remove the validator from the pipeline, since it's not 	TokenNameCOMMENT_LINE	remove the validator from the pipeline, since it's not 
// supposed to do anything. 	TokenNameCOMMENT_LINE	supposed to do anything. 
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentSource	TokenNameIdentifier	 f Document Source
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fDocumentSource	TokenNameIdentifier	 f Document Source
.	TokenNameDOT	
setDocumentHandler	TokenNameIdentifier	 set Document Handler
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
setDocumentSource	TokenNameIdentifier	 set Document Source
(	TokenNameLPAREN	
fDocumentSource	TokenNameIdentifier	 f Document Source
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// indicate that the validator was removed. 	TokenNameCOMMENT_LINE	indicate that the validator was removed. 
fElementDepth	TokenNameIdentifier	 f Element Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
2	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// We don't call reportSchemaError here, because the spec 	TokenNameCOMMENT_LINE	We don't call reportSchemaError here, because the spec 
// doesn't think it's invalid not to be able to find a 	TokenNameCOMMENT_LINE	doesn't think it's invalid not to be able to find a 
// declaration or type definition for an element. Xerces is 	TokenNameCOMMENT_LINE	declaration or type definition for an element. Xerces is 
// reporting it as an error for historical reasons, but in 	TokenNameCOMMENT_LINE	reporting it as an error for historical reasons, but in 
// PSVI, we shouldn't mark this element as invalid because 	TokenNameCOMMENT_LINE	PSVI, we shouldn't mark this element as invalid because 
// of this. - SG 	TokenNameCOMMENT_LINE	of this. - SG 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
"cvc-elt.1.a"	TokenNameStringLiteral	cvc-elt.1.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if wildcard = strict, report error. 	TokenNameCOMMENT_LINE	if wildcard = strict, report error. 
// needs to be called before fXSIErrorReporter.pushContext() 	TokenNameCOMMENT_LINE	needs to be called before fXSIErrorReporter.pushContext() 
// so that the error belongs to the parent element. 	TokenNameCOMMENT_LINE	so that the error belongs to the parent element. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
wildcard	TokenNameIdentifier	 wildcard
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
wildcard	TokenNameIdentifier	 wildcard
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
PC_STRICT	TokenNameIdentifier	 PC  STRICT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// report error, because wilcard = strict 	TokenNameCOMMENT_LINE	report error, because wilcard = strict 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.c"	TokenNameStringLiteral	cvc-complex-type.2.4.c
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// no element decl or type found for this element. 	TokenNameCOMMENT_LINE	no element decl or type found for this element. 
// Allowed by the spec, we can choose to either laxly assess this 	TokenNameCOMMENT_LINE	Allowed by the spec, we can choose to either laxly assess this 
// element, or to skip it. Now we choose lax assessment. 	TokenNameCOMMENT_LINE	element, or to skip it. Now we choose lax assessment. 
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
// any type has mixed content, so we don't need to append buffer 	TokenNameCOMMENT_LINE	any type has mixed content, so we don't need to append buffer 
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// push error reporter context: record the current position 	TokenNameCOMMENT_LINE	push error reporter context: record the current position 
// This has to happen after we process skip contents, 	TokenNameCOMMENT_LINE	This has to happen after we process skip contents, 
// otherwise push and pop won't be correctly paired. 	TokenNameCOMMENT_LINE	otherwise push and pop won't be correctly paired. 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// push error reporter context: record the current position 	TokenNameCOMMENT_LINE	push error reporter context: record the current position 
// This has to happen after we process skip contents, 	TokenNameCOMMENT_LINE	This has to happen after we process skip contents, 
// otherwise push and pop won't be correctly paired. 	TokenNameCOMMENT_LINE	otherwise push and pop won't be correctly paired. 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get xsi:type 	TokenNameCOMMENT_LINE	get xsi:type 
if	TokenNameif	
(	TokenNameLPAREN	
xsiType	TokenNameIdentifier	 xsi Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
oldType	TokenNameIdentifier	 old Type
=	TokenNameEQUAL	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
getAndCheckXsiType	TokenNameIdentifier	 get And Check Xsi Type
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
xsiType	TokenNameIdentifier	 xsi Type
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// If it fails, use the old type. Use anyType if ther is no old type. 	TokenNameCOMMENT_LINE	If it fails, use the old type. Use anyType if ther is no old type. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
oldType	TokenNameIdentifier	 old Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
fAnyType	TokenNameIdentifier	 f Any Type
;	TokenNameSEMICOLON	
else	TokenNameelse	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
oldType	TokenNameIdentifier	 old Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
// if the element has a fixed value constraint, we need to append 	TokenNameCOMMENT_LINE	if the element has a fixed value constraint, we need to append 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if the type is simple, we need to append 	TokenNameCOMMENT_LINE	if the type is simple, we need to append 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// if the type is simple content complex type, we need to append 	TokenNameCOMMENT_LINE	if the type is simple content complex type, we need to append 
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// Element Locally Valid (Element) 	TokenNameCOMMENT_LINE	Element Locally Valid (Element) 
// 2 Its {abstract} must be false. 	TokenNameCOMMENT_LINE	2 Its {abstract} must be false. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getAbstract	TokenNameIdentifier	 get Abstract
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.2"	TokenNameStringLiteral	cvc-elt.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// make the current element validation root 	TokenNameCOMMENT_LINE	make the current element validation root 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationRoot	TokenNameIdentifier	 f Validation Root
=	TokenNameEQUAL	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// update normalization flags 	TokenNameCOMMENT_LINE	update normalization flags 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// reset values 	TokenNameCOMMENT_LINE	reset values 
fFirstChunk	TokenNameIdentifier	 f First Chunk
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fTrailing	TokenNameIdentifier	 f Trailing
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fUnionType	TokenNameIdentifier	 f Union Type
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Element Locally Valid (Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Type) 
// 2 Its {abstract} must be false. 	TokenNameCOMMENT_LINE	2 Its {abstract} must be false. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
getAbstract	TokenNameIdentifier	 get Abstract
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-type.2"	TokenNameStringLiteral	cvc-type.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// find out if the content type is simple and if variety is union 	TokenNameCOMMENT_LINE	find out if the content type is simple and if variety is union 
// to be able to do character normalization 	TokenNameCOMMENT_LINE	to be able to do character normalization 
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUnionType	TokenNameIdentifier	 f Union Type
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
.	TokenNameDOT	
getWhitespace	TokenNameIdentifier	 get Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DatatypeException	TokenNameIdentifier	 Datatype Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// do nothing 	TokenNameCOMMENT_LINE	do nothing 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// normalization: simple type 	TokenNameCOMMENT_LINE	normalization: simple type 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if !union type 	TokenNameCOMMENT_LINE	if !union type 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_UNION	TokenNameIdentifier	 VARIETY  UNION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUnionType	TokenNameIdentifier	 f Union Type
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
getWhitespace	TokenNameIdentifier	 get Whitespace
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
DatatypeException	TokenNameIdentifier	 Datatype Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// do nothing 	TokenNameCOMMENT_LINE	do nothing 
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// then try to get the content model 	TokenNameCOMMENT_LINE	then try to get the content model 
fCurrentCM	TokenNameIdentifier	 f Current CM
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentCM	TokenNameIdentifier	 f Current CM
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
)	TokenNameRPAREN	
.	TokenNameDOT	
getContentModel	TokenNameIdentifier	 get Content Model
(	TokenNameLPAREN	
fCMBuilder	TokenNameIdentifier	 f CM Builder
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// and get the initial content model state 	TokenNameCOMMENT_LINE	and get the initial content model state 
fCurrCMState	TokenNameIdentifier	 f Curr CM State
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentCM	TokenNameIdentifier	 f Current CM
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
startContentModel	TokenNameIdentifier	 start Content Model
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// get information about xsi:nil 	TokenNameCOMMENT_LINE	get information about xsi:nil 
String	TokenNameIdentifier	 String
xsiNil	TokenNameIdentifier	 xsi Nil
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// only deal with xsi:nil when there is an element declaration 	TokenNameCOMMENT_LINE	only deal with xsi:nil when there is an element declaration 
if	TokenNameif	
(	TokenNameLPAREN	
xsiNil	TokenNameIdentifier	 xsi Nil
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
getXsiNil	TokenNameIdentifier	 get Xsi Nil
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
xsiNil	TokenNameIdentifier	 xsi Nil
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// now validate everything related with the attributes 	TokenNameCOMMENT_LINE	now validate everything related with the attributes 
// first, get the attribute group 	TokenNameCOMMENT_LINE	first, get the attribute group 
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
attrGrp	TokenNameIdentifier	 attr Grp
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
attrGrp	TokenNameIdentifier	 attr Grp
=	TokenNameEQUAL	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
getAttrGrp	TokenNameIdentifier	 get Attr Grp
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// activate identity constraints 	TokenNameCOMMENT_LINE	activate identity constraints 
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0 && !fIgnoreIDC) { 	TokenNameCOMMENT_LINE	if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0 && !fIgnoreIDC) { 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fIDCPos	TokenNameIdentifier	 f IDC Pos
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIdConstraint	TokenNameIdentifier	 f Id Constraint
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
// initialize when identity constrains are defined for the elem 	TokenNameCOMMENT_LINE	initialize when identity constrains are defined for the elem 
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
initValueStoresFor	TokenNameIdentifier	 init Value Stores For
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
,	TokenNameCOMMA	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
attrGrp	TokenNameIdentifier	 attr Grp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// add default attributes 	TokenNameCOMMENT_LINE	add default attributes 
if	TokenNameif	
(	TokenNameLPAREN	
attrGrp	TokenNameIdentifier	 attr Grp
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
addDefaultAttributes	TokenNameIdentifier	 add Default Attributes
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
attrGrp	TokenNameIdentifier	 attr Grp
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// call all active identity constraints 	TokenNameCOMMENT_LINE	call all active identity constraints 
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherCount	TokenNameIdentifier	 get Matcher Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherAt	TokenNameIdentifier	 get Matcher At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
matcher	TokenNameIdentifier	 matcher
.	TokenNameDOT	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// PSVI: add validation context 	TokenNameCOMMENT_LINE	PSVI: add validation context 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidationContext	TokenNameIdentifier	 f Validation Context
=	TokenNameEQUAL	
fValidationRoot	TokenNameIdentifier	 f Validation Root
;	TokenNameSEMICOLON	
// PSVI: add element declaration 	TokenNameCOMMENT_LINE	PSVI: add element declaration 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fDeclaration	TokenNameIdentifier	 f Declaration
=	TokenNameEQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
;	TokenNameSEMICOLON	
// PSVI: add element type 	TokenNameCOMMENT_LINE	PSVI: add element type 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fTypeDecl	TokenNameIdentifier	 f Type Decl
=	TokenNameEQUAL	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
// PSVI: add notation attribute 	TokenNameCOMMENT_LINE	PSVI: add notation attribute 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
fNotation	TokenNameIdentifier	 f Notation
;	TokenNameSEMICOLON	
// PSVI: add nil 	TokenNameCOMMENT_LINE	PSVI: add nil 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
fNil	TokenNameIdentifier	 f Nil
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handleStartElement(QName,XMLAttributes,boolean) 	TokenNameCOMMENT_LINE	handleStartElement(QName,XMLAttributes,boolean) 
/** * Handle end element. If there is not text content, and there is a * {value constraint} on the corresponding element decl, then * set the fDefaultValue XMLString representing the default value. */	TokenNameCOMMENT_JAVADOC	 Handle end element. If there is not text content, and there is a {value constraint} on the corresponding element decl, then set the fDefaultValue XMLString representing the default value. 
Augmentations	TokenNameIdentifier	 Augmentations
handleEndElement	TokenNameIdentifier	 handle End Element
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"==>handleEndElement:"	TokenNameStringLiteral	==>handleEndElement:
+	TokenNamePLUS	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if we are skipping, return 	TokenNameCOMMENT_LINE	if we are skipping, return 
if	TokenNameif	
(	TokenNameLPAREN	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// but if this is the top element that we are skipping, 	TokenNameCOMMENT_LINE	but if this is the top element that we are skipping, 
// restore the states. 	TokenNameCOMMENT_LINE	restore the states. 
if	TokenNameif	
(	TokenNameLPAREN	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
==	TokenNameEQUAL_EQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
&&	TokenNameAND_AND	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// set the partial validation depth to the depth of parent 	TokenNameCOMMENT_LINE	set the partial validation depth to the depth of parent 
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
=	TokenNameEQUAL	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fSkipValidationDepth	TokenNameIdentifier	 f Skip Validation Depth
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fElementDepth	TokenNameIdentifier	 f Element Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
fSubElement	TokenNameIdentifier	 f Sub Element
=	TokenNameEQUAL	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
fNilStack	TokenNameIdentifier	 f Nil Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
fNotationStack	TokenNameIdentifier	 f Notation Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
fTypeStack	TokenNameIdentifier	 f Type Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentCM	TokenNameIdentifier	 f Current CM
=	TokenNameEQUAL	
fCMStack	TokenNameIdentifier	 f CM Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
=	TokenNameEQUAL	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
=	TokenNameEQUAL	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
fStringContent	TokenNameIdentifier	 f String Content
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fElementDepth	TokenNameIdentifier	 f Element Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PSVI: validation attempted: 	TokenNameCOMMENT_LINE	PSVI: validation attempted: 
// use default values in psvi item for 	TokenNameCOMMENT_LINE	use default values in psvi item for 
// validation attempted, validity, and error codes 	TokenNameCOMMENT_LINE	validation attempted, validity, and error codes 
// check extra schema constraints on root element 	TokenNameCOMMENT_LINE	check extra schema constraints on root element 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
fFullChecking	TokenNameIdentifier	 f Full Checking
&&	TokenNameAND_AND	
!	TokenNameNOT	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
fullSchemaChecking	TokenNameIdentifier	 full Schema Checking
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
,	TokenNameCOMMA	
fSubGroupHandler	TokenNameIdentifier	 f Sub Group Handler
,	TokenNameCOMMA	
fCMBuilder	TokenNameIdentifier	 f CM Builder
,	TokenNameCOMMA	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// now validate the content of the element 	TokenNameCOMMENT_LINE	now validate the content of the element 
processElementContent	TokenNameIdentifier	 process Element Content
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fIDCChecking	TokenNameIdentifier	 f IDC Checking
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Element Locally Valid (Element) 	TokenNameCOMMENT_LINE	Element Locally Valid (Element) 
// 6 The element information item must be valid with respect to each of the {identity-constraint definitions} as per Identity-constraint Satisfied (3.11.4). 	TokenNameCOMMENT_LINE	6 The element information item must be valid with respect to each of the {identity-constraint definitions} as per Identity-constraint Satisfied (3.11.4). 
// call matchers and de-activate context 	TokenNameCOMMENT_LINE	call matchers and de-activate context 
int	TokenNameint	
oldCount	TokenNameIdentifier	 old Count
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherCount	TokenNameIdentifier	 get Matcher Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
oldCount	TokenNameIdentifier	 old Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherAt	TokenNameIdentifier	 get Matcher At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
matcher	TokenNameIdentifier	 matcher
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fCurrentType	TokenNameIdentifier	 f Current Type
,	TokenNameCOMMA	
false	TokenNamefalse	
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
matcher	TokenNameIdentifier	 matcher
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fCurrentType	TokenNameIdentifier	 f Current Type
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getNillable	TokenNameIdentifier	 get Nillable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
:	TokenNameCOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
,	TokenNameCOMMA	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
:	TokenNameCOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValueType	TokenNameIdentifier	 actual Value Type
,	TokenNameCOMMA	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
:	TokenNameCOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
itemValueTypes	TokenNameIdentifier	 item Value Types
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
popContext	TokenNameIdentifier	 pop Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
newCount	TokenNameIdentifier	 new Count
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherCount	TokenNameIdentifier	 get Matcher Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// handle everything *but* keyref's. 	TokenNameCOMMENT_LINE	handle everything *but* keyref's. 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
oldCount	TokenNameIdentifier	 old Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
newCount	TokenNameIdentifier	 new Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherAt	TokenNameIdentifier	 get Matcher At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matcher	TokenNameIdentifier	 matcher
instanceof	TokenNameinstanceof	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
selMatcher	TokenNameIdentifier	 sel Matcher
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
)	TokenNameRPAREN	
matcher	TokenNameIdentifier	 matcher
;	TokenNameSEMICOLON	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
selMatcher	TokenNameIdentifier	 sel Matcher
.	TokenNameDOT	
getIdentityConstraint	TokenNameIdentifier	 get Identity Constraint
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
id	TokenNameIdentifier	 id
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEYREF	TokenNameIdentifier	 IC  KEYREF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
transplant	TokenNameIdentifier	 transplant
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
selMatcher	TokenNameIdentifier	 sel Matcher
.	TokenNameDOT	
getInitialDepth	TokenNameIdentifier	 get Initial Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// now handle keyref's/... 	TokenNameCOMMENT_LINE	now handle keyref's/... 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
oldCount	TokenNameIdentifier	 old Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>=	TokenNameGREATER_EQUAL	
newCount	TokenNameIdentifier	 new Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
=	TokenNameEQUAL	
fMatcherStack	TokenNameIdentifier	 f Matcher Stack
.	TokenNameDOT	
getMatcherAt	TokenNameIdentifier	 get Matcher At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
matcher	TokenNameIdentifier	 matcher
instanceof	TokenNameinstanceof	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
selMatcher	TokenNameIdentifier	 sel Matcher
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Selector	TokenNameIdentifier	 Selector
.	TokenNameDOT	
Matcher	TokenNameIdentifier	 Matcher
)	TokenNameRPAREN	
matcher	TokenNameIdentifier	 matcher
;	TokenNameSEMICOLON	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
selMatcher	TokenNameIdentifier	 sel Matcher
.	TokenNameDOT	
getIdentityConstraint	TokenNameIdentifier	 get Identity Constraint
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
id	TokenNameIdentifier	 id
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEYREF	TokenNameIdentifier	 IC  KEYREF
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
values	TokenNameIdentifier	 values
=	TokenNameEQUAL	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
getValueStoreFor	TokenNameIdentifier	 get Value Store For
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
selMatcher	TokenNameIdentifier	 sel Matcher
.	TokenNameDOT	
getInitialDepth	TokenNameIdentifier	 get Initial Depth
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
// nothing to do if nothing matched! 	TokenNameCOMMENT_LINE	nothing to do if nothing matched! 
values	TokenNameIdentifier	 values
.	TokenNameDOT	
endDocumentFragment	TokenNameIdentifier	 end Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Check if we should modify the xsi:type ignore depth 	TokenNameCOMMENT_LINE	Check if we should modify the xsi:type ignore depth 
// This check is independent of whether this is the validation root, 	TokenNameCOMMENT_LINE	This check is independent of whether this is the validation root, 
// and should be done before the element depth is decremented. 	TokenNameCOMMENT_LINE	and should be done before the element depth is decremented. 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
<	TokenNameLESS	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIgnoreXSITypeDepth	TokenNameIdentifier	 f Ignore XSI Type Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// have we reached the end tag of the validation root? 	TokenNameCOMMENT_LINE	have we reached the end tag of the validation root? 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4). 	TokenNameCOMMENT_LINE	7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4). 
String	TokenNameIdentifier	 String
invIdRef	TokenNameIdentifier	 inv Id Ref
=	TokenNameEQUAL	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
checkIDRefID	TokenNameIdentifier	 check ID Ref ID
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
resetIDTables	TokenNameIdentifier	 reset ID Tables
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
invIdRef	TokenNameIdentifier	 inv Id Ref
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-id.1"	TokenNameStringLiteral	cvc-id.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
invIdRef	TokenNameIdentifier	 inv Id Ref
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// check extra schema constraints 	TokenNameCOMMENT_LINE	check extra schema constraints 
if	TokenNameif	
(	TokenNameLPAREN	
fFullChecking	TokenNameIdentifier	 f Full Checking
&&	TokenNameAND_AND	
!	TokenNameNOT	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
fullSchemaChecking	TokenNameIdentifier	 full Schema Checking
(	TokenNameLPAREN	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
,	TokenNameCOMMA	
fSubGroupHandler	TokenNameIdentifier	 f Sub Group Handler
,	TokenNameCOMMA	
fCMBuilder	TokenNameIdentifier	 f CM Builder
,	TokenNameCOMMA	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
grammars	TokenNameIdentifier	 grammars
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammars	TokenNameIdentifier	 get Grammars
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return the final set of grammars validator ended up with 	TokenNameCOMMENT_LINE	return the final set of grammars validator ended up with 
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Set grammars as immutable 	TokenNameCOMMENT_LINE	Set grammars as immutable 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
grammars	TokenNameIdentifier	 grammars
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammars	TokenNameIdentifier	 grammars
[	TokenNameLBRACKET	
k	TokenNameIdentifier	 k
]	TokenNameRBRACKET	
.	TokenNameDOT	
setImmutable	TokenNameIdentifier	 set Immutable
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
.	TokenNameDOT	
cacheGrammars	TokenNameIdentifier	 cache Grammars
(	TokenNameLPAREN	
XMLGrammarDescription	TokenNameIdentifier	 XML Grammar Description
.	TokenNameDOT	
XML_SCHEMA	TokenNameIdentifier	 XML  SCHEMA
,	TokenNameCOMMA	
grammars	TokenNameIdentifier	 grammars
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
endElementPSVI	TokenNameIdentifier	 end Element PSVI
(	TokenNameLPAREN	
true	TokenNametrue	
,	TokenNameCOMMA	
grammars	TokenNameIdentifier	 grammars
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
endElementPSVI	TokenNameIdentifier	 end Element PSVI
(	TokenNameLPAREN	
false	TokenNamefalse	
,	TokenNameCOMMA	
grammars	TokenNameIdentifier	 grammars
,	TokenNameCOMMA	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// decrease element depth and restore states 	TokenNameCOMMENT_LINE	decrease element depth and restore states 
fElementDepth	TokenNameIdentifier	 f Element Depth
--	TokenNameMINUS_MINUS	
;	TokenNameSEMICOLON	
// get the states for the parent element. 	TokenNameCOMMENT_LINE	get the states for the parent element. 
fSubElement	TokenNameIdentifier	 f Sub Element
=	TokenNameEQUAL	
fSubElementStack	TokenNameIdentifier	 f Sub Element Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
fElemDeclStack	TokenNameIdentifier	 f Elem Decl Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
fNilStack	TokenNameIdentifier	 f Nil Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
fNotationStack	TokenNameIdentifier	 f Notation Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
fTypeStack	TokenNameIdentifier	 f Type Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrentCM	TokenNameIdentifier	 f Current CM
=	TokenNameEQUAL	
fCMStack	TokenNameIdentifier	 f CM Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
=	TokenNameEQUAL	
fStrictAssessStack	TokenNameIdentifier	 f Strict Assess Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
=	TokenNameEQUAL	
fCMStateStack	TokenNameIdentifier	 f CM State Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fSawText	TokenNameIdentifier	 f Saw Text
=	TokenNameEQUAL	
fSawTextStack	TokenNameIdentifier	 f Saw Text Stack
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
=	TokenNameEQUAL	
fStringContent	TokenNameIdentifier	 f String Content
[	TokenNameLBRACKET	
fElementDepth	TokenNameIdentifier	 f Element Depth
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// We should have a stack for whitespace value, and pop it up here. 	TokenNameCOMMENT_LINE	We should have a stack for whitespace value, and pop it up here. 
// But when fWhiteSpace != -1, and we see a sub-element, it must be 	TokenNameCOMMENT_LINE	But when fWhiteSpace != -1, and we see a sub-element, it must be 
// an error (at least for Schema 1.0). So for valid documents, the 	TokenNameCOMMENT_LINE	an error (at least for Schema 1.0). So for valid documents, the 
// only value we are going to push/pop in the stack is -1. 	TokenNameCOMMENT_LINE	only value we are going to push/pop in the stack is -1. 
// Here we just mimic the effect of popping -1. -SG 	TokenNameCOMMENT_LINE	Here we just mimic the effect of popping -1. -SG 
fWhiteSpace	TokenNameIdentifier	 f White Space
=	TokenNameEQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
// Same for append buffer. Simple types and elements with fixed 	TokenNameCOMMENT_LINE	Same for append buffer. Simple types and elements with fixed 
// value constraint don't allow sub-elements. -SG 	TokenNameCOMMENT_LINE	value constraint don't allow sub-elements. -SG 
fAppendBuffer	TokenNameIdentifier	 f Append Buffer
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
// same here. 	TokenNameCOMMENT_LINE	same here. 
fUnionType	TokenNameIdentifier	 f Union Type
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// handleEndElement(QName,boolean)*/ 	TokenNameCOMMENT_LINE	handleEndElement(QName,boolean)*/ 
final	TokenNamefinal	
Augmentations	TokenNameIdentifier	 Augmentations
endElementPSVI	TokenNameIdentifier	 end Element PSVI
(	TokenNameLPAREN	
boolean	TokenNameboolean	
root	TokenNameIdentifier	 root
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
grammars	TokenNameIdentifier	 grammars
,	TokenNameCOMMA	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// the 5 properties sent on startElement calls 	TokenNameCOMMENT_LINE	the 5 properties sent on startElement calls 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fDeclaration	TokenNameIdentifier	 f Declaration
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fTypeDecl	TokenNameIdentifier	 f Type Decl
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fNotation	TokenNameIdentifier	 f Notation
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidationContext	TokenNameIdentifier	 f Validation Context
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fValidationRoot	TokenNameIdentifier	 f Validation Root
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fNil	TokenNameIdentifier	 f Nil
=	TokenNameEQUAL	
this	TokenNamethis	
.	TokenNameDOT	
fNil	TokenNameIdentifier	 f Nil
;	TokenNameSEMICOLON	
// PSVI: validation attempted 	TokenNameCOMMENT_LINE	PSVI: validation attempted 
// nothing below or at the same level has none or partial 	TokenNameCOMMENT_LINE	nothing below or at the same level has none or partial 
// (which means this level is strictly assessed, and all chidren 	TokenNameCOMMENT_LINE	(which means this level is strictly assessed, and all chidren 
// are full), so this one has full 	TokenNameCOMMENT_LINE	are full), so this one has full 
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
>	TokenNameGREATER	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidationAttempted	TokenNameIdentifier	 f Validation Attempted
=	TokenNameEQUAL	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDATION_FULL	TokenNameIdentifier	 VALIDATION  FULL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// nothing below or at the same level has full or partial 	TokenNameCOMMENT_LINE	nothing below or at the same level has full or partial 
// (which means this level is not strictly assessed, and all chidren 	TokenNameCOMMENT_LINE	(which means this level is not strictly assessed, and all chidren 
// are none), so this one has none 	TokenNameCOMMENT_LINE	are none), so this one has none 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fElementDepth	TokenNameIdentifier	 f Element Depth
>	TokenNameGREATER	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidationAttempted	TokenNameIdentifier	 f Validation Attempted
=	TokenNameEQUAL	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDATION_NONE	TokenNameIdentifier	 VALIDATION  NONE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// otherwise partial, and anything above this level will be partial 	TokenNameCOMMENT_LINE	otherwise partial, and anything above this level will be partial 
else	TokenNameelse	
{	TokenNameLBRACE	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidationAttempted	TokenNameIdentifier	 f Validation Attempted
=	TokenNameEQUAL	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDATION_PARTIAL	TokenNameIdentifier	 VALIDATION  PARTIAL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// this guarantees that depth settings do not cross-over between sibling nodes 	TokenNameCOMMENT_LINE	this guarantees that depth settings do not cross-over between sibling nodes 
if	TokenNameif	
(	TokenNameLPAREN	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
==	TokenNameEQUAL_EQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
==	TokenNameEQUAL_EQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDefaultValue	TokenNameIdentifier	 f Default Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fSpecified	TokenNameIdentifier	 f Specified
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fStrictAssess	TokenNameIdentifier	 f Strict Assess
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// get all errors for the current element, its attribute, 	TokenNameCOMMENT_LINE	get all errors for the current element, its attribute, 
// and subelements (if they were strictly assessed). 	TokenNameCOMMENT_LINE	and subelements (if they were strictly assessed). 
// any error would make this element invalid. 	TokenNameCOMMENT_LINE	any error would make this element invalid. 
// and we merge these errors to the parent element. 	TokenNameCOMMENT_LINE	and we merge these errors to the parent element. 
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errors	TokenNameIdentifier	 errors
=	TokenNameEQUAL	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
mergeContext	TokenNameIdentifier	 merge Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// PSVI: error codes 	TokenNameCOMMENT_LINE	PSVI: error codes 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fErrors	TokenNameIdentifier	 f Errors
=	TokenNameEQUAL	
errors	TokenNameIdentifier	 errors
;	TokenNameSEMICOLON	
// PSVI: validity 	TokenNameCOMMENT_LINE	PSVI: validity 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidity	TokenNameIdentifier	 f Validity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
errors	TokenNameIdentifier	 errors
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDITY_VALID	TokenNameIdentifier	 VALIDITY  VALID
:	TokenNameCOLON	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDITY_INVALID	TokenNameIdentifier	 VALIDITY  INVALID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// PSVI: validity 	TokenNameCOMMENT_LINE	PSVI: validity 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fValidity	TokenNameIdentifier	 f Validity
=	TokenNameEQUAL	
ElementPSVI	TokenNameIdentifier	 Element PSVI
.	TokenNameDOT	
VALIDITY_NOTKNOWN	TokenNameIdentifier	 VALIDITY  NOTKNOWN
;	TokenNameSEMICOLON	
// Discard the current context: ignore any error happened within 	TokenNameCOMMENT_LINE	Discard the current context: ignore any error happened within 
// the sub-elements/attributes of this element, because those 	TokenNameCOMMENT_LINE	the sub-elements/attributes of this element, because those 
// errors won't affect the validity of the parent elements. 	TokenNameCOMMENT_LINE	errors won't affect the validity of the parent elements. 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
popContext	TokenNameIdentifier	 pop Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
root	TokenNameIdentifier	 root
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// store [schema information] in the PSVI 	TokenNameCOMMENT_LINE	store [schema information] in the PSVI 
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fGrammars	TokenNameIdentifier	 f Grammars
=	TokenNameEQUAL	
grammars	TokenNameIdentifier	 grammars
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
fSchemaInformation	TokenNameIdentifier	 f Schema Information
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Augmentations	TokenNameIdentifier	 Augmentations
getEmptyAugs	TokenNameIdentifier	 get Empty Augs
(	TokenNameLPAREN	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
augs	TokenNameIdentifier	 augs
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
fAugmentations	TokenNameIdentifier	 f Augmentations
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
removeAllItems	TokenNameIdentifier	 remove All Items
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ELEMENT_PSVI	TokenNameIdentifier	 ELEMENT  PSVI
,	TokenNameCOMMA	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fCurrentPSVI	TokenNameIdentifier	 f Current PSVI
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
augs	TokenNameIdentifier	 augs
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
storeLocations	TokenNameIdentifier	 store Locations
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
sLocation	TokenNameIdentifier	 s Location
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
nsLocation	TokenNameIdentifier	 ns Location
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
sLocation	TokenNameIdentifier	 s Location
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
tokenizeSchemaLocationStr	TokenNameIdentifier	 tokenize Schema Location Str
(	TokenNameLPAREN	
sLocation	TokenNameIdentifier	 s Location
,	TokenNameCOMMA	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
,	TokenNameCOMMA	
fLocator	TokenNameIdentifier	 f Locator
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
null	TokenNamenull	
:	TokenNameCOLON	
fLocator	TokenNameIdentifier	 f Locator
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// error! 	TokenNameCOMMENT_LINE	error! 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
"SchemaLocation"	TokenNameStringLiteral	SchemaLocation
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
sLocation	TokenNameIdentifier	 s Location
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
nsLocation	TokenNameIdentifier	 ns Location
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
LocationArray	TokenNameIdentifier	 Location Array
la	TokenNameIdentifier	 la
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
LocationArray	TokenNameIdentifier	 Location Array
)	TokenNameRPAREN	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
la	TokenNameIdentifier	 la
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
la	TokenNameIdentifier	 la
=	TokenNameEQUAL	
new	TokenNamenew	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
LocationArray	TokenNameIdentifier	 Location Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
,	TokenNameCOMMA	
la	TokenNameIdentifier	 la
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fLocator	TokenNameIdentifier	 f Locator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
nsLocation	TokenNameIdentifier	 ns Location
=	TokenNameEQUAL	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
nsLocation	TokenNameIdentifier	 ns Location
,	TokenNameCOMMA	
fLocator	TokenNameIdentifier	 f Locator
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
la	TokenNameIdentifier	 la
.	TokenNameDOT	
addLocation	TokenNameIdentifier	 add Location
(	TokenNameLPAREN	
nsLocation	TokenNameIdentifier	 ns Location
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//storeLocations 	TokenNameCOMMENT_LINE	storeLocations 
//this is the function where logic of retrieving grammar is written , parser first tries to get the grammar from 	TokenNameCOMMENT_LINE	this is the function where logic of retrieving grammar is written , parser first tries to get the grammar from 
//the local pool, if not in local pool, it gives chance to application to be able to retrieve the grammar, then it 	TokenNameCOMMENT_LINE	the local pool, if not in local pool, it gives chance to application to be able to retrieve the grammar, then it 
//tries to parse the grammar using location hints from the give namespace. 	TokenNameCOMMENT_LINE	tries to parse the grammar using location hints from the give namespace. 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
short	TokenNameshort	
contextType	TokenNameIdentifier	 context Type
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
namespace	TokenNameIdentifier	 namespace
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
enclosingElement	TokenNameIdentifier	 enclosing Element
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
triggeringComponent	TokenNameIdentifier	 triggering Component
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
//get the grammar from local pool... 	TokenNameCOMMENT_LINE	get the grammar from local pool... 
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
)	TokenNameRPAREN	
fGrammarPool	TokenNameIdentifier	 f Grammar Pool
.	TokenNameDOT	
retrieveGrammar	TokenNameIdentifier	 retrieve Grammar
(	TokenNameLPAREN	
fXSDDescription	TokenNameIdentifier	 f XSD Description
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// put this grammar into the bucket, along with grammars 	TokenNameCOMMENT_LINE	put this grammar into the bucket, along with grammars 
// imported by it (directly or indirectly) 	TokenNameCOMMENT_LINE	imported by it (directly or indirectly) 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
putGrammar	TokenNameIdentifier	 put Grammar
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
true	TokenNametrue	
,	TokenNameCOMMA	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: a conflict between new grammar(s) and grammars 	TokenNameCOMMENT_LINE	REVISIT: a conflict between new grammar(s) and grammars 
// in the bucket. What to do? A warning? An exception? 	TokenNameCOMMENT_LINE	in the bucket. What to do? A warning? An exception? 
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
"GrammarConflict"	TokenNameStringLiteral	GrammarConflict
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fUseGrammarPoolOnly	TokenNameIdentifier	 f Use Grammar Pool Only
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
&&	TokenNameAND_AND	
!	TokenNameNOT	
hasSchemaComponent	TokenNameIdentifier	 has Schema Component
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
contextType	TokenNameIdentifier	 context Type
,	TokenNameCOMMA	
triggeringComponent	TokenNameIdentifier	 triggering Component
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fContextType	TokenNameIdentifier	 f Context Type
=	TokenNameEQUAL	
contextType	TokenNameIdentifier	 context Type
;	TokenNameSEMICOLON	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
setNamespace	TokenNameIdentifier	 set Namespace
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fEnclosedElementName	TokenNameIdentifier	 f Enclosed Element Name
=	TokenNameEQUAL	
enclosingElement	TokenNameIdentifier	 enclosing Element
;	TokenNameSEMICOLON	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fTriggeringComponent	TokenNameIdentifier	 f Triggering Component
=	TokenNameEQUAL	
triggeringComponent	TokenNameIdentifier	 triggering Component
;	TokenNameSEMICOLON	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fAttributes	TokenNameIdentifier	 f Attributes
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fLocator	TokenNameIdentifier	 f Locator
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
setBaseSystemId	TokenNameIdentifier	 set Base System Id
(	TokenNameLPAREN	
fLocator	TokenNameIdentifier	 f Locator
.	TokenNameDOT	
getExpandedSystemId	TokenNameIdentifier	 get Expanded System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Hashtable	TokenNameIdentifier	 Hashtable
locationPairs	TokenNameIdentifier	 location Pairs
=	TokenNameEQUAL	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
locationArray	TokenNameIdentifier	 location Array
=	TokenNameEQUAL	
locationPairs	TokenNameIdentifier	 location Pairs
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
namespace	TokenNameIdentifier	 namespace
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
:	TokenNameCOLON	
namespace	TokenNameIdentifier	 namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
locationArray	TokenNameIdentifier	 location Array
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
temp	TokenNameIdentifier	 temp
=	TokenNameEQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
LocationArray	TokenNameIdentifier	 Location Array
)	TokenNameRPAREN	
locationArray	TokenNameIdentifier	 location Array
)	TokenNameRPAREN	
.	TokenNameDOT	
getLocationArray	TokenNameIdentifier	 get Location Array
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
temp	TokenNameIdentifier	 temp
.	TokenNameDOT	
length	TokenNameIdentifier	 length
!=	TokenNameNOT_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
fXSDDescription	TokenNameIdentifier	 f XSD Description
,	TokenNameCOMMA	
temp	TokenNameIdentifier	 temp
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
boolean	TokenNameboolean	
toParseSchema	TokenNameIdentifier	 to Parse Schema
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// use location hints instead 	TokenNameCOMMENT_LINE	use location hints instead 
locationPairs	TokenNameIdentifier	 location Pairs
=	TokenNameEQUAL	
EMPTY_TABLE	TokenNameIdentifier	 EMPTY  TABLE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// try to parse the grammar using location hints from that namespace.. 	TokenNameCOMMENT_LINE	try to parse the grammar using location hints from that namespace.. 
try	TokenNametry	
{	TokenNameLBRACE	
XMLInputSource	TokenNameIdentifier	 XML Input Source
xis	TokenNameIdentifier	 xis
=	TokenNameEQUAL	
XMLSchemaLoader	TokenNameIdentifier	 XML Schema Loader
.	TokenNameDOT	
resolveDocument	TokenNameIdentifier	 resolve Document
(	TokenNameLPAREN	
fXSDDescription	TokenNameIdentifier	 f XSD Description
,	TokenNameCOMMA	
locationPairs	TokenNameIdentifier	 location Pairs
,	TokenNameCOMMA	
fEntityResolver	TokenNameIdentifier	 f Entity Resolver
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fNamespaceGrowth	TokenNameIdentifier	 f Namespace Growth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
try	TokenNametry	
{	TokenNameLBRACE	
// if we are dealing with a different schema location, then include the new schema 	TokenNameCOMMENT_LINE	if we are dealing with a different schema location, then include the new schema 
// into the existing grammar 	TokenNameCOMMENT_LINE	into the existing grammar 
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
XMLEntityManager	TokenNameIdentifier	 XML Entity Manager
.	TokenNameDOT	
expandSystemId	TokenNameIdentifier	 expand System Id
(	TokenNameLPAREN	
xis	TokenNameIdentifier	 xis
.	TokenNameDOT	
getSystemId	TokenNameIdentifier	 get System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
xis	TokenNameIdentifier	 xis
.	TokenNameDOT	
getBaseSystemId	TokenNameIdentifier	 get Base System Id
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
false	TokenNamefalse	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
toParseSchema	TokenNameIdentifier	 to Parse Schema
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
MalformedURIException	TokenNameIdentifier	 Malformed URI Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
toParseSchema	TokenNameIdentifier	 to Parse Schema
)	TokenNameRPAREN	
{	TokenNameLBRACE	
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fSchemaLoader	TokenNameIdentifier	 f Schema Loader
.	TokenNameDOT	
loadSchema	TokenNameIdentifier	 load Schema
(	TokenNameLPAREN	
fXSDDescription	TokenNameIdentifier	 f XSD Description
,	TokenNameCOMMA	
xis	TokenNameIdentifier	 xis
,	TokenNameCOMMA	
fLocationPairs	TokenNameIdentifier	 f Location Pairs
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
IOException	TokenNameIdentifier	 IO Exception
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locationHints	TokenNameIdentifier	 location Hints
=	TokenNameEQUAL	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
getLocationHints	TokenNameIdentifier	 get Location Hints
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
fErrorReporter	TokenNameIdentifier	 f Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
"schema_reference.4"	TokenNameStringLiteral	schema_reference.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
locationHints	TokenNameIdentifier	 location Hints
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
?	TokenNameQUESTION	
locationHints	TokenNameIdentifier	 location Hints
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
:	TokenNameCOLON	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
EMPTY_STRING	TokenNameIdentifier	 EMPTY  STRING
}	TokenNameRBRACE	
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_WARNING	TokenNameIdentifier	 SEVERITY  WARNING
,	TokenNameCOMMA	
ex	TokenNameIdentifier	 ex
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//findSchemaGrammar 	TokenNameCOMMENT_LINE	findSchemaGrammar 
private	TokenNameprivate	
boolean	TokenNameboolean	
hasSchemaComponent	TokenNameIdentifier	 has Schema Component
(	TokenNameLPAREN	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
,	TokenNameCOMMA	
short	TokenNameshort	
contextType	TokenNameIdentifier	 context Type
,	TokenNameCOMMA	
QName	TokenNameIdentifier	 Q Name
triggeringComponent	TokenNameIdentifier	 triggering Component
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
triggeringComponent	TokenNameIdentifier	 triggering Component
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
localName	TokenNameIdentifier	 local Name
=	TokenNameEQUAL	
triggeringComponent	TokenNameIdentifier	 triggering Component
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
localName	TokenNameIdentifier	 local Name
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
contextType	TokenNameIdentifier	 context Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ELEMENT	TokenNameIdentifier	 CONTEXT  ELEMENT
:	TokenNameCOLON	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getElementDeclaration	TokenNameIdentifier	 get Element Declaration
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ATTRIBUTE	TokenNameIdentifier	 CONTEXT  ATTRIBUTE
:	TokenNameCOLON	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getAttributeDeclaration	TokenNameIdentifier	 get Attribute Declaration
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
case	TokenNamecase	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_XSITYPE	TokenNameIdentifier	 CONTEXT  XSITYPE
:	TokenNameCOLON	
return	TokenNamereturn	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getTypeDefinition	TokenNameIdentifier	 get Type Definition
(	TokenNameLPAREN	
localName	TokenNameIdentifier	 local Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locations	TokenNameIdentifier	 locations
,	TokenNameCOMMA	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
locations	TokenNameIdentifier	 locations
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
locations	TokenNameIdentifier	 locations
,	TokenNameCOMMA	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getDocumentLocations	TokenNameIdentifier	 get Document Locations
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
setLocationHints	TokenNameIdentifier	 set Location Hints
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
desc	TokenNameIdentifier	 desc
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
locations	TokenNameIdentifier	 locations
,	TokenNameCOMMA	
StringList	TokenNameIdentifier	 String List
docLocations	TokenNameIdentifier	 doc Locations
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
locations	TokenNameIdentifier	 locations
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
hints	TokenNameIdentifier	 hints
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
length	TokenNameIdentifier	 length
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
int	TokenNameint	
counter	TokenNameIdentifier	 counter
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
docLocations	TokenNameIdentifier	 doc Locations
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
hints	TokenNameIdentifier	 hints
[	TokenNameLBRACKET	
counter	TokenNameIdentifier	 counter
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
locations	TokenNameIdentifier	 locations
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
counter	TokenNameIdentifier	 counter
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
counter	TokenNameIdentifier	 counter
==	TokenNameEQUAL_EQUAL	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
=	TokenNameEQUAL	
hints	TokenNameIdentifier	 hints
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
=	TokenNameEQUAL	
new	TokenNamenew	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
counter	TokenNameIdentifier	 counter
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
hints	TokenNameIdentifier	 hints
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fXSDDescription	TokenNameIdentifier	 f XSD Description
.	TokenNameDOT	
fLocationHints	TokenNameIdentifier	 f Location Hints
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
counter	TokenNameIdentifier	 counter
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
getAndCheckXsiType	TokenNameIdentifier	 get And Check Xsi Type
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
xsiType	TokenNameIdentifier	 xsi Type
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// This method also deals with clause 1.2.1.2 of the constraint 	TokenNameCOMMENT_LINE	This method also deals with clause 1.2.1.2 of the constraint 
// Validation Rule: Schema-Validity Assessment (Element) 	TokenNameCOMMENT_LINE	Validation Rule: Schema-Validity Assessment (Element) 
// Element Locally Valid (Element) 	TokenNameCOMMENT_LINE	Element Locally Valid (Element) 
// 4 If there is an attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is type, then all of the following must be true: 	TokenNameCOMMENT_LINE	4 If there is an attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is type, then all of the following must be true: 
// 4.1 The normalized value of that attribute information item must be valid with respect to the built-in QName simple type, as defined by String Valid (3.14.4); 	TokenNameCOMMENT_LINE	4.1 The normalized value of that attribute information item must be valid with respect to the built-in QName simple type, as defined by String Valid (3.14.4); 
QName	TokenNameIdentifier	 Q Name
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
fQNameDV	TokenNameIdentifier	 f Q Name DV
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
xsiType	TokenNameIdentifier	 xsi Type
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.4.1"	TokenNameStringLiteral	cvc-elt.4.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
,	TokenNameCOMMA	
xsiType	TokenNameIdentifier	 xsi Type
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 4.2 The local name and namespace name (as defined in QName Interpretation (3.15.3)), of the actual value of that attribute information item must resolve to a type definition, as defined in QName resolution (Instance) (3.15.4) 	TokenNameCOMMENT_LINE	4.2 The local name and namespace name (as defined in QName Interpretation (3.15.3)), of the actual value of that attribute information item must resolve to a type definition, as defined in QName resolution (Instance) (3.15.4) 
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// if the namespace is schema namespace, first try built-in types 	TokenNameCOMMENT_LINE	if the namespace is schema namespace, first try built-in types 
if	TokenNameif	
(	TokenNameLPAREN	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
)	TokenNameRPAREN	
{	TokenNameLBRACE	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if it's not schema built-in types, then try to get a grammar 	TokenNameCOMMENT_LINE	if it's not schema built-in types, then try to get a grammar 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//try to find schema grammar by different means.... 	TokenNameCOMMENT_LINE	try to find schema grammar by different means.... 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_XSITYPE	TokenNameIdentifier	 CONTEXT  XSITYPE
,	TokenNameCOMMA	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
typeName	TokenNameIdentifier	 type Name
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
type	TokenNameIdentifier	 type
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
typeName	TokenNameIdentifier	 type Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// still couldn't find the type, report an error 	TokenNameCOMMENT_LINE	still couldn't find the type, report an error 
if	TokenNameif	
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.4.2"	TokenNameStringLiteral	cvc-elt.4.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
xsiType	TokenNameIdentifier	 xsi Type
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if there is no current type, set this one as current. 	TokenNameCOMMENT_LINE	if there is no current type, set this one as current. 
// and we don't need to do extra checking 	TokenNameCOMMENT_LINE	and we don't need to do extra checking 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
block	TokenNameIdentifier	 block
=	TokenNameEQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
DERIVATION_NONE	TokenNameIdentifier	 DERIVATION  NONE
;	TokenNameSEMICOLON	
// 4.3 The local type definition must be validly derived from the {type definition} given the union of the {disallowed substitutions} and the {type definition}'s {prohibited substitutions}, as defined in Type Derivation OK (Complex) (3.4.6) (if it is a complex type definition), or given {disallowed substitutions} as defined in Type Derivation OK (Simple) (3.14.6) (if it is a simple type definition). 	TokenNameCOMMENT_LINE	4.3 The local type definition must be validly derived from the {type definition} given the union of the {disallowed substitutions} and the {type definition}'s {prohibited substitutions}, as defined in Type Derivation OK (Complex) (3.4.6) (if it is a complex type definition), or given {disallowed substitutions} as defined in Type Derivation OK (Simple) (3.14.6) (if it is a simple type definition). 
// Note: It's possible to have fCurrentType be non-null and fCurrentElemDecl 	TokenNameCOMMENT_LINE	Note: It's possible to have fCurrentType be non-null and fCurrentElemDecl 
// be null, if the current type is set using the property "root-type-definition". 	TokenNameCOMMENT_LINE	be null, if the current type is set using the property "root-type-definition". 
// In that case, we don't disallow any substitutions. -PM 	TokenNameCOMMENT_LINE	In that case, we don't disallow any substitutions. -PM 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
block	TokenNameIdentifier	 block
=	TokenNameEQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
block	TokenNameIdentifier	 block
|=	TokenNameOR_EQUAL	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
)	TokenNameRPAREN	
.	TokenNameDOT	
fBlock	TokenNameIdentifier	 f Block
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
checkTypeDerivationOk	TokenNameIdentifier	 check Type Derivation Ok
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
,	TokenNameCOMMA	
fCurrentType	TokenNameIdentifier	 f Current Type
,	TokenNameCOMMA	
block	TokenNameIdentifier	 block
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.4.3"	TokenNameStringLiteral	cvc-elt.4.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
xsiType	TokenNameIdentifier	 xsi Type
,	TokenNameCOMMA	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
//getAndCheckXsiType 	TokenNameCOMMENT_LINE	getAndCheckXsiType 
boolean	TokenNameboolean	
getXsiNil	TokenNameIdentifier	 get Xsi Nil
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
String	TokenNameIdentifier	 String
xsiNil	TokenNameIdentifier	 xsi Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Element Locally Valid (Element) 	TokenNameCOMMENT_LINE	Element Locally Valid (Element) 
// 3 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	3 The appropriate case among the following must be true: 
// 3.1 If {nillable} is false, then there must be no attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is nil. 	TokenNameCOMMENT_LINE	3.1 If {nillable} is false, then there must be no attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is nil. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getNillable	TokenNameIdentifier	 get Nillable
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.3.1"	TokenNameStringLiteral	cvc-elt.3.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 3.2 If {nillable} is true and there is such an attribute information item and its actual value is true , then all of the following must be true: 	TokenNameCOMMENT_LINE	3.2 If {nillable} is true and there is such an attribute information item and its actual value is true , then all of the following must be true: 
// 3.2.2 There must be no fixed {value constraint}. 	TokenNameCOMMENT_LINE	3.2.2 There must be no fixed {value constraint}. 
else	TokenNameelse	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
XMLChar	TokenNameIdentifier	 XML Char
.	TokenNameDOT	
trim	TokenNameIdentifier	 trim
(	TokenNameLPAREN	
xsiNil	TokenNameIdentifier	 xsi Nil
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_TRUE	TokenNameIdentifier	 ATTVAL  TRUE
)	TokenNameRPAREN	
||	TokenNameOR_OR	
value	TokenNameIdentifier	 value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
ATTVAL_TRUE_1	TokenNameIdentifier	 ATTVAL  TRUE 1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.3.2.2"	TokenNameStringLiteral	cvc-elt.3.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
void	TokenNamevoid	
processAttributes	TokenNameIdentifier	 process Attributes
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
attrGrp	TokenNameIdentifier	 attr Grp
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"==>processAttributes: "	TokenNameStringLiteral	==>processAttributes: 
+	TokenNamePLUS	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// whether we have seen a Wildcard ID. 	TokenNameCOMMENT_LINE	whether we have seen a Wildcard ID. 
String	TokenNameIdentifier	 String
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// for each present attribute 	TokenNameCOMMENT_LINE	for each present attribute 
int	TokenNameint	
attCount	TokenNameIdentifier	 att Count
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
attrPSVI	TokenNameIdentifier	 attr PSVI
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSimple	TokenNameIdentifier	 is Simple
=	TokenNameEQUAL	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
;	TokenNameSEMICOLON	
XSObjectList	TokenNameIdentifier	 XS Object List
attrUses	TokenNameIdentifier	 attr Uses
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
int	TokenNameint	
useCount	TokenNameIdentifier	 use Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
attrWildcard	TokenNameIdentifier	 attr Wildcard
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSimple	TokenNameIdentifier	 is Simple
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrUses	TokenNameIdentifier	 attr Uses
=	TokenNameEQUAL	
attrGrp	TokenNameIdentifier	 attr Grp
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
useCount	TokenNameIdentifier	 use Count
=	TokenNameEQUAL	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrWildcard	TokenNameIdentifier	 attr Wildcard
=	TokenNameEQUAL	
attrGrp	TokenNameIdentifier	 attr Grp
.	TokenNameDOT	
fAttributeWC	TokenNameIdentifier	 f Attribute WC
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Element Locally Valid (Complex Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Complex Type) 
// 3 For each attribute information item in the element information item's [attributes] excepting those whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation, the appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	3 For each attribute information item in the element information item's [attributes] excepting those whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation, the appropriate case among the following must be true: 
// get the corresponding attribute decl 	TokenNameCOMMENT_LINE	get the corresponding attribute decl 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
<	TokenNameLESS	
attCount	TokenNameIdentifier	 att Count
;	TokenNameSEMICOLON	
index	TokenNameIdentifier	 index
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"==>process attribute: "	TokenNameStringLiteral	==>process attribute: 
+	TokenNamePLUS	
fTempQName	TokenNameIdentifier	 f Temp Q Name
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
||	TokenNameOR_OR	
fIdConstraint	TokenNameIdentifier	 f Id Constraint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getAugmentations	TokenNameIdentifier	 get Augmentations
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
=	TokenNameEQUAL	
(	TokenNameLPAREN	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
)	TokenNameRPAREN	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
getItem	TokenNameIdentifier	 get Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRIBUTE_PSVI	TokenNameIdentifier	 ATTRIBUTE  PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attrPSVI	TokenNameIdentifier	 attr PSVI
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
attrPSVI	TokenNameIdentifier	 attr PSVI
=	TokenNameEQUAL	
new	TokenNamenew	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRIBUTE_PSVI	TokenNameIdentifier	 ATTRIBUTE  PSVI
,	TokenNameCOMMA	
attrPSVI	TokenNameIdentifier	 attr PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PSVI attribute: validation context 	TokenNameCOMMENT_LINE	PSVI attribute: validation context 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidationContext	TokenNameIdentifier	 f Validation Context
=	TokenNameEQUAL	
fValidationRoot	TokenNameIdentifier	 f Validation Root
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Element Locally Valid (Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Type) 
// 3.1.1 The element information item's [attributes] must be empty, excepting those 	TokenNameCOMMENT_LINE	3.1.1 The element information item's [attributes] must be empty, excepting those 
// whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and 	TokenNameCOMMENT_LINE	whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and 
// whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation. 	TokenNameCOMMENT_LINE	whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation. 
// for the 4 xsi attributes, get appropriate decl, and validate 	TokenNameCOMMENT_LINE	for the 4 xsi attributes, get appropriate decl, and validate 
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
attrDecl	TokenNameIdentifier	 attr Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrDecl	TokenNameIdentifier	 attr Decl
=	TokenNameEQUAL	
XSI_TYPE	TokenNameIdentifier	 XSI  TYPE
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrDecl	TokenNameIdentifier	 attr Decl
=	TokenNameEQUAL	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_SCHEMALOCATION	TokenNameIdentifier	 XSI  SCHEMALOCATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrDecl	TokenNameIdentifier	 attr Decl
=	TokenNameEQUAL	
XSI_SCHEMALOCATION	TokenNameIdentifier	 XSI  SCHEMALOCATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NONAMESPACESCHEMALOCATION	TokenNameIdentifier	 XSI  NONAMESPACESCHEMALOCATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrDecl	TokenNameIdentifier	 attr Decl
=	TokenNameEQUAL	
XSI_NONAMESPACESCHEMALOCATION	TokenNameIdentifier	 XSI  NONAMESPACESCHEMALOCATION
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
attrDecl	TokenNameIdentifier	 attr Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
processOneAttribute	TokenNameIdentifier	 process One Attribute
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
attrDecl	TokenNameIdentifier	 attr Decl
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
attrPSVI	TokenNameIdentifier	 attr PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for namespace attributes, no_validation/unknow_validity 	TokenNameCOMMENT_LINE	for namespace attributes, no_validation/unknow_validity 
if	TokenNameif	
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
==	TokenNameEQUAL_EQUAL	
XMLSymbols	TokenNameIdentifier	 XML Symbols
.	TokenNameDOT	
PREFIX_XMLNS	TokenNameIdentifier	 PREFIX  XMLNS
||	TokenNameOR_OR	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
.	TokenNameDOT	
startsWith	TokenNameIdentifier	 starts With
(	TokenNameLPAREN	
"xmlns:"	TokenNameStringLiteral	xmlns:
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// simple type doesn't allow any other attributes 	TokenNameCOMMENT_LINE	simple type doesn't allow any other attributes 
if	TokenNameif	
(	TokenNameLPAREN	
isSimple	TokenNameIdentifier	 is Simple
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-type.3.1.1"	TokenNameStringLiteral	cvc-type.3.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// it's not xmlns, and not xsi, then we need to find a decl for it 	TokenNameCOMMENT_LINE	it's not xmlns, and not xsi, then we need to find a decl for it 
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
currUse	TokenNameIdentifier	 curr Use
=	TokenNameEQUAL	
null	TokenNamenull	
,	TokenNameCOMMA	
oneUse	TokenNameIdentifier	 one Use
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
useCount	TokenNameIdentifier	 use Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
oneUse	TokenNameIdentifier	 one Use
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
)	TokenNameRPAREN	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oneUse	TokenNameIdentifier	 one Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
==	TokenNameEQUAL_EQUAL	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
&&	TokenNameAND_AND	
oneUse	TokenNameIdentifier	 one Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
==	TokenNameEQUAL_EQUAL	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currUse	TokenNameIdentifier	 curr Use
=	TokenNameEQUAL	
oneUse	TokenNameIdentifier	 one Use
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 3.2 otherwise all of the following must be true: 	TokenNameCOMMENT_LINE	3.2 otherwise all of the following must be true: 
// 3.2.1 There must be an {attribute wildcard}. 	TokenNameCOMMENT_LINE	3.2.1 There must be an {attribute wildcard}. 
// 3.2.2 The attribute information item must be valid with respect to it as defined in Item Valid (Wildcard) (3.10.4). 	TokenNameCOMMENT_LINE	3.2.2 The attribute information item must be valid with respect to it as defined in Item Valid (Wildcard) (3.10.4). 
// if failed, get it from wildcard 	TokenNameCOMMENT_LINE	if failed, get it from wildcard 
if	TokenNameif	
(	TokenNameLPAREN	
currUse	TokenNameIdentifier	 curr Use
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//if (attrWildcard == null) 	TokenNameCOMMENT_LINE	if (attrWildcard == null) 
// reportSchemaError("cvc-complex-type.3.2.1", new Object[]{element.rawname, fTempQName.rawname}); 	TokenNameCOMMENT_LINE	reportSchemaError("cvc-complex-type.3.2.1", new Object[]{element.rawname, fTempQName.rawname}); 
if	TokenNameif	
(	TokenNameLPAREN	
attrWildcard	TokenNameIdentifier	 attr Wildcard
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
attrWildcard	TokenNameIdentifier	 attr Wildcard
.	TokenNameDOT	
allowNamespace	TokenNameIdentifier	 allow Namespace
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// so this attribute is not allowed 	TokenNameCOMMENT_LINE	so this attribute is not allowed 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.3.2.2"	TokenNameStringLiteral	cvc-complex-type.3.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// We have seen an attribute that was not declared 	TokenNameCOMMENT_LINE	We have seen an attribute that was not declared 
fNFullValidationDepth	TokenNameIdentifier	 f N Full Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
currDecl	TokenNameIdentifier	 curr Decl
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currUse	TokenNameIdentifier	 curr Use
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currDecl	TokenNameIdentifier	 curr Decl
=	TokenNameEQUAL	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// which means it matches a wildcard 	TokenNameCOMMENT_LINE	which means it matches a wildcard 
// skip it if processContents is skip 	TokenNameCOMMENT_LINE	skip it if processContents is skip 
if	TokenNameif	
(	TokenNameLPAREN	
attrWildcard	TokenNameIdentifier	 attr Wildcard
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
PC_SKIP	TokenNameIdentifier	 PC  SKIP
)	TokenNameRPAREN	
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
//try to find grammar by different means... 	TokenNameCOMMENT_LINE	try to find grammar by different means... 
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ATTRIBUTE	TokenNameIdentifier	 CONTEXT  ATTRIBUTE
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currDecl	TokenNameIdentifier	 curr Decl
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalAttributeDecl	TokenNameIdentifier	 get Global Attribute Decl
(	TokenNameLPAREN	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if can't find 	TokenNameCOMMENT_LINE	if can't find 
if	TokenNameif	
(	TokenNameLPAREN	
currDecl	TokenNameIdentifier	 curr Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if strict, report error 	TokenNameCOMMENT_LINE	if strict, report error 
if	TokenNameif	
(	TokenNameLPAREN	
attrWildcard	TokenNameIdentifier	 attr Wildcard
.	TokenNameDOT	
fProcessContents	TokenNameIdentifier	 f Process Contents
==	TokenNameEQUAL_EQUAL	
XSWildcardDecl	TokenNameIdentifier	 XS Wildcard Decl
.	TokenNameDOT	
PC_STRICT	TokenNameIdentifier	 PC  STRICT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.3.2.2"	TokenNameStringLiteral	cvc-complex-type.3.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// then continue to the next attribute 	TokenNameCOMMENT_LINE	then continue to the next attribute 
continue	TokenNamecontinue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 5 Let [Definition:] the wild IDs be the set of all attribute information item to which clause 3.2 applied and whose validation resulted in a context-determined declaration of mustFind or no context-determined declaration at all, and whose [local name] and [namespace name] resolve (as defined by QName resolution (Instance) (3.15.4)) to an attribute declaration whose {type definition} is or is derived from ID. Then all of the following must be true: 	TokenNameCOMMENT_LINE	5 Let [Definition:] the wild IDs be the set of all attribute information item to which clause 3.2 applied and whose validation resulted in a context-determined declaration of mustFind or no context-determined declaration at all, and whose [local name] and [namespace name] resolve (as defined by QName resolution (Instance) (3.15.4)) to an attribute declaration whose {type definition} is or is derived from ID. Then all of the following must be true: 
// 5.1 There must be no more than one item in wild IDs. 	TokenNameCOMMENT_LINE	5.1 There must be no more than one item in wild IDs. 
if	TokenNameif	
(	TokenNameLPAREN	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
)	TokenNameRPAREN	
.	TokenNameDOT	
isIDType	TokenNameIdentifier	 is ID Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.5.1"	TokenNameStringLiteral	cvc-complex-type.5.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
processOneAttribute	TokenNameIdentifier	 process One Attribute
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
,	TokenNameCOMMA	
currUse	TokenNameIdentifier	 curr Use
,	TokenNameCOMMA	
attrPSVI	TokenNameIdentifier	 attr PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// end of for (all attributes) 	TokenNameCOMMENT_LINE	end of for (all attributes) 
// 5.2 If wild IDs is non-empty, there must not be any attribute uses among the {attribute uses} whose {attribute declaration}'s {type definition} is or is derived from ID. 	TokenNameCOMMENT_LINE	5.2 If wild IDs is non-empty, there must not be any attribute uses among the {attribute uses} whose {attribute declaration}'s {type definition} is or is derived from ID. 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSimple	TokenNameIdentifier	 is Simple
&&	TokenNameAND_AND	
attrGrp	TokenNameIdentifier	 attr Grp
.	TokenNameDOT	
fIDAttrName	TokenNameIdentifier	 f ID Attr Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.5.2"	TokenNameStringLiteral	cvc-complex-type.5.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
wildcardIDName	TokenNameIdentifier	 wildcard ID Name
,	TokenNameCOMMA	
attrGrp	TokenNameIdentifier	 attr Grp
.	TokenNameDOT	
fIDAttrName	TokenNameIdentifier	 f ID Attr Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
//processAttributes 	TokenNameCOMMENT_LINE	processAttributes 
void	TokenNamevoid	
processOneAttribute	TokenNameIdentifier	 process One Attribute
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
int	TokenNameint	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
currDecl	TokenNameIdentifier	 curr Decl
,	TokenNameCOMMA	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
currUse	TokenNameIdentifier	 curr Use
,	TokenNameCOMMA	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
attrPSVI	TokenNameIdentifier	 attr PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
attrValue	TokenNameIdentifier	 attr Value
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// Attribute Locally Valid 	TokenNameCOMMENT_LINE	Attribute Locally Valid 
// For an attribute information item to be locally valid with respect to an attribute declaration all of the following must be true: 	TokenNameCOMMENT_LINE	For an attribute information item to be locally valid with respect to an attribute declaration all of the following must be true: 
// 1 The declaration must not be absent (see Missing Sub-components (5.3) for how this can fail to be the case). 	TokenNameCOMMENT_LINE	1 The declaration must not be absent (see Missing Sub-components (5.3) for how this can fail to be the case). 
// 2 Its {type definition} must not be absent. 	TokenNameCOMMENT_LINE	2 Its {type definition} must not be absent. 
// 3 The item's normalized value must be locally valid with respect to that {type definition} as per String Valid (3.14.4). 	TokenNameCOMMENT_LINE	3 The item's normalized value must be locally valid with respect to that {type definition} as per String Valid (3.14.4). 
// get simple type 	TokenNameCOMMENT_LINE	get simple type 
XSSimpleType	TokenNameIdentifier	 XS Simple Type
attDV	TokenNameIdentifier	 att DV
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
attDV	TokenNameIdentifier	 att DV
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// store the normalized value 	TokenNameCOMMENT_LINE	store the normalized value 
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
setValue	TokenNameIdentifier	 set Value
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// PSVI: element notation 	TokenNameCOMMENT_LINE	PSVI: element notation 
if	TokenNameif	
(	TokenNameLPAREN	
attDV	TokenNameIdentifier	 att DV
.	TokenNameDOT	
getVariety	TokenNameIdentifier	 get Variety
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
VARIETY_ATOMIC	TokenNameIdentifier	 VARIETY  ATOMIC
&&	TokenNameAND_AND	
attDV	TokenNameIdentifier	 att DV
.	TokenNameDOT	
getPrimitiveKind	TokenNameIdentifier	 get Primitive Kind
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
.	TokenNameDOT	
PRIMITIVE_NOTATION	TokenNameIdentifier	 PRIMITIVE  NOTATION
)	TokenNameRPAREN	
{	TokenNameLBRACE	
QName	TokenNameIdentifier	 Q Name
qName	TokenNameIdentifier	 q Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
)	TokenNameRPAREN	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammar	TokenNameIdentifier	 grammar
=	TokenNameEQUAL	
fGrammarBucket	TokenNameIdentifier	 f Grammar Bucket
.	TokenNameDOT	
getGrammar	TokenNameIdentifier	 get Grammar
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
//REVISIT: is it possible for the notation to be in different namespace than the attribute 	TokenNameCOMMENT_LINE	REVISIT: is it possible for the notation to be in different namespace than the attribute 
//with which it is associated, CHECK !! <fof n1:att1 = "n2:notation1" ..> 	TokenNameCOMMENT_LINE	with which it is associated, CHECK !! <fof n1:att1 = "n2:notation1" ..> 
// should we give chance to the application to be able to retrieve a grammar - nb 	TokenNameCOMMENT_LINE	should we give chance to the application to be able to retrieve a grammar - nb 
//REVISIT: what would be the triggering component here.. if it is attribute value that 	TokenNameCOMMENT_LINE	REVISIT: what would be the triggering component here.. if it is attribute value that 
// triggered the loading of grammar ?? -nb 	TokenNameCOMMENT_LINE	triggered the loading of grammar ?? -nb 
if	TokenNameif	
(	TokenNameLPAREN	
grammar	TokenNameIdentifier	 grammar
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNotation	TokenNameIdentifier	 f Notation
=	TokenNameEQUAL	
grammar	TokenNameIdentifier	 grammar
.	TokenNameDOT	
getGlobalNotationDecl	TokenNameIdentifier	 get Global Notation Decl
(	TokenNameLPAREN	
qName	TokenNameIdentifier	 q Name
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
idve	TokenNameIdentifier	 idve
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
idve	TokenNameIdentifier	 idve
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
idve	TokenNameIdentifier	 idve
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-attribute.3"	TokenNameStringLiteral	cvc-attribute.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
(	TokenNameLPAREN	
attDV	TokenNameIdentifier	 att DV
instanceof	TokenNameinstanceof	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
?	TokenNameQUESTION	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
XSSimpleTypeDecl	TokenNameIdentifier	 XS Simple Type Decl
)	TokenNameRPAREN	
attDV	TokenNameIdentifier	 att DV
)	TokenNameRPAREN	
.	TokenNameDOT	
getTypeName	TokenNameIdentifier	 get Type Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
attDV	TokenNameIdentifier	 att DV
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// get the value constraint from use or decl 	TokenNameCOMMENT_LINE	get the value constraint from use or decl 
// 4 The item's actual value must match the value of the {value constraint}, if it is present and fixed. // now check the value against the simpleType 	TokenNameCOMMENT_LINE	4 The item's actual value must match the value of the {value constraint}, if it is present and fixed. // now check the value against the simpleType 
if	TokenNameif	
(	TokenNameLPAREN	
actualValue	TokenNameIdentifier	 actual Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
.	TokenNameDOT	
isComparable	TokenNameIdentifier	 is Comparable
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-attribute.4"	TokenNameStringLiteral	cvc-attribute.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 3.1 If there is among the {attribute uses} an attribute use with an {attribute declaration} whose {name} matches the attribute information item's [local name] and whose {target namespace} is identical to the attribute information item's [namespace name] (where an absent {target namespace} is taken to be identical to a [namespace name] with no value), then the attribute information must be valid with respect to that attribute use as per Attribute Locally Valid (Use) (3.5.4). In this case the {attribute declaration} of that attribute use is the context-determined declaration for the attribute information item with respect to Schema-Validity Assessment (Attribute) (3.2.4) and Assessment Outcome (Attribute) (3.2.5). 	TokenNameCOMMENT_LINE	3.1 If there is among the {attribute uses} an attribute use with an {attribute declaration} whose {name} matches the attribute information item's [local name] and whose {target namespace} is identical to the attribute information item's [namespace name] (where an absent {target namespace} is taken to be identical to a [namespace name] with no value), then the attribute information must be valid with respect to that attribute use as per Attribute Locally Valid (Use) (3.5.4). In this case the {attribute declaration} of that attribute use is the context-determined declaration for the attribute information item with respect to Schema-Validity Assessment (Attribute) (3.2.4) and Assessment Outcome (Attribute) (3.2.5). 
if	TokenNameif	
(	TokenNameLPAREN	
actualValue	TokenNameIdentifier	 actual Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
currUse	TokenNameIdentifier	 curr Use
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fConstraintType	TokenNameIdentifier	 f Constraint Type
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
.	TokenNameDOT	
isComparable	TokenNameIdentifier	 is Comparable
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
,	TokenNameCOMMA	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.3.1"	TokenNameStringLiteral	cvc-complex-type.3.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fTempQName	TokenNameIdentifier	 f Temp Q Name
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
attrValue	TokenNameIdentifier	 attr Value
,	TokenNameCOMMA	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIdConstraint	TokenNameIdentifier	 f Id Constraint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PSVI: attribute declaration 	TokenNameCOMMENT_LINE	PSVI: attribute declaration 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fDeclaration	TokenNameIdentifier	 f Declaration
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
;	TokenNameSEMICOLON	
// PSVI: attribute type 	TokenNameCOMMENT_LINE	PSVI: attribute type 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fTypeDecl	TokenNameIdentifier	 f Type Decl
=	TokenNameEQUAL	
attDV	TokenNameIdentifier	 att DV
;	TokenNameSEMICOLON	
// PSVI: attribute normalized value 	TokenNameCOMMENT_LINE	PSVI: attribute normalized value 
// NOTE: we always store the normalized value, even if it's invlid, 	TokenNameCOMMENT_LINE	NOTE: we always store the normalized value, even if it's invlid, 
// because it might still be useful to the user. But when the it's 	TokenNameCOMMENT_LINE	because it might still be useful to the user. But when the it's 
// not valid, the normalized value is not trustable. 	TokenNameCOMMENT_LINE	not valid, the normalized value is not trustable. 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// PSVI: validation attempted: 	TokenNameCOMMENT_LINE	PSVI: validation attempted: 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidationAttempted	TokenNameIdentifier	 f Validation Attempted
=	TokenNameEQUAL	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
.	TokenNameDOT	
VALIDATION_FULL	TokenNameIdentifier	 VALIDATION  FULL
;	TokenNameSEMICOLON	
// We have seen an attribute that was declared. 	TokenNameCOMMENT_LINE	We have seen an attribute that was declared. 
fNNoneValidationDepth	TokenNameIdentifier	 f N None Validation Depth
=	TokenNameEQUAL	
fElementDepth	TokenNameIdentifier	 f Element Depth
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
errors	TokenNameIdentifier	 errors
=	TokenNameEQUAL	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
mergeContext	TokenNameIdentifier	 merge Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// PSVI: error codes 	TokenNameCOMMENT_LINE	PSVI: error codes 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fErrors	TokenNameIdentifier	 f Errors
=	TokenNameEQUAL	
errors	TokenNameIdentifier	 errors
;	TokenNameSEMICOLON	
// PSVI: validity 	TokenNameCOMMENT_LINE	PSVI: validity 
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidity	TokenNameIdentifier	 f Validity
=	TokenNameEQUAL	
(	TokenNameLPAREN	
errors	TokenNameIdentifier	 errors
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
.	TokenNameDOT	
VALIDITY_VALID	TokenNameIdentifier	 VALIDITY  VALID
:	TokenNameCOLON	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
.	TokenNameDOT	
VALIDITY_INVALID	TokenNameIdentifier	 VALIDITY  INVALID
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
void	TokenNamevoid	
addDefaultAttributes	TokenNameIdentifier	 add Default Attributes
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
XMLAttributes	TokenNameIdentifier	 XML Attributes
attributes	TokenNameIdentifier	 attributes
,	TokenNameCOMMA	
XSAttributeGroupDecl	TokenNameIdentifier	 XS Attribute Group Decl
attrGrp	TokenNameIdentifier	 attr Grp
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Check after all specified attrs are scanned 	TokenNameCOMMENT_LINE	Check after all specified attrs are scanned 
// (1) report error for REQUIRED attrs that are missing (V_TAGc) 	TokenNameCOMMENT_LINE	(1) report error for REQUIRED attrs that are missing (V_TAGc) 
// REVISIT: should we check prohibited attributes? 	TokenNameCOMMENT_LINE	REVISIT: should we check prohibited attributes? 
// (2) report error for PROHIBITED attrs that are present (V_TAGc) 	TokenNameCOMMENT_LINE	(2) report error for PROHIBITED attrs that are present (V_TAGc) 
// (3) add default attrs (FIXED and NOT_FIXED) 	TokenNameCOMMENT_LINE	(3) add default attrs (FIXED and NOT_FIXED) 
// 	TokenNameCOMMENT_LINE	 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
"==>addDefaultAttributes: "	TokenNameStringLiteral	==>addDefaultAttributes: 
+	TokenNamePLUS	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
XSObjectList	TokenNameIdentifier	 XS Object List
attrUses	TokenNameIdentifier	 attr Uses
=	TokenNameEQUAL	
attrGrp	TokenNameIdentifier	 attr Grp
.	TokenNameDOT	
getAttributeUses	TokenNameIdentifier	 get Attribute Uses
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
useCount	TokenNameIdentifier	 use Count
=	TokenNameEQUAL	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
currUse	TokenNameIdentifier	 curr Use
;	TokenNameSEMICOLON	
XSAttributeDecl	TokenNameIdentifier	 XS Attribute Decl
currDecl	TokenNameIdentifier	 curr Decl
;	TokenNameSEMICOLON	
short	TokenNameshort	
constType	TokenNameIdentifier	 const Type
;	TokenNameSEMICOLON	
ValidatedInfo	TokenNameIdentifier	 Validated Info
defaultValue	TokenNameIdentifier	 default Value
;	TokenNameSEMICOLON	
boolean	TokenNameboolean	
isSpecified	TokenNameIdentifier	 is Specified
;	TokenNameSEMICOLON	
QName	TokenNameIdentifier	 Q Name
attName	TokenNameIdentifier	 att Name
;	TokenNameSEMICOLON	
// for each attribute use 	TokenNameCOMMENT_LINE	for each attribute use 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
useCount	TokenNameIdentifier	 use Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currUse	TokenNameIdentifier	 curr Use
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSAttributeUseImpl	TokenNameIdentifier	 XS Attribute Use Impl
)	TokenNameRPAREN	
attrUses	TokenNameIdentifier	 attr Uses
.	TokenNameDOT	
item	TokenNameIdentifier	 item
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
currDecl	TokenNameIdentifier	 curr Decl
=	TokenNameEQUAL	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fAttrDecl	TokenNameIdentifier	 f Attr Decl
;	TokenNameSEMICOLON	
// get value constraint 	TokenNameCOMMENT_LINE	get value constraint 
constType	TokenNameIdentifier	 const Type
=	TokenNameEQUAL	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fConstraintType	TokenNameIdentifier	 f Constraint Type
;	TokenNameSEMICOLON	
defaultValue	TokenNameIdentifier	 default Value
=	TokenNameEQUAL	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
constType	TokenNameIdentifier	 const Type
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
constType	TokenNameIdentifier	 const Type
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
defaultValue	TokenNameIdentifier	 default Value
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// whether this attribute is specified 	TokenNameCOMMENT_LINE	whether this attribute is specified 
isSpecified	TokenNameIdentifier	 is Specified
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Element Locally Valid (Complex Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Complex Type) 
// 4 The {attribute declaration} of each attribute use in the {attribute uses} whose 	TokenNameCOMMENT_LINE	4 The {attribute declaration} of each attribute use in the {attribute uses} whose 
// {required} is true matches one of the attribute information items in the element 	TokenNameCOMMENT_LINE	{required} is true matches one of the attribute information items in the element 
// information item's [attributes] as per clause 3.1 above. 	TokenNameCOMMENT_LINE	information item's [attributes] as per clause 3.1 above. 
if	TokenNameif	
(	TokenNameLPAREN	
currUse	TokenNameIdentifier	 curr Use
.	TokenNameDOT	
fUse	TokenNameIdentifier	 f Use
==	TokenNameEQUAL_EQUAL	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
USE_REQUIRED	TokenNameIdentifier	 USE  REQUIRED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSpecified	TokenNameIdentifier	 is Specified
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.4"	TokenNameStringLiteral	cvc-complex-type.4
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// if the attribute is not specified, then apply the value constraint 	TokenNameCOMMENT_LINE	if the attribute is not specified, then apply the value constraint 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
isSpecified	TokenNameIdentifier	 is Specified
&&	TokenNameAND_AND	
constType	TokenNameIdentifier	 const Type
!=	TokenNameNOT_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
attName	TokenNameIdentifier	 att Name
=	TokenNameEQUAL	
new	TokenNamenew	
QName	TokenNameIdentifier	 Q Name
(	TokenNameLPAREN	
null	TokenNamenull	
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
,	TokenNameCOMMA	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
normalized	TokenNameIdentifier	 normalized
=	TokenNameEQUAL	
(	TokenNameLPAREN	
defaultValue	TokenNameIdentifier	 default Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
defaultValue	TokenNameIdentifier	 default Value
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
int	TokenNameint	
attrIndex	TokenNameIdentifier	 attr Index
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
attributes	TokenNameIdentifier	 attributes
instanceof	TokenNameinstanceof	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
attrs	TokenNameIdentifier	 attrs
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XMLAttributesImpl	TokenNameIdentifier	 XML Attributes Impl
)	TokenNameRPAREN	
attributes	TokenNameIdentifier	 attributes
;	TokenNameSEMICOLON	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
getLength	TokenNameIdentifier	 get Length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrs	TokenNameIdentifier	 attrs
.	TokenNameDOT	
addAttributeNS	TokenNameIdentifier	 add Attribute NS
(	TokenNameLPAREN	
attName	TokenNameIdentifier	 att Name
,	TokenNameCOMMA	
"CDATA"	TokenNameStringLiteral	CDATA
,	TokenNameCOMMA	
normalized	TokenNameIdentifier	 normalized
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
attrIndex	TokenNameIdentifier	 attr Index
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
addAttribute	TokenNameIdentifier	 add Attribute
(	TokenNameLPAREN	
attName	TokenNameIdentifier	 att Name
,	TokenNameCOMMA	
"CDATA"	TokenNameStringLiteral	CDATA
,	TokenNameCOMMA	
normalized	TokenNameIdentifier	 normalized
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fAugPSVI	TokenNameIdentifier	 f Aug PSVI
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// PSVI: attribute is "schema" specified 	TokenNameCOMMENT_LINE	PSVI: attribute is "schema" specified 
Augmentations	TokenNameIdentifier	 Augmentations
augs	TokenNameIdentifier	 augs
=	TokenNameEQUAL	
attributes	TokenNameIdentifier	 attributes
.	TokenNameDOT	
getAugmentations	TokenNameIdentifier	 get Augmentations
(	TokenNameLPAREN	
attrIndex	TokenNameIdentifier	 attr Index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
attrPSVI	TokenNameIdentifier	 attr PSVI
=	TokenNameEQUAL	
new	TokenNamenew	
AttributePSVImpl	TokenNameIdentifier	 Attribute PSV Impl
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
augs	TokenNameIdentifier	 augs
.	TokenNameDOT	
putItem	TokenNameIdentifier	 put Item
(	TokenNameLPAREN	
Constants	TokenNameIdentifier	 Constants
.	TokenNameDOT	
ATTRIBUTE_PSVI	TokenNameIdentifier	 ATTRIBUTE  PSVI
,	TokenNameCOMMA	
attrPSVI	TokenNameIdentifier	 attr PSVI
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fDeclaration	TokenNameIdentifier	 f Declaration
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fTypeDecl	TokenNameIdentifier	 f Type Decl
=	TokenNameEQUAL	
currDecl	TokenNameIdentifier	 curr Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValue	TokenNameIdentifier	 f Value
.	TokenNameDOT	
copyFrom	TokenNameIdentifier	 copy From
(	TokenNameLPAREN	
defaultValue	TokenNameIdentifier	 default Value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidationContext	TokenNameIdentifier	 f Validation Context
=	TokenNameEQUAL	
fValidationRoot	TokenNameIdentifier	 f Validation Root
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidity	TokenNameIdentifier	 f Validity
=	TokenNameEQUAL	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
.	TokenNameDOT	
VALIDITY_VALID	TokenNameIdentifier	 VALIDITY  VALID
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fValidationAttempted	TokenNameIdentifier	 f Validation Attempted
=	TokenNameEQUAL	
AttributePSVI	TokenNameIdentifier	 Attribute PSVI
.	TokenNameDOT	
VALIDATION_FULL	TokenNameIdentifier	 VALIDATION  FULL
;	TokenNameSEMICOLON	
attrPSVI	TokenNameIdentifier	 attr PSVI
.	TokenNameDOT	
fSpecified	TokenNameIdentifier	 f Specified
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// for 	TokenNameCOMMENT_LINE	for 
}	TokenNameRBRACE	
// addDefaultAttributes 	TokenNameCOMMENT_LINE	addDefaultAttributes 
/** * If there is not text content, and there is a * {value constraint} on the corresponding element decl, then return * an XMLString representing the default value. */	TokenNameCOMMENT_JAVADOC	 If there is not text content, and there is a {value constraint} on the corresponding element decl, then return an XMLString representing the default value. 
void	TokenNamevoid	
processElementContent	TokenNameIdentifier	 process Element Content
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 1 If the item is ?valid? with respect to an element declaration as per Element Locally Valid (Element) (?3.3.4) and the {value constraint} is present, but clause 3.2 of Element Locally Valid (Element) (?3.3.4) above is not satisfied and the item has no element or character information item [children], then schema. Furthermore, the post-schema-validation infoset has the canonical lexical representation of the {value constraint} value as the item's [schema normalized value] property. 	TokenNameCOMMENT_LINE	1 If the item is ?valid? with respect to an element declaration as per Element Locally Valid (Element) (?3.3.4) and the {value constraint} is present, but clause 3.2 of Element Locally Valid (Element) (?3.3.4) above is not satisfied and the item has no element or character information item [children], then schema. Furthermore, the post-schema-validation infoset has the canonical lexical representation of the {value constraint} value as the item's [schema normalized value] property. 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fSawText	TokenNameIdentifier	 f Saw Text
&&	TokenNameAND_AND	
!	TokenNameNOT	
fSubElement	TokenNameIdentifier	 f Sub Element
&&	TokenNameAND_AND	
!	TokenNameNOT	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
strv	TokenNameIdentifier	 strv
=	TokenNameEQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
bufLen	TokenNameIdentifier	 buf Len
=	TokenNameEQUAL	
strv	TokenNameIdentifier	 strv
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
bufLen	TokenNameIdentifier	 buf Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
bufLen	TokenNameIdentifier	 buf Len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
strv	TokenNameIdentifier	 strv
.	TokenNameDOT	
getChars	TokenNameIdentifier	 get Chars
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bufLen	TokenNameIdentifier	 buf Len
,	TokenNameCOMMA	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
bufLen	TokenNameIdentifier	 buf Len
;	TokenNameSEMICOLON	
fDefaultValue	TokenNameIdentifier	 f Default Value
=	TokenNameEQUAL	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// fixed values are handled later, after xsi:type determined. 	TokenNameCOMMENT_LINE	fixed values are handled later, after xsi:type determined. 
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Element Locally Valid (Element) 	TokenNameCOMMENT_LINE	Element Locally Valid (Element) 
// 3.2.1 The element information item must have no character or element information item [children]. 	TokenNameCOMMENT_LINE	3.2.1 The element information item must have no character or element information item [children]. 
if	TokenNameif	
(	TokenNameLPAREN	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSubElement	TokenNameIdentifier	 f Sub Element
||	TokenNameOR_OR	
fSawText	TokenNameIdentifier	 f Saw Text
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.3.2.1"	TokenNameStringLiteral	cvc-elt.3.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_XSI	TokenNameIdentifier	 URI  XSI
+	TokenNamePLUS	
","	TokenNameStringLiteral	,
+	TokenNamePLUS	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
XSI_NIL	TokenNameIdentifier	 XSI  NIL
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
this	TokenNamethis	
.	TokenNameDOT	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
reset	TokenNameIdentifier	 reset
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 5 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	5 The appropriate case among the following must be true: 
// 5.1 If the declaration has a {value constraint}, the item has neither element nor character [children] and clause 3.2 has not applied, then all of the following must be true: 	TokenNameCOMMENT_LINE	5.1 If the declaration has a {value constraint}, the item has neither element nor character [children] and clause 3.2 has not applied, then all of the following must be true: 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
!=	TokenNameNOT_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_NONE	TokenNameIdentifier	 VC  NONE
&&	TokenNameAND_AND	
!	TokenNameNOT	
fSubElement	TokenNameIdentifier	 f Sub Element
&&	TokenNameAND_AND	
!	TokenNameNOT	
fSawText	TokenNameIdentifier	 f Saw Text
&&	TokenNameAND_AND	
!	TokenNameNOT	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 5.1.1 If the actual type definition is a local type definition then the canonical lexical representation of the {value constraint} value must be a valid default for the actual type definition as defined in Element Default Valid (Immediate) (3.3.6). 	TokenNameCOMMENT_LINE	5.1.1 If the actual type definition is a local type definition then the canonical lexical representation of the {value constraint} value must be a valid default for the actual type definition as defined in Element Default Valid (Immediate) (3.3.6). 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
!=	TokenNameNOT_EQUAL	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fType	TokenNameIdentifier	 f Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
//REVISIT:we should pass ValidatedInfo here. 	TokenNameCOMMENT_LINE	REVISIT:we should pass ValidatedInfo here. 
if	TokenNameif	
(	TokenNameLPAREN	
XSConstraints	TokenNameIdentifier	 XS Constraints
.	TokenNameDOT	
ElementDefaultValidImmediate	TokenNameIdentifier	 Element Default Valid Immediate
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fState4XsiType	TokenNameIdentifier	 f State4 Xsi Type
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.5.1.1"	TokenNameStringLiteral	cvc-elt.5.1.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 5.1.2 The element information item with the canonical lexical representation of the {value constraint} value used as its normalized value must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4). 	TokenNameCOMMENT_LINE	5.1.2 The element information item with the canonical lexical representation of the {value constraint} value used as its normalized value must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4). 
// REVISIT: don't use toString, but validateActualValue instead 	TokenNameCOMMENT_LINE	REVISIT: don't use toString, but validateActualValue instead 
// use the fState4ApplyDefault 	TokenNameCOMMENT_LINE	use the fState4ApplyDefault 
elementLocallyValidType	TokenNameIdentifier	 element Locally Valid Type
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// The following method call also deal with clause 1.2.2 of the constraint 	TokenNameCOMMENT_LINE	The following method call also deal with clause 1.2.2 of the constraint 
// Validation Rule: Schema-Validity Assessment (Element) 	TokenNameCOMMENT_LINE	Validation Rule: Schema-Validity Assessment (Element) 
// 5.2 If the declaration has no {value constraint} or the item has either element or character [children] or clause 3.2 has applied, then all of the following must be true: 	TokenNameCOMMENT_LINE	5.2 If the declaration has no {value constraint} or the item has either element or character [children] or clause 3.2 has applied, then all of the following must be true: 
// 5.2.1 The element information item must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4). 	TokenNameCOMMENT_LINE	5.2.1 The element information item must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4). 
Object	TokenNameIdentifier	 Object
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
elementLocallyValidType	TokenNameIdentifier	 element Locally Valid Type
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
fBuffer	TokenNameIdentifier	 f Buffer
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 5.2.2 If there is a fixed {value constraint} and clause 3.2 has not applied, all of the following must be true: 	TokenNameCOMMENT_LINE	5.2.2 If there is a fixed {value constraint} and clause 3.2 has not applied, all of the following must be true: 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
getConstraintType	TokenNameIdentifier	 get Constraint Type
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
VC_FIXED	TokenNameIdentifier	 VC  FIXED
&&	TokenNameAND_AND	
!	TokenNameNOT	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 5.2.2.1 The element information item must have no element information item [children]. 	TokenNameCOMMENT_LINE	5.2.2.1 The element information item must have no element information item [children]. 
if	TokenNameif	
(	TokenNameLPAREN	
fSubElement	TokenNameIdentifier	 f Sub Element
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.5.2.2.1"	TokenNameStringLiteral	cvc-elt.5.2.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 5.2.2.2 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	5.2.2.2 The appropriate case among the following must be true: 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
COMPLEX_TYPE	TokenNameIdentifier	 COMPLEX  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
// 5.2.2.2.1 If the {content type} of the actual type definition is mixed, then the initial value of the item must match the canonical lexical representation of the {value constraint} value. 	TokenNameCOMMENT_LINE	5.2.2.2.1 If the {content type} of the actual type definition is mixed, then the initial value of the item must match the canonical lexical representation of the {value constraint} value. 
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: how to get the initial value, does whiteSpace count? 	TokenNameCOMMENT_LINE	REVISIT: how to get the initial value, does whiteSpace count? 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
)	TokenNameRPAREN	
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.5.2.2.2.1"	TokenNameStringLiteral	cvc-elt.5.2.2.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 5.2.2.2.2 If the {content type} of the actual type definition is a simple type definition, then the actual value of the item must match the canonical lexical representation of the {value constraint} value. 	TokenNameCOMMENT_LINE	5.2.2.2.2 If the {content type} of the actual type definition is a simple type definition, then the actual value of the item must match the canonical lexical representation of the {value constraint} value. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
actualValue	TokenNameIdentifier	 actual Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
.	TokenNameDOT	
isComparable	TokenNameIdentifier	 is Comparable
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.5.2.2.2.2"	TokenNameStringLiteral	cvc-elt.5.2.2.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
actualValue	TokenNameIdentifier	 actual Value
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
!	TokenNameNOT	
ValidatedInfo	TokenNameIdentifier	 Validated Info
.	TokenNameDOT	
isComparable	TokenNameIdentifier	 is Comparable
(	TokenNameLPAREN	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
actualValue	TokenNameIdentifier	 actual Value
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
actualValue	TokenNameIdentifier	 actual Value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: the spec didn't mention this case: fixed 	TokenNameCOMMENT_LINE	REVISIT: the spec didn't mention this case: fixed 
// value with simple type 	TokenNameCOMMENT_LINE	value with simple type 
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.5.2.2.2.2"	TokenNameStringLiteral	cvc-elt.5.2.2.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
content	TokenNameIdentifier	 content
,	TokenNameCOMMA	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
.	TokenNameDOT	
fDefault	TokenNameIdentifier	 f Default
.	TokenNameDOT	
stringValue	TokenNameIdentifier	 string Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDefaultValue	TokenNameIdentifier	 f Default Value
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
&&	TokenNameAND_AND	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fUnionType	TokenNameIdentifier	 f Union Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// for union types we need to send data because we delayed sending 	TokenNameCOMMENT_LINE	for union types we need to send data because we delayed sending 
// this data when we received it in the characters() call. 	TokenNameCOMMENT_LINE	this data when we received it in the characters() call. 
String	TokenNameIdentifier	 String
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
.	TokenNameDOT	
normalizedValue	TokenNameIdentifier	 normalized Value
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
content	TokenNameIdentifier	 content
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
content	TokenNameIdentifier	 content
=	TokenNameEQUAL	
fBuffer	TokenNameIdentifier	 f Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
bufLen	TokenNameIdentifier	 buf Len
=	TokenNameEQUAL	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<	TokenNameLESS	
bufLen	TokenNameIdentifier	 buf Len
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
=	TokenNameEQUAL	
new	TokenNamenew	
char	TokenNamechar	
[	TokenNameLBRACKET	
bufLen	TokenNameIdentifier	 buf Len
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
content	TokenNameIdentifier	 content
.	TokenNameDOT	
getChars	TokenNameIdentifier	 get Chars
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
bufLen	TokenNameIdentifier	 buf Len
,	TokenNameCOMMA	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
ch	TokenNameIdentifier	 ch
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
offset	TokenNameIdentifier	 offset
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
.	TokenNameDOT	
length	TokenNameIdentifier	 length
=	TokenNameEQUAL	
bufLen	TokenNameIdentifier	 buf Len
;	TokenNameSEMICOLON	
fDocumentHandler	TokenNameIdentifier	 f Document Handler
.	TokenNameDOT	
characters	TokenNameIdentifier	 characters
(	TokenNameLPAREN	
fNormalizedStr	TokenNameIdentifier	 f Normalized Str
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// processElementContent 	TokenNameCOMMENT_LINE	processElementContent 
Object	TokenNameIdentifier	 Object
elementLocallyValidType	TokenNameIdentifier	 element Locally Valid Type
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
textContent	TokenNameIdentifier	 text Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
return	TokenNamereturn	
null	TokenNamenull	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
retValue	TokenNameIdentifier	 ret Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
// Element Locally Valid (Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Type) 
// 3 The appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	3 The appropriate case among the following must be true: 
// 3.1 If the type definition is a simple type definition, then all of the following must be true: 	TokenNameCOMMENT_LINE	3.1 If the type definition is a simple type definition, then all of the following must be true: 
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
.	TokenNameDOT	
getTypeCategory	TokenNameIdentifier	 get Type Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
XSTypeDefinition	TokenNameIdentifier	 XS Type Definition
.	TokenNameDOT	
SIMPLE_TYPE	TokenNameIdentifier	 SIMPLE  TYPE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 3.1.2 The element information item must have no element information item [children]. 	TokenNameCOMMENT_LINE	3.1.2 The element information item must have no element information item [children]. 
if	TokenNameif	
(	TokenNameLPAREN	
fSubElement	TokenNameIdentifier	 f Sub Element
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-type.3.1.2"	TokenNameStringLiteral	cvc-type.3.1.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 3.1.3 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the normalized value must be valid with respect to the type definition as defined by String Valid (3.14.4). 	TokenNameCOMMENT_LINE	3.1.3 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the normalized value must be valid with respect to the type definition as defined by String Valid (3.14.4). 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
||	TokenNameOR_OR	
fUnionType	TokenNameIdentifier	 f Union Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNormalizationRequired	TokenNameIdentifier	 set Normalization Required
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
retValue	TokenNameIdentifier	 ret Value
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
textContent	TokenNameIdentifier	 text Content
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-type.3.1.3"	TokenNameStringLiteral	cvc-type.3.1.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
textContent	TokenNameIdentifier	 text Content
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
// 3.2 If the type definition is a complex type definition, then the element information item must be valid with respect to the type definition as per Element Locally Valid (Complex Type) (3.4.4); 	TokenNameCOMMENT_LINE	3.2 If the type definition is a complex type definition, then the element information item must be valid with respect to the type definition as per Element Locally Valid (Complex Type) (3.4.4); 
retValue	TokenNameIdentifier	 ret Value
=	TokenNameEQUAL	
elementLocallyValidComplexType	TokenNameIdentifier	 element Locally Valid Complex Type
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
textContent	TokenNameIdentifier	 text Content
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
retValue	TokenNameIdentifier	 ret Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// elementLocallyValidType 	TokenNameCOMMENT_LINE	elementLocallyValidType 
Object	TokenNameIdentifier	 Object
elementLocallyValidComplexType	TokenNameIdentifier	 element Locally Valid Complex Type
(	TokenNameLPAREN	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
textContent	TokenNameIdentifier	 text Content
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
ctype	TokenNameIdentifier	 ctype
=	TokenNameEQUAL	
(	TokenNameLPAREN	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
)	TokenNameRPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
;	TokenNameSEMICOLON	
// Element Locally Valid (Complex Type) 	TokenNameCOMMENT_LINE	Element Locally Valid (Complex Type) 
// For an element information item to be locally valid with respect to a complex type definition all of the following must be true: 	TokenNameCOMMENT_LINE	For an element information item to be locally valid with respect to a complex type definition all of the following must be true: 
// 1 {abstract} is false. 	TokenNameCOMMENT_LINE	1 {abstract} is false. 
// 2 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the appropriate case among the following must be true: 	TokenNameCOMMENT_LINE	2 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the appropriate case among the following must be true: 
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNil	TokenNameIdentifier	 f Nil
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// 2.1 If the {content type} is empty, then the element information item has no character or element information item [children]. 	TokenNameCOMMENT_LINE	2.1 If the {content type} is empty, then the element information item has no character or element information item [children]. 
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_EMPTY	TokenNameIdentifier	 CONTENTTYPE  EMPTY
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
fSubElement	TokenNameIdentifier	 f Sub Element
||	TokenNameOR_OR	
fSawText	TokenNameIdentifier	 f Saw Text
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.1"	TokenNameStringLiteral	cvc-complex-type.2.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 2.2 If the {content type} is a simple type definition, then the element information item has no element information item [children], and the normalized value of the element information item is valid with respect to that simple type definition as defined by String Valid (3.14.4). 	TokenNameCOMMENT_LINE	2.2 If the {content type} is a simple type definition, then the element information item has no element information item [children], and the normalized value of the element information item is valid with respect to that simple type definition as defined by String Valid (3.14.4). 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_SIMPLE	TokenNameIdentifier	 CONTENTTYPE  SIMPLE
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSubElement	TokenNameIdentifier	 f Sub Element
)	TokenNameRPAREN	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.2"	TokenNameStringLiteral	cvc-complex-type.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
XSSimpleType	TokenNameIdentifier	 XS Simple Type
dv	TokenNameIdentifier	 dv
=	TokenNameEQUAL	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fXSSimpleType	TokenNameIdentifier	 f XS Simple Type
;	TokenNameSEMICOLON	
try	TokenNametry	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
fNormalizeData	TokenNameIdentifier	 f Normalize Data
||	TokenNameOR_OR	
fUnionType	TokenNameIdentifier	 f Union Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValidationState	TokenNameIdentifier	 f Validation State
.	TokenNameDOT	
setNormalizationRequired	TokenNameIdentifier	 set Normalization Required
(	TokenNameLPAREN	
true	TokenNametrue	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
actualValue	TokenNameIdentifier	 actual Value
=	TokenNameEQUAL	
dv	TokenNameIdentifier	 dv
.	TokenNameDOT	
validate	TokenNameIdentifier	 validate
(	TokenNameLPAREN	
textContent	TokenNameIdentifier	 text Content
,	TokenNameCOMMA	
fValidationState	TokenNameIdentifier	 f Validation State
,	TokenNameCOMMA	
fValidatedInfo	TokenNameIdentifier	 f Validated Info
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
catch	TokenNamecatch	
(	TokenNameLPAREN	
InvalidDatatypeValueException	TokenNameIdentifier	 Invalid Datatype Value Exception
e	TokenNameIdentifier	 e
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
e	TokenNameIdentifier	 e
.	TokenNameDOT	
getArgs	TokenNameIdentifier	 get Args
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.2"	TokenNameStringLiteral	cvc-complex-type.2.2
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// REVISIT: eventually, this method should return the same actualValue as elementLocallyValidType... 	TokenNameCOMMENT_LINE	REVISIT: eventually, this method should return the same actualValue as elementLocallyValidType... 
// obviously it'll return null when the content is complex. 	TokenNameCOMMENT_LINE	obviously it'll return null when the content is complex. 
}	TokenNameRBRACE	
// 2.3 If the {content type} is element-only, then the element information item has no character information item [children] other than those whose [character code] is defined as a white space in [XML 1.0 (Second Edition)]. 	TokenNameCOMMENT_LINE	2.3 If the {content type} is element-only, then the element information item has no character information item [children] other than those whose [character code] is defined as a white space in [XML 1.0 (Second Edition)]. 
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fSawCharacters	TokenNameIdentifier	 f Saw Characters
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.3"	TokenNameStringLiteral	cvc-complex-type.2.3
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// 2.4 If the {content type} is element-only or mixed, then the sequence of the element information item's element information item [children], if any, taken in order, is valid with respect to the {content type}'s particle, as defined in Element Sequence Locally Valid (Particle) (3.9.4). 	TokenNameCOMMENT_LINE	2.4 If the {content type} is element-only or mixed, then the sequence of the element information item's element information item [children], if any, taken in order, is valid with respect to the {content type}'s particle, as defined in Element Sequence Locally Valid (Particle) (3.9.4). 
if	TokenNameif	
(	TokenNameLPAREN	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_ELEMENT	TokenNameIdentifier	 CONTENTTYPE  ELEMENT
||	TokenNameOR_OR	
ctype	TokenNameIdentifier	 ctype
.	TokenNameDOT	
fContentType	TokenNameIdentifier	 f Content Type
==	TokenNameEQUAL_EQUAL	
XSComplexTypeDecl	TokenNameIdentifier	 XS Complex Type Decl
.	TokenNameDOT	
CONTENTTYPE_MIXED	TokenNameIdentifier	 CONTENTTYPE  MIXED
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// if the current state is a valid state, check whether 	TokenNameCOMMENT_LINE	if the current state is a valid state, check whether 
// it's one of the final states. 	TokenNameCOMMENT_LINE	it's one of the final states. 
if	TokenNameif	
(	TokenNameLPAREN	
DEBUG	TokenNameIdentifier	 DEBUG
)	TokenNameRPAREN	
{	TokenNameLBRACE	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
out	TokenNameIdentifier	 out
.	TokenNameDOT	
println	TokenNameIdentifier	 println
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
>=	TokenNameGREATER_EQUAL	
0	TokenNameIntegerLiteral	
&&	TokenNameAND_AND	
!	TokenNameNOT	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
endContentModel	TokenNameIdentifier	 end Content Model
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
expected	TokenNameIdentifier	 expected
=	TokenNameEQUAL	
expectedStr	TokenNameIdentifier	 expected Str
(	TokenNameLPAREN	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
whatCanGoHere	TokenNameIdentifier	 what Can Go Here
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
occurenceInfo	TokenNameIdentifier	 occurence Info
=	TokenNameEQUAL	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
occurenceInfo	TokenNameIdentifier	 occurence Info
(	TokenNameLPAREN	
fCurrCMState	TokenNameIdentifier	 f Curr CM State
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
minOccurs	TokenNameIdentifier	 min Occurs
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
0	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
// Check if this is a violation of minOccurs 	TokenNameCOMMENT_LINE	Check if this is a violation of minOccurs 
if	TokenNameif	
(	TokenNameLPAREN	
count	TokenNameIdentifier	 count
<	TokenNameLESS	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
required	TokenNameIdentifier	 required
=	TokenNameEQUAL	
minOccurs	TokenNameIdentifier	 min Occurs
-	TokenNameMINUS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
>	TokenNameGREATER	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.j"	TokenNameStringLiteral	cvc-complex-type.2.4.j
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
getTermName	TokenNameIdentifier	 get Term Name
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
required	TokenNameIdentifier	 required
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.i"	TokenNameStringLiteral	cvc-complex-type.2.4.i
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
fCurrentCM	TokenNameIdentifier	 f Current CM
.	TokenNameDOT	
getTermName	TokenNameIdentifier	 get Term Name
(	TokenNameLPAREN	
occurenceInfo	TokenNameIdentifier	 occurence Info
[	TokenNameLBRACKET	
3	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
Integer	TokenNameIdentifier	 Integer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
minOccurs	TokenNameIdentifier	 min Occurs
)	TokenNameRPAREN	
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.b"	TokenNameStringLiteral	cvc-complex-type.2.4.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-complex-type.2.4.b"	TokenNameStringLiteral	cvc-complex-type.2.4.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
expected	TokenNameIdentifier	 expected
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// elementLocallyValidComplexType 	TokenNameCOMMENT_LINE	elementLocallyValidComplexType 
void	TokenNamevoid	
processRootTypeQName	TokenNameIdentifier	 process Root Type Q Name
(	TokenNameLPAREN	
final	TokenNamefinal	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
rootTypeQName	TokenNameIdentifier	 root Type Q Name
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
=	TokenNameEQUAL	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XMLConstants	TokenNameIdentifier	 XML Constants
.	TokenNameDOT	
NULL_NS_URI	TokenNameIdentifier	 NULL  NS  URI
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
SchemaSymbols	TokenNameIdentifier	 Schema Symbols
.	TokenNameDOT	
URI_SCHEMAFORSCHEMA	TokenNameIdentifier	 URI  SCHEMAFORSCHEMA
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
.	TokenNameDOT	
SG_SchemaNS	TokenNameIdentifier	 SG  Schema NS
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammarForRootType	TokenNameIdentifier	 grammar For Root Type
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ELEMENT	TokenNameIdentifier	 CONTEXT  ELEMENT
,	TokenNameCOMMA	
rootTypeNamespace	TokenNameIdentifier	 root Type Namespace
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammarForRootType	TokenNameIdentifier	 grammar For Root Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentType	TokenNameIdentifier	 f Current Type
=	TokenNameEQUAL	
grammarForRootType	TokenNameIdentifier	 grammar For Root Type
.	TokenNameDOT	
getGlobalTypeDecl	TokenNameIdentifier	 get Global Type Decl
(	TokenNameLPAREN	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentType	TokenNameIdentifier	 f Current Type
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
typeName	TokenNameIdentifier	 type Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XMLConstants	TokenNameIdentifier	 XML Constants
.	TokenNameDOT	
DEFAULT_NS_PREFIX	TokenNameIdentifier	 DEFAULT  NS  PREFIX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
rootTypeQName	TokenNameIdentifier	 root Type Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-type.1"	TokenNameStringLiteral	cvc-type.1
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
typeName	TokenNameIdentifier	 type Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// processRootTypeQName 	TokenNameCOMMENT_LINE	processRootTypeQName 
void	TokenNamevoid	
processRootElementDeclQName	TokenNameIdentifier	 process Root Element Decl Q Name
(	TokenNameLPAREN	
final	TokenNamefinal	
javax	TokenNameIdentifier	 javax
.	TokenNameDOT	
xml	TokenNameIdentifier	 xml
.	TokenNameDOT	
namespace	TokenNameIdentifier	 namespace
.	TokenNameDOT	
QName	TokenNameIdentifier	 Q Name
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
,	TokenNameCOMMA	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
rootElementDeclNamespace	TokenNameIdentifier	 root Element Decl Namespace
=	TokenNameEQUAL	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getNamespaceURI	TokenNameIdentifier	 get Namespace URI
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
rootElementDeclNamespace	TokenNameIdentifier	 root Element Decl Namespace
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
rootElementDeclNamespace	TokenNameIdentifier	 root Element Decl Namespace
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XMLConstants	TokenNameIdentifier	 XML Constants
.	TokenNameDOT	
NULL_NS_URI	TokenNameIdentifier	 NULL  NS  URI
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
rootElementDeclNamespace	TokenNameIdentifier	 root Element Decl Namespace
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
final	TokenNamefinal	
SchemaGrammar	TokenNameIdentifier	 Schema Grammar
grammarForRootElement	TokenNameIdentifier	 grammar For Root Element
=	TokenNameEQUAL	
findSchemaGrammar	TokenNameIdentifier	 find Schema Grammar
(	TokenNameLPAREN	
XSDDescription	TokenNameIdentifier	 XSD Description
.	TokenNameDOT	
CONTEXT_ELEMENT	TokenNameIdentifier	 CONTEXT  ELEMENT
,	TokenNameCOMMA	
rootElementDeclNamespace	TokenNameIdentifier	 root Element Decl Namespace
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
grammarForRootElement	TokenNameIdentifier	 grammar For Root Element
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
=	TokenNameEQUAL	
grammarForRootElement	TokenNameIdentifier	 grammar For Root Element
.	TokenNameDOT	
getGlobalElementDecl	TokenNameIdentifier	 get Global Element Decl
(	TokenNameLPAREN	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
declName	TokenNameIdentifier	 decl Name
=	TokenNameEQUAL	
(	TokenNameLPAREN	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
XMLConstants	TokenNameIdentifier	 XML Constants
.	TokenNameDOT	
DEFAULT_NS_PREFIX	TokenNameIdentifier	 DEFAULT  NS  PREFIX
)	TokenNameRPAREN	
)	TokenNameRPAREN	
?	TokenNameQUESTION	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
:	TokenNameCOLON	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getPrefix	TokenNameIdentifier	 get Prefix
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
":"	TokenNameStringLiteral	:
+	TokenNamePLUS	
rootElementDeclQName	TokenNameIdentifier	 root Element Decl Q Name
.	TokenNameDOT	
getLocalPart	TokenNameIdentifier	 get Local Part
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.1.a"	TokenNameStringLiteral	cvc-elt.1.a
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
declName	TokenNameIdentifier	 decl Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
checkElementMatchesRootElementDecl	TokenNameIdentifier	 check Element Matches Root Element Decl
(	TokenNameLPAREN	
fCurrentElemDecl	TokenNameIdentifier	 f Current Elem Decl
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// processRootElementDeclQName 	TokenNameCOMMENT_LINE	processRootElementDeclQName 
void	TokenNamevoid	
checkElementMatchesRootElementDecl	TokenNameIdentifier	 check Element Matches Root Element Decl
(	TokenNameLPAREN	
final	TokenNamefinal	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
rootElementDecl	TokenNameIdentifier	 root Element Decl
,	TokenNameCOMMA	
final	TokenNamefinal	
QName	TokenNameIdentifier	 Q Name
element	TokenNameIdentifier	 element
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// Report an error if the name of the element does 	TokenNameCOMMENT_LINE	Report an error if the name of the element does 
// not match the name of the specified element declaration. 	TokenNameCOMMENT_LINE	not match the name of the specified element declaration. 
if	TokenNameif	
(	TokenNameLPAREN	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
localpart	TokenNameIdentifier	 localpart
!=	TokenNameNOT_EQUAL	
rootElementDecl	TokenNameIdentifier	 root Element Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
||	TokenNameOR_OR	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
uri	TokenNameIdentifier	 uri
!=	TokenNameNOT_EQUAL	
rootElementDecl	TokenNameIdentifier	 root Element Decl
.	TokenNameDOT	
fTargetNamespace	TokenNameIdentifier	 f Target Namespace
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
"cvc-elt.1.b"	TokenNameStringLiteral	cvc-elt.1.b
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
element	TokenNameIdentifier	 element
.	TokenNameDOT	
rawname	TokenNameIdentifier	 rawname
,	TokenNameCOMMA	
rootElementDecl	TokenNameIdentifier	 root Element Decl
.	TokenNameDOT	
fName	TokenNameIdentifier	 f Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// checkElementMatchesRootElementDecl 	TokenNameCOMMENT_LINE	checkElementMatchesRootElementDecl 
void	TokenNamevoid	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
arguments	TokenNameIdentifier	 arguments
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fDoValidation	TokenNameIdentifier	 f Do Validation
)	TokenNameRPAREN	
fXSIErrorReporter	TokenNameIdentifier	 f XSI Error Reporter
.	TokenNameDOT	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
XSMessageFormatter	TokenNameIdentifier	 XS Message Formatter
.	TokenNameDOT	
SCHEMA_DOMAIN	TokenNameIdentifier	 SCHEMA  DOMAIN
,	TokenNameCOMMA	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
arguments	TokenNameIdentifier	 arguments
,	TokenNameCOMMA	
XMLErrorReporter	TokenNameIdentifier	 XML Error Reporter
.	TokenNameDOT	
SEVERITY_ERROR	TokenNameIdentifier	 SEVERITY  ERROR
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
String	TokenNameIdentifier	 String
expectedStr	TokenNameIdentifier	 expected Str
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
expected	TokenNameIdentifier	 expected
)	TokenNameRPAREN	
{	TokenNameLBRACE	
StringBuffer	TokenNameIdentifier	 String Buffer
ret	TokenNameIdentifier	 ret
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
"{"	TokenNameStringLiteral	{
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
ret	TokenNameIdentifier	 ret
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
", "	TokenNameStringLiteral	, 
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ret	TokenNameIdentifier	 ret
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
expected	TokenNameIdentifier	 expected
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
ret	TokenNameIdentifier	 ret
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
'}'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
ret	TokenNameIdentifier	 ret
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/**********************************/	TokenNameCOMMENT_JAVADOC	*******************************
// xpath matcher information 	TokenNameCOMMENT_LINE	xpath matcher information 
/** * Stack of XPath matchers for identity constraints. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Stack of XPath matchers for identity constraints. * @author Andy Clark, IBM 
protected	TokenNameprotected	
static	TokenNamestatic	
class	TokenNameclass	
XPathMatcherStack	TokenNameIdentifier	 X Path Matcher Stack
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Active matchers. */	TokenNameCOMMENT_JAVADOC	 Active matchers. 
protected	TokenNameprotected	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fMatchers	TokenNameIdentifier	 f Matchers
=	TokenNameEQUAL	
new	TokenNamenew	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
[	TokenNameLBRACKET	
4	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
/** Count of active matchers. */	TokenNameCOMMENT_JAVADOC	 Count of active matchers. 
protected	TokenNameprotected	
int	TokenNameint	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
;	TokenNameSEMICOLON	
/** Offset stack for contexts. */	TokenNameCOMMENT_JAVADOC	 Offset stack for contexts. 
protected	TokenNameprotected	
IntStack	TokenNameIdentifier	 Int Stack
fContextStack	TokenNameIdentifier	 f Context Stack
=	TokenNameEQUAL	
new	TokenNamenew	
IntStack	TokenNameIdentifier	 Int Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
public	TokenNamepublic	
XPathMatcherStack	TokenNameIdentifier	 X Path Matcher Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// <init>() 	TokenNameCOMMENT_LINE	<init>() 
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
/** Resets the XPath matcher stack. */	TokenNameCOMMENT_JAVADOC	 Resets the XPath matcher stack. 
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMatchers	TokenNameIdentifier	 f Matchers
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fContextStack	TokenNameIdentifier	 f Context Stack
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// clear() 	TokenNameCOMMENT_LINE	clear() 
/** Returns the size of the stack. */	TokenNameCOMMENT_JAVADOC	 Returns the size of the stack. 
public	TokenNamepublic	
int	TokenNameint	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fContextStack	TokenNameIdentifier	 f Context Stack
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// size():int 	TokenNameCOMMENT_LINE	size():int 
/** Returns the count of XPath matchers. */	TokenNameCOMMENT_JAVADOC	 Returns the count of XPath matchers. 
public	TokenNamepublic	
int	TokenNameint	
getMatcherCount	TokenNameIdentifier	 get Matcher Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getMatcherCount():int 	TokenNameCOMMENT_LINE	getMatcherCount():int 
/** Adds a matcher. */	TokenNameCOMMENT_JAVADOC	 Adds a matcher. 
public	TokenNamepublic	
void	TokenNamevoid	
addMatcher	TokenNameIdentifier	 add Matcher
(	TokenNameLPAREN	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
matcher	TokenNameIdentifier	 matcher
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureMatcherCapacity	TokenNameIdentifier	 ensure Matcher Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMatchers	TokenNameIdentifier	 f Matchers
[	TokenNameLBRACKET	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
matcher	TokenNameIdentifier	 matcher
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// addMatcher(XPathMatcher) 	TokenNameCOMMENT_LINE	addMatcher(XPathMatcher) 
/** Returns the XPath matcher at the specified index. */	TokenNameCOMMENT_JAVADOC	 Returns the XPath matcher at the specified index. 
public	TokenNamepublic	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
getMatcherAt	TokenNameIdentifier	 get Matcher At
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fMatchers	TokenNameIdentifier	 f Matchers
[	TokenNameLBRACKET	
index	TokenNameIdentifier	 index
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getMatcherAt(index):XPathMatcher 	TokenNameCOMMENT_LINE	getMatcherAt(index):XPathMatcher 
/** Pushes a new context onto the stack. */	TokenNameCOMMENT_JAVADOC	 Pushes a new context onto the stack. 
public	TokenNamepublic	
void	TokenNamevoid	
pushContext	TokenNameIdentifier	 push Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fContextStack	TokenNameIdentifier	 f Context Stack
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// pushContext() 	TokenNameCOMMENT_LINE	pushContext() 
/** Pops a context off of the stack. */	TokenNameCOMMENT_JAVADOC	 Pops a context off of the stack. 
public	TokenNamepublic	
void	TokenNamevoid	
popContext	TokenNameIdentifier	 pop Context
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
=	TokenNameEQUAL	
fContextStack	TokenNameIdentifier	 f Context Stack
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// popContext() 	TokenNameCOMMENT_LINE	popContext() 
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
/** Ensures the size of the matchers array. */	TokenNameCOMMENT_JAVADOC	 Ensures the size of the matchers array. 
private	TokenNameprivate	
void	TokenNamevoid	
ensureMatcherCapacity	TokenNameIdentifier	 ensure Matcher Capacity
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fMatchersCount	TokenNameIdentifier	 f Matchers Count
==	TokenNameEQUAL_EQUAL	
fMatchers	TokenNameIdentifier	 f Matchers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
array	TokenNameIdentifier	 array
=	TokenNameEQUAL	
new	TokenNamenew	
XPathMatcher	TokenNameIdentifier	 X Path Matcher
[	TokenNameLBRACKET	
fMatchers	TokenNameIdentifier	 f Matchers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fMatchers	TokenNameIdentifier	 f Matchers
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
array	TokenNameIdentifier	 array
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fMatchers	TokenNameIdentifier	 f Matchers
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fMatchers	TokenNameIdentifier	 f Matchers
=	TokenNameEQUAL	
array	TokenNameIdentifier	 array
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// ensureMatcherCapacity() 	TokenNameCOMMENT_LINE	ensureMatcherCapacity() 
}	TokenNameRBRACE	
// class XPathMatcherStack 	TokenNameCOMMENT_LINE	class XPathMatcherStack 
// value store implementations 	TokenNameCOMMENT_LINE	value store implementations 
/** * Value store implementation base class. There are specific subclasses * for handling unique, key, and keyref. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Value store implementation base class. There are specific subclasses for handling unique, key, and keyref. * @author Andy Clark, IBM 
protected	TokenNameprotected	
abstract	TokenNameabstract	
class	TokenNameclass	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
implements	TokenNameimplements	
ValueStore	TokenNameIdentifier	 Value Store
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Identity constraint. */	TokenNameCOMMENT_JAVADOC	 Identity constraint. 
protected	TokenNameprotected	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
int	TokenNameint	
fFieldCount	TokenNameIdentifier	 f Field Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
Field	TokenNameIdentifier	 Field
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fFields	TokenNameIdentifier	 f Fields
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** current data */	TokenNameCOMMENT_JAVADOC	 current data 
protected	TokenNameprotected	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalValues	TokenNameIdentifier	 f Local Values
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
ShortList	TokenNameIdentifier	 Short List
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** Current data value count. */	TokenNameCOMMENT_JAVADOC	 Current data value count. 
protected	TokenNameprotected	
int	TokenNameint	
fValuesCount	TokenNameIdentifier	 f Values Count
;	TokenNameSEMICOLON	
/** global data */	TokenNameCOMMENT_JAVADOC	 global data 
public	TokenNamepublic	
final	TokenNamefinal	
Vector	TokenNameIdentifier	 Vector
fValues	TokenNameIdentifier	 f Values
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
ShortVector	TokenNameIdentifier	 Short Vector
fValueTypes	TokenNameIdentifier	 f Value Types
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
public	TokenNamepublic	
Vector	TokenNameIdentifier	 Vector
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fValueTypesLength	TokenNameIdentifier	 f Value Types Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
short	TokenNameshort	
fValueType	TokenNameIdentifier	 f Value Type
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
boolean	TokenNameboolean	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
int	TokenNameint	
fItemValueTypesLength	TokenNameIdentifier	 f Item Value Types Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
private	TokenNameprivate	
ShortList	TokenNameIdentifier	 Short List
fItemValueType	TokenNameIdentifier	 f Item Value Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
/** buffer for error messages */	TokenNameCOMMENT_JAVADOC	 buffer for error messages 
final	TokenNamefinal	
StringBuffer	TokenNameIdentifier	 String Buffer
fTempBuffer	TokenNameIdentifier	 f Temp Buffer
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Constructs a value store for the specified identity constraint. */	TokenNameCOMMENT_JAVADOC	 Constructs a value store for the specified identity constraint. 
protected	TokenNameprotected	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
identityConstraint	TokenNameIdentifier	 identity Constraint
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
=	TokenNameEQUAL	
identityConstraint	TokenNameIdentifier	 identity Constraint
;	TokenNameSEMICOLON	
fFieldCount	TokenNameIdentifier	 f Field Count
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getFieldCount	TokenNameIdentifier	 get Field Count
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fFields	TokenNameIdentifier	 f Fields
=	TokenNameEQUAL	
new	TokenNamenew	
Field	TokenNameIdentifier	 Field
[	TokenNameLBRACKET	
fFieldCount	TokenNameIdentifier	 f Field Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fLocalValues	TokenNameIdentifier	 f Local Values
=	TokenNameEQUAL	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
fFieldCount	TokenNameIdentifier	 f Field Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
fFieldCount	TokenNameIdentifier	 f Field Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
=	TokenNameEQUAL	
new	TokenNamenew	
ShortList	TokenNameIdentifier	 Short List
[	TokenNameLBRACKET	
fFieldCount	TokenNameIdentifier	 f Field Count
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fFields	TokenNameIdentifier	 f Fields
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getFieldAt	TokenNameIdentifier	 get Field At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// <init>(IdentityConstraint) 	TokenNameCOMMENT_LINE	<init>(IdentityConstraint) 
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
// destroys this ValueStore; useful when, for instance, a 	TokenNameCOMMENT_LINE	destroys this ValueStore; useful when, for instance, a 
// locally-scoped ID constraint is involved. 	TokenNameCOMMENT_LINE	locally-scoped ID constraint is involved. 
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValuesCount	TokenNameIdentifier	 f Values Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fValueTypesLength	TokenNameIdentifier	 f Value Types Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fValueType	TokenNameIdentifier	 f Value Type
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
=	TokenNameEQUAL	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
fItemValueTypesLength	TokenNameIdentifier	 f Item Value Types Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fItemValueType	TokenNameIdentifier	 f Item Value Type
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValueTypes	TokenNameIdentifier	 f Value Types
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
setSize	TokenNameIdentifier	 set Size
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// end clear():void 	TokenNameCOMMENT_LINE	end clear():void 
// appends the contents of one ValueStore to those of us. 	TokenNameCOMMENT_LINE	appends the contents of one ValueStore to those of us. 
public	TokenNamepublic	
void	TokenNamevoid	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
newVal	TokenNameIdentifier	 new Val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
newVal	TokenNameIdentifier	 new Val
.	TokenNameDOT	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
newVal	TokenNameIdentifier	 new Val
.	TokenNameDOT	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// append(ValueStoreBase) 	TokenNameCOMMENT_LINE	append(ValueStoreBase) 
/** Start scope for value store. */	TokenNameCOMMENT_JAVADOC	 Start scope for value store. 
public	TokenNamepublic	
void	TokenNamevoid	
startValueScope	TokenNameIdentifier	 start Value Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValuesCount	TokenNameIdentifier	 f Values Count
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLocalValues	TokenNameIdentifier	 f Local Values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
null	TokenNamenull	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// startValueScope() 	TokenNameCOMMENT_LINE	startValueScope() 
/** Ends scope for value store. */	TokenNameCOMMENT_JAVADOC	 Ends scope for value store. 
public	TokenNamepublic	
void	TokenNamevoid	
endValueScope	TokenNameIdentifier	 end Value Scope
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fValuesCount	TokenNameIdentifier	 f Values Count
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEY	TokenNameIdentifier	 IC  KEY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"AbsentKeyValue"	TokenNameStringLiteral	AbsentKeyValue
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
eName	TokenNameIdentifier	 e Name
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// Validation Rule: Identity-constraint Satisfied 	TokenNameCOMMENT_LINE	Validation Rule: Identity-constraint Satisfied 
// 4.2 If the {identity-constraint category} is key, then all of the following must be true: 	TokenNameCOMMENT_LINE	4.2 If the {identity-constraint category} is key, then all of the following must be true: 
// 4.2.1 The target node set and the qualified node set are equal, that is, every member of the 	TokenNameCOMMENT_LINE	4.2.1 The target node set and the qualified node set are equal, that is, every member of the 
// target node set is also a member of the qualified node set and vice versa. 	TokenNameCOMMENT_LINE	target node set is also a member of the qualified node set and vice versa. 
// 	TokenNameCOMMENT_LINE	 
// If the IDC is a key check whether we have all the fields. 	TokenNameCOMMENT_LINE	If the IDC is a key check whether we have all the fields. 
if	TokenNameif	
(	TokenNameLPAREN	
fValuesCount	TokenNameIdentifier	 f Values Count
!=	TokenNameNOT_EQUAL	
fFieldCount	TokenNameIdentifier	 f Field Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEY	TokenNameIdentifier	 IC  KEY
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"KeyNotEnoughValues"	TokenNameStringLiteral	KeyNotEnoughValues
;	TokenNameSEMICOLON	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
)	TokenNameRPAREN	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
key	TokenNameIdentifier	 key
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
eName	TokenNameIdentifier	 e Name
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endValueScope() 	TokenNameCOMMENT_LINE	endValueScope() 
// This is needed to allow keyref's to look for matched keys 	TokenNameCOMMENT_LINE	This is needed to allow keyref's to look for matched keys 
// in the correct scope. Unique and Key may also need to 	TokenNameCOMMENT_LINE	in the correct scope. Unique and Key may also need to 
// override this method for purposes of their own. 	TokenNameCOMMENT_LINE	override this method for purposes of their own. 
// This method is called whenever the DocumentFragment 	TokenNameCOMMENT_LINE	This method is called whenever the DocumentFragment 
// of an ID Constraint goes out of scope. 	TokenNameCOMMENT_LINE	of an ID Constraint goes out of scope. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocumentFragment	TokenNameIdentifier	 end Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// endDocumentFragment():void 	TokenNameCOMMENT_LINE	endDocumentFragment():void 
/** * Signals the end of the document. This is where the specific * instances of value stores can verify the integrity of the * identity constraints. */	TokenNameCOMMENT_JAVADOC	 Signals the end of the document. This is where the specific instances of value stores can verify the integrity of the identity constraints. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// endDocument() 	TokenNameCOMMENT_LINE	endDocument() 
// 	TokenNameCOMMENT_LINE	 
// ValueStore methods 	TokenNameCOMMENT_LINE	ValueStore methods 
// 	TokenNameCOMMENT_LINE	 
/* reports an error if an element is matched * has nillable true and is matched by a key. */	TokenNameCOMMENT_BLOCK	 reports an error if an element is matched has nillable true and is matched by a key. 
public	TokenNamepublic	
void	TokenNamevoid	
reportError	TokenNameIdentifier	 report Error
(	TokenNameLPAREN	
String	TokenNameIdentifier	 String
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
{	TokenNameLBRACE	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
args	TokenNameIdentifier	 args
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// reportError(String,Object[]) 	TokenNameCOMMENT_LINE	reportError(String,Object[]) 
/** * Adds the specified value to the value store. * * @param field The field associated to the value. This reference * is used to ensure that each field only adds a value * once within a selection scope. * @param mayMatch a flag indiciating whether the field may be matched. * @param actualValue The value to add. * @param valueType Type of the value to add. * @param itemValueType If the value is a list, a list of types for each of the values in the list. */	TokenNameCOMMENT_JAVADOC	 Adds the specified value to the value store. * @param field The field associated to the value. This reference is used to ensure that each field only adds a value once within a selection scope. @param mayMatch a flag indiciating whether the field may be matched. @param actualValue The value to add. @param valueType Type of the value to add. @param itemValueType If the value is a list, a list of types for each of the values in the list. 
public	TokenNamepublic	
void	TokenNamevoid	
addValue	TokenNameIdentifier	 add Value
(	TokenNameLPAREN	
Field	TokenNameIdentifier	 Field
field	TokenNameIdentifier	 field
,	TokenNameCOMMA	
boolean	TokenNameboolean	
mayMatch	TokenNameIdentifier	 may Match
,	TokenNameCOMMA	
Object	TokenNameIdentifier	 Object
actualValue	TokenNameIdentifier	 actual Value
,	TokenNameCOMMA	
short	TokenNameshort	
valueType	TokenNameIdentifier	 value Type
,	TokenNameCOMMA	
ShortList	TokenNameIdentifier	 Short List
itemValueType	TokenNameIdentifier	 item Value Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
fFieldCount	TokenNameIdentifier	 f Field Count
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
--	TokenNameMINUS_MINUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fFields	TokenNameIdentifier	 f Fields
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
field	TokenNameIdentifier	 field
)	TokenNameRPAREN	
{	TokenNameLBRACE	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// do we even know this field? 	TokenNameCOMMENT_LINE	do we even know this field? 
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
==	TokenNameEQUAL_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"UnknownField"	TokenNameStringLiteral	UnknownField
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
eName	TokenNameIdentifier	 e Name
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
mayMatch	TokenNameIdentifier	 may Match
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"FieldMultipleMatch"	TokenNameStringLiteral	FieldMultipleMatch
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
field	TokenNameIdentifier	 field
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
fValuesCount	TokenNameIdentifier	 f Values Count
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fLocalValues	TokenNameIdentifier	 f Local Values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
actualValue	TokenNameIdentifier	 actual Value
;	TokenNameSEMICOLON	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
valueType	TokenNameIdentifier	 value Type
;	TokenNameSEMICOLON	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
itemValueType	TokenNameIdentifier	 item Value Type
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValuesCount	TokenNameIdentifier	 f Values Count
==	TokenNameEQUAL_EQUAL	
fFieldCount	TokenNameIdentifier	 f Field Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
checkDuplicateValues	TokenNameIdentifier	 check Duplicate Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// store values 	TokenNameCOMMENT_LINE	store values 
for	TokenNamefor	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
addElement	TokenNameIdentifier	 add Element
(	TokenNameLPAREN	
fLocalValues	TokenNameIdentifier	 f Local Values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addValueType	TokenNameIdentifier	 add Value Type
(	TokenNameLPAREN	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
addItemValueType	TokenNameIdentifier	 add Item Value Type
(	TokenNameLPAREN	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// addValue(String,Field) 	TokenNameCOMMENT_LINE	addValue(String,Field) 
/** * Returns true if this value store contains the locally scoped value stores */	TokenNameCOMMENT_JAVADOC	 Returns true if this value store contains the locally scoped value stores 
public	TokenNamepublic	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// REVISIT: we can improve performance by using hash codes, instead of 	TokenNameCOMMENT_LINE	REVISIT: we can improve performance by using hash codes, instead of 
// traversing global vector that could be quite large. 	TokenNameCOMMENT_LINE	traversing global vector that could be quite large. 
int	TokenNameint	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
LOOP	TokenNameIdentifier	 LOOP
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
next	TokenNameIdentifier	 next
)	TokenNameRPAREN	
{	TokenNameLBRACE	
next	TokenNameIdentifier	 next
=	TokenNameEQUAL	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Object	TokenNameIdentifier	 Object
value1	TokenNameIdentifier	 value1
=	TokenNameEQUAL	
fLocalValues	TokenNameIdentifier	 f Local Values
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
Object	TokenNameIdentifier	 Object
value2	TokenNameIdentifier	 value2
=	TokenNameEQUAL	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
short	TokenNameshort	
valueType1	TokenNameIdentifier	 value Type1
=	TokenNameEQUAL	
fLocalValueTypes	TokenNameIdentifier	 f Local Value Types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
short	TokenNameshort	
valueType2	TokenNameIdentifier	 value Type2
=	TokenNameEQUAL	
getValueTypeAt	TokenNameIdentifier	 get Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
value2	TokenNameIdentifier	 value2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
valueType1	TokenNameIdentifier	 value Type1
!=	TokenNameNOT_EQUAL	
valueType2	TokenNameIdentifier	 value Type2
||	TokenNameOR_OR	
!	TokenNameNOT	
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
LOOP	TokenNameIdentifier	 LOOP
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
valueType1	TokenNameIdentifier	 value Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
||	TokenNameOR_OR	
valueType1	TokenNameIdentifier	 value Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LISTOFUNION_DT	TokenNameIdentifier	 LISTOFUNION  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ShortList	TokenNameIdentifier	 Short List
list1	TokenNameIdentifier	 list1
=	TokenNameEQUAL	
fLocalItemValueTypes	TokenNameIdentifier	 f Local Item Value Types
[	TokenNameLBRACKET	
j	TokenNameIdentifier	 j
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
ShortList	TokenNameIdentifier	 Short List
list2	TokenNameIdentifier	 list2
=	TokenNameEQUAL	
getItemValueTypeAt	TokenNameIdentifier	 get Item Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
list1	TokenNameIdentifier	 list1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
list2	TokenNameIdentifier	 list2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
list1	TokenNameIdentifier	 list1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
list2	TokenNameIdentifier	 list2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
continue	TokenNamecontinue	
LOOP	TokenNameIdentifier	 LOOP
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// found it 	TokenNameCOMMENT_LINE	found it 
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// didn't find it 	TokenNameCOMMENT_LINE	didn't find it 
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// contains():boolean 	TokenNameCOMMENT_LINE	contains():boolean 
/** * Returns -1 if this value store contains the specified * values, otherwise the index of the first field in the * key sequence. */	TokenNameCOMMENT_JAVADOC	 Returns -1 if this value store contains the specified values, otherwise the index of the first field in the key sequence. 
public	TokenNamepublic	
int	TokenNameint	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
vsb	TokenNameIdentifier	 vsb
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Vector	TokenNameIdentifier	 Vector
values	TokenNameIdentifier	 values
=	TokenNameEQUAL	
vsb	TokenNameIdentifier	 vsb
.	TokenNameDOT	
fValues	TokenNameIdentifier	 f Values
;	TokenNameSEMICOLON	
final	TokenNamefinal	
int	TokenNameint	
size1	TokenNameIdentifier	 size1
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fFieldCount	TokenNameIdentifier	 f Field Count
<=	TokenNameLESS_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size1	TokenNameIdentifier	 size1
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
val	TokenNameIdentifier	 val
=	TokenNameEQUAL	
vsb	TokenNameIdentifier	 vsb
.	TokenNameDOT	
getValueTypeAt	TokenNameIdentifier	 get Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
valueTypeContains	TokenNameIdentifier	 value Type Contains
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
)	TokenNameRPAREN	
||	TokenNameOR_OR	
!	TokenNameNOT	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
val	TokenNameIdentifier	 val
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
||	TokenNameOR_OR	
val	TokenNameIdentifier	 val
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LISTOFUNION_DT	TokenNameIdentifier	 LISTOFUNION  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ShortList	TokenNameIdentifier	 Short List
list1	TokenNameIdentifier	 list1
=	TokenNameEQUAL	
vsb	TokenNameIdentifier	 vsb
.	TokenNameDOT	
getItemValueTypeAt	TokenNameIdentifier	 get Item Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
itemValueTypeContains	TokenNameIdentifier	 item Value Type Contains
(	TokenNameLPAREN	
list1	TokenNameIdentifier	 list1
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
/** Handle n-tuples. **/	TokenNameCOMMENT_JAVADOC	 Handle n-tuples. *
else	TokenNameelse	
{	TokenNameLBRACE	
final	TokenNamefinal	
int	TokenNameint	
size2	TokenNameIdentifier	 size2
=	TokenNameEQUAL	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** Iterate over each set of fields. **/	TokenNameCOMMENT_JAVADOC	 Iterate over each set of fields. *
OUTER	TokenNameIdentifier	 OUTER
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size1	TokenNameIdentifier	 size1
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
+=	TokenNamePLUS_EQUAL	
fFieldCount	TokenNameIdentifier	 f Field Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
/** Check whether this set is contained in the value store. **/	TokenNameCOMMENT_JAVADOC	 Check whether this set is contained in the value store. *
INNER	TokenNameIdentifier	 INNER
:	TokenNameCOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
j	TokenNameIdentifier	 j
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
<	TokenNameLESS	
size2	TokenNameIdentifier	 size2
;	TokenNameSEMICOLON	
j	TokenNameIdentifier	 j
+=	TokenNamePLUS_EQUAL	
fFieldCount	TokenNameIdentifier	 f Field Count
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
k	TokenNameIdentifier	 k
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
k	TokenNameIdentifier	 k
<	TokenNameLESS	
fFieldCount	TokenNameIdentifier	 f Field Count
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
{	TokenNameLBRACE	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
value1	TokenNameIdentifier	 value1
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
Object	TokenNameIdentifier	 Object
value2	TokenNameIdentifier	 value2
=	TokenNameEQUAL	
fValues	TokenNameIdentifier	 f Values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
short	TokenNameshort	
valueType1	TokenNameIdentifier	 value Type1
=	TokenNameEQUAL	
vsb	TokenNameIdentifier	 vsb
.	TokenNameDOT	
getValueTypeAt	TokenNameIdentifier	 get Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
final	TokenNamefinal	
short	TokenNameshort	
valueType2	TokenNameIdentifier	 value Type2
=	TokenNameEQUAL	
getValueTypeAt	TokenNameIdentifier	 get Value Type At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
value1	TokenNameIdentifier	 value1
!=	TokenNameNOT_EQUAL	
value2	TokenNameIdentifier	 value2
&&	TokenNameAND_AND	
(	TokenNameLPAREN	
valueType1	TokenNameIdentifier	 value Type1
!=	TokenNameNOT_EQUAL	
valueType2	TokenNameIdentifier	 value Type2
||	TokenNameOR_OR	
value1	TokenNameIdentifier	 value1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
value1	TokenNameIdentifier	 value1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
value2	TokenNameIdentifier	 value2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
INNER	TokenNameIdentifier	 INNER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
valueType1	TokenNameIdentifier	 value Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LIST_DT	TokenNameIdentifier	 LIST  DT
||	TokenNameOR_OR	
valueType1	TokenNameIdentifier	 value Type1
==	TokenNameEQUAL_EQUAL	
XSConstants	TokenNameIdentifier	 XS Constants
.	TokenNameDOT	
LISTOFUNION_DT	TokenNameIdentifier	 LISTOFUNION  DT
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ShortList	TokenNameIdentifier	 Short List
list1	TokenNameIdentifier	 list1
=	TokenNameEQUAL	
vsb	TokenNameIdentifier	 vsb
.	TokenNameDOT	
getItemValueTypeAt	TokenNameIdentifier	 get Item Value Type At
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ShortList	TokenNameIdentifier	 Short List
list2	TokenNameIdentifier	 list2
=	TokenNameEQUAL	
getItemValueTypeAt	TokenNameIdentifier	 get Item Value Type At
(	TokenNameLPAREN	
j	TokenNameIdentifier	 j
+	TokenNamePLUS	
k	TokenNameIdentifier	 k
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
list1	TokenNameIdentifier	 list1
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
list2	TokenNameIdentifier	 list2
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
||	TokenNameOR_OR	
!	TokenNameNOT	
list1	TokenNameIdentifier	 list1
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
list2	TokenNameIdentifier	 list2
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
continue	TokenNamecontinue	
INNER	TokenNameIdentifier	 INNER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
continue	TokenNamecontinue	
OUTER	TokenNameIdentifier	 OUTER
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
i	TokenNameIdentifier	 i
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// contains(Vector):Object 	TokenNameCOMMENT_LINE	contains(Vector):Object 
// 	TokenNameCOMMENT_LINE	 
// Protected methods 	TokenNameCOMMENT_LINE	Protected methods 
// 	TokenNameCOMMENT_LINE	 
protected	TokenNameprotected	
void	TokenNamevoid	
checkDuplicateValues	TokenNameIdentifier	 check Duplicate Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no-op 	TokenNameCOMMENT_LINE	no-op 
}	TokenNameRBRACE	
// duplicateValue(Hashtable) 	TokenNameCOMMENT_LINE	duplicateValue(Hashtable) 
/** Returns a string of the specified values. */	TokenNameCOMMENT_JAVADOC	 Returns a string of the specified values. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
values	TokenNameIdentifier	 values
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no values 	TokenNameCOMMENT_LINE	no values 
int	TokenNameint	
size	TokenNameIdentifier	 size
=	TokenNameEQUAL	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
size	TokenNameIdentifier	 size
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fTempBuffer	TokenNameIdentifier	 f Temp Buffer
.	TokenNameDOT	
setLength	TokenNameIdentifier	 set Length
(	TokenNameLPAREN	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// construct value string 	TokenNameCOMMENT_LINE	construct value string 
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
size	TokenNameIdentifier	 size
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fTempBuffer	TokenNameIdentifier	 f Temp Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fTempBuffer	TokenNameIdentifier	 f Temp Buffer
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fTempBuffer	TokenNameIdentifier	 f Temp Buffer
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// toString(Object[]):String 	TokenNameCOMMENT_LINE	toString(Object[]):String 
/** Returns a string of the specified values. */	TokenNameCOMMENT_JAVADOC	 Returns a string of the specified values. 
protected	TokenNameprotected	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
Vector	TokenNameIdentifier	 Vector
values	TokenNameIdentifier	 values
,	TokenNameCOMMA	
int	TokenNameint	
start	TokenNameIdentifier	 start
,	TokenNameCOMMA	
int	TokenNameint	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// no values 	TokenNameCOMMENT_LINE	no values 
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
""	TokenNameStringLiteral	 
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// one value 	TokenNameCOMMENT_LINE	one value 
if	TokenNameif	
(	TokenNameLPAREN	
length	TokenNameIdentifier	 length
==	TokenNameEQUAL_EQUAL	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
String	TokenNameIdentifier	 String
.	TokenNameDOT	
valueOf	TokenNameIdentifier	 value Of
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// construct value string 	TokenNameCOMMENT_LINE	construct value string 
StringBuffer	TokenNameIdentifier	 String Buffer
str	TokenNameIdentifier	 str
=	TokenNameEQUAL	
new	TokenNamenew	
StringBuffer	TokenNameIdentifier	 String Buffer
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
length	TokenNameIdentifier	 length
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
','	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
values	TokenNameIdentifier	 values
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
start	TokenNameIdentifier	 start
+	TokenNamePLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
str	TokenNameIdentifier	 str
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// toString(Vector,int,int):String 	TokenNameCOMMENT_LINE	toString(Vector,int,int):String 
// 	TokenNameCOMMENT_LINE	 
// Object methods 	TokenNameCOMMENT_LINE	Object methods 
// 	TokenNameCOMMENT_LINE	 
/** Returns a string representation of this object. */	TokenNameCOMMENT_JAVADOC	 Returns a string representation of this object. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
super	TokenNamesuper	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index1	TokenNameIdentifier	 index1
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'$'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index1	TokenNameIdentifier	 index1
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index1	TokenNameIdentifier	 index1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
index2	TokenNameIdentifier	 index2
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'.'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index2	TokenNameIdentifier	 index2
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index2	TokenNameIdentifier	 index2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
+	TokenNamePLUS	
'['	TokenNameCharacterLiteral	
+	TokenNamePLUS	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
+	TokenNamePLUS	
']'	TokenNameCharacterLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// toString():String 	TokenNameCOMMENT_LINE	toString():String 
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
private	TokenNameprivate	
void	TokenNamevoid	
addValueType	TokenNameIdentifier	 add Value Type
(	TokenNameLPAREN	
short	TokenNameshort	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fValueTypesLength	TokenNameIdentifier	 f Value Types Length
++	TokenNamePLUS_PLUS	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueType	TokenNameIdentifier	 f Value Type
=	TokenNameEQUAL	
type	TokenNameIdentifier	 type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fValueType	TokenNameIdentifier	 f Value Type
!=	TokenNameNOT_EQUAL	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fValueTypes	TokenNameIdentifier	 f Value Types
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueTypes	TokenNameIdentifier	 f Value Types
=	TokenNameEQUAL	
new	TokenNamenew	
ShortVector	TokenNameIdentifier	 Short Vector
(	TokenNameLPAREN	
fValueTypesLength	TokenNameIdentifier	 f Value Types Length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fValueTypesLength	TokenNameIdentifier	 f Value Types Length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fValueType	TokenNameIdentifier	 f Value Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
type	TokenNameIdentifier	 type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
short	TokenNameshort	
getValueTypeAt	TokenNameIdentifier	 get Value Type At
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
valueAt	TokenNameIdentifier	 value At
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fValueType	TokenNameIdentifier	 f Value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
valueTypeContains	TokenNameIdentifier	 value Type Contains
(	TokenNameLPAREN	
short	TokenNameshort	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseValueTypeVector	TokenNameIdentifier	 f Use Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fValueTypes	TokenNameIdentifier	 f Value Types
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fValueType	TokenNameIdentifier	 f Value Type
==	TokenNameEQUAL_EQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
void	TokenNamevoid	
addItemValueType	TokenNameIdentifier	 add Item Value Type
(	TokenNameLPAREN	
ShortList	TokenNameIdentifier	 Short List
itemValueType	TokenNameIdentifier	 item Value Type
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
itemValueType	TokenNameIdentifier	 item Value Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fItemValueTypesLength	TokenNameIdentifier	 f Item Value Types Length
++	TokenNamePLUS_PLUS	
==	TokenNameEQUAL_EQUAL	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemValueType	TokenNameIdentifier	 f Item Value Type
=	TokenNameEQUAL	
itemValueType	TokenNameIdentifier	 item Value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
!	TokenNameNOT	
(	TokenNameLPAREN	
fItemValueType	TokenNameIdentifier	 f Item Value Type
==	TokenNameEQUAL_EQUAL	
itemValueType	TokenNameIdentifier	 item Value Type
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fItemValueType	TokenNameIdentifier	 f Item Value Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fItemValueType	TokenNameIdentifier	 f Item Value Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
itemValueType	TokenNameIdentifier	 item Value Type
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
=	TokenNameEQUAL	
true	TokenNametrue	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
=	TokenNameEQUAL	
new	TokenNamenew	
Vector	TokenNameIdentifier	 Vector
(	TokenNameLPAREN	
fItemValueTypesLength	TokenNameIdentifier	 f Item Value Types Length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
1	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fItemValueTypesLength	TokenNameIdentifier	 f Item Value Types Length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
fItemValueType	TokenNameIdentifier	 f Item Value Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
itemValueType	TokenNameIdentifier	 item Value Type
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
private	TokenNameprivate	
ShortList	TokenNameIdentifier	 Short List
getItemValueTypeAt	TokenNameIdentifier	 get Item Value Type At
(	TokenNameLPAREN	
int	TokenNameint	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ShortList	TokenNameIdentifier	 Short List
)	TokenNameRPAREN	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
elementAt	TokenNameIdentifier	 element At
(	TokenNameLPAREN	
index	TokenNameIdentifier	 index
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fItemValueType	TokenNameIdentifier	 f Item Value Type
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
private	TokenNameprivate	
boolean	TokenNameboolean	
itemValueTypeContains	TokenNameIdentifier	 item Value Type Contains
(	TokenNameLPAREN	
ShortList	TokenNameIdentifier	 Short List
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fUseItemValueTypeVector	TokenNameIdentifier	 f Use Item Value Type Vector
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fItemValueTypes	TokenNameIdentifier	 f Item Value Types
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
fItemValueType	TokenNameIdentifier	 f Item Value Type
==	TokenNameEQUAL_EQUAL	
value	TokenNameIdentifier	 value
||	TokenNameOR_OR	
(	TokenNameLPAREN	
fItemValueType	TokenNameIdentifier	 f Item Value Type
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
&&	TokenNameAND_AND	
fItemValueType	TokenNameIdentifier	 f Item Value Type
.	TokenNameDOT	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class ValueStoreBase 	TokenNameCOMMENT_LINE	class ValueStoreBase 
/** * Unique value store. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Unique value store. * @author Andy Clark, IBM 
protected	TokenNameprotected	
class	TokenNameclass	
UniqueValueStore	TokenNameIdentifier	 Unique Value Store
extends	TokenNameextends	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Constructs a unique value store. */	TokenNameCOMMENT_JAVADOC	 Constructs a unique value store. 
public	TokenNamepublic	
UniqueValueStore	TokenNameIdentifier	 Unique Value Store
(	TokenNameLPAREN	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
unique	TokenNameIdentifier	 unique
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
unique	TokenNameIdentifier	 unique
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>(Unique) 	TokenNameCOMMENT_LINE	<init>(Unique) 
// 	TokenNameCOMMENT_LINE	 
// ValueStoreBase protected methods 	TokenNameCOMMENT_LINE	ValueStoreBase protected methods 
// 	TokenNameCOMMENT_LINE	 
/** * Called when a duplicate value is added. */	TokenNameCOMMENT_JAVADOC	 Called when a duplicate value is added. 
protected	TokenNameprotected	
void	TokenNamevoid	
checkDuplicateValues	TokenNameIdentifier	 check Duplicate Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// is this value as a group duplicated? 	TokenNameCOMMENT_LINE	is this value as a group duplicated? 
if	TokenNameif	
(	TokenNameLPAREN	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"DuplicateUnique"	TokenNameStringLiteral	DuplicateUnique
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLocalValues	TokenNameIdentifier	 f Local Values
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
eName	TokenNameIdentifier	 e Name
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// duplicateValue(Hashtable) 	TokenNameCOMMENT_LINE	duplicateValue(Hashtable) 
}	TokenNameRBRACE	
// class UniqueValueStore 	TokenNameCOMMENT_LINE	class UniqueValueStore 
/** * Key value store. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Key value store. * @author Andy Clark, IBM 
protected	TokenNameprotected	
class	TokenNameclass	
KeyValueStore	TokenNameIdentifier	 Key Value Store
extends	TokenNameextends	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
{	TokenNameLBRACE	
// REVISIT: Implement a more efficient storage mechanism. -Ac 	TokenNameCOMMENT_LINE	REVISIT: Implement a more efficient storage mechanism. -Ac 
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Constructs a key value store. */	TokenNameCOMMENT_JAVADOC	 Constructs a key value store. 
public	TokenNamepublic	
KeyValueStore	TokenNameIdentifier	 Key Value Store
(	TokenNameLPAREN	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>(Key) 	TokenNameCOMMENT_LINE	<init>(Key) 
// 	TokenNameCOMMENT_LINE	 
// ValueStoreBase protected methods 	TokenNameCOMMENT_LINE	ValueStoreBase protected methods 
// 	TokenNameCOMMENT_LINE	 
/** * Called when a duplicate value is added. */	TokenNameCOMMENT_JAVADOC	 Called when a duplicate value is added. 
protected	TokenNameprotected	
void	TokenNamevoid	
checkDuplicateValues	TokenNameIdentifier	 check Duplicate Values
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"DuplicateKey"	TokenNameStringLiteral	DuplicateKey
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fLocalValues	TokenNameIdentifier	 f Local Values
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
eName	TokenNameIdentifier	 e Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
cName	TokenNameIdentifier	 c Name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getIdentityConstraintName	TokenNameIdentifier	 get Identity Constraint Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
,	TokenNameCOMMA	
eName	TokenNameIdentifier	 e Name
,	TokenNameCOMMA	
cName	TokenNameIdentifier	 c Name
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// duplicateValue(Hashtable) 	TokenNameCOMMENT_LINE	duplicateValue(Hashtable) 
}	TokenNameRBRACE	
// class KeyValueStore 	TokenNameCOMMENT_LINE	class KeyValueStore 
/** * Key reference value store. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Key reference value store. * @author Andy Clark, IBM 
protected	TokenNameprotected	
class	TokenNameclass	
KeyRefValueStore	TokenNameIdentifier	 Key Ref Value Store
extends	TokenNameextends	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Key value store. */	TokenNameCOMMENT_JAVADOC	 Key value store. 
protected	TokenNameprotected	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
fKeyValueStore	TokenNameIdentifier	 f Key Value Store
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Constructs a key value store. */	TokenNameCOMMENT_JAVADOC	 Constructs a key value store. 
public	TokenNamepublic	
KeyRefValueStore	TokenNameIdentifier	 Key Ref Value Store
(	TokenNameLPAREN	
KeyRef	TokenNameIdentifier	 Key Ref
keyRef	TokenNameIdentifier	 key Ref
,	TokenNameCOMMA	
KeyValueStore	TokenNameIdentifier	 Key Value Store
keyValueStore	TokenNameIdentifier	 key Value Store
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
(	TokenNameLPAREN	
keyRef	TokenNameIdentifier	 key Ref
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fKeyValueStore	TokenNameIdentifier	 f Key Value Store
=	TokenNameEQUAL	
keyValueStore	TokenNameIdentifier	 key Value Store
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// <init>(KeyRef) 	TokenNameCOMMENT_LINE	<init>(KeyRef) 
// 	TokenNameCOMMENT_LINE	 
// ValueStoreBase methods 	TokenNameCOMMENT_LINE	ValueStoreBase methods 
// 	TokenNameCOMMENT_LINE	 
// end the value Scope; here's where we have to tie 	TokenNameCOMMENT_LINE	end the value Scope; here's where we have to tie 
// up keyRef loose ends. 	TokenNameCOMMENT_LINE	up keyRef loose ends. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocumentFragment	TokenNameIdentifier	 end Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// do all the necessary management... 	TokenNameCOMMENT_LINE	do all the necessary management... 
super	TokenNamesuper	
.	TokenNameDOT	
endDocumentFragment	TokenNameIdentifier	 end Document Fragment
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// verify references 	TokenNameCOMMENT_LINE	verify references 
// get the key store corresponding (if it exists): 	TokenNameCOMMENT_LINE	get the key store corresponding (if it exists): 
fKeyValueStore	TokenNameIdentifier	 f Key Value Store
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fValueStoreCache	TokenNameIdentifier	 f Value Store Cache
.	TokenNameDOT	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
(	TokenNameLPAREN	
(	TokenNameLPAREN	
KeyRef	TokenNameIdentifier	 Key Ref
)	TokenNameRPAREN	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
)	TokenNameRPAREN	
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
fKeyValueStore	TokenNameIdentifier	 f Key Value Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// report error 	TokenNameCOMMENT_LINE	report error 
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"KeyRefOutOfScope"	TokenNameStringLiteral	KeyRefOutOfScope
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
value	TokenNameIdentifier	 value
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
value	TokenNameIdentifier	 value
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
errorIndex	TokenNameIdentifier	 error Index
=	TokenNameEQUAL	
fKeyValueStore	TokenNameIdentifier	 f Key Value Store
.	TokenNameDOT	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
this	TokenNamethis	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
errorIndex	TokenNameIdentifier	 error Index
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
code	TokenNameIdentifier	 code
=	TokenNameEQUAL	
"KeyNotFound"	TokenNameStringLiteral	KeyNotFound
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
values	TokenNameIdentifier	 values
=	TokenNameEQUAL	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
fValues	TokenNameIdentifier	 f Values
,	TokenNameCOMMA	
errorIndex	TokenNameIdentifier	 error Index
,	TokenNameCOMMA	
fFieldCount	TokenNameIdentifier	 f Field Count
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
element	TokenNameIdentifier	 element
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getElementName	TokenNameIdentifier	 get Element Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
String	TokenNameIdentifier	 String
name	TokenNameIdentifier	 name
=	TokenNameEQUAL	
fIdentityConstraint	TokenNameIdentifier	 f Identity Constraint
.	TokenNameDOT	
getName	TokenNameIdentifier	 get Name
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
reportSchemaError	TokenNameIdentifier	 report Schema Error
(	TokenNameLPAREN	
code	TokenNameIdentifier	 code
,	TokenNameCOMMA	
new	TokenNamenew	
Object	TokenNameIdentifier	 Object
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
{	TokenNameLBRACE	
name	TokenNameIdentifier	 name
,	TokenNameCOMMA	
values	TokenNameIdentifier	 values
,	TokenNameCOMMA	
element	TokenNameIdentifier	 element
}	TokenNameRBRACE	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endDocumentFragment() 	TokenNameCOMMENT_LINE	endDocumentFragment() 
/** End document. */	TokenNameCOMMENT_JAVADOC	 End document. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
super	TokenNamesuper	
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// endDocument() 	TokenNameCOMMENT_LINE	endDocument() 
}	TokenNameRBRACE	
// class KeyRefValueStore 	TokenNameCOMMENT_LINE	class KeyRefValueStore 
// value store management 	TokenNameCOMMENT_LINE	value store management 
/** * Value store cache. This class is used to store the values for * identity constraints. * * @author Andy Clark, IBM */	TokenNameCOMMENT_JAVADOC	 Value store cache. This class is used to store the values for identity constraints. * @author Andy Clark, IBM 
protected	TokenNameprotected	
class	TokenNameclass	
ValueStoreCache	TokenNameIdentifier	 Value Store Cache
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
final	TokenNamefinal	
LocalIDKey	TokenNameIdentifier	 Local ID Key
fLocalId	TokenNameIdentifier	 f Local Id
=	TokenNameEQUAL	
new	TokenNamenew	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// values stores 	TokenNameCOMMENT_LINE	values stores 
/** stores all global Values stores. */	TokenNameCOMMENT_JAVADOC	 stores all global Values stores. 
protected	TokenNameprotected	
final	TokenNamefinal	
ArrayList	TokenNameIdentifier	 Array List
fValueStores	TokenNameIdentifier	 f Value Stores
=	TokenNameEQUAL	
new	TokenNamenew	
ArrayList	TokenNameIdentifier	 Array List
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
/** * Values stores associated to specific identity constraints. * This hashtable maps IdentityConstraints and * the 0-based element on which their selectors first matched to * a corresponding ValueStore. This should take care * of all cases, including where ID constraints with * descendant-or-self axes occur on recursively-defined * elements. */	TokenNameCOMMENT_JAVADOC	 Values stores associated to specific identity constraints. This hashtable maps IdentityConstraints and the 0-based element on which their selectors first matched to a corresponding ValueStore. This should take care of all cases, including where ID constraints with descendant-or-self axes occur on recursively-defined elements. 
protected	TokenNameprotected	
final	TokenNamefinal	
HashMap	TokenNameIdentifier	 Hash Map
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// sketch of algorithm: 	TokenNameCOMMENT_LINE	sketch of algorithm: 
// - when a constraint is first encountered, its 	TokenNameCOMMENT_LINE	- when a constraint is first encountered, its 
// values are stored in the (local) fIdentityConstraint2ValueStoreMap; 	TokenNameCOMMENT_LINE	values are stored in the (local) fIdentityConstraint2ValueStoreMap; 
// - Once it is validated (i.e., when it goes out of scope), 	TokenNameCOMMENT_LINE	- Once it is validated (i.e., when it goes out of scope), 
// its values are merged into the fGlobalIDConstraintMap; 	TokenNameCOMMENT_LINE	its values are merged into the fGlobalIDConstraintMap; 
// - as we encounter keyref's, we look at the global table to 	TokenNameCOMMENT_LINE	- as we encounter keyref's, we look at the global table to 
// validate them. 	TokenNameCOMMENT_LINE	validate them. 
// 	TokenNameCOMMENT_LINE	 
// The fGlobalIDMapStack has the following structure: 	TokenNameCOMMENT_LINE	The fGlobalIDMapStack has the following structure: 
// - validation always occurs against the fGlobalIDConstraintMap 	TokenNameCOMMENT_LINE	- validation always occurs against the fGlobalIDConstraintMap 
// (which comprises all the "eligible" id constraints); 	TokenNameCOMMENT_LINE	(which comprises all the "eligible" id constraints); 
// When an endElement is found, this Hashtable is merged with the one 	TokenNameCOMMENT_LINE	When an endElement is found, this Hashtable is merged with the one 
// below in the stack. 	TokenNameCOMMENT_LINE	below in the stack. 
// When a start tag is encountered, we create a new 	TokenNameCOMMENT_LINE	When a start tag is encountered, we create a new 
// fGlobalIDConstraintMap. 	TokenNameCOMMENT_LINE	fGlobalIDConstraintMap. 
// i.e., the top of the fGlobalIDMapStack always contains 	TokenNameCOMMENT_LINE	i.e., the top of the fGlobalIDMapStack always contains 
// the preceding siblings' eligible id constraints; 	TokenNameCOMMENT_LINE	the preceding siblings' eligible id constraints; 
// the fGlobalIDConstraintMap contains descendants+self. 	TokenNameCOMMENT_LINE	the fGlobalIDConstraintMap contains descendants+self. 
// keyrefs can only match descendants+self. 	TokenNameCOMMENT_LINE	keyrefs can only match descendants+self. 
protected	TokenNameprotected	
final	TokenNamefinal	
Stack	TokenNameIdentifier	 Stack
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
=	TokenNameEQUAL	
new	TokenNamenew	
Stack	TokenNameIdentifier	 Stack
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
protected	TokenNameprotected	
final	TokenNamefinal	
HashMap	TokenNameIdentifier	 Hash Map
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
=	TokenNameEQUAL	
new	TokenNamenew	
HashMap	TokenNameIdentifier	 Hash Map
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
/** Default constructor. */	TokenNameCOMMENT_JAVADOC	 Default constructor. 
public	TokenNamepublic	
ValueStoreCache	TokenNameIdentifier	 Value Store Cache
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
// <init>() 	TokenNameCOMMENT_LINE	<init>() 
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
/** Resets the identity constraint cache. */	TokenNameCOMMENT_JAVADOC	 Resets the identity constraint cache. 
public	TokenNamepublic	
void	TokenNamevoid	
startDocument	TokenNameIdentifier	 start Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
.	TokenNameDOT	
removeAllElements	TokenNameIdentifier	 remove All Elements
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startDocument() 	TokenNameCOMMENT_LINE	startDocument() 
// startElement: pushes the current fGlobalIDConstraintMap 	TokenNameCOMMENT_LINE	startElement: pushes the current fGlobalIDConstraintMap 
// onto fGlobalMapStack and clears fGlobalIDConstraint map. 	TokenNameCOMMENT_LINE	onto fGlobalMapStack and clears fGlobalIDConstraint map. 
public	TokenNamepublic	
void	TokenNamevoid	
startElement	TokenNameIdentifier	 start Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// only clone the map when there are elements 	TokenNameCOMMENT_LINE	only clone the map when there are elements 
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
>	TokenNameGREATER	
0	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
clone	TokenNameIdentifier	 clone
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
else	TokenNameelse	
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
.	TokenNameDOT	
push	TokenNameIdentifier	 push
(	TokenNameLPAREN	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// startElement(void) 	TokenNameCOMMENT_LINE	startElement(void) 
/** endElement(): merges contents of fGlobalIDConstraintMap with the * top of fGlobalMapStack into fGlobalIDConstraintMap. */	TokenNameCOMMENT_JAVADOC	 endElement(): merges contents of fGlobalIDConstraintMap with the top of fGlobalMapStack into fGlobalIDConstraintMap. 
public	TokenNamepublic	
void	TokenNamevoid	
endElement	TokenNameIdentifier	 end Element
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
.	TokenNameDOT	
isEmpty	TokenNameIdentifier	 is Empty
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
// must be an invalid doc! 	TokenNameCOMMENT_LINE	must be an invalid doc! 
}	TokenNameRBRACE	
HashMap	TokenNameIdentifier	 Hash Map
oldMap	TokenNameIdentifier	 old Map
=	TokenNameEQUAL	
(	TokenNameLPAREN	
HashMap	TokenNameIdentifier	 Hash Map
)	TokenNameRPAREN	
fGlobalMapStack	TokenNameIdentifier	 f Global Map Stack
.	TokenNameDOT	
pop	TokenNameIdentifier	 pop
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
// return if there is no element 	TokenNameCOMMENT_LINE	return if there is no element 
if	TokenNameif	
(	TokenNameLPAREN	
oldMap	TokenNameIdentifier	 old Map
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
Iterator	TokenNameIdentifier	 Iterator
entries	TokenNameIdentifier	 entries
=	TokenNameEQUAL	
oldMap	TokenNameIdentifier	 old Map
.	TokenNameDOT	
entrySet	TokenNameIdentifier	 entry Set
(	TokenNameLPAREN	
)	TokenNameRPAREN	
.	TokenNameDOT	
iterator	TokenNameIdentifier	 iterator
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
while	TokenNamewhile	
(	TokenNameLPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
hasNext	TokenNameIdentifier	 has Next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
entry	TokenNameIdentifier	 entry
=	TokenNameEQUAL	
(	TokenNameLPAREN	
Map	TokenNameIdentifier	 Map
.	TokenNameDOT	
Entry	TokenNameIdentifier	 Entry
)	TokenNameRPAREN	
entries	TokenNameIdentifier	 entries
.	TokenNameDOT	
next	TokenNameIdentifier	 next
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
=	TokenNameEQUAL	
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getKey	TokenNameIdentifier	 get Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
oldVal	TokenNameIdentifier	 old Val
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
entry	TokenNameIdentifier	 entry
.	TokenNameDOT	
getValue	TokenNameIdentifier	 get Value
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
oldVal	TokenNameIdentifier	 old Val
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
currVal	TokenNameIdentifier	 curr Val
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currVal	TokenNameIdentifier	 curr Val
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
oldVal	TokenNameIdentifier	 old Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
currVal	TokenNameIdentifier	 curr Val
!=	TokenNameNOT_EQUAL	
oldVal	TokenNameIdentifier	 old Val
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currVal	TokenNameIdentifier	 curr Val
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
oldVal	TokenNameIdentifier	 old Val
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endElement() 	TokenNameCOMMENT_LINE	endElement() 
/** * Initializes the value stores for the specified element * declaration. */	TokenNameCOMMENT_JAVADOC	 Initializes the value stores for the specified element declaration. 
public	TokenNamepublic	
void	TokenNamevoid	
initValueStoresFor	TokenNameIdentifier	 init Value Stores For
(	TokenNameLPAREN	
XSElementDecl	TokenNameIdentifier	 XS Element Decl
eDecl	TokenNameIdentifier	 e Decl
,	TokenNameCOMMA	
FieldActivator	TokenNameIdentifier	 Field Activator
activator	TokenNameIdentifier	 activator
)	TokenNameRPAREN	
{	TokenNameLBRACE	
// initialize value stores for unique fields 	TokenNameCOMMENT_LINE	initialize value stores for unique fields 
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
icArray	TokenNameIdentifier	 ic Array
=	TokenNameEQUAL	
eDecl	TokenNameIdentifier	 e Decl
.	TokenNameDOT	
fIDConstraints	TokenNameIdentifier	 f ID Constraints
;	TokenNameSEMICOLON	
int	TokenNameint	
icCount	TokenNameIdentifier	 ic Count
=	TokenNameEQUAL	
eDecl	TokenNameIdentifier	 e Decl
.	TokenNameDOT	
fIDCPos	TokenNameIdentifier	 f IDC Pos
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
icCount	TokenNameIdentifier	 ic Count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
switch	TokenNameswitch	
(	TokenNameLPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
case	TokenNamecase	
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_UNIQUE	TokenNameIdentifier	 IC  UNIQUE
)	TokenNameRPAREN	
:	TokenNameCOLON	
// initialize value stores for unique fields 	TokenNameCOMMENT_LINE	initialize value stores for unique fields 
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
unique	TokenNameIdentifier	 unique
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
)	TokenNameRPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
LocalIDKey	TokenNameIdentifier	 Local ID Key
toHash	TokenNameIdentifier	 to Hash
=	TokenNameEQUAL	
new	TokenNamenew	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
unique	TokenNameIdentifier	 unique
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
UniqueValueStore	TokenNameIdentifier	 Unique Value Store
uniqueValueStore	TokenNameIdentifier	 unique Value Store
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UniqueValueStore	TokenNameIdentifier	 Unique Value Store
)	TokenNameRPAREN	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
uniqueValueStore	TokenNameIdentifier	 unique Value Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
uniqueValueStore	TokenNameIdentifier	 unique Value Store
=	TokenNameEQUAL	
new	TokenNamenew	
UniqueValueStore	TokenNameIdentifier	 Unique Value Store
(	TokenNameLPAREN	
unique	TokenNameIdentifier	 unique
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
,	TokenNameCOMMA	
uniqueValueStore	TokenNameIdentifier	 unique Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
uniqueValueStore	TokenNameIdentifier	 unique Value Store
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
uniqueValueStore	TokenNameIdentifier	 unique Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activateSelectorFor	TokenNameIdentifier	 activate Selector For
(	TokenNameLPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEY	TokenNameIdentifier	 IC  KEY
)	TokenNameRPAREN	
:	TokenNameCOLON	
// initialize value stores for key fields 	TokenNameCOMMENT_LINE	initialize value stores for key fields 
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
key	TokenNameIdentifier	 key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
UniqueOrKey	TokenNameIdentifier	 Unique Or Key
)	TokenNameRPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
toHash	TokenNameIdentifier	 to Hash
=	TokenNameEQUAL	
new	TokenNamenew	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KeyValueStore	TokenNameIdentifier	 Key Value Store
keyValueStore	TokenNameIdentifier	 key Value Store
=	TokenNameEQUAL	
(	TokenNameLPAREN	
KeyValueStore	TokenNameIdentifier	 Key Value Store
)	TokenNameRPAREN	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyValueStore	TokenNameIdentifier	 key Value Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyValueStore	TokenNameIdentifier	 key Value Store
=	TokenNameEQUAL	
new	TokenNamenew	
KeyValueStore	TokenNameIdentifier	 Key Value Store
(	TokenNameLPAREN	
key	TokenNameIdentifier	 key
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
,	TokenNameCOMMA	
keyValueStore	TokenNameIdentifier	 key Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
keyValueStore	TokenNameIdentifier	 key Value Store
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
keyValueStore	TokenNameIdentifier	 key Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activateSelectorFor	TokenNameIdentifier	 activate Selector For
(	TokenNameLPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
case	TokenNamecase	
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEYREF	TokenNameIdentifier	 IC  KEYREF
)	TokenNameRPAREN	
:	TokenNameCOLON	
// initialize value stores for keyRef fields 	TokenNameCOMMENT_LINE	initialize value stores for keyRef fields 
KeyRef	TokenNameIdentifier	 Key Ref
keyRef	TokenNameIdentifier	 key Ref
=	TokenNameEQUAL	
(	TokenNameLPAREN	
KeyRef	TokenNameIdentifier	 Key Ref
)	TokenNameRPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
toHash	TokenNameIdentifier	 to Hash
=	TokenNameEQUAL	
new	TokenNamenew	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
keyRef	TokenNameIdentifier	 key Ref
,	TokenNameCOMMA	
fElementDepth	TokenNameIdentifier	 f Element Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
KeyRefValueStore	TokenNameIdentifier	 Key Ref Value Store
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
=	TokenNameEQUAL	
(	TokenNameLPAREN	
KeyRefValueStore	TokenNameIdentifier	 Key Ref Value Store
)	TokenNameRPAREN	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
=	TokenNameEQUAL	
new	TokenNamenew	
KeyRefValueStore	TokenNameIdentifier	 Key Ref Value Store
(	TokenNameLPAREN	
keyRef	TokenNameIdentifier	 key Ref
,	TokenNameCOMMA	
null	TokenNamenull	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
toHash	TokenNameIdentifier	 to Hash
,	TokenNameCOMMA	
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
{	TokenNameLBRACE	
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
.	TokenNameDOT	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
keyRefValueStore	TokenNameIdentifier	 key Ref Value Store
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
activateSelectorFor	TokenNameIdentifier	 activate Selector For
(	TokenNameLPAREN	
icArray	TokenNameIdentifier	 ic Array
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
break	TokenNamebreak	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// initValueStoresFor(XSElementDecl) 	TokenNameCOMMENT_LINE	initValueStoresFor(XSElementDecl) 
/** Returns the value store associated to the specified IdentityConstraint. */	TokenNameCOMMENT_JAVADOC	 Returns the value store associated to the specified IdentityConstraint. 
public	TokenNamepublic	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
getValueStoreFor	TokenNameIdentifier	 get Value Store For
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLocalId	TokenNameIdentifier	 f Local Id
.	TokenNameDOT	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
initialDepth	TokenNameIdentifier	 initial Depth
;	TokenNameSEMICOLON	
fLocalId	TokenNameIdentifier	 f Local Id
.	TokenNameDOT	
fId	TokenNameIdentifier	 f Id
=	TokenNameEQUAL	
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fLocalId	TokenNameIdentifier	 f Local Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getValueStoreFor(IdentityConstraint, int):ValueStoreBase 	TokenNameCOMMENT_LINE	getValueStoreFor(IdentityConstraint, int):ValueStoreBase 
/** Returns the global value store associated to the specified IdentityConstraint. */	TokenNameCOMMENT_JAVADOC	 Returns the global value store associated to the specified IdentityConstraint. 
public	TokenNamepublic	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
getGlobalValueStoreFor	TokenNameIdentifier	 get Global Value Store For
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// getValueStoreFor(IdentityConstraint):ValueStoreBase 	TokenNameCOMMENT_LINE	getValueStoreFor(IdentityConstraint):ValueStoreBase 
// This method takes the contents of the (local) ValueStore 	TokenNameCOMMENT_LINE	This method takes the contents of the (local) ValueStore 
// associated with id and moves them into the global 	TokenNameCOMMENT_LINE	associated with id and moves them into the global 
// hashtable, if id is a <unique> or a <key>. 	TokenNameCOMMENT_LINE	hashtable, if id is a <unique> or a <key>. 
// If it's a <keyRef>, then we leave it for later. 	TokenNameCOMMENT_LINE	If it's a <keyRef>, then we leave it for later. 
public	TokenNamepublic	
void	TokenNamevoid	
transplant	TokenNameIdentifier	 transplant
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
int	TokenNameint	
initialDepth	TokenNameIdentifier	 initial Depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLocalId	TokenNameIdentifier	 f Local Id
.	TokenNameDOT	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
initialDepth	TokenNameIdentifier	 initial Depth
;	TokenNameSEMICOLON	
fLocalId	TokenNameIdentifier	 f Local Id
.	TokenNameDOT	
fId	TokenNameIdentifier	 f Id
=	TokenNameEQUAL	
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
newVals	TokenNameIdentifier	 new Vals
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fIdentityConstraint2ValueStoreMap	TokenNameIdentifier	 f Identity Constraint2 Value Store Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
fLocalId	TokenNameIdentifier	 f Local Id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
.	TokenNameDOT	
getCategory	TokenNameIdentifier	 get Category
(	TokenNameLPAREN	
)	TokenNameRPAREN	
==	TokenNameEQUAL_EQUAL	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
.	TokenNameDOT	
IC_KEYREF	TokenNameIdentifier	 IC  KEYREF
)	TokenNameRPAREN	
return	TokenNamereturn	
;	TokenNameSEMICOLON	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
currVals	TokenNameIdentifier	 curr Vals
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
currVals	TokenNameIdentifier	 curr Vals
!=	TokenNameNOT_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
currVals	TokenNameIdentifier	 curr Vals
.	TokenNameDOT	
append	TokenNameIdentifier	 append
(	TokenNameLPAREN	
newVals	TokenNameIdentifier	 new Vals
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
currVals	TokenNameIdentifier	 curr Vals
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
fGlobalIDConstraintMap	TokenNameIdentifier	 f Global ID Constraint Map
.	TokenNameDOT	
put	TokenNameIdentifier	 put
(	TokenNameLPAREN	
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
newVals	TokenNameIdentifier	 new Vals
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// transplant(id) 	TokenNameCOMMENT_LINE	transplant(id) 
/** Check identity constraints. */	TokenNameCOMMENT_JAVADOC	 Check identity constraints. 
public	TokenNamepublic	
void	TokenNamevoid	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
int	TokenNameint	
count	TokenNameIdentifier	 count
=	TokenNameEQUAL	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
size	TokenNameIdentifier	 size
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
count	TokenNameIdentifier	 count
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
++	TokenNamePLUS_PLUS	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
valueStore	TokenNameIdentifier	 value Store
=	TokenNameEQUAL	
(	TokenNameLPAREN	
ValueStoreBase	TokenNameIdentifier	 Value Store Base
)	TokenNameRPAREN	
fValueStores	TokenNameIdentifier	 f Value Stores
.	TokenNameDOT	
get	TokenNameIdentifier	 get
(	TokenNameLPAREN	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
valueStore	TokenNameIdentifier	 value Store
.	TokenNameDOT	
endDocument	TokenNameIdentifier	 end Document
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// endDocument() 	TokenNameCOMMENT_LINE	endDocument() 
// 	TokenNameCOMMENT_LINE	 
// Object methods 	TokenNameCOMMENT_LINE	Object methods 
// 	TokenNameCOMMENT_LINE	 
/** Returns a string representation of this object. */	TokenNameCOMMENT_JAVADOC	 Returns a string representation of this object. 
public	TokenNamepublic	
String	TokenNameIdentifier	 String
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
String	TokenNameIdentifier	 String
s	TokenNameIdentifier	 s
=	TokenNameEQUAL	
super	TokenNamesuper	
.	TokenNameDOT	
toString	TokenNameIdentifier	 to String
(	TokenNameLPAREN	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
int	TokenNameint	
index1	TokenNameIdentifier	 index1
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'$'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index1	TokenNameIdentifier	 index1
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index1	TokenNameIdentifier	 index1
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
int	TokenNameint	
index2	TokenNameIdentifier	 index2
=	TokenNameEQUAL	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
lastIndexOf	TokenNameIdentifier	 last Index Of
(	TokenNameLPAREN	
'.'	TokenNameCharacterLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
if	TokenNameif	
(	TokenNameLPAREN	
index2	TokenNameIdentifier	 index2
!=	TokenNameNOT_EQUAL	
-	TokenNameMINUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
.	TokenNameDOT	
substring	TokenNameIdentifier	 substring
(	TokenNameLPAREN	
index2	TokenNameIdentifier	 index2
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
s	TokenNameIdentifier	 s
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// toString():String 	TokenNameCOMMENT_LINE	toString():String 
}	TokenNameRBRACE	
// class ValueStoreCache 	TokenNameCOMMENT_LINE	class ValueStoreCache 
// the purpose of this class is to enable IdentityConstraint,int 	TokenNameCOMMENT_LINE	the purpose of this class is to enable IdentityConstraint,int 
// pairs to be used easily as keys in Hashtables. 	TokenNameCOMMENT_LINE	pairs to be used easily as keys in Hashtables. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
LocalIDKey	TokenNameIdentifier	 Local ID Key
{	TokenNameLBRACE	
public	TokenNamepublic	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
fId	TokenNameIdentifier	 f Id
;	TokenNameSEMICOLON	
public	TokenNamepublic	
int	TokenNameint	
fDepth	TokenNameIdentifier	 f Depth
;	TokenNameSEMICOLON	
public	TokenNamepublic	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
LocalIDKey	TokenNameIdentifier	 Local ID Key
(	TokenNameLPAREN	
IdentityConstraint	TokenNameIdentifier	 Identity Constraint
id	TokenNameIdentifier	 id
,	TokenNameCOMMA	
int	TokenNameint	
depth	TokenNameIdentifier	 depth
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fId	TokenNameIdentifier	 f Id
=	TokenNameEQUAL	
id	TokenNameIdentifier	 id
;	TokenNameSEMICOLON	
fDepth	TokenNameIdentifier	 f Depth
=	TokenNameEQUAL	
depth	TokenNameIdentifier	 depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// init(IdentityConstraint, int) 	TokenNameCOMMENT_LINE	init(IdentityConstraint, int) 
// object method 	TokenNameCOMMENT_LINE	object method 
public	TokenNamepublic	
int	TokenNameint	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fId	TokenNameIdentifier	 f Id
.	TokenNameDOT	
hashCode	TokenNameIdentifier	 hash Code
(	TokenNameLPAREN	
)	TokenNameRPAREN	
+	TokenNamePLUS	
fDepth	TokenNameIdentifier	 f Depth
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
public	TokenNamepublic	
boolean	TokenNameboolean	
equals	TokenNameIdentifier	 equals
(	TokenNameLPAREN	
Object	TokenNameIdentifier	 Object
localIDKey	TokenNameIdentifier	 local ID Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
localIDKey	TokenNameIdentifier	 local ID Key
instanceof	TokenNameinstanceof	
LocalIDKey	TokenNameIdentifier	 Local ID Key
)	TokenNameRPAREN	
{	TokenNameLBRACE	
LocalIDKey	TokenNameIdentifier	 Local ID Key
lIDKey	TokenNameIdentifier	 l ID Key
=	TokenNameEQUAL	
(	TokenNameLPAREN	
LocalIDKey	TokenNameIdentifier	 Local ID Key
)	TokenNameRPAREN	
localIDKey	TokenNameIdentifier	 local ID Key
;	TokenNameSEMICOLON	
return	TokenNamereturn	
(	TokenNameLPAREN	
lIDKey	TokenNameIdentifier	 l ID Key
.	TokenNameDOT	
fId	TokenNameIdentifier	 f Id
==	TokenNameEQUAL_EQUAL	
fId	TokenNameIdentifier	 f Id
&&	TokenNameAND_AND	
lIDKey	TokenNameIdentifier	 l ID Key
.	TokenNameDOT	
fDepth	TokenNameIdentifier	 f Depth
==	TokenNameEQUAL_EQUAL	
fDepth	TokenNameIdentifier	 f Depth
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class LocalIDKey 	TokenNameCOMMENT_LINE	class LocalIDKey 
/** * A simple vector for <code>short</code>s. */	TokenNameCOMMENT_JAVADOC	 A simple vector for <code>short</code>s. 
protected	TokenNameprotected	
static	TokenNamestatic	
final	TokenNamefinal	
class	TokenNameclass	
ShortVector	TokenNameIdentifier	 Short Vector
{	TokenNameLBRACE	
// 	TokenNameCOMMENT_LINE	 
// Data 	TokenNameCOMMENT_LINE	Data 
// 	TokenNameCOMMENT_LINE	 
/** Current length. */	TokenNameCOMMENT_JAVADOC	 Current length. 
private	TokenNameprivate	
int	TokenNameint	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
/** Data. */	TokenNameCOMMENT_JAVADOC	 Data. 
private	TokenNameprivate	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
fData	TokenNameIdentifier	 f Data
;	TokenNameSEMICOLON	
// 	TokenNameCOMMENT_LINE	 
// Constructors 	TokenNameCOMMENT_LINE	Constructors 
// 	TokenNameCOMMENT_LINE	 
public	TokenNamepublic	
ShortVector	TokenNameIdentifier	 Short Vector
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
}	TokenNameRBRACE	
public	TokenNamepublic	
ShortVector	TokenNameIdentifier	 Short Vector
(	TokenNameLPAREN	
int	TokenNameint	
initialCapacity	TokenNameIdentifier	 initial Capacity
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fData	TokenNameIdentifier	 f Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
initialCapacity	TokenNameIdentifier	 initial Capacity
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Public methods 	TokenNameCOMMENT_LINE	Public methods 
// 	TokenNameCOMMENT_LINE	 
/** Returns the length of the vector. */	TokenNameCOMMENT_JAVADOC	 Returns the length of the vector. 
public	TokenNamepublic	
int	TokenNameint	
length	TokenNameIdentifier	 length
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Adds the value to the vector. */	TokenNameCOMMENT_JAVADOC	 Adds the value to the vector. 
public	TokenNamepublic	
void	TokenNamevoid	
add	TokenNameIdentifier	 add
(	TokenNameLPAREN	
short	TokenNameshort	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
ensureCapacity	TokenNameIdentifier	 ensure Capacity
(	TokenNameLPAREN	
fLength	TokenNameIdentifier	 f Length
+	TokenNamePLUS	
1	TokenNameIntegerLiteral	
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fData	TokenNameIdentifier	 f Data
[	TokenNameLBRACKET	
fLength	TokenNameIdentifier	 f Length
++	TokenNamePLUS_PLUS	
]	TokenNameRBRACKET	
=	TokenNameEQUAL	
value	TokenNameIdentifier	 value
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns the short value at the specified position in the vector. */	TokenNameCOMMENT_JAVADOC	 Returns the short value at the specified position in the vector. 
public	TokenNamepublic	
short	TokenNameshort	
valueAt	TokenNameIdentifier	 value At
(	TokenNameLPAREN	
int	TokenNameint	
position	TokenNameIdentifier	 position
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
fData	TokenNameIdentifier	 f Data
[	TokenNameLBRACKET	
position	TokenNameIdentifier	 position
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Clears the vector. */	TokenNameCOMMENT_JAVADOC	 Clears the vector. 
public	TokenNamepublic	
void	TokenNamevoid	
clear	TokenNameIdentifier	 clear
(	TokenNameLPAREN	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fLength	TokenNameIdentifier	 f Length
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
/** Returns whether the short is contained in the vector. */	TokenNameCOMMENT_JAVADOC	 Returns whether the short is contained in the vector. 
public	TokenNamepublic	
boolean	TokenNameboolean	
contains	TokenNameIdentifier	 contains
(	TokenNameLPAREN	
short	TokenNameshort	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
for	TokenNamefor	
(	TokenNameLPAREN	
int	TokenNameint	
i	TokenNameIdentifier	 i
=	TokenNameEQUAL	
0	TokenNameIntegerLiteral	
;	TokenNameSEMICOLON	
i	TokenNameIdentifier	 i
<	TokenNameLESS	
fLength	TokenNameIdentifier	 f Length
;	TokenNameSEMICOLON	
++	TokenNamePLUS_PLUS	
i	TokenNameIdentifier	 i
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fData	TokenNameIdentifier	 f Data
[	TokenNameLBRACKET	
i	TokenNameIdentifier	 i
]	TokenNameRBRACKET	
==	TokenNameEQUAL_EQUAL	
value	TokenNameIdentifier	 value
)	TokenNameRPAREN	
{	TokenNameLBRACE	
return	TokenNamereturn	
true	TokenNametrue	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
return	TokenNamereturn	
false	TokenNamefalse	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
// 	TokenNameCOMMENT_LINE	 
// Private methods 	TokenNameCOMMENT_LINE	Private methods 
// 	TokenNameCOMMENT_LINE	 
/** Ensures capacity. */	TokenNameCOMMENT_JAVADOC	 Ensures capacity. 
private	TokenNameprivate	
void	TokenNamevoid	
ensureCapacity	TokenNameIdentifier	 ensure Capacity
(	TokenNameLPAREN	
int	TokenNameint	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
if	TokenNameif	
(	TokenNameLPAREN	
fData	TokenNameIdentifier	 f Data
==	TokenNameEQUAL_EQUAL	
null	TokenNamenull	
)	TokenNameRPAREN	
{	TokenNameLBRACE	
fData	TokenNameIdentifier	 f Data
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
8	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
else	TokenNameelse	
if	TokenNameif	
(	TokenNameLPAREN	
fData	TokenNameIdentifier	 f Data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
<=	TokenNameLESS_EQUAL	
size	TokenNameIdentifier	 size
)	TokenNameRPAREN	
{	TokenNameLBRACE	
short	TokenNameshort	
[	TokenNameLBRACKET	
]	TokenNameRBRACKET	
newdata	TokenNameIdentifier	 newdata
=	TokenNameEQUAL	
new	TokenNamenew	
short	TokenNameshort	
[	TokenNameLBRACKET	
fData	TokenNameIdentifier	 f Data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
*	TokenNameMULTIPLY	
2	TokenNameIntegerLiteral	
]	TokenNameRBRACKET	
;	TokenNameSEMICOLON	
System	TokenNameIdentifier	 System
.	TokenNameDOT	
arraycopy	TokenNameIdentifier	 arraycopy
(	TokenNameLPAREN	
fData	TokenNameIdentifier	 f Data
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
newdata	TokenNameIdentifier	 newdata
,	TokenNameCOMMA	
0	TokenNameIntegerLiteral	
,	TokenNameCOMMA	
fData	TokenNameIdentifier	 f Data
.	TokenNameDOT	
length	TokenNameIdentifier	 length
)	TokenNameRPAREN	
;	TokenNameSEMICOLON	
fData	TokenNameIdentifier	 f Data
=	TokenNameEQUAL	
newdata	TokenNameIdentifier	 newdata
;	TokenNameSEMICOLON	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
}	TokenNameRBRACE	
// class SchemaValidator 	TokenNameCOMMENT_LINE	class SchemaValidator 
